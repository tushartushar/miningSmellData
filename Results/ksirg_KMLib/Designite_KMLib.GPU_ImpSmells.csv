Implementation smell,Namespace,Class,File,Method,Description
Long Method,KMLib.GPU,CudaLinearCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The method has 107 lines of code.
Long Method,KMLib.GPU,CudaRBFCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The method has 136 lines of code.
Long Method,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,UpdateAlpha,The method has 123 lines of code.
Long Method,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,UpdateAlpha,The method has 123 lines of code.
Long Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,The method has 109 lines of code.
Long Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaParameters,The method has 162 lines of code.
Long Method,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeModel,The method has 105 lines of code.
Long Method,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaParameters,The method has 155 lines of code.
Long Method,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,ComputeModel,The method has 106 lines of code.
Long Method,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,solve_l2r_l2_svc_cuda,The method has 186 lines of code.
Complex Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Complex Method,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Complex Method,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToEllpackRFormat,The method has 5 parameters. Parameters: vecVals' vecCols' rowLength' problemElements' align
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToERTILPFormat,The method has 6 parameters. Parameters: vecVals' vecCols' rowLength' problemElements' align' ThreadsPerRow
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSlicedEllpack,The method has 7 parameters. Parameters: vecVals' vecCols' sliceStart' rowLenght' problemElements' threadsPerRow' sliceSize
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSERTILP,The method has 8 parameters. Parameters: vecVals' vecCols' sliceStart' rowLenght' problemElements' threadsPerRow' sliceSize' preFetch
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,InitBuffer,The method has 5 parameters. Parameters: matVals' matIdx' matRowLenght' index' bufferPtr
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetBufferIdx,The method has 5 parameters. Parameters: matIdx' matRowLenght' index' bufferPtr' value
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetTextureMemory,The method has 6 parameters. Parameters: cuda' cuModule' texture' texName' data' memPtr
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetTextureMemory,The method has 5 parameters. Parameters: cuda' texture' texName' data' memPtr
Long Parameter List,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The method has 5 parameters. Parameters: size' maxBlocksPerGrid' maxThreadsPerBlock' threads' blocks
Long Parameter List,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,rbfSlicedEllpackKernel,The method has 10 parameters. Parameters: th' vecVals' vecCols' vecLengths' sliceStart' result' mainVecIdx' nrRows' gamma' align
Long Parameter List,KMLib.GPU.GPUKernels,EllpackDenseVectorBuilder,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\EllpackDenseVectorBuilder.cs,EllpackDenseVectorBuilder,The method has 7 parameters. Parameters: cu' vector' vals' cols' length' rows' dim
Long Parameter List,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The method has 5 parameters. Parameters: size' maxBlock' maxThreadsPerBlock' threads' blocks
Long Parameter List,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The method has 5 parameters. Parameters: size' maxBlock' maxThreadsPerBlock' threads' blocks
Long Parameter List,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,solve_l2r_l2_svc_cuda,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Identifier,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,,The length of the parameter alphaParamOffsetInGradFinalize is 30.
Long Identifier,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,,The length of the parameter alphaParamOffsetInObjSquareAlpha is 32.
Long Identifier,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,,The length of the parameter alphaOldParamOffsetInUpdateAlpha is 32.
Long Identifier,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,,The length of the parameter alphaParamOffsetInGradFinalize is 30.
Long Identifier,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,,The length of the parameter alphaParamOffsetInObjSquareAlpha is 32.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2ERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2ERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "            CudaHelpers.TransformToERTILPFormat(out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 131.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "            CudaHelpers.TransformToERTILPFormat(out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 131.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 159.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 159.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 152.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 152.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 159.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 152.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "            CudaHelpers.TransformToERTILPFormat(out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 131.
Long Statement,KMLib.GPU,CuEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuEvaluator.cs,SetCudaRedFunctionParams,The length of the statement  "            CudaHelpers.GetNumThreadsAndBlocks(sizeSV'maxReductionBlocks' maxReductionThreads' ref reductionThreads' ref reductionBlocks); " is 126.
Long Statement,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize'preFechSize); " is 145.
Long Statement,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize'preFechSize); " is 145.
Long Statement,KMLib.GPU,CuExpChiERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuNChi2ERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSERTILP(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize'preFechSize); " is 145.
Long Statement,KMLib.GPU,CuRBFERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuRBFEllILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuExpChiSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 139.
Long Statement,KMLib.GPU,CuNChi2SlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 139.
Long Statement,KMLib.GPU,CuExpChiEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiEllKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuNChi2EllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2EllKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 139.
Long Statement,KMLib.GPU,CuRBFEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Init,The length of the statement  "                vecBuilder = new EllpackDenseVectorBuilder(cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements[0].Dim); " is 140.
Long Statement,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSRFormat,The length of the statement  "            //transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSCFormat,The length of the statement  "            //transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSCFormat2,The length of the statement  "            //transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,AllProducts,The length of the statement  "            gpu.Launch(blockPerGrid'blockSize'cudaFunctionName'valsPtr'idxPtr'vecLenghtPtr'sliceStartPtr'selfLinDotPtr'labelsPtr'outputPtr'mainVecIdx'problemElements.Length'Gamma'align); " is 174.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The length of the statement  "            CudaHelpers.TransformToSlicedEllpack(out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow'sliceSize); " is 138.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The length of the statement  "            //outputIntPtr = gpu.HostAllocate<float>(problemElements.Length); // .HostAllocate(memSize' CUDADriver.CU_MEMHOSTALLOC_DEVICEMAP); " is 130.
Long Statement,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The length of the statement  "            CudaHelpers.GetNumThreadsAndBlocks(problemSize' maxReductionBlocks' threadsPerBlock' ref reductionThreads' ref reductionBlocks); " is 128.
Long Statement,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaData,The length of the statement  "            CudaHelpers.GetNumThreadsAndBlocks(problemSize' maxReductionBlocks' threadsPerBlock' ref reductionThreads' ref reductionBlocks); " is 128.
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,CuExpChiSlEllEvaluator,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,CuExpChiSlEllEvaluator,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,CuRBFSlEllEvaluator,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,CuRBFSlEllEvaluator,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFEllILPEvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFEllILPEvaluator.cs,SetCudaDataForEllpack,The following statement contains a magic number: int align = 2;
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuExpChiERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,CuExpChiERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;
Magic Number,KMLib.GPU,CuExpChiERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,CuExpChiERTILPKernel,The following statement contains a magic number: Prefetch =2;
Magic Number,KMLib.GPU,CuNChi2ERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,CuNChi2ERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;
Magic Number,KMLib.GPU,CuNChi2ERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,CuNChi2ERTILPKernel,The following statement contains a magic number: Prefetch =2;
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: preFechSize = 2;
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuRBFERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,CuRBFERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;
Magic Number,KMLib.GPU,CuRBFERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,CuRBFERTILPKernel,The following statement contains a magic number: Prefetch =2;
Magic Number,KMLib.GPU,CuRBFERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFERTILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CuRBFEllILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFEllILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CuRBFEllILPKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Init,The following statement contains a magic number: int align = 2;
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,CuExpChiSlEllKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,CuExpChiSlEllKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,CuNChi2SlEllKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,CuNChi2SlEllKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,CuRBFSlEllKernel,The following statement contains a magic number: threadsPerRow =  4;
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,CuRBFSlEllKernel,The following statement contains a magic number: sliceSize =  64;
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuRBFSlEllKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling(1.0 * sliceSize * threadsPerRow / 64) * 64;
Magic Number,KMLib.GPU,CuRBFEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to devece                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                  //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernl                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to devece                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                  //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernl                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to devece                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                  //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernl                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSlicedEllpack,The following statement contains a magic number: int alignParam = 64;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSERTILP,The following statement contains a magic number: int alignParam = 64;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;
Magic Number,KMLib.GPU,CudaHelpers,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,CudafyRBFSlicedEllpackKernel,The following statement contains a magic number: threadsPerRow = 4;
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,CudafyRBFSlicedEllpackKernel,The following statement contains a magic number: sliceSize = 64;
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling( 1.0*sliceSize * threadsPerRow / 64)*64;
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling( 1.0*sliceSize * threadsPerRow / 64)*64;
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to device                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                    //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernel                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to device                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                    //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernel                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,C:\repos\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++)              {                  //set the buffer values from k-th support vector                  CudaHelpers.InitBuffer(TrainedModel.SupportElements[k]' svVecIntPtrs[k % 2]);                    cuda.SynchronizeStream(stream);                  //copy asynchronously from buffer to device                  cuda.CopyHostToDeviceAsync(mainVecPtr' svVecIntPtrs[k % 2]' memSvSize' stream);                    //set the last parameter in kernel (column index)                     // colIndexParamOffset                  cuda.SetParameter(cuFunc' lastParameterOffset' (uint)k);                  //launch kernel                      cuda.LaunchAsync(cuFunc' gridDimX' 1' stream);                    if (k > 0)                  {                      //clear the previous host buffer                      CudaHelpers.SetBufferIdx(TrainedModel.SupportElements[k - 1]' svVecIntPtrs[(k + 1) % 2]' 0.0f);                  }                }
Magic Number,KMLib.GPU,CuRBFCSRKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFCSRKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU,CuRBFCSRKernel,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFCSRKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)             {                 if (DiagonalDotCacheBuilded)                     return DiagonalDotCache[element1];                 else                 {                     //all parts are the same                     // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                     //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                     // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                     //so we can prod set to 1 beceause exp(0)==1                     prod = 1f;                 }             }             else             {                 //when element1 and element2 are different we have to compute all parts                 x1Squere = linKernel.Product(element1' element1);                 x2Squere = linKernel.Product(element2' element2);                 dot = linKernel.Product(element1' element2);                 prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));             }
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,CuRBFEllILPKernelCol2,The following statement contains a magic number: preFetch = 2;
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  if (DiagonalDotCacheBuilded)                      return DiagonalDotCache[element1];                  else                  {                      //all parts are the same                      // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                      // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  }              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,C:\repos\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,Init,The following statement contains a magic number: uint memSize = (uint)(2*problemElements.Length * sizeof(float));
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] - 1);                    si.obj = v / 2;              }
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,UpdateAlpha,The following statement contains a magic number: float quad_coef = Qii + Qjj - 2 * yi * yj * Qij;
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The following statement contains a magic number: uint memSize = (uint)(sizeof(float) * problemSize * 2);
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The following statement contains a magic number: reduceVal = new float[redSize*2];
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The following statement contains a magic number: reduceIdx = new int[redSize*2];
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: alignSize = (uint) ((problemSize / (reductionThreads * 2)) * reductionThreads * 2);
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: alignSize = (uint) ((problemSize / (reductionThreads * 2)) * reductionThreads * 2);
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGThreadsPerBlock = 64;
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,The following statement contains a magic number: while (iter<MaxIter)              {                    //Find i: Maximizes -y_i * grad(f)_i' i in I_up(\alpha)                  Tuple<int' float> maxPair = FindMaxPair();                  int i = maxPair.Item1;                  GMaxI = maxPair.Item2;                                    if (iter % 250 == 0)                  {                      GMaxJ = FindStoppingGradVal();                        if (GMaxI - GMaxJ < EPS)                          break;                  }                    //Compute i-th kernel collumn' set the specific memory region on GPU'                   ComputeKernel(i' kiPtr);                      // j: mimimizes the decrease of obj value                  //    (if quadratic coefficeint <= 0' replace it with tau)                  //    -y_j*grad(f)_j < -y_i*grad(f)_i' j in I_low(\alpha)                  int j = FindMinPair(i' GMaxI);                          //Compute j-th kernel collumn                  ComputeKernel(j' kjPtr);                      float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    //update alpha - serial code' one iteration                  UpdateAlpha(i' j);                  // update gradient G                  float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      UpdateGrad(i' j' delta_alpha_i' delta_alpha_j);                    //czy to potrzebne???                  // update alpha_status and G_bar'                  iter++;              }
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] - 1);                    si.obj = v / 2;              }
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,UpdateAlpha,The following statement contains a magic number: float quad_coef = Qii + Qjj - 2 * yi * yj * Qij;
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGThreadsPerBlock = 64;
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2)              {                    float[] w = new float[w_size];                      int e0 = start[0] + count[0];                  int k = 0;                  for (; k < e0; k++)                      sub_prob.Y[k] = +1;                  for (; k < sub_prob.ElementsCount; k++)                      sub_prob.Y[k] = -1;                    Debug.WriteLine("init data on cuda");                  //copy all needed data to CUDA device                  SetCudaData(sub_prob);                  Debug.WriteLine("set cuda data complete");                  //Fill data on CUDA                  FillDataOnCuda(sub_prob' w' weighted_C[0]' weighted_C[1]);                    Stopwatch solverTime = Stopwatch.StartNew();                  solve_l2r_l2_bb_svc_cuda(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                  solverTime.Stop();                  Console.WriteLine("------ solver time {0}"' solverTime.Elapsed);                    model.W = new double[w_size];                  for (int s = 0; s < w.Length; s++)                  {                      model.W[s] = w[s];                  }              }              else              {                  model.W = new double[w_size * nr_class];                  float[] w = new float[w_size];                    SetCudaData(sub_prob);                    ///one against many                  for (int i = 0; i < nr_class; i++)                  {                      int si = start[i];                      int ei = si + count[i];                        int k = 0;                      for (; k < si; k++)                          sub_prob.Y[k] = -1;                      for (; k < ei; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        FillDataOnCuda(sub_prob' w' weighted_C[i]' C);                      //train_one(sub_prob' param' w' weighted_C[i]' param.C);                      solve_l2r_l2_bb_svc_cuda(sub_prob' w' epsilon' weighted_C[i]' C);                        for (j = 0; j < n; j++)                          model.W[j * nr_class + i] = w[j];                  }              }
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: int M = 10;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: int maxIter = 5000;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,DoBBstep,The following statement contains a magic number: if (sub_prob.FeaturesCount > 10000)              {                  bpgUpdateW = (sub_prob.Elements[0].Dim + tpbUpdateW - 1) / tpbUpdateW;              }              else              {                  bpgUpdateW = (sub_prob.Elements[0].Dim * 32 + tpbUpdateW) / tpbUpdateW;              }
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,DoBBstep,The following statement contains a magic number: if (sub_prob.FeaturesCount > 10000)              {                  bpgUpdateW = (sub_prob.Elements[0].Dim + tpbUpdateW - 1) / tpbUpdateW;              }              else              {                  bpgUpdateW = (sub_prob.Elements[0].Dim * 32 + tpbUpdateW) / tpbUpdateW;              }
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeObjGPU,The following statement contains a magic number: val = val / 2;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks(vecDim' 64' threadsPerBlock' ref threadsForReduceObjW' ref bpgReduceW);
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks(problem.ElementsCount' 64' threadsPerBlock' ref threadsForReduceObjAlpha' ref bpgReduceAlpha);
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaParameters,The following statement contains a magic number: tpbUpdateW =  64;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,FillDataOnCuda,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,FillDataOnCuda,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2)              {                    float[] w = new float[w_size];                      int e0 = start[0] + count[0];                  int k = 0;                  for (; k < e0; k++)                      sub_prob.Y[k] = +1;                  for (; k < sub_prob.ElementsCount; k++)                      sub_prob.Y[k] = -1;                    //copy all needed data to CUDA device                  SetCudaData(sub_prob);                    //Fill data on CUDA                  FillDataOnCuda(sub_prob' w' weighted_C[0]' weighted_C[1]);                    Stopwatch solverTime = Stopwatch.StartNew();                  solve_l2r_l2_bb_svc_cuda(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                  solverTime.Stop();                  Console.WriteLine("------ solver time {0}"' solverTime.Elapsed);                    model.W = new double[w_size];                  for (int s = 0; s < w.Length; s++)                  {                      model.W[s] = w[s];                  }              }              else              {                  model.W = new double[w_size * nr_class];                  float[] w = new float[w_size];                    SetCudaData(sub_prob);                    ///one against many                  for (int i = 0; i < nr_class; i++)                  {                      int si = start[i];                      int ei = si + count[i];                        int k = 0;                      for (; k < si; k++)                          sub_prob.Y[k] = -1;                      for (; k < ei; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        FillDataOnCuda(sub_prob' w' weighted_C[i]' C);                      //train_one(sub_prob' param' w' weighted_C[i]' param.C);                      solve_l2r_l2_bb_svc_cuda(sub_prob' w' epsilon' weighted_C[i]' C);                        for (j = 0; j < n; j++)                          model.W[j * nr_class + i] = w[j];                  }              }
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: int M = 10;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: int maxIter = 600;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: while (iter <= maxIter)              {                                    maxFuncVal = func_vals.Max();                    lambda = step;                  //nonemonotone line search                  for (int i = 0; i < 10; i++)                  {                      DoBBstep(-lambda'sub_prob);                        //compute Obj                      obj = ComputeObjGPU(wTempVecPtr'alphaTmpPtr);                        //compute linpart                      float linPart = ComputeLinPart(gamma'lambda); //* (alpha_tmp-alpha)'*grad                        if (obj <= (maxFuncVal + linPart))                      {                          int idx = (iter + 1) % M;                          func_vals[idx] = obj;                          break;                        }                      lambda = (sig1 * lambda + sig2 * lambda) / 2;                  }                    //change alpha's pointers                  var tmpPtr = alphaOldPtr.Pointer;                  alphaOldPtr.Pointer = alphaPtr.Pointer;                  alphaPtr.Pointer = alphaTmpPtr.Pointer;                  alphaTmpPtr.Pointer = tmpPtr;                    //change w - pointers                  var tempPtr= wVecPtr.Pointer;                  wVecPtr.Pointer = wTempVecPtr.Pointer;                  wTempVecPtr.Pointer = tempPtr;                    //change gradients                  //gradOldPtr = grad                  //compute new grad                  float gradNorm = float.PositiveInfinity;                  ComputeGradient(sub_prob);                  if (gradNorm < epsilon)                  {                      break;                  }                    //compute BB step                  step = ComputeBBStep();                    iter++;              }
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: while (iter <= maxIter)              {                                    maxFuncVal = func_vals.Max();                    lambda = step;                  //nonemonotone line search                  for (int i = 0; i < 10; i++)                  {                      DoBBstep(-lambda'sub_prob);                        //compute Obj                      obj = ComputeObjGPU(wTempVecPtr'alphaTmpPtr);                        //compute linpart                      float linPart = ComputeLinPart(gamma'lambda); //* (alpha_tmp-alpha)'*grad                        if (obj <= (maxFuncVal + linPart))                      {                          int idx = (iter + 1) % M;                          func_vals[idx] = obj;                          break;                        }                      lambda = (sig1 * lambda + sig2 * lambda) / 2;                  }                    //change alpha's pointers                  var tmpPtr = alphaOldPtr.Pointer;                  alphaOldPtr.Pointer = alphaPtr.Pointer;                  alphaPtr.Pointer = alphaTmpPtr.Pointer;                  alphaTmpPtr.Pointer = tmpPtr;                    //change w - pointers                  var tempPtr= wVecPtr.Pointer;                  wVecPtr.Pointer = wTempVecPtr.Pointer;                  wTempVecPtr.Pointer = tempPtr;                    //change gradients                  //gradOldPtr = grad                  //compute new grad                  float gradNorm = float.PositiveInfinity;                  ComputeGradient(sub_prob);                  if (gradNorm < epsilon)                  {                      break;                  }                    //compute BB step                  step = ComputeBBStep();                    iter++;              }
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeObjGPU,The following statement contains a magic number: val = val / 2;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeBBStep,The following statement contains a magic number: if ( (iter+1)  % 2 == 0)              {                  step = step2;              }
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks(vecDim' 64' threadsPerBlock' ref threadsForReduceObjW' ref bpgReduceW);
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks(problem.ElementsCount' 64' threadsPerBlock' ref threadsForReduceObjAlpha' ref bpgReduceAlpha);
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,FillDataOnCuda,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,FillDataOnCuda,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2((size + 1) / 2) : maxThreadsPerBlock;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2)              {                    float[] w = new float[w_size];                  //for (int z = 0; z < w.Length; z++)                  //{                  //    w[z] = 1.0f;                  //}                      int e0 = start[0] + count[0];                  int k = 0;                  for (; k < e0; k++)                      sub_prob.Y[k] = +1;                  for (; k < sub_prob.ElementsCount; k++)                      sub_prob.Y[k] = -1;                    //copy all needed data to CUDA device                  SetCudaData(sub_prob);                    //Fill data on CUDA                  FillDataOnCuda(sub_prob' w' weighted_C[0]' weighted_C[1]);                    solve_l2r_l2_svc_cuda(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                    model.W = new double[w_size];                  for (int s = 0; s < w.Length; s++)                  {                      model.W[s] = w[s];                  }              }              else              {                  model.W = new double[w_size * nr_class];                  float[] w = new float[w_size];                    SetCudaData(sub_prob);                    ///one against many                  for (int i = 0; i < nr_class; i++)                  {                      int si = start[i];                      int ei = si + count[i];                        int k = 0;                      for (; k < si; k++)                          sub_prob.Y[k] = -1;                      for (; k < ei; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        FillDataOnCuda(sub_prob' w' weighted_C[i]' C);                      //train_one(sub_prob' param' w' weighted_C[i]' param.C);                      solve_l2r_l2_svc_cuda(sub_prob' w' epsilon' weighted_C[i]' C);                        for (j = 0; j < n; j++)                          model.W[j * nr_class + i] = w[j];                  }              }
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,FillDataOnCuda,The following statement contains a magic number: diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,FillDataOnCuda,The following statement contains a magic number: diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,SetCudaData,The following statement contains a magic number: float[] diag = new float[3];
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,C:\repos\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,solve_l2r_l2_svc_cuda,The following statement contains a magic number: int maxIter = 2000;
