Implementation smell,Namespace,Class,File,Method,Description
Long Method,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The method has 122 lines of code.
Long Method,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,The method has 101 lines of code.
Long Method,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,The method has 102 lines of code.
Long Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The method has 237 lines of code.
Long Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The method has 235 lines of code.
Long Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The method has 228 lines of code.
Long Method,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeModel,The method has 130 lines of code.
Long Method,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The method has 189 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The method has 267 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The method has 278 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,select_working_set,The method has 134 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The method has 147 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The method has 125 lines of code.
Long Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The method has 228 lines of code.
Long Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The method has 153 lines of code.
Complex Method,KMLib.Helpers,SparseVec,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\SparseVec.cs,DotProduct,Cyclomatic complexity of the method is 8
Complex Method,KMLib.Helpers,SortedNVal,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\SortedNVal.cs,AddAsc,Cyclomatic complexity of the method is 8
Complex Method,KMLib.Helpers,BlockCache,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,SwapIndex,Cyclomatic complexity of the method is 10
Complex Method,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,Cyclomatic complexity of the method is 40
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,select_working_set,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,Cyclomatic complexity of the method is 40
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,select_working_set,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,Cyclomatic complexity of the method is 39
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,Cyclomatic complexity of the method is 21
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeModel,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,Cyclomatic complexity of the method is 22
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,Cyclomatic complexity of the method is 38
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,Cyclomatic complexity of the method is 13
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,Cyclomatic complexity of the method is 39
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,Cyclomatic complexity of the method is 11
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,MergeSteps,Cyclomatic complexity of the method is 10
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeAlphaStep,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,Cyclomatic complexity of the method is 40
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,Cyclomatic complexity of the method is 21
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ComputeModel,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ExamineExample,Cyclomatic complexity of the method is 13
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,Cyclomatic complexity of the method is 20
Long Parameter List,KMLib.Helpers,AlphaInfo,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\AlphaInfo.cs,AlphaInfo,The method has 5 parameters. Parameters: k' alpha1' y1' E1' product
Long Parameter List,KMLib.Helpers,StepPairVariable,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\StepVariable.cs,StepPairVariable,The method has 5 parameters. Parameters: st1' st2' product' si' eta
Long Parameter List,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,CreateSubProblem,The method has 5 parameters. Parameters: foldsElements' foldsLabels' trainFoldIndexes' subProbSize' subLabels
Long Parameter List,KMLib,Problem<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The method has 5 parameters. Parameters: sparseVec' labels' numberOfFeatures' numberOfClasses' elementClasses
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,UpdateWandAlpha,The method has 7 parameters. Parameters: update_alpha' update_w' base_alpha' base_w' step' dir' sub_prob
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeGradient,The method has 5 parameters. Parameters: sub_prob' w' alpha' diag' grad
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,UpdateWandAlpha,The method has 5 parameters. Parameters: alpha' w' step' dir' sub_prob
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeGradient,The method has 5 parameters. Parameters: sub_prob' w' alpha' diag' grad
Long Parameter List,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The method has 6 parameters. Parameters: problem' nr_class' label' start' count' perm
Long Parameter List,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The method has 6 parameters. Parameters: sub_prob' w' eps' Cp' Cn' solver_type
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The method has 5 parameters. Parameters: GMax' GMax2' i' Q_i' minIdx
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The method has 5 parameters. Parameters: GMax' rangePart' i' Q_i' minIdx
Long Parameter List,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Statement,KMLib.Evaluate,RBFDualEvaluator,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,Predict,The length of the statement  "                    float x1Squere = elements[i].DotProduct();// linKernel.Product(elements[i]' elements[i]);//linKernel.DiagonalDotCache[i]; " is 121.
Long Statement,KMLib.Helpers,AlphaPair,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\AlphaPair.cs,ToString,The length of the statement  "            sb.AppendFormat("Index1={0} Alpha1={1}; Index2={2} Alpha2={3}; Rho={4}"' FirstIndex' FirstAlpha' SecondIndex' SecondAlpha' Threshold); " is 134.
Long Statement,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The length of the statement  "                            value = float.Parse(oneLine.Substring(indexSeparatorPosition + 1' partEnd - (indexSeparatorPosition + 1))' CultureInfo.InvariantCulture); " is 137.
Long Statement,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,CrossValidation,The length of the statement  "            //    TProblemElement[] subProbElem = CreateSubProblem(foldsElements' foldsLabels' trainFoldIndexes' subProbSize' out subLabels); " is 129.
Long Statement,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,CrossValidateOnFolds,The length of the statement  "                TProblemElement[] subProbElem = CreateSubProblem(foldsElements' foldsLabels' trainFoldIndexes' subProbSize' out subLabels); " is 123.
Long Statement,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,CreateSubProblem,The length of the statement  "                Debug.Assert(foldsLabels[trainFoldIndex].Count == foldsElements[trainFoldIndex].Count' "---Two lists should have the same lenght"); " is 131.
Long Statement,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,TrainAndTestValidation,The length of the statement  "            Console.WriteLine(string.Format("init' dispose and prediction on {0} elements takes {1}' correct={2}"' TestProblem.ElementsCount' t.Elapsed'correct)); " is 150.
Long Statement,KMLib,CSVM<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\CSVM.cs,Train,The length of the statement  "            Console.WriteLine("model obj={0} rho={1} nSV={2} iter={3}"' model.Obj' model.Bias' model.SupportElements.Length'model.Iter);" is 124.
Complex Conditional,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,KKTViolator,The conditional expression  "(r1 < -tolerance && alpha < C) || (r1 > tolerance && alpha > 0)"  is complex.
Complex Conditional,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ExamineExample,The conditional expression  "(r1 < -tolerance && alph1 < C) || (r1 > tolerance && alph1 > 0)"  is complex.
Magic Number,KMLib.Evaluate,LinearPrimalEvaluator,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Evaluate\LinearPrimalEvaluator.cs,Predict,The following statement contains a magic number: TrainedModel.NumberOfClasses == 2
Magic Number,KMLib.Evaluate,LinearPrimalEvaluator,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Evaluate\LinearPrimalEvaluator.cs,ComputeDecisions,The following statement contains a magic number: TrainedModel.NumberOfClasses == 2
Magic Number,KMLib.Evaluate,RBFDualEvaluator,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,Predict,The following statement contains a magic number: Parallel.For(0' elements.Length'                  i =>                  {                        //for (int i = 0; i < elements.Length; i++)                      //{                      float x1Squere = elements[i].DotProduct();// linKernel.Product(elements[i]' elements[i]);//linKernel.DiagonalDotCache[i];                                            float sum = 0;                        int index = -1;                        for (int k = 0; k < TrainedModel.SupportElementsIndexes.Length; k++)                      {                          //support vector squere                          float x2Squere = linKernel.DiagonalDotCache[k];                            float dot = linKernel.Product(elements[i]' TrainedModel.SupportElements[k]);                            float rbfVal = (float)Math.Exp(-gamma * (x1Squere + x2Squere - 2 * dot));                              index = TrainedModel.SupportElementsIndexes[k];                          sum += TrainedModel.Alpha[index] * TrainedModel.Y[k] * rbfVal;                      }                      sum -= TrainedModel.Bias;                      predictions[i] = sum < 0 ? -1 : 1;                  }              );
Magic Number,KMLib.Evaluate,RBFDualEvaluator,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,PredictVal,The following statement contains a magic number: float rbfVal = (float)Math.Exp(-gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.Helpers,Vector,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\SparseVec.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,KMLib.Helpers,Vector,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\SparseVec.cs,ToString,The following statement contains a magic number: i < Math.Min(5'Indices.Length)
Magic Number,KMLib.Helpers,BlockCache,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size /= 4;
Magic Number,KMLib.Helpers,BlockCache,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size -= _count * (16 / 4);
Magic Number,KMLib.Helpers,BlockCache,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size -= _count * (16 / 4);
Magic Number,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: int listCapacity = 1 << 13;
Magic Number,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: Dictionary<float' int> coutLabels = new Dictionary<float' int>(10);
Magic Number,KMLib.Helpers,IOHelper,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: List<KeyValuePair<int' float>> vec = new List<KeyValuePair<int' float>>(32);
Magic Number,KMLib.Helpers,Point2D,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Helpers\Point2D.cs,GetHashCode,The following statement contains a magic number: return X.GetHashCode()*29 + Y.GetHashCode();
Magic Number,KMLib.Kernels,ChiSquaredKernel,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Kernels\ChiSquaredKernel.cs,Product,The following statement contains a magic number: return 1.0f-0.5f*result;
Magic Number,KMLib.Kernels,RbfParameterSelection,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Kernels\RBFParameterSelection.cs,SearchParams,The following statement contains a magic number: float bestGamma = -2f;
Magic Number,KMLib.Kernels,CachedKernel<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Kernels\CachedKernel.cs,CachedKernel,The following statement contains a magic number: cache = new BlockCache(problem.ElementsCount' (long)(CacheSize * (1 << 20)));
Magic Number,KMLib.Kernels,RbfKernel,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Kernels\RbfKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib,Validation<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Validation.cs,MakeFoldsSplit,The following statement contains a magic number: int nr_class = 2;
Magic Number,KMLib,Model<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Model.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,KMLib,Problem<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: NumberOfClasses = 2;
Magic Number,KMLib,Problem<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: ElementLabels = new float[2]{-1'1};
Magic Number,KMLib,Problem<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: NumberOfClasses = 2;
Magic Number,KMLib,Problem<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: ElementLabels = new float[2] { -1' 1 };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,The following statement contains a magic number: nr_class == 2
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: int maxIter = 200000;
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: float step = 0.01f;
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: hess_step = 0.01f;
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,UpdateWandAlpha,The following statement contains a magic number: Math.Abs(d) < 1e-10
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,The following statement contains a magic number: nr_class == 2
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The following statement contains a magic number: double step = 0.01f;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double step = 0.01f;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: int M = 10;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double sig1 = 0.1;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double sig2 = 0.9;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double gamma = 10e-4;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double l_min = 10e-20;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double l_max = 10e20;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: lambda = (sig1 * lambda + sig2 * lambda) / 2;
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: i < 10
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,UpdateWandAlpha,The following statement contains a magic number: Math.Abs(d) < 1e-12
Magic Number,KMLib.SVMSolvers,BBLinSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeGradient,The following statement contains a magic number: Math.Abs(alpha[i]) > 10e-10
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: float[][] ker2Cols = new float[2][];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: counter = Math.Min(problemSize' 1000);
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: si.obj = v / 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: float[][] ker2Cols = new float[2][];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: counter = Math.Min(problemSize' 1000);
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,The following statement contains a magic number: float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The following statement contains a magic number: int max_nr_class = 16;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The following statement contains a magic number: max_nr_class *= 2;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: double[] diag = new double[] { 0.5 / Cn' 0' 0.5 / Cp };
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: double[] diag = new double[] { 0.5 / Cn' 0' 0.5 / Cp };
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: diag[2] = 0;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: upper_bound[2] = Cp;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: int max_iter = 5000;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: Math.Abs(PG) > 1.0e-12
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v += alpha[i] * (alpha[i] * diag[y_i + 1] - 2);
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v += alpha[i] * (alpha[i] * diag[y_i + 1] - 2);
Magic Number,KMLib.SVMSolvers,LinearSolver,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: counter = Math.Min(problemSize' 1000);
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,ObjVal,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,The following statement contains a magic number: quad_coef = (float)(data.Q_i[i] + QD[j] - 2.0 * y[i] * data.Q_i[j]);
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: counter = Math.Min(problemSize' 1000);
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The following statement contains a magic number: float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeAlphaStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: counter = Math.Min(problemSize' 1000);
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12f;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,reconstruct_gradient,The following statement contains a magic number: nr_free * problemSize > 2 * active_size * (problemSize - active_size)
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,The following statement contains a magic number: float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,do_shrinking,The following statement contains a magic number: unshrink == false && GMax1 + GMax2 <= EPS * 10
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Duplicate Code,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,D:\research\architectureSmells\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The method contains a code clone-set at the following line numbers (starting from the method definition): ((55' 82)' (90' 117))
