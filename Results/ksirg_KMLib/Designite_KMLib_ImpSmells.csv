Implementation smell,Namespace,Class,File,Method,Description
Long Method,KMLib.Helpers,IOHelper,C:\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The method has 122 lines of code.
Long Method,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,The method has 101 lines of code.
Long Method,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,The method has 102 lines of code.
Long Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The method has 237 lines of code.
Long Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The method has 235 lines of code.
Long Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The method has 228 lines of code.
Long Method,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeModel,The method has 130 lines of code.
Long Method,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The method has 189 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The method has 267 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The method has 278 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,select_working_set,The method has 134 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The method has 147 lines of code.
Long Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The method has 125 lines of code.
Long Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The method has 228 lines of code.
Long Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The method has 153 lines of code.
Complex Method,KMLib.Helpers,BlockCache,C:\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,SwapIndex,Cyclomatic complexity of the method is 10
Complex Method,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,Cyclomatic complexity of the method is 29
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,select_working_set,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,Cyclomatic complexity of the method is 29
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,select_working_set,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,Cyclomatic complexity of the method is 26
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeModel,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,Cyclomatic complexity of the method is 18
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,Cyclomatic complexity of the method is 27
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,Cyclomatic complexity of the method is 28
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeAlphaStep,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,Cyclomatic complexity of the method is 10
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,Cyclomatic complexity of the method is 29
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 9
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,Cyclomatic complexity of the method is 14
Complex Method,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,do_shrinking,Cyclomatic complexity of the method is 12
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ComputeModel,Cyclomatic complexity of the method is 8
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ExamineExample,Cyclomatic complexity of the method is 13
Complex Method,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,Cyclomatic complexity of the method is 14
Long Parameter List,KMLib.Helpers,AlphaInfo,C:\repos\ksirg_KMLib\KMLib\Helpers\AlphaInfo.cs,AlphaInfo,The method has 5 parameters. Parameters: k' alpha1' y1' E1' product
Long Parameter List,KMLib.Helpers,StepPairVariable,C:\repos\ksirg_KMLib\KMLib\Helpers\StepVariable.cs,StepPairVariable,The method has 5 parameters. Parameters: st1' st2' product' si' eta
Long Parameter List,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,CreateSubProblem,The method has 5 parameters. Parameters: foldsElements' foldsLabels' trainFoldIndexes' subProbSize' subLabels
Long Parameter List,KMLib,Problem<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The method has 5 parameters. Parameters: sparseVec' labels' numberOfFeatures' numberOfClasses' elementClasses
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,UpdateWandAlpha,The method has 7 parameters. Parameters: update_alpha' update_w' base_alpha' base_w' step' dir' sub_prob
Long Parameter List,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeGradient,The method has 5 parameters. Parameters: sub_prob' w' alpha' diag' grad
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The method has 5 parameters. Parameters: sub_prob' w' epsilon' Cp' Cn
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,UpdateWandAlpha,The method has 5 parameters. Parameters: alpha' w' step' dir' sub_prob
Long Parameter List,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeGradient,The method has 5 parameters. Parameters: sub_prob' w' alpha' diag' grad
Long Parameter List,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The method has 6 parameters. Parameters: problem' nr_class' label' start' count' perm
Long Parameter List,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The method has 6 parameters. Parameters: sub_prob' w' eps' Cp' Cn' solver_type
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The method has 5 parameters. Parameters: GMax' GMax2' i' Q_i' minIdx
Long Parameter List,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The method has 5 parameters. Parameters: GMax' rangePart' i' Q_i' minIdx
Long Parameter List,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The method has 5 parameters. Parameters: minusOnes' y_' alpha_' si' shrinking
Long Statement,KMLib.Evaluate,RBFDualEvaluator,C:\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,Predict,The length of the statement  "                    float x1Squere = elements[i].DotProduct();// linKernel.Product(elements[i]' elements[i]);//linKernel.DiagonalDotCache[i]; " is 121.
Long Statement,KMLib.Helpers,AlphaPair,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\AlphaPair.cs,ToString,The length of the statement  "            sb.AppendFormat("Index1={0} Alpha1={1}; Index2={2} Alpha2={3}; Rho={4}"' FirstIndex' FirstAlpha' SecondIndex' SecondAlpha' Threshold); " is 134.
Long Statement,KMLib.Helpers,IOHelper,C:\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The length of the statement  "                            value = float.Parse(oneLine.Substring(indexSeparatorPosition + 1' partEnd - (indexSeparatorPosition + 1))' CultureInfo.InvariantCulture); " is 137.
Long Statement,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,CrossValidation,The length of the statement  "            //    TProblemElement[] subProbElem = CreateSubProblem(foldsElements' foldsLabels' trainFoldIndexes' subProbSize' out subLabels); " is 129.
Long Statement,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,CrossValidateOnFolds,The length of the statement  "                TProblemElement[] subProbElem = CreateSubProblem(foldsElements' foldsLabels' trainFoldIndexes' subProbSize' out subLabels); " is 123.
Long Statement,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,CreateSubProblem,The length of the statement  "                Debug.Assert(foldsLabels[trainFoldIndex].Count == foldsElements[trainFoldIndex].Count' "---Two lists should have the same lenght"); " is 131.
Long Statement,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,TrainAndTestValidation,The length of the statement  "            Console.WriteLine(string.Format("init' dispose and prediction on {0} elements takes {1}' correct={2}"' TestProblem.ElementsCount' t.Elapsed'correct)); " is 150.
Long Statement,KMLib,CSVM<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\CSVM.cs,Train,The length of the statement  "            Console.WriteLine("model obj={0} rho={1} nSV={2} iter={3}"' model.Obj' model.Bias' model.SupportElements.Length'model.Iter);" is 124.
Complex Conditional,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,KKTViolator,The conditional expression  "(r1 < -tolerance && alpha < C) || (r1 > tolerance && alpha > 0)"  is complex.
Complex Conditional,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ExamineExample,The conditional expression  "(r1 < -tolerance && alph1 < C) || (r1 > tolerance && alph1 > 0)"  is complex.
Magic Number,KMLib.Evaluate,LinearPrimalEvaluator,C:\repos\ksirg_KMLib\KMLib\Evaluate\LinearPrimalEvaluator.cs,Predict,The following statement contains a magic number: if (TrainedModel.NumberOfClasses == 2)              {                  //add multiplication by first label                  var lab0 = TrainedModel.Labels[0];                  //odwróciłem znak                  //return (dec_values[0]*lab0 > 0) ? TrainedModel.Labels[0] : TrainedModel.Labels[1];                                    return (dec_values[0] > 0) ? TrainedModel.Labels[0] : TrainedModel.Labels[1];              }              else              {                  int dec_max_idx = 0;                  for (int i = 1; i < TrainedModel.NumberOfClasses; i++)                  {                      if (dec_values[i] > dec_values[dec_max_idx]) dec_max_idx = i;                  }                  return TrainedModel.Labels[dec_max_idx];// model.label[dec_max_idx];              }
Magic Number,KMLib.Evaluate,LinearPrimalEvaluator,C:\repos\ksirg_KMLib\KMLib\Evaluate\LinearPrimalEvaluator.cs,ComputeDecisions,The following statement contains a magic number: if (TrainedModel.NumberOfClasses == 2)// && TrainedModel.solverType != SolverType.MCSVM_CS)                  nr_w = 1;              else                  nr_w = TrainedModel.NumberOfClasses;
Magic Number,KMLib.Evaluate,RBFDualEvaluator,C:\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,Predict,The following statement contains a magic number: Parallel.For(0' elements.Length'                  i =>                  {                        //for (int i = 0; i < elements.Length; i++)                      //{                      float x1Squere = elements[i].DotProduct();// linKernel.Product(elements[i]' elements[i]);//linKernel.DiagonalDotCache[i];                                            float sum = 0;                        int index = -1;                        for (int k = 0; k < TrainedModel.SupportElementsIndexes.Length; k++)                      {                          //support vector squere                          float x2Squere = linKernel.DiagonalDotCache[k];                            float dot = linKernel.Product(elements[i]' TrainedModel.SupportElements[k]);                            float rbfVal = (float)Math.Exp(-gamma * (x1Squere + x2Squere - 2 * dot));                              index = TrainedModel.SupportElementsIndexes[k];                          sum += TrainedModel.Alpha[index] * TrainedModel.Y[k] * rbfVal;                      }                      sum -= TrainedModel.Bias;                      predictions[i] = sum < 0 ? -1 : 1;                  }              );
Magic Number,KMLib.Evaluate,RBFDualEvaluator,C:\repos\ksirg_KMLib\KMLib\Evaluate\RBFEvaluator.cs,PredictVal,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElementsIndexes.Length; k++)              {                  //support vector squere                  float x2Squere = TrainedModel.SupportElements[k].DotProduct();// linKernel.DiagonalDotCache[k];                    float dot = linKernel.Product(element' TrainedModel.SupportElements[k]);                    float rbfVal = (float)Math.Exp(-gamma * (x1Squere + x2Squere - 2 * dot));                      index = TrainedModel.SupportElementsIndexes[k];                  sum += TrainedModel.Alpha[index] * TrainedModel.Y[k] * rbfVal;              }
Magic Number,KMLib.Helpers,Vector,C:\repos\ksirg_KMLib\KMLib\Helpers\SparseVec.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,KMLib.Helpers,Vector,C:\repos\ksirg_KMLib\KMLib\Helpers\SparseVec.cs,ToString,The following statement contains a magic number: for (int i = 0; i < Math.Min(5'Indices.Length); i++)              {                  sb.AppendFormat("{0}/{1:0.00} ;"' Indices[i]' Values[i]);              }
Magic Number,KMLib.Helpers,BlockCache,C:\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size /= 4;
Magic Number,KMLib.Helpers,BlockCache,C:\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size -= _count * (16 / 4);
Magic Number,KMLib.Helpers,BlockCache,C:\repos\ksirg_KMLib\KMLib\Helpers\BlockCache.cs,BlockCache,The following statement contains a magic number: _size -= _count * (16 / 4);
Magic Number,KMLib.Helpers,IOHelper,C:\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: int listCapacity = 1 << 13;
Magic Number,KMLib.Helpers,IOHelper,C:\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: Dictionary<float' int> coutLabels = new Dictionary<float' int>(10);
Magic Number,KMLib.Helpers,IOHelper,C:\repos\ksirg_KMLib\KMLib\Helpers\IOHelpers.cs,ReadVectorsFromFile,The following statement contains a magic number: List<KeyValuePair<int' float>> vec = new List<KeyValuePair<int' float>>(32);
Magic Number,KMLib.Helpers,Point2D,C:\repos\ksirg_KMLib\KMLib\Helpers\Point2D.cs,GetHashCode,The following statement contains a magic number: return X.GetHashCode()*29 + Y.GetHashCode();
Magic Number,KMLib.Kernels,CachedKernel<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Kernels\CachedKernel.cs,CachedKernel,The following statement contains a magic number: cache = new BlockCache(problem.ElementsCount' (long)(CacheSize * (1 << 20)));
Magic Number,KMLib.Kernels,RbfKernel,C:\repos\ksirg_KMLib\KMLib\Kernels\RbfKernel.cs,Product,The following statement contains a magic number: float prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));
Magic Number,KMLib.Kernels,RbfKernel,C:\repos\ksirg_KMLib\KMLib\Kernels\RbfKernel.cs,Product,The following statement contains a magic number: if (element1 == element2)              {                  //if (DiagonalDotCacheBuilded)                  //    return DiagonalDotCache[element1];                  //else                  //{                      //all parts are the same                     // x1Squere = x2Squere = dot = linKernel.Product(element1' element1);                      //prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));                     // (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero                      //so we can prod set to 1 beceause exp(0)==1                      prod = 1f;                  //}              }              else              {                  //when element1 and element2 are different we have to compute all parts                  x1Squere = linKernel.Product(element1' element1);                  x2Squere = linKernel.Product(element2' element2);                  dot = linKernel.Product(element1' element2);                  prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));              }
Magic Number,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,MakeFoldsSplit,The following statement contains a magic number: int nr_class = 2;
Magic Number,KMLib,Validation<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Validation.cs,SetFoldsStarts,The following statement contains a magic number: for (int i = 0; i <= nrFolds; i++)              {                  int newFoldStart = i * probSize / nrFolds;                    if (lastFoldStart == newFoldStart)                      newFoldStart += 1;                  else if (lastFoldStart + 2 == newFoldStart)                  {                      newFoldStart -= 1;                  }                  foldStart[i] = newFoldStart;                  lastFoldStart = foldStart[i];              }
Magic Number,KMLib,Model<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Model.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,KMLib,Problem<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: NumberOfClasses = 2;
Magic Number,KMLib,Problem<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: ElementLabels = new float[2]{-1'1};
Magic Number,KMLib,Problem<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: NumberOfClasses = 2;
Magic Number,KMLib,Problem<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\Problem.cs,Problem,The following statement contains a magic number: ElementLabels = new float[2] { -1' 1 };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2)              {                    float[] w = new float[w_size];                  //for (int z = 0; z < w.Length; z++)                  //{                  //    w[z] = 1.0f;                  //}                      int e0 = start[0] + count[0];                  int k = 0;                  for (; k < e0; k++)                      sub_prob.Y[k] = +1;                  for (; k < sub_prob.ElementsCount; k++)                      sub_prob.Y[k] = -1;                        solve_l2r_l2_svc_parallel(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                    model.W = new double[w_size];                  for (int s = 0; s < w.Length; s++)                  {                      model.W[s] = w[s];                  }              }              else              {                  model.W = new double[w_size * nr_class];                  float[] w = new float[w_size];                      ///one against many                  for (int i = 0; i < nr_class; i++)                  {                      int si = start[i];                      int ei = si + count[i];                        int k = 0;                      for (; k < si; k++)                          sub_prob.Y[k] = -1;                      for (; k < ei; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        //train_one(sub_prob' param' w' weighted_C[i]' param.C);                      solve_l2r_l2_svc_parallel(sub_prob' w' epsilon' weighted_C[i]' C);                        for (j = 0; j < n; j++)                          model.W[j * nr_class + i] = w[j];                  }              }
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: int maxIter = 200000;
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,solve_l2r_l2_svc_parallel,The following statement contains a magic number: float[] diag = new float[] { (float)(0.5 / Cn)' 0' (float)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,ConjugateLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ConjugateLinSolver.cs,UpdateWandAlpha,The following statement contains a magic number: for (int p = 0; p < base_alpha.Length; p++)              {                                    float old_alpha = base_alpha[p];                    float alphaStep = step*dir[p];                    update_alpha[p] = Math.Max(base_alpha[p] + alphaStep' 0);// base_alpha[p] + alphaStep;//                                     var spVec = sub_prob.Elements[p];                  float d = (update_alpha[p] - old_alpha); // we multiply by *y_i  4 lines lower                                    //jeśli uaktualinienie jest małe                  if (Math.Abs(d) < 1e-10)                      continue;                  sbyte y_i = (sbyte)sub_prob.Y[p];                  d *= y_i;                  int idx=-1;                  for (int k = 0; k < spVec.Count; k++)                  {                      idx = spVec.Indices[k] - 1;                      update_w[idx] +=d * spVec.Values[k];                  }                }
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2)              {                    double[] w = new double[w_size];                  //for (int z = 0; z < w.Length; z++)                  //{                  //    w[z] = 1.0f;                  //}                      int e0 = start[0] + count[0];                  int k = 0;                  for (; k < e0; k++)                      sub_prob.Y[k] = +1;                  for (; k < sub_prob.ElementsCount; k++)                      sub_prob.Y[k] = -1;                        solve_l2r_l2_svc_bb(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l2_svc_nm_bb(sub_prob' w' epsilon' weighted_C[0]' weighted_C[1]);                  //solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                    model.W = new double[w_size];                  for (int s = 0; s < w.Length; s++)                  {                      model.W[s] = w[s];                  }              }              else              {                  model.W = new double[w_size * nr_class];                  double[] w = new double[w_size];                      ///one against many                  for (int i = 0; i < nr_class; i++)                  {                      int si = start[i];                      int ei = si + count[i];                        int k = 0;                      for (; k < si; k++)                          sub_prob.Y[k] = -1;                      for (; k < ei; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        //train_one(sub_prob' param' w' weighted_C[i]' param.C);                      solve_l2r_l2_svc_bb(sub_prob' w' epsilon' weighted_C[i]' C);                        for (j = 0; j < n; j++)                          model.W[j * nr_class + i] = w[j];                  }              }
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double[] diag = new double[] { (double)(0.5 / Cn)' 0' (double)(0.5 / Cp) };
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: int M = 10;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double sig1 = 0.1;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double sig2 = 0.9;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double gamma = 10e-4;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double l_min = 10e-20;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: double l_max = 10e20;
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: while (iter <= maxIter)              {                    max_funcVal = func_vals.Max();                    lambda = step;                    for (int i = 0; i < 10; i++)                  {                      Buffer.BlockCopy(alpha' 0' alpha_tmp' 0' alpha.Length * sizeof(double));                      Buffer.BlockCopy(w' 0' w_tmp' 0' w.Length * sizeof(double));                        UpdateWandAlpha(alpha_tmp' w_tmp' -lambda' projGrad' sub_prob);                        obj = ComputeObj(w_tmp' alpha_tmp' sub_prob' diag);                        double linPart = gamma * ComputeDiff(alpha_tmp' alpha' projGrad);                      if (obj <= (max_funcVal + linPart))                      {                          int idx = (iter+1) % M;                          func_vals[idx] = obj;                          break;                        }                      lambda = (sig1 * lambda + sig2 * lambda) / 2;                    }                      //remember old alpha                    //Buffer.BlockCopy(alpha' 0' alphaOld' 0' alpha.Length * sizeof(double));                  //Buffer.BlockCopy(alpha_tmp' 0' alpha' 0' alpha.Length * sizeof(double));                  var tmpPtr = alphaOld;                  alphaOld = alpha;                  alpha = alpha_tmp;                  alpha_tmp = tmpPtr;                    //Buffer.BlockCopy(w_tmp' 0' w' 0' w.Length * sizeof(double));                  var w_tmpPtr = w;                  w = w_tmp;                  w_tmp = w_tmpPtr;                                    // Buffer.BlockCopy(projGrad' 0' oldGrad' 0' projGrad.Length * sizeof(double));                  var grad_tmpPtr = oldGrad;                  oldGrad = projGrad;                  projGrad = grad_tmpPtr;                      //computes -gradient                  //grad = b-A*xtemp'                   gradNorm = ComputeGradient(sub_prob' w' alpha' diag' ref projGrad);                    //stop condition                  if (gradNorm < epsilon)                  {                      break;                  }                    step = ComputeBBStep(alpha' alphaOld' projGrad' oldGrad);                    iter++;              }
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,solve_l2r_l2_svc_nm_bb,The following statement contains a magic number: while (iter <= maxIter)              {                    max_funcVal = func_vals.Max();                    lambda = step;                    for (int i = 0; i < 10; i++)                  {                      Buffer.BlockCopy(alpha' 0' alpha_tmp' 0' alpha.Length * sizeof(double));                      Buffer.BlockCopy(w' 0' w_tmp' 0' w.Length * sizeof(double));                        UpdateWandAlpha(alpha_tmp' w_tmp' -lambda' projGrad' sub_prob);                        obj = ComputeObj(w_tmp' alpha_tmp' sub_prob' diag);                        double linPart = gamma * ComputeDiff(alpha_tmp' alpha' projGrad);                      if (obj <= (max_funcVal + linPart))                      {                          int idx = (iter+1) % M;                          func_vals[idx] = obj;                          break;                        }                      lambda = (sig1 * lambda + sig2 * lambda) / 2;                    }                      //remember old alpha                    //Buffer.BlockCopy(alpha' 0' alphaOld' 0' alpha.Length * sizeof(double));                  //Buffer.BlockCopy(alpha_tmp' 0' alpha' 0' alpha.Length * sizeof(double));                  var tmpPtr = alphaOld;                  alphaOld = alpha;                  alpha = alpha_tmp;                  alpha_tmp = tmpPtr;                    //Buffer.BlockCopy(w_tmp' 0' w' 0' w.Length * sizeof(double));                  var w_tmpPtr = w;                  w = w_tmp;                  w_tmp = w_tmpPtr;                                    // Buffer.BlockCopy(projGrad' 0' oldGrad' 0' projGrad.Length * sizeof(double));                  var grad_tmpPtr = oldGrad;                  oldGrad = projGrad;                  projGrad = grad_tmpPtr;                      //computes -gradient                  //grad = b-A*xtemp'                   gradNorm = ComputeGradient(sub_prob' w' alpha' diag' ref projGrad);                    //stop condition                  if (gradNorm < epsilon)                  {                      break;                  }                    step = ComputeBBStep(alpha' alphaOld' projGrad' oldGrad);                    iter++;              }
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,UpdateWandAlpha,The following statement contains a magic number: for (int p = 0; p < alpha.Length; p++)              {                                    double old_alpha = alpha[p];                  double alphaStep = step*dir[p];                    //projected update' all alphas>=0                  double alpha_new = Math.Max(alpha[p] + alphaStep' 0);// base_alpha[p] + alphaStep;//                                     //real alpha update                  double d = (alpha_new - old_alpha); // we multiply by *y_i  4 lines lower                                    //if update is small                  if (Math.Abs(d) < 1e-12)                      continue;                    sbyte y_i = (sbyte)sub_prob.Y[p];                  d *= y_i;                  int idx=-1;                    var spVec = sub_prob.Elements[p];                  //if alpha[p] has changed then we should                   //change w- vector                                   for (int k = 0; k < spVec.Count; k++)                  {                      idx = spVec.Indices[k] - 1;                      w[idx] +=(double) d * spVec.Values[k];                  }                    alpha[p] = (double)alpha_new;                }
Magic Number,KMLib.SVMSolvers,BBLinSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\BBLinSolver.cs,ComputeGradient,The following statement contains a magic number: for (int i = 0; i < grad.Length; i++)              {                  //intialized gradient i-th row                  grad[i] = 0;                    var element = sub_prob.Elements[i];                  //computes dot product between W and all elements                  double dot = 0;                  for (int k = 0; k < element.Count; k++)                  {                      dot += w[element.Indices[k] - 1] * element.Values[k];                  }                    sbyte y_i = (sbyte)sub_prob.Y[i];                  //"minus" -gradient                  //grad[i] =1- grad[i] * y_i - alpha[i]*diag[y_i+1];                    //normal gradient                    grad[i] = (double)(dot * y_i + alpha[i] * diag[y_i + 1] - 1);                      //projection                  if (alpha[i] == 0)                  {                      // grad[i] = Math.Min(0' grad[i]);                  }                  //else                  //{                  //    grad[i] = grad[i];                  //    // projGrad_i[i] = grad_i[i];                  //}                    //minus gradient - descent direction                  // grad[i] = -grad[i];                    //projected maximum norm                  if (Math.Abs(alpha[i]) > 10e-10)                  {                      max = Math.Max(max' Math.Abs(grad[i]));                  }                  //else                  //{                  //    max = Math.Max(max' Math.Abs(grad[i]));                  //}              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: float[][] ker2Cols = new float[2][];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                      kernel.AllProducts(i' j' ker2Cols);                  float[] Q_i = ker2Cols[0];                  float[] Q_j = ker2Cols[1];                    //float[] Q_i = Q.GetQ(i' active_size);                  //float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                      kernel.AllProducts(i' j' ker2Cols);                  float[] Q_i = ker2Cols[0];                  float[] Q_j = ker2Cols[1];                    //float[] Q_i = Q.GetQ(i' active_size);                  //float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                      kernel.AllProducts(i' j' ker2Cols);                  float[] Q_i = ker2Cols[0];                  float[] Q_j = ker2Cols[1];                    //float[] Q_i = Q.GetQ(i' active_size);                  //float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] + p[i]);                    si.obj = v / 2;              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))              {                  for (i = active_size; i < problemSize; i++)                  {                      float[] Q_i = Q.GetQ(i' active_size);                      for (j = 0; j < active_size; j++)                          if (is_free(j))                              G[i] += alpha[j] * Q_i[j];                  }              }              else              {                  for (i = 0; i < active_size; i++)                      if (is_free(i))                      {                          float[] Q_i = Q.GetQ(i' problemSize);                          float alpha_i = alpha[i];                          for (j = active_size; j < problemSize; j++)                              G[j] += alpha_i * Q_i[j];                      }              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)              {                  unshrink = true;                  reconstruct_gradient();                  active_size = problemSize;              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver2Cols<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver2Cols.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: float[][] ker2Cols = new float[2][];
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                                          float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                                          float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                                          float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          //Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                         // Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] + p[i]);                    si.obj = v / 2;              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))              {                  for (i = active_size; i < problemSize; i++)                  {                      float[] Q_i = Q.GetQ(i' active_size);                      for (j = 0; j < active_size; j++)                          if (is_free(j))                              G[i] += alpha[j] * Q_i[j];                  }              }              else              {                  for (i = 0; i < active_size; i++)                      if (is_free(i))                      {                          float[] Q_i = Q.GetQ(i' problemSize);                          float alpha_i = alpha[i];                          for (j = active_size; j < problemSize; j++)                              G[j] += alpha_i * Q_i[j];                      }              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)              {                  unshrink = true;                  reconstruct_gradient();                  active_size = problemSize;              }
Magic Number,KMLib.SVMSolvers,SmoFirstOrderSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFirstOrderSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    int i = rand.Next(active_size);                  int j = i;                  while (j==i)                  {                      j = rand.Next(active_size);                       }                                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                    update_alpha_status(i);                  update_alpha_status(j);                        double nG = 0;                  double nL1G = 0;                  double nMaxG = double.NegativeInfinity;                    float GMax = -INF;                  float GMax2 = -INF;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                      //nG += G[k] * G[k];                      //nL1G += Math.Abs( G[k]);                      //nMaxG = Math.Max(nMaxG' Math.Abs(G[k]));                        if (y[k] == +1)                      {                          if (!is_upper_bound(k))                          {                              if (-G[k] >= GMax)                                  GMax = -G[k];                          }                          if (!is_lower_bound(k))                          {                              if (G[k] >= GMax2)                                  GMax2 = G[k];                          }                      }                      else                      {                          if (!is_lower_bound(k))                          {                              if (G[k] >= GMax)                                  GMax = G[k];                          }                          if (!is_upper_bound(k))                          {                              if (-G[k] >= GMax2)                                  GMax2 = -G[k];                          }                      }                  }                    if (GMax + GMax2 < EPS)                      break;                                      }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    int i = rand.Next(active_size);                  int j = i;                  while (j==i)                  {                      j = rand.Next(active_size);                       }                                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                    update_alpha_status(i);                  update_alpha_status(j);                        double nG = 0;                  double nL1G = 0;                  double nMaxG = double.NegativeInfinity;                    float GMax = -INF;                  float GMax2 = -INF;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                      //nG += G[k] * G[k];                      //nL1G += Math.Abs( G[k]);                      //nMaxG = Math.Max(nMaxG' Math.Abs(G[k]));                        if (y[k] == +1)                      {                          if (!is_upper_bound(k))                          {                              if (-G[k] >= GMax)                                  GMax = -G[k];                          }                          if (!is_lower_bound(k))                          {                              if (G[k] >= GMax2)                                  GMax2 = G[k];                          }                      }                      else                      {                          if (!is_lower_bound(k))                          {                              if (G[k] >= GMax)                                  GMax = G[k];                          }                          if (!is_upper_bound(k))                          {                              if (-G[k] >= GMax2)                                  GMax2 = -G[k];                          }                      }                  }                    if (GMax + GMax2 < EPS)                      break;                                      }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] + p[i]);                    si.obj = v / 2;              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))              {                  for (i = active_size; i < problemSize; i++)                  {                      float[] Q_i = Q.GetQ(i' active_size);                      for (j = 0; j < active_size; j++)                          if (is_free(j))                              G[i] += alpha[j] * Q_i[j];                  }              }              else              {                  for (i = 0; i < active_size; i++)                      if (is_free(i))                      {                          float[] Q_i = Q.GetQ(i' problemSize);                          float alpha_i = alpha[i];                          for (j = active_size; j < problemSize; j++)                              G[j] += alpha_i * Q_i[j];                      }              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)              {                  unshrink = true;                  reconstruct_gradient();                  active_size = problemSize;              }
Magic Number,KMLib.SVMSolvers,SmoRandomSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoRandomSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeModel,The following statement contains a magic number: if (solverType == SolverType.MCSVM_CS)              {                  //model.w = new double[n * nr_class];                  model.W = new double[n * nr_class];                  for (int i = 0; i < nr_class; i++)                  {                      for (j = start[i]; j < start[i] + count[i]; j++)                      {                          sub_prob.Y[j] = i;                      }                  }                    //SolverMCSVM_CS solver = new SolverMCSVM_CS(sub_prob' nr_class' weighted_C' param.eps);                  //solver.solve(model.w);              }              else              {                  if (nr_class == 2)                  {                      model.W = new double[w_size];                        int e0 = start[0] + count[0];                      int k = 0;                      for (; k < e0; k++)                          sub_prob.Y[k] = +1;                      for (; k < sub_prob.ElementsCount; k++)                          sub_prob.Y[k] = -1;                        //train_one(sub_prob' param' model.w' weighted_C[0]' weighted_C[1]);                      solve_l2r_l1l2_svc(sub_prob' model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);                  }                  else                  {                      model.W = new double[w_size * nr_class];                      double[] w = new double[w_size];                        ///one against many                      for (int i = 0; i < nr_class; i++)                      {                          int si = start[i];                          int ei = si + count[i];                            int k = 0;                          for (; k < si; k++)                              sub_prob.Y[k] = -1;                          for (; k < ei; k++)                              sub_prob.Y[k] = +1;                          for (; k < sub_prob.ElementsCount; k++)                              sub_prob.Y[k] = -1;                            //train_one(sub_prob' param' w' weighted_C[i]' param.C);                          solve_l2r_l1l2_svc(sub_prob' w' epsilon' weighted_C[0]' C' solverType);                            for (j = 0; j < n; j++)                              model.W[j * nr_class + i] = w[j];                      }                  }                }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The following statement contains a magic number: int max_nr_class = 16;
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,groupClasses,The following statement contains a magic number: for (i = 0; i < l; i++)              {                  int this_label = (int)problem.Y[i];//prob.y[i];                  int j;                  for (j = 0; j < nr_class; j++)                  {                      if (this_label == label[j])                      {                          ++count[j];                          break;                      }                  }                  data_label[i] = j;                  if (j == nr_class)                  {                      if (nr_class == max_nr_class)                      {                          max_nr_class *= 2;                          label = label.CopyToNewArray(max_nr_class);// copyToNewArray(label' max_nr_class);                          count = count.CopyToNewArray(max_nr_class);// copyToNewArray(count' max_nr_class);                      }                      label[nr_class] = this_label;                      count[nr_class] = 1;                      ++nr_class;                  }              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: double[] diag = new double[] { 0.5 / Cn' 0' 0.5 / Cp };
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: double[] diag = new double[] { 0.5 / Cn' 0' 0.5 / Cp };
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: if (solver_type == SolverType.L2R_L1LOSS_SVC_DUAL)              {                  diag[0] = 0;                  diag[2] = 0;                  upper_bound[0] = Cn;                  upper_bound[2] = Cp;              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: if (solver_type == SolverType.L2R_L1LOSS_SVC_DUAL)              {                  diag[0] = 0;                  diag[2] = 0;                  upper_bound[0] = Cn;                  upper_bound[2] = Cp;              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: int max_iter = 5000;
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,solve_l2r_l1l2_svc,The following statement contains a magic number: while (iter < max_iter)              {                  PGmax_new = Double.NegativeInfinity;                  PGmin_new = Double.PositiveInfinity;                        for (i = 0; i < active_size; i++)                  {                      int j = i + rand.Next(active_size - i);// .nextInt(active_size - i);                        //swap(index' i' j);                        index.SwapIndex(i' j);                  }                    for (s = 0; s < active_size; s++)                  {                            i = index[s];                        G = 0;                      sbyte yi = y[i];                        //for (FeatureNode xi : prob.x[i]) {                      //    G += w[xi.index - 1] * xi.value;                      //}                      //above changed into:                      var element = sub_prob.Elements[i];                      for (int k = 0; k < element.Count; k++)                      {                          G += w[element.Indices[k] - 1] * element.Values[k];                      }                        G = G * yi - 1;                        C = upper_bound[GETI(y' i)];                      G += alpha[i] * diag[GETI(y' i)];                        PG = 0;                      if (alpha[i] == 0)                      {                          if (G > PGmax_old)                          {                              //active_size--;                              ////swap(index' s' active_size);                              //index.SwapIndex(s' active_size);                              //s--;                              continue;                          }                          else if (G < 0)                          {                              PG = G;                          }                      }                      else if (alpha[i] == C)                      {                          if (G < PGmin_old)                          {                              //active_size--;                              ////swap(index' s' active_size);                              //index.SwapIndex(s' active_size);                              //s--;                              continue;                          }                          else if (G > 0)                          {                              PG = G;                          }                      }                      else                      {                          PG = G;                      }                        PGmax_new = Math.Max(PGmax_new' PG);                      PGmin_new = Math.Min(PGmin_new' PG);                        if (Math.Abs(PG) > 1.0e-12)                      {                          double alpha_old = alpha[i];                          alpha[i] = Math.Min(Math.Max(alpha[i] - G / QD[i]' 0.0)' C);                            //update vector "w"                          d = (alpha[i] - alpha_old) * yi;                          var spVec = sub_prob.Elements[i];                          for (int k = 0; k < spVec.Count; k++)                          {                              w[spVec.Indices[k] - 1] += d * spVec.Values[k];                          }                          //above                           //for (FeatureNode xi : prob.x[i]) {                          //    w[xi.index - 1] += d * xi.value;                          //}                      }                      // obj= ComputeObj(w' alpha' sub_prob' diag);                  }                  //st.Stop();  #if DEBUG                    //  obj= ComputeObj(w' alpha' sub_prob' diag);                  // Debug.WriteLine("obj = {0}' time = {1}"'obj'st.Elapsed);    #endif                  iter++;                  //if (iter % 10 == 0) info(".");                    if (PGmax_new - PGmin_new <= eps)                  {                      if (active_size == l)                          break;                      else                      {                          active_size = l;                          //  info("*");                          PGmax_old = Double.PositiveInfinity;                          PGmin_old = Double.NegativeInfinity;                          continue;                      }                  }                  PGmax_old = PGmax_new;                  PGmin_old = PGmin_new;                  if (PGmax_old <= 0) PGmax_old = Double.PositiveInfinity;                  if (PGmin_old >= 0) PGmin_old = Double.NegativeInfinity;              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: for (int i = 0; i < alpha.Length; i++)              {                  sbyte y_i = (sbyte)sub_prob.Y[i];                    //original line                  //v += alpha[i] * (alpha[i] * diag[GETI(y_i' i)] - 2);                  v += alpha[i] * (alpha[i] * diag[y_i + 1] - 2);                  if (alpha[i] > 0) ++nSV;              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: for (int i = 0; i < alpha.Length; i++)              {                  sbyte y_i = (sbyte)sub_prob.Y[i];                    //original line                  //v += alpha[i] * (alpha[i] * diag[GETI(y_i' i)] - 2);                  v += alpha[i] * (alpha[i] * diag[y_i + 1] - 2);                  // v1 += 0.5 * alpha[i] * (alpha[i] * diag[y_i + 1] - 2);                  if (alpha[i] > 0) ++nSV;              }
Magic Number,KMLib.SVMSolvers,LinearSolver,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\LinearSolver.cs,ComputeObj,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: while (iter<IterMaX)             {                 if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  int i = working_set[0];                 int j = working_set[1];                                                     ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                                             UpdateGradients(Q_i' Q_j' delta_alpha_i' delta_alpha_j);                  //  Parallel.ForEach(partition' UpdateGradient);                  // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }                                }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: while (iter<IterMaX)             {                 if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  int i = working_set[0];                 int j = working_set[1];                                                     ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                                             UpdateGradients(Q_i' Q_j' delta_alpha_i' delta_alpha_j);                  //  Parallel.ForEach(partition' UpdateGradient);                  // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }                                }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,Solve,The following statement contains a magic number: while (iter<IterMaX)             {                 if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  int i = working_set[0];                 int j = working_set[1];                                                     ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                                    float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                                             UpdateGradients(Q_i' Q_j' delta_alpha_i' delta_alpha_j);                  //  Parallel.ForEach(partition' UpdateGradient);                  // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }                                }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,ObjVal,The following statement contains a magic number: v = v / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)             {                 unshrink = true;                 reconstruct_gradient();                 active_size = problemSize;             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))             {                 for (i = active_size; i < problemSize; i++)                 {                     float[] Q_i = Q.GetQ(i' active_size);                     for (j = 0; j < active_size; j++)                         if (is_free(j))                             G[i] += alpha[j] * Q_i[j];                 }             }             else             {                 for (i = 0; i < active_size; i++)                     if (is_free(i))                     {                         float[] Q_i = Q.GetQ(i' problemSize);                         float alpha_i = alpha[i];                         for (j = active_size; j < problemSize; j++)                             G[j] += alpha_i * Q_i[j];                     }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                 r = sum_free / nr_free;             else                 r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,The following statement contains a magic number: for (int j = data.Range.Item1; j < data.Range.Item2; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         grad_diff = data.GMax + G[j];                         //save max value                         if (G[j] >= GMax2)                             GMax2 = G[j];                            if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] - 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                  localMaxMin.Second = obj_diff;                             }                         }                     }                 }                 else                 {                     if (!is_upper_bound(j))                     {                         grad_diff = data.GMax - G[j];                         //save -max                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                          if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] + 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                 localMaxMin.Second = obj_diff;                             }                         }                     }                 }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,The following statement contains a magic number: for (int j = data.Range.Item1; j < data.Range.Item2; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         grad_diff = data.GMax + G[j];                         //save max value                         if (G[j] >= GMax2)                             GMax2 = G[j];                            if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] - 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                  localMaxMin.Second = obj_diff;                             }                         }                     }                 }                 else                 {                     if (!is_upper_bound(j))                     {                         grad_diff = data.GMax - G[j];                         //save -max                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                          if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] + 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                 localMaxMin.Second = obj_diff;                             }                         }                     }                 }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,The following statement contains a magic number: for (int j = data.Range.Item1; j < data.Range.Item2; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         grad_diff = data.GMax + G[j];                         //save max value                         if (G[j] >= GMax2)                             GMax2 = G[j];                            if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] - 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                  localMaxMin.Second = obj_diff;                             }                         }                     }                 }                 else                 {                     if (!is_upper_bound(j))                     {                         grad_diff = data.GMax - G[j];                         //save -max                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                          if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] + 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                 localMaxMin.Second = obj_diff;                             }                         }                     }                 }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver2<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver2.cs,FindMinPairInThread,The following statement contains a magic number: for (int j = data.Range.Item1; j < data.Range.Item2; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         grad_diff = data.GMax + G[j];                         //save max value                         if (G[j] >= GMax2)                             GMax2 = G[j];                            if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] - 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                  localMaxMin.Second = obj_diff;                             }                         }                     }                 }                 else                 {                     if (!is_upper_bound(j))                     {                         grad_diff = data.GMax - G[j];                         //save -max                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                          if (grad_diff > 0)                         {                              quad_coef = (float)(data.Q_i[i] + QD[j] + 2.0 * y[i] * data.Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              if (obj_diff < localMaxMin.Second)                             {                                 localMaxMin.First = j;                                 localMaxMin.Second = obj_diff;                             }                         }                     }                 }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)             {                  if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  //if (select_working_set(working_set' processors) != 0)                 //    break;                  int i = working_set[0];                 int j = working_set[1];                  ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                  float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                    //for (int k = 0; k < active_size; k++)                 //{                 //    G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                 //}                   var partition = Partitioner.Create(0' active_size);                  Parallel.ForEach(partition' (range) =>                 {                     int rangeEnd = range.Item2;                     for (int k = range.Item1; k < rangeEnd; k++)                     {                         G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                     }                  });                   // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)             {                  if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  //if (select_working_set(working_set' processors) != 0)                 //    break;                  int i = working_set[0];                 int j = working_set[1];                  ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                  float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                    //for (int k = 0; k < active_size; k++)                 //{                 //    G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                 //}                   var partition = Partitioner.Create(0' active_size);                  Parallel.ForEach(partition' (range) =>                 {                     int rangeEnd = range.Item2;                     for (int k = range.Item1; k < rangeEnd; k++)                     {                         G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                     }                  });                   // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)             {                  if (--counter == 0)                 {                     counter = Math.Min(problemSize' 1000);                     if (shrinking) do_shrinking();                     //Procedures.info(".");                 }                  if (select_working_set(working_set' processors) != 0)                 {                     // reconstruct the whole gradient                     reconstruct_gradient();                     // reset active set size and check                     active_size = problemSize;                     // Procedures.info("*");                     if (select_working_set(working_set' processors) != 0)                         break;                     else                         counter = 1;	// do shrinking next iteration                 }                  //if (select_working_set(working_set' processors) != 0)                 //    break;                  int i = working_set[0];                 int j = working_set[1];                  ++iter;                 // update alpha[i] and alpha[j]' handle bounds carefully                 float[] Q_i = Q.GetQ(i' active_size);                 float[] Q_j = Q.GetQ(j' active_size);                  float C_i = get_C(i);                 float C_j = get_C(j);                  float old_alpha_i = alpha[i];                 float old_alpha_j = alpha[j];                  if (y[i] != y[j])                 {                     float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (-G[i] - G[j]) / quad_coef;                     float diff = alpha[i] - alpha[j];                     alpha[i] += delta;                     alpha[j] += delta;                      if (diff > 0)                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = diff;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = -diff;                         }                     }                     if (diff > C_i - C_j)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = C_i - diff;                         }                     }                     else                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = C_j + diff;                         }                     }                 }                 else                 {                     float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                     if (quad_coef <= 0)                         quad_coef = 1e-12f;                     float delta = (G[i] - G[j]) / quad_coef;                     float sum = alpha[i] + alpha[j];                     alpha[i] -= delta;                     alpha[j] += delta;                      if (sum > C_i)                     {                         if (alpha[i] > C_i)                         {                             alpha[i] = C_i;                             alpha[j] = sum - C_i;                         }                     }                     else                     {                         if (alpha[j] < 0)                         {                             alpha[j] = 0;                             alpha[i] = sum;                         }                     }                     if (sum > C_j)                     {                         if (alpha[j] > C_j)                         {                             alpha[j] = C_j;                             alpha[i] = sum - C_j;                         }                     }                     else                     {                         if (alpha[i] < 0)                         {                             alpha[i] = 0;                             alpha[j] = sum;                         }                     }                 }                  // update G                  float delta_alpha_i = alpha[i] - old_alpha_i;                 float delta_alpha_j = alpha[j] - old_alpha_j;                    //for (int k = 0; k < active_size; k++)                 //{                 //    G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                 //}                   var partition = Partitioner.Create(0' active_size);                  Parallel.ForEach(partition' (range) =>                 {                     int rangeEnd = range.Item2;                     for (int k = range.Item1; k < rangeEnd; k++)                     {                         G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                     }                  });                   // update alpha_status and G_bar                  {                     bool ui = is_upper_bound(i);                     bool uj = is_upper_bound(j);                     update_alpha_status(i);                     update_alpha_status(j);                     int k;                     if (ui != is_upper_bound(i))                     {                         Q_i = Q.GetQ(i' problemSize);                         if (ui)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_i * Q_i[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_i * Q_i[k];                     }                      if (uj != is_upper_bound(j))                     {                         Q_j = Q.GetQ(j' problemSize);                         if (uj)                             for (k = 0; k < problemSize; k++)                                 G_bar[k] -= C_j * Q_j[k];                         else                             for (k = 0; k < problemSize; k++)                                 G_bar[k] += C_j * Q_j[k];                     }                 }              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,Solve,The following statement contains a magic number: {                 float v = 0;                 int i;                 for (i = 0; i < problemSize; i++)                     v += alpha[i] * (G[i] + p[i]);                  si.obj = v / 2;             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)             {                 unshrink = true;                 reconstruct_gradient();                 active_size = problemSize;             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))             {                 for (i = active_size; i < problemSize; i++)                 {                     float[] Q_i = Q.GetQ(i' active_size);                     for (j = 0; j < active_size; j++)                         if (is_free(j))                             G[i] += alpha[j] * Q_i[j];                 }             }             else             {                 for (i = 0; i < active_size; i++)                     if (is_free(i))                     {                         float[] Q_i = Q.GetQ(i' problemSize);                         float alpha_i = alpha[i];                         for (j = active_size; j < problemSize; j++)                             G[j] += alpha_i * Q_i[j];                     }             }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The following statement contains a magic number: for (int j = 0; j < active_size; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         float grad_diff = GMax + G[j];                         if (G[j] >= GMax2)                             GMax2 = G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                               minIdx.Add(j' obj_diff);                              //if (obj_diff < obj_diff_Min) //previous "<="                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                              //    // minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                              //}                             //else if (obj_diff_Min < obj_diff_NMin)                             //{                             //  //  minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                 else                 {                     if (!is_upper_bound(j))                     {                         float grad_diff = GMax - G[j];                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              minIdx.Add(j' obj_diff);                             //if (obj_diff < obj_diff_Min)                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                             //    //minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                             //}                             //else if (obj_diff < obj_diff_NMin)                             //{                             //    minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                  //if (minSecIdx.Count > pairsCount)                 //{                 //    var minPair = minSecIdx.Min;                 //    minSecIdx.Remove(minPair);                   //    obj_diff_NMin = minPair.Value;                 //}              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The following statement contains a magic number: for (int j = 0; j < active_size; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         float grad_diff = GMax + G[j];                         if (G[j] >= GMax2)                             GMax2 = G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                               minIdx.Add(j' obj_diff);                              //if (obj_diff < obj_diff_Min) //previous "<="                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                              //    // minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                              //}                             //else if (obj_diff_Min < obj_diff_NMin)                             //{                             //  //  minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                 else                 {                     if (!is_upper_bound(j))                     {                         float grad_diff = GMax - G[j];                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              minIdx.Add(j' obj_diff);                             //if (obj_diff < obj_diff_Min)                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                             //    //minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                             //}                             //else if (obj_diff < obj_diff_NMin)                             //{                             //    minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                  //if (minSecIdx.Count > pairsCount)                 //{                 //    var minPair = minSecIdx.Min;                 //    minSecIdx.Remove(minPair);                   //    obj_diff_NMin = minPair.Value;                 //}              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The following statement contains a magic number: for (int j = 0; j < active_size; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         float grad_diff = GMax + G[j];                         if (G[j] >= GMax2)                             GMax2 = G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                               minIdx.Add(j' obj_diff);                              //if (obj_diff < obj_diff_Min) //previous "<="                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                              //    // minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                              //}                             //else if (obj_diff_Min < obj_diff_NMin)                             //{                             //  //  minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                 else                 {                     if (!is_upper_bound(j))                     {                         float grad_diff = GMax - G[j];                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              minIdx.Add(j' obj_diff);                             //if (obj_diff < obj_diff_Min)                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                             //    //minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                             //}                             //else if (obj_diff < obj_diff_NMin)                             //{                             //    minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                  //if (minSecIdx.Count > pairsCount)                 //{                 //    var minPair = minSecIdx.Min;                 //    minSecIdx.Remove(minPair);                   //    obj_diff_NMin = minPair.Value;                 //}              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjSeq,The following statement contains a magic number: for (int j = 0; j < active_size; j++)             {                 if (y[j] == +1)                 {                     if (!is_lower_bound(j))                     {                         float grad_diff = GMax + G[j];                         if (G[j] >= GMax2)                             GMax2 = G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                               minIdx.Add(j' obj_diff);                              //if (obj_diff < obj_diff_Min) //previous "<="                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                              //    // minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                              //}                             //else if (obj_diff_Min < obj_diff_NMin)                             //{                             //  //  minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                 else                 {                     if (!is_upper_bound(j))                     {                         float grad_diff = GMax - G[j];                         if (-G[j] >= GMax2)                             GMax2 = -G[j];                         if (grad_diff > 0)                         {                             float obj_diff;                             float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                             if (quad_coef > 0)                                 obj_diff = -(grad_diff * grad_diff) / quad_coef;                             else                                 obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                              minIdx.Add(j' obj_diff);                             //if (obj_diff < obj_diff_Min)                             //{                             //    GMin_idx = j;                             //    obj_diff_Min = obj_diff;                             //    //minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff_Min));                             //}                             //else if (obj_diff < obj_diff_NMin)                             //{                             //    minSecIdx.Add(new KeyValuePair<int' float>(j' obj_diff));                              //}                             //else continue;                         }                         //else continue;                     }                     //else continue;                 }                  //if (minSecIdx.Count > pairsCount)                 //{                 //    var minPair = minSecIdx.Min;                 //    minSecIdx.Remove(minPair);                   //    obj_diff_NMin = minPair.Value;                 //}              }
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel,The following statement contains a magic number: Parallel.ForEach(rangePart' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (range' loopState' maxMinPair) =>                {                    int endRange = range.Item2;                    for (int j = range.Item1; j < endRange; j++)                    {                        if (y[j] == +1)                        {                            if (!is_lower_bound(j))                            {                                float grad_diff = GMax + G[j];                                if (G[j] >= maxMinPair.First)                                    maxMinPair.First = G[j];                                   if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                        else                        {                            if (!is_upper_bound(j))                            {                                float grad_diff = GMax - G[j];                                if (-G[j] >= maxMinPair.First)                                    maxMinPair.First = -G[j];                                 if (grad_diff > 0)                                {                                    float obj_diff;                                    float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                    if (quad_coef > 0)                                        obj_diff = -(grad_diff * grad_diff) / quad_coef;                                    else                                        obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                     if (obj_diff < maxMinPair.Second.Second)                                    {                                        maxMinPair.Second.First = j;                                        maxMinPair.Second.Second = obj_diff;                                    }                                }                            }                        }                    }                    return maxMinPair;                }'                (maxMinPair) =>                {                    lock (lockObj)                    {                        if (GMax2Tmp < maxMinPair.First)                            GMax2Tmp = maxMinPair.First;                        //todo: in this solver we use only one value and index'                         minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                    }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,FindMinObjParallel2,The following statement contains a magic number: Parallel.For(0' active_size' () => new Pair<float' Pair<int' float>>(-INF' new Pair<int' float>(-1' INF))'                (j' loopState' maxMinPair) =>                {                    if (y[j] == +1)                    {                        if (!is_lower_bound(j))                        {                            float grad_diff = GMax + G[j];                            if (G[j] >= maxMinPair.First)                                maxMinPair.First = G[j];                              if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                    else                    {                        if (!is_upper_bound(j))                        {                            float grad_diff = GMax - G[j];                            if (-G[j] >= maxMinPair.First)                                maxMinPair.First = -G[j];                             if (grad_diff > 0)                            {                                float obj_diff;                                float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                                if (quad_coef > 0)                                    obj_diff = -(grad_diff * grad_diff) / quad_coef;                                else                                    obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                 if (obj_diff < maxMinPair.Second.Second)                                {                                    maxMinPair.Second.First = j;                                    maxMinPair.Second.Second = obj_diff;                                }                            }                        }                    }                     //if (maxMinPair.Second.First == -1)                    //    return null;                    return maxMinPair;                }'                (maxMinPair) =>                {                    if (maxMinPair != null && maxMinPair.Second.First != -1)                        lock (lockObj)                        {                            if (GMax2Tmp < maxMinPair.First)                                GMax2Tmp = maxMinPair.First;                             minIdx.Add(maxMinPair.Second.First' maxMinPair.Second.Second);                        }                }            );
Magic Number,KMLib.SVMSolvers,ParallelSmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSmoFanSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                 r = sum_free / nr_free;             else                 r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeAlphaStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeAlphaStep,The following statement contains a magic number: if (eta < 0)              {                  //original version with plus                    //a2 = alph2 + y2 * (E2 - E1) / eta;                    a2 = alph2 - y2 * (E1 - E2) / eta;                    if (a2 < L) a2 = L;                  else if (a2 > H) a2 = H;              }              else              {                  {                      float c1 = eta / 2;                      float c2 = y2 * (E1 - E2) - eta * alph2;                      Lobj = c1 * L * L + c2 * L;                      Hobj = c1 * H * H + c2 * H;                  }                    if (Lobj > Hobj + epsilon) a2 = L;                  else if (Lobj < Hobj - epsilon) a2 = H;                  else a2 = alph2;              }
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The following statement contains a magic number: if (eta < 0)              {                  //original version with plus                    //a2 = alph2 + y2 * (E2 - E1) / eta;                    a2 = alph2 - y2 * (E1 - E2) / eta;                    if (a2 < L) a2 = L;                  else if (a2 > H) a2 = H;              }              else              {                  {                      float c1 = eta / 2;                      float c2 = y2 * (E1 - E2) - eta * alph2;                      Lobj = c1 * L * L + c2 * L;                      Hobj = c1 * H * H + c2 * H;                  }                    if (Lobj > Hobj + epsilon) a2 = L;                  else if (Lobj < Hobj - epsilon) a2 = H;                  else a2 = alph2;              }
Magic Number,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,TakeStep,The following statement contains a magic number: if (a1 > 0 && a1 < C)                  bnew = b + E1 + y1 * (a1 - alph1) * k11 + y2 * (a2 - alph2) * k12;              else              {                  if (a2 > 0 && a2 < C)                      bnew = b + E2 + y1 * (a1 - alph1) * k12 + y2 * (a2 - alph2) * k22;                  else                  {                      b1 = b + E1 + y1 * (a1 - alph1) * k11 + y2 * (a2 - alph2) * k12;                      b2 = b + E2 + y1 * (a1 - alph1) * k12 + y2 * (a2 - alph2) * k22;                      bnew = (b1 + b2) / 2;                  }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: int counter = Math.Min(problemSize' 1000) + 1;
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: int[] working_set = new int[2];
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: while (true)              {                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(problemSize' 1000);                      if (shrinking) do_shrinking();                      //Procedures.info(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = problemSize;                      // Procedures.info("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1;	// do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.GetQ(i' active_size);                  float[] Q_j = Q.GetQ(j' active_size);                    float C_i = get_C(i);                  float C_j = get_C(j);                    float old_alpha_i = alpha[i];                  float old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      float quad_coef = Q_i[i] + Q_j[j] + 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (-G[i] - G[j]) / quad_coef;                      float diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = -diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      float quad_coef = Q_i[i] + Q_j[j] - 2 * Q_i[j];                      if (quad_coef <= 0)                          quad_coef = 1e-12f;                      float delta = (G[i] - G[j]) / quad_coef;                      float sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                        if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    float delta_alpha_i = alpha[i] - old_alpha_i;                  float delta_alpha_j = alpha[j] - old_alpha_j;                      for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k] * delta_alpha_i + Q_j[k] * delta_alpha_j;                                       }                                      // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.GetQ(i' problemSize);                          if (ui)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_i * Q_i[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_i * Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.GetQ(j' problemSize);                          if (uj)                              for (k = 0; k < problemSize; k++)                                  G_bar[k] -= C_j * Q_j[k];                          else                              for (k = 0; k < problemSize; k++)                                  G_bar[k] += C_j * Q_j[k];                      }                  }                }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,Solve,The following statement contains a magic number: {                  float v = 0;                  int i;                  for (i = 0; i < problemSize; i++)                      v += alpha[i] * (G[i] + p[i]);                    si.obj = v / 2;              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * problemSize > 2 * active_size * (problemSize - active_size))              {                  for (i = active_size; i < problemSize; i++)                  {                      float[] Q_i = Q.GetQ(i' active_size);                      for (j = 0; j < active_size; j++)                          if (is_free(j))                              G[i] += alpha[j] * Q_i[j];                  }              }              else              {                  for (i = 0; i < active_size; i++)                      if (is_free(i))                      {                          float[] Q_i = Q.GetQ(i' problemSize);                          float alpha_i = alpha[i];                          for (j = active_size; j < problemSize; j++)                              G[j] += alpha_i * Q_i[j];                      }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++)              {                  if (y[j] == +1)                  {                      if (!is_lower_bound(j))                      {                          float grad_diff = GMax + G[j];                          if (G[j] >= GMax2)                              GMax2 = G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] - 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }                  else                  {                      if (!is_upper_bound(j))                      {                          float grad_diff = GMax - G[j];                          if (-G[j] >= GMax2)                              GMax2 = -G[j];                          if (grad_diff > 0)                          {                              float obj_diff;                              float quad_coef = (float)(Q_i[i] + QD[j] + 2.0 * y[i] * Q_i[j]);                              if (quad_coef > 0)                                  obj_diff = -(grad_diff * grad_diff) / quad_coef;                              else                                  obj_diff = (float)(-(grad_diff * grad_diff) / 1e-12);                                if (obj_diff <= obj_diff_Min)                              {                                  GMin_idx = j;                                  obj_diff_Min = obj_diff;                              }                          }                      }                  }              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && GMax1 + GMax2 <= EPS * 10)              {                  unshrink = true;                  reconstruct_gradient();                  active_size = problemSize;              }
Magic Number,KMLib.SVMSolvers,SmoFanSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SmoFanSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free / nr_free;              else                  r = (ub + lb) / 2;
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The following statement contains a magic number: eta = 2 * k12 - k11 - k22;
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The following statement contains a magic number: if (eta < 0)              {                  //original version with plus                    //a2 = alph2 + y2 * (E2 - E1) / eta;                    a2 = alph2 - y2 * (E1 - E2) / eta;                    if (a2 < L) a2 = L;                  else if (a2 > H) a2 = H;              }              else              {                  {                      float c1 = eta / 2;                      float c2 = y2 * (E1 - E2) - eta * alph2;                      Lobj = c1 * L * L + c2 * L;                      Hobj = c1 * H * H + c2 * H;                  }                    if (Lobj > Hobj + epsilon) a2 = L;                  else if (Lobj < Hobj - epsilon) a2 = H;                  else a2 = alph2;              }
Magic Number,KMLib.SVMSolvers,SMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\SMOSolver.cs,TakeStep,The following statement contains a magic number: if (a1 > 0 && a1 < C)                  bnew = b + E1 + y1 * (a1 - alph1) * k11 + y2 * (a2 - alph2) * k12;              else              {                  if (a2 > 0 && a2 < C)                      bnew = b + E2 + y1 * (a1 - alph1) * k12 + y2 * (a2 - alph2) * k22;                  else                  {                      b1 = b + E1 + y1 * (a1 - alph1) * k11 + y2 * (a2 - alph2) * k12;                      b2 = b + E2 + y1 * (a1 - alph1) * k12 + y2 * (a2 - alph2) * k22;                      bnew = (b1 + b2) / 2;                  }              }
Duplicate Code,KMLib.SVMSolvers,ParallelSMOSolver<TProblemElement>,C:\repos\ksirg_KMLib\KMLib\SVMSolvers\ParallelSMOSolver.cs,ComputeModel,The method contains a code clone-set at the following line numbers (starting from the method definition): ((55' 82)' (90' 117))
