Implementation smell,Namespace,Class,File,Method,Description
Long Method,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The method has 148 lines of code.
Long Method,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,CleanUpCharacters,The method has 377 lines of code.
Long Method,IFilterTextReader,PropertyMapper,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\PropertyMapper.cs,PropertyMapper,The method has 274 lines of code.
Complex Method,IFilterTextReader,FilterLoader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterLoader.cs,LoadAndInitIFilter,Cyclomatic complexity of the method is 9
Complex Method,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,ReadLine,Cyclomatic complexity of the method is 9
Complex Method,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,Cyclomatic complexity of the method is 18
Long Parameter List,IFilterTextReader,FilterLoader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterLoader.cs,LoadAndInitIFilter,The method has 5 parameters. Parameters: stream' extension' disableEmbeddedContent' fileName' readIntoMemory
Long Parameter List,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,FilterReader,The method has 7 parameters. Parameters: fileName' extension' disableEmbeddedContent' includeProperties' readIntoMemory' filterReaderTimeout' timeout
Long Parameter List,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,FilterReader,The method has 7 parameters. Parameters: stream' extension' disableEmbeddedContent' includeProperties' readIntoMemory' filterReaderTimeout' timeout
Long Parameter List,IFilterTextReader,Property,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\Property.cs,Property,The method has 5 parameters. Parameters: propertySetGuid' propertyName' friendlyName' type' mask
Long Statement,IFilterTextReader,FilterLoader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterLoader.cs,LoadAndInitIFilter,The length of the statement  "                    throw new IFOldFilterFormat("An error occured while trying to load a stream with the IPersistStream interface"' exception); " is 123.
Long Statement,IFilterTextReader,FilterLoader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterLoader.cs,LoadAndInitIFilter,The length of the statement  "                throw new IFOldFilterFormat("The IFilter does not support the IPersistStream interface' supply a filename to use the IFilter"); " is 127.
Magic Number,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,ReadLine,The following statement contains a magic number: var buffer = new char[2048];
Magic Number,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,ReadLine,The following statement contains a magic number: while (!done)              {                  var charsRead = Read(buffer' 0' 1024);                    if (charsRead <= 0)                  {                      if (stringBuilder.Length != 0)                          done = true;                      else                          return null;                  }                    for (var i = 0; i < charsRead; i++)                  {                      var chr = buffer[i];                        switch (chr)                      {                          case '\r':                              _carriageReturnFound = true;                              done = true;                              break;                            case '\n':                              if (!_carriageReturnFound)                                  done = true;                                                                break;                            default:                              _carriageReturnFound = false;                              stringBuilder.Append(buffer[i]);                              break;                      }                        if (done)                      {                          i++;                          if (i < charsRead)                          {                              if (_charsLeftFromLastRead == null)                              {                                  _charsLeftFromLastRead = new char[charsRead - i];                                  Array.Copy(buffer' i' _charsLeftFromLastRead' 0' charsRead - i);                              }                              else                              {                                  var charsLeft = charsRead - i;                                  var temp = new char[_charsLeftFromLastRead.Length + charsLeft];                                  Array.Copy(buffer' i' temp' 0' charsLeft);                                  _charsLeftFromLastRead.CopyTo(temp' charsLeft);                                  _charsLeftFromLastRead = temp;                              }                          }                            _done = false;                          break;                      }                  }              }
Magic Number,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following statement contains a magic number: while (!_done && charsRead < count)              {                  if (_charsLeftFromLastRead != null)                  {                      var charsToCopy = (_charsLeftFromLastRead.Length < count - charsRead)                          ? _charsLeftFromLastRead.Length                          : count - charsRead;                        Array.Copy(_charsLeftFromLastRead' 0' buffer' index + charsRead' charsToCopy);                        charsRead += charsToCopy;                        if (charsToCopy < _charsLeftFromLastRead.Length)                      {                          var temp = new char[_charsLeftFromLastRead.Length - charsToCopy];                          Array.Copy(_charsLeftFromLastRead' charsToCopy' temp' 0' temp.Length);                          _charsLeftFromLastRead = temp;                      }                      else                          _charsLeftFromLastRead = null;                        if (_charsLeftFromLastRead == null && _endOfChunks)                          _done = true;                        continue;                  }                    // If we don't have a valid chunck anymore then read a new chunck                  if (!_chunkValid)                  {                      var result = _filter.GetChunk(out _chunk);                      _chunkValid = result == NativeMethods.IFilterReturnCode.S_OK;                        switch (result)                      {                          case NativeMethods.IFilterReturnCode.FILTER_E_ACCESS:                              throw new IFAccesFailure("Could not acces IFilter object' invalid file");                            case NativeMethods.IFilterReturnCode.FILTER_E_END_OF_CHUNKS:                              _done = true;                              _endOfChunks = true;                              break;                      }                        // If the read chunk isn't valid then continue                      if (!_chunkValid) continue;                  }                    var textLength = (uint)(count - charsRead);                  if (textLength < 8192)                      textLength = 8192;                    var textBuffer = new char[textLength + 1];                  var textRead = false;                    switch (_chunk.flags)                  {                      case NativeMethods.CHUNKSTATE.CHUNK_FILTER_OWNED_VALUE:                          // No support for filter owned values so this chunk is always invalid                          _chunkValid = false;                          continue;                        case NativeMethods.CHUNKSTATE.CHUNK_VALUE:                            if (!_includeProperties)                          {                              _chunkValid = false;                              continue;                          }                            var valuePtr = IntPtr.Zero;                          var valueResult = _filter.GetValue(ref valuePtr);                          CheckResult(valueResult);                            switch (valueResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_VALUES:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_VALUES:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_VALUES:                                  var temp = GetPropertyNameAndValue(valuePtr);                                  if (!string.IsNullOrEmpty(temp))                                  {                                      textBuffer = temp.ToCharArray();                                      textLength = (uint) textBuffer.Length;                                      textRead = true;                                  }                                        _chunkValid = false;                                  break;                          }                            break;                        case NativeMethods.CHUNKSTATE.CHUNK_TEXT:                            var textResult = _filter.GetText(ref textLength' textBuffer);                          CheckResult(textResult);                            switch (textResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_EMBEDDING_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_LINK_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_TEXT:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT:                                    textRead = true;                                  // Remove junk from the buffer                                  CleanUpCharacters(textLength' textBuffer);                                    // Check the break type                                  switch (_chunk.breakType)                                  {                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOW:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOC:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOP:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOS:                                          if (textBuffer[textLength - 1] != ' ' && textBuffer[textLength - 1] != '\n')                                          {                                              textBuffer[textLength] = '\n';                                              textLength += 1;                                          }                                          break;                                  }                                    if (textResult == NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT)                                      _chunkValid = false;                                    break;                          }                            break;                  }                    if (textRead)                  {                      var read = (int)textLength;                      if (read + charsRead > count)                      {                          var charsLeft = (read + charsRead - count);                          _charsLeftFromLastRead = new char[charsLeft];                          Array.Copy(textBuffer' read - charsLeft' _charsLeftFromLastRead' 0' charsLeft);                          read -= charsLeft;                      }                      else                          _charsLeftFromLastRead = null;                        Array.Copy(textBuffer' 0' buffer' index + charsRead' read);                      charsRead += read;                  }                    if (Timeout())                      break;              }
Magic Number,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following statement contains a magic number: while (!_done && charsRead < count)              {                  if (_charsLeftFromLastRead != null)                  {                      var charsToCopy = (_charsLeftFromLastRead.Length < count - charsRead)                          ? _charsLeftFromLastRead.Length                          : count - charsRead;                        Array.Copy(_charsLeftFromLastRead' 0' buffer' index + charsRead' charsToCopy);                        charsRead += charsToCopy;                        if (charsToCopy < _charsLeftFromLastRead.Length)                      {                          var temp = new char[_charsLeftFromLastRead.Length - charsToCopy];                          Array.Copy(_charsLeftFromLastRead' charsToCopy' temp' 0' temp.Length);                          _charsLeftFromLastRead = temp;                      }                      else                          _charsLeftFromLastRead = null;                        if (_charsLeftFromLastRead == null && _endOfChunks)                          _done = true;                        continue;                  }                    // If we don't have a valid chunck anymore then read a new chunck                  if (!_chunkValid)                  {                      var result = _filter.GetChunk(out _chunk);                      _chunkValid = result == NativeMethods.IFilterReturnCode.S_OK;                        switch (result)                      {                          case NativeMethods.IFilterReturnCode.FILTER_E_ACCESS:                              throw new IFAccesFailure("Could not acces IFilter object' invalid file");                            case NativeMethods.IFilterReturnCode.FILTER_E_END_OF_CHUNKS:                              _done = true;                              _endOfChunks = true;                              break;                      }                        // If the read chunk isn't valid then continue                      if (!_chunkValid) continue;                  }                    var textLength = (uint)(count - charsRead);                  if (textLength < 8192)                      textLength = 8192;                    var textBuffer = new char[textLength + 1];                  var textRead = false;                    switch (_chunk.flags)                  {                      case NativeMethods.CHUNKSTATE.CHUNK_FILTER_OWNED_VALUE:                          // No support for filter owned values so this chunk is always invalid                          _chunkValid = false;                          continue;                        case NativeMethods.CHUNKSTATE.CHUNK_VALUE:                            if (!_includeProperties)                          {                              _chunkValid = false;                              continue;                          }                            var valuePtr = IntPtr.Zero;                          var valueResult = _filter.GetValue(ref valuePtr);                          CheckResult(valueResult);                            switch (valueResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_VALUES:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_VALUES:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_VALUES:                                  var temp = GetPropertyNameAndValue(valuePtr);                                  if (!string.IsNullOrEmpty(temp))                                  {                                      textBuffer = temp.ToCharArray();                                      textLength = (uint) textBuffer.Length;                                      textRead = true;                                  }                                        _chunkValid = false;                                  break;                          }                            break;                        case NativeMethods.CHUNKSTATE.CHUNK_TEXT:                            var textResult = _filter.GetText(ref textLength' textBuffer);                          CheckResult(textResult);                            switch (textResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_EMBEDDING_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_LINK_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_TEXT:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT:                                    textRead = true;                                  // Remove junk from the buffer                                  CleanUpCharacters(textLength' textBuffer);                                    // Check the break type                                  switch (_chunk.breakType)                                  {                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOW:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOC:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOP:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOS:                                          if (textBuffer[textLength - 1] != ' ' && textBuffer[textLength - 1] != '\n')                                          {                                              textBuffer[textLength] = '\n';                                              textLength += 1;                                          }                                          break;                                  }                                    if (textResult == NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT)                                      _chunkValid = false;                                    break;                          }                            break;                  }                    if (textRead)                  {                      var read = (int)textLength;                      if (read + charsRead > count)                      {                          var charsLeft = (read + charsRead - count);                          _charsLeftFromLastRead = new char[charsLeft];                          Array.Copy(textBuffer' read - charsLeft' _charsLeftFromLastRead' 0' charsLeft);                          read -= charsLeft;                      }                      else                          _charsLeftFromLastRead = null;                        Array.Copy(textBuffer' 0' buffer' index + charsRead' read);                      charsRead += read;                  }                    if (Timeout())                      break;              }
Magic Number,IFilterTextReader,PROPVARIANT,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\NativeMethods.cs,GetDataBytes,The following statement contains a magic number: switch (IntPtr.Size)                  {                      case 4:                          BitConverter.GetBytes(p.ToInt32()).CopyTo(ret' 0);                          break;                      case 8:                          BitConverter.GetBytes(p.ToInt64()).CopyTo(ret' 0);                          break;                  }
Magic Number,IFilterTextReader,PROPVARIANT,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\NativeMethods.cs,GetDataBytes,The following statement contains a magic number: switch (IntPtr.Size)                  {                      case 4:                          BitConverter.GetBytes(p.ToInt32()).CopyTo(ret' 0);                          break;                      case 8:                          BitConverter.GetBytes(p.ToInt64()).CopyTo(ret' 0);                          break;                  }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Timeout,The following switch statement is missing a default case: switch (_filterReaderTimeout)                  {                      case FilterReaderTimeout.TimeoutOnly:                          return true;                        case FilterReaderTimeout.TimeoutWithException:                          throw new IFFilterTimeout("The IFilter has timed out");                  }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following switch statement is missing a default case: switch (result)                      {                          case NativeMethods.IFilterReturnCode.FILTER_E_ACCESS:                              throw new IFAccesFailure("Could not acces IFilter object' invalid file");                            case NativeMethods.IFilterReturnCode.FILTER_E_END_OF_CHUNKS:                              _done = true;                              _endOfChunks = true;                              break;                      }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following switch statement is missing a default case: switch (_chunk.flags)                  {                      case NativeMethods.CHUNKSTATE.CHUNK_FILTER_OWNED_VALUE:                          // No support for filter owned values so this chunk is always invalid                          _chunkValid = false;                          continue;                        case NativeMethods.CHUNKSTATE.CHUNK_VALUE:                            if (!_includeProperties)                          {                              _chunkValid = false;                              continue;                          }                            var valuePtr = IntPtr.Zero;                          var valueResult = _filter.GetValue(ref valuePtr);                          CheckResult(valueResult);                            switch (valueResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_VALUES:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_VALUES:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_VALUES:                                  var temp = GetPropertyNameAndValue(valuePtr);                                  if (!string.IsNullOrEmpty(temp))                                  {                                      textBuffer = temp.ToCharArray();                                      textLength = (uint) textBuffer.Length;                                      textRead = true;                                  }                                        _chunkValid = false;                                  break;                          }                            break;                        case NativeMethods.CHUNKSTATE.CHUNK_TEXT:                            var textResult = _filter.GetText(ref textLength' textBuffer);                          CheckResult(textResult);                            switch (textResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_EMBEDDING_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_LINK_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_TEXT:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT:                                    textRead = true;                                  // Remove junk from the buffer                                  CleanUpCharacters(textLength' textBuffer);                                    // Check the break type                                  switch (_chunk.breakType)                                  {                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOW:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOC:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOP:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOS:                                          if (textBuffer[textLength - 1] != ' ' && textBuffer[textLength - 1] != '\n')                                          {                                              textBuffer[textLength] = '\n';                                              textLength += 1;                                          }                                          break;                                  }                                    if (textResult == NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT)                                      _chunkValid = false;                                    break;                          }                            break;                  }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following switch statement is missing a default case: switch (valueResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_VALUES:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_VALUES:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_VALUES:                                  var temp = GetPropertyNameAndValue(valuePtr);                                  if (!string.IsNullOrEmpty(temp))                                  {                                      textBuffer = temp.ToCharArray();                                      textLength = (uint) textBuffer.Length;                                      textRead = true;                                  }                                        _chunkValid = false;                                  break;                          }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following switch statement is missing a default case: switch (textResult)                          {                              case NativeMethods.IFilterReturnCode.FILTER_E_EMBEDDING_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_LINK_UNAVAILABLE:                              case NativeMethods.IFilterReturnCode.FILTER_E_NO_MORE_TEXT:                                  _chunkValid = false;                                  break;                                case NativeMethods.IFilterReturnCode.S_OK:                              case NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT:                                    textRead = true;                                  // Remove junk from the buffer                                  CleanUpCharacters(textLength' textBuffer);                                    // Check the break type                                  switch (_chunk.breakType)                                  {                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOW:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOC:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOP:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOS:                                          if (textBuffer[textLength - 1] != ' ' && textBuffer[textLength - 1] != '\n')                                          {                                              textBuffer[textLength] = '\n';                                              textLength += 1;                                          }                                          break;                                  }                                    if (textResult == NativeMethods.IFilterReturnCode.FILTER_S_LAST_TEXT)                                      _chunkValid = false;                                    break;                          }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,Read,The following switch statement is missing a default case: switch (_chunk.breakType)                                  {                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_NO_BREAK:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOW:                                          break;                                        case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOC:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOP:                                      case NativeMethods.CHUNK_BREAKTYPE.CHUNK_EOS:                                          if (textBuffer[textLength - 1] != ' ' && textBuffer[textLength - 1] != '\n')                                          {                                              textBuffer[textLength] = '\n';                                              textLength += 1;                                          }                                          break;                                  }
Missing Default,IFilterTextReader,FilterReader,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\FilterReader.cs,CheckResult,The following switch statement is missing a default case: switch (result)              {                  case NativeMethods.IFilterReturnCode.FILTER_E_PASSWORD:                      throw new IFFileIsPasswordProtected("The file '" + _fileName +                                                          "' or a file inside this file (e.g. in the case of a ZIP) is password protected");                    case NativeMethods.IFilterReturnCode.E_ACCESSDENIED:                  case NativeMethods.IFilterReturnCode.FILTER_E_ACCESS:                      throw new IFAccesFailure("Unable to acces the IFilter or file");                    case NativeMethods.IFilterReturnCode.E_OUTOFMEMORY:                      throw new OutOfMemoryException("Not enough memory to proceed reading the file '" +                                                     _fileName +                                                     "'");                    case NativeMethods.IFilterReturnCode.FILTER_E_UNKNOWNFORMAT:                      throw new IFUnknownFormat("The file '" + _fileName +                                                "' is not in the format the IFilter would expect it to be");              }
Missing Default,IFilterTextReader,PROPVARIANT,C:\repos\Sicos1977_IFilterTextReader\IFilterTextReader\NativeMethods.cs,GetDataBytes,The following switch statement is missing a default case: switch (IntPtr.Size)                  {                      case 4:                          BitConverter.GetBytes(p.ToInt32()).CopyTo(ret' 0);                          break;                      case 8:                          BitConverter.GetBytes(p.ToInt64()).CopyTo(ret' 0);                          break;                  }
