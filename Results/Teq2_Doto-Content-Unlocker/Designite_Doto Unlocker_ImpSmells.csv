Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,Cyclomatic complexity of the method is 17
Complex Method,Doto_Unlocker,DotoContent,C:\repos\Teq2_Doto-Content-Unlocker\DotoContent.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,Doto_Unlocker.Model,Huds,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Huds.cs,InstallContent,Cyclomatic complexity of the method is 10
Complex Method,Doto_Unlocker.VDF,VdfParser,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VDF\VdfParser.cs,Parse,Cyclomatic complexity of the method is 24
Long Parameter List,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,BitBlt,The method has 9 parameters.
Long Parameter List,Doto_Unlocker,MainForm,C:\repos\Teq2_Doto-Content-Unlocker\MainForm.cs,InvalidateContent,The method has 5 parameters.
Long Parameter List,Doto_Unlocker,VTFLib,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\VtfLib.cs,vlImageConvert,The method has 6 parameters.
Long Parameter List,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,WriteDataPortionToFile,The method has 6 parameters.
Long Parameter List,Doto_Unlocker.Model,Huds,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Huds.cs,HudCreate,The method has 5 parameters.
Long Statement,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The length of the statement  "	Rectangle underLine = new Rectangle (borderWidth' titleRectangle.Bottom - underLineWidth - borderWidth - underlineVerticalIndent' titleRectangle.Right - borderWidth * 2' underLineWidth); " is 186.
Long Statement,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The length of the statement  "			drawingGraphics.FillRectangle (highlighted' underLine.Left + underlineVerticalIndent' underLine.Top' textSize.Width + 10' underLineWidth); " is 138.
Long Statement,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The length of the statement  "	Rectangle textBounds = new Rectangle (textPoint' new Size (underLine.Width - textPoint.X' underLine.Top - textPoint.Y)); " is 120.
Long Statement,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,OnPaint,The length of the statement  "		BitBlt (new HandleRef (e.Graphics' hdc)' e.ClipRectangle.X' e.ClipRectangle.Y' e.ClipRectangle.Width' e.ClipRectangle.Height' new HandleRef (drawingGraphics' hdc_buffer)' e.ClipRectangle.X' e.ClipRectangle.Y' SRCCOPY); " is 218.
Long Statement,Doto_Unlocker,MainForm,C:\repos\Teq2_Doto-Content-Unlocker\MainForm.cs,MainForm_Load,The length of the statement  "		ShowInfo ("Current Steam Client and Dota 2 paths are invalid and can't be detected automatically.\r\n" + "Please select correct Steam Client folder in next window."); " is 166.
Long Statement,Doto_Unlocker,DotoContent,C:\repos\Teq2_Doto-Content-Unlocker\DotoContent.cs,Initialize,The length of the statement  "		ShowErr ("Access to vpk archive failed"' "File name: \"" + ((VpkFileIOException)e).VpkFileName + "\"\r\nMake sure Dota 2 client isn't running' if it' close game client and try again."' false); " is 192.
Long Statement,Doto_Unlocker,DotoContent,C:\repos\Teq2_Doto-Content-Unlocker\DotoContent.cs,CommonHandler,The length of the statement  "		ShowErr ("Vpk file had been updated after program has opened."' string.Format ("File name: \"{0}\"\r\nVpk dir parsed: {1}\r\nFile updated: {2}"' outdated.VpkFileName' outdated.DirLoaded' outdated.LastUpdated)' false); " is 217.
Long Statement,Doto_Unlocker,SettingsForm,C:\repos\Teq2_Doto-Content-Unlocker\SettingsForm.cs,tileStyle_Click,The length of the statement  "	metroStyleManager1.Style = (MetroColorStyle)Enum.Parse (typeof(MetroColorStyle)' (string)boxStyles.Items [boxStyles.SelectedIndex]); " is 132.
Long Statement,Doto_Unlocker,SettingsForm,C:\repos\Teq2_Doto-Content-Unlocker\SettingsForm.cs,btnOk_Click,The length of the statement  "					MetroMessageBox.Show (this' string.Format ("\r\nAn error occurred while saving settings: \r\n\"{0}\""' ex.Message)' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 169.
Long Statement,Doto_Unlocker,SettingsForm,C:\repos\Teq2_Doto-Content-Unlocker\SettingsForm.cs,btnOk_Click,The length of the statement  "			MetroMessageBox.Show (this' "\r\nDota 2 not found in steam-library'\r\n make sure game properly installed"' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 161.
Long Statement,Doto_Unlocker,SettingsForm,C:\repos\Teq2_Doto-Content-Unlocker\SettingsForm.cs,btnOk_Click,The length of the statement  "		MetroMessageBox.Show (this' "\r\nSteam client not found\r\nPlease select another directory."' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 147.
Long Statement,Doto_Unlocker,SettingsForm,C:\repos\Teq2_Doto-Content-Unlocker\SettingsForm.cs,Browse,The length of the statement  "				MetroMessageBox.Show (this' "\r\nSteam client not found\r\nPlease select another directory."' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 147.
Long Statement,Doto_Unlocker,SplashScreen,C:\repos\Teq2_Doto-Content-Unlocker\SplashScreen.cs,SetOwnerEnabled,The length of the statement  "	SetWindowLong (Owner.Handle' GWL_STYLE' GetWindowLong (Owner.Handle' GWL_STYLE) & ~WS_DISABLED | (enabled ? 0 : WS_DISABLED)); " is 126.
Long Statement,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,OverwriteFile,The length of the statement  "		WriteDataPortionToFile (vpkDataFileName' data' 0' fileStruc.PreloadedDataOffset' fileStruc.PreloadBytes' restoreTimestamp); " is 123.
Long Statement,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,OverwriteFile,The length of the statement  "		WriteDataPortionToFile (vpkDataFileName' data' fileStruc.PreloadBytes' fileStruc.EntryOffset' fileStruc.EntryLength' restoreTimestamp); " is 135.
Long Statement,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,FindFile,The length of the statement  "		return dir.Data.SingleOrDefault (entry => entry.Path.Equals (path) && entry.Name.Equals (name' StringComparison.OrdinalIgnoreCase) && entry.Ext.Equals (ext)); " is 158.
Long Statement,Doto_Unlocker.Model,Announcers,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Announcers.cs,talkerScriptInstall,The length of the statement  "	talkerScriptTxt = Regex.Replace (talkerScriptTxt' "criterion\\s+\"(\\S+)\"\\s+(\\S+)\\s+\"(\\S+)\"(.*)"' m => CriterionsEdit (m' fullname' criterionsNames)' RegexOptions.IgnoreCase); " is 182.
Long Statement,Doto_Unlocker.Model,Announcers,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Announcers.cs,talkerScriptInstall,The length of the statement  "	talkerScriptTxt = Regex.Replace (talkerScriptTxt' @"criteria\s+(?:(\S+)[ ]*)+"' m => CriterionsRename (m' criterionsNames)' RegexOptions.IgnoreCase); " is 149.
Long Statement,Doto_Unlocker.Model,DefaultHudReader,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudReader.cs,ReadFile,The length of the statement  "		var file = defaultFiles.SingleOrDefault (f => rel.Equals (f.Path + '/' + f.Name + '.' + f.Ext' StringComparison.OrdinalIgnoreCase)); " is 132.
Long Statement,Doto_Unlocker.Model,Huds,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Huds.cs,HudCreate,The length of the statement  "	var iconFileInfo = hudsIcons.Single (file => file.Name.Equals (Path.GetFileName (icon)' StringComparison.OrdinalIgnoreCase)); " is 125.
Long Statement,Doto_Unlocker.Model,Huds,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Huds.cs,HudCreate,The length of the statement  "	var hudFilesSet = hudsFiles.Where (file_entry => file_entry.Path.StartsWith (filesPath' StringComparison.OrdinalIgnoreCase)); " is 125.
Long Statement,Doto_Unlocker.Model,LoadingScreens,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\LoadingScreens.cs,LoadLoadingScreens,The length of the statement  "		VdfNode lsInfo = lsSchemaList.FirstOrDefault (entry => path.EndsWith (entry ["visuals"] [0] ["asset"]' StringComparison.OrdinalIgnoreCase)); " is 140.
Long Statement,Doto_Unlocker.Model,SteamAPI,C:\repos\Teq2_Doto-Content-Unlocker\Model\SteamAPI.cs,GetSchemaURL,The length of the statement  "	string resp = httpRequest ("https://api.steampowered.com/IEconItems_570/GetSchemaURL/v1/?key=" + ApiKey + "&format=vdf&language=en"); " is 133.
Long Statement,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The length of the statement  "			if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) { " is 136.
Long Statement,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The length of the statement  "					pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */; " is 124.
Empty Catch Block,Doto_Unlocker,Settings,C:\repos\Teq2_Doto-Content-Unlocker\Settings.cs,Settings,The method has an empty catch block.
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,ButtonOverlay,The following statement contains a magic number: btn.Width = 120;  
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,ButtonOverlay,The following statement contains a magic number: btn.Height = 50;  
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,OnResize,The following statement contains a magic number: btn.Location = new Point (Width / 2 - btn.Width / 2' Height / 2 - btn.Height / 2);  
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,OnResize,The following statement contains a magic number: btn.Location = new Point (Width / 2 - btn.Width / 2' Height / 2 - btn.Height / 2);  
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,OnResize,The following statement contains a magic number: btn.Location = new Point (Width / 2 - btn.Width / 2' Height / 2 - btn.Height / 2);  
Magic Number,Doto_Unlocker.Controls,ButtonOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ButtonOverlay.cs,OnResize,The following statement contains a magic number: btn.Location = new Point (Width / 2 - btn.Width / 2' Height / 2 - btn.Height / 2);  
Magic Number,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The following statement contains a magic number: using (var baseColor = new SolidBrush (lineColor)) {  	drawingGraphics.FillRectangle (baseColor' underLine);  	// highlight  	using (var highlighted = new SolidBrush (styleColor)) {  		drawingGraphics.FillRectangle (highlighted' underLine.Left + underlineVerticalIndent' underLine.Top' textSize.Width + 10' underLineWidth);  	}  }  
Magic Number,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The following statement contains a magic number: using (var highlighted = new SolidBrush (styleColor)) {  	drawingGraphics.FillRectangle (highlighted' underLine.Left + underlineVerticalIndent' underLine.Top' textSize.Width + 10' underLineWidth);  }  
Magic Number,Doto_Unlocker.Controls,ContentTile,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ContentTile.cs,Redraw,The following statement contains a magic number: drawingGraphics.FillRectangle (highlighted' underLine.Left + underlineVerticalIndent' underLine.Top' textSize.Width + 10' underLineWidth);  
Magic Number,Doto_Unlocker.Controls,MyFlowLayoutPanel,C:\repos\Teq2_Doto-Content-Unlocker\Controls\MyFlowLayoutPanel.cs,MyFlowLayoutPanel,The following statement contains a magic number: ShowScrollBar (Handle' 3' 0);  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,ProgressOverlay,The following statement contains a magic number: spinner.Maximum = 100;  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,ProgressOverlay,The following statement contains a magic number: spinner.Value = 50;  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,OnPaint,The following statement contains a magic number: spinner.Location = new System.Drawing.Point (this.Width / 2 - spinnerWidth / 2' this.Height / 2 - spinnerHeight / 2);  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,OnPaint,The following statement contains a magic number: spinner.Location = new System.Drawing.Point (this.Width / 2 - spinnerWidth / 2' this.Height / 2 - spinnerHeight / 2);  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,OnPaint,The following statement contains a magic number: spinner.Location = new System.Drawing.Point (this.Width / 2 - spinnerWidth / 2' this.Height / 2 - spinnerHeight / 2);  
Magic Number,Doto_Unlocker.Controls,ProgressOverlay,C:\repos\Teq2_Doto-Content-Unlocker\Controls\ProgressOverlay.cs,OnPaint,The following statement contains a magic number: spinner.Location = new System.Drawing.Point (this.Width / 2 - spinnerWidth / 2' this.Height / 2 - spinnerHeight / 2);  
Magic Number,Doto_Unlocker,MainForm,C:\repos\Teq2_Doto-Content-Unlocker\MainForm.cs,registerContentType,The following statement contains a magic number: container.Padding = new System.Windows.Forms.Padding (0' 3' 0' 0);  
Magic Number,Doto_Unlocker,MainForm,C:\repos\Teq2_Doto-Content-Unlocker\MainForm.cs,OnResize,The following statement contains a magic number: if (WindowState == FormWindowState.Maximized && WindowState != lastState) {  	var container = containers.Current;  	if (container != null)  		this.rightPanel.Width += container.Width - container.EffectiveWidth;  }  else {  	this.rightPanel.Width = (int)((this.Width - this.Padding.Horizontal) * 0.35);  }  
Magic Number,Doto_Unlocker,MainForm,C:\repos\Teq2_Doto-Content-Unlocker\MainForm.cs,OnResize,The following statement contains a magic number: this.rightPanel.Width = (int)((this.Width - this.Padding.Horizontal) * 0.35);  
Magic Number,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,FindFile,The following statement contains a magic number: if (match.Success) {  	string path = match.Groups [1].Value;  	string name = match.Groups [2].Value;  	string ext = match.Groups [3].Value;  	return dir.Data.SingleOrDefault (entry => entry.Path.Equals (path) && entry.Name.Equals (name' StringComparison.OrdinalIgnoreCase) && entry.Ext.Equals (ext));  }  
Magic Number,Doto_Unlocker.VPK,VpkArchive,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkArchive.cs,FindFile,The following statement contains a magic number: if (match.Success) {  	string path = match.Groups [1].Value;  	string name = match.Groups [2].Value;  	string ext = match.Groups [3].Value;  	return dir.Data.SingleOrDefault (entry => entry.Path.Equals (path) && entry.Name.Equals (name' StringComparison.OrdinalIgnoreCase) && entry.Ext.Equals (ext));  }  
Magic Number,Doto_Unlocker.VPK,VpkDir,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkDir.cs,LoadHeader,The following statement contains a magic number: if (header.Version > 2)  	throw new InvalidVpkFileStructureException () {  		FailType = VPKFail.UnsupportedVer'  		Version = header.Version  	};  
Magic Number,Doto_Unlocker.VPK,VpkDir,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VPK\VpkDir.cs,LoadHeader,The following statement contains a magic number: if (header.Version == 2) {  	header.Unknown1 = reader.ReadUInt32 ();  	header.FooterLength = reader.ReadUInt32 ();  	header.Unknown3 = reader.ReadUInt32 ();  	header.Unknown4 = reader.ReadUInt32 ();  }  
Magic Number,Doto_Unlocker.Model,Announcers,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\Announcers.cs,CriterionsEdit,The following statement contains a magic number: return string.Format ("criterion \"{0}_2\" {1} \"{2}\" {3}"' criterionName' key' value' match.Groups [4].Value);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 152;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_left' 243' height - 227' newWidth' 227);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_left' 243' height - 227' newWidth' 227);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_left' 243' height - 227' newWidth' 227);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 264;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (minimap' 0' height - ratio * newWidth - 5' newWidth' ratio * newWidth + 5);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (minimap' 0' height - ratio * newWidth - 5' newWidth' ratio * newWidth + 5);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 209;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (center_left' 539' height - ratio * newWidth - 1' newWidth' ratio * newWidth + 1);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 386;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (center_right_i' 748' height - ratio * newWidth - 4' newWidth' ratio * newWidth + 4);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (center_right_i' 748' height - ratio * newWidth - 4' newWidth' ratio * newWidth + 4);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (center_right_i' 748' height - ratio * newWidth - 4' newWidth' ratio * newWidth + 4);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 254;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (portrait' 333' height - ratio * newWidth' newWidth' ratio * newWidth);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 391;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 90;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_inv' 1129' height - ratio * newWidth - 10' newWidth' ratio * newWidth + 10);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_inv' 1129' height - ratio * newWidth - 10' newWidth' ratio * newWidth + 10);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (spacer_inv' 1129' height - ratio * newWidth - 10' newWidth' ratio * newWidth + 10);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 222;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (rocks' 1090' height - ratio * newWidth' newWidth' ratio * newWidth);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (top' 0' 0' width' 35);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: newWidth = 80;  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (clocks' 760' -40' newWidth' ratio * newWidth);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (clocks' 760' -40' newWidth' ratio * newWidth);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (overlay' 0' -100' 1600' 1000);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (overlay' 0' -100' 1600' 1000);  
Magic Number,Doto_Unlocker.Model,HudConstructor,C:\repos\Teq2_Doto-Content-Unlocker\Model\Content\HudConstructor.cs,Construct,The following statement contains a magic number: canvas.DrawImage (overlay' 0' -100' 1600' 1000);  
Magic Number,Doto_Unlocker.Model,SteamAPI,C:\repos\Teq2_Doto-Content-Unlocker\Model\SteamAPI.cs,httpRequest,The following statement contains a magic number: try {  	HttpWebResponse response = (HttpWebResponse)req.GetResponse ();  	if ((int)response.StatusCode != 200)  		return null;  	String src = new StreamReader (response.GetResponseStream ()).ReadToEnd ();  	response.Close ();  	return src;  }  catch (WebException) {  	return null;  }  
Magic Number,Doto_Unlocker.Model,SteamAPI,C:\repos\Teq2_Doto-Content-Unlocker\Model\SteamAPI.cs,httpRequest,The following statement contains a magic number: if ((int)response.StatusCode != 200)  	return null;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: try {  	VTFLib.vlBindImage (uiImage);  	fixed (byte* lpBuffer = vtf_data) {  		if (!VTFLib.vlImageLoadLump (lpBuffer' (uint)vtf_data.Length' false))  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	var width = VTFLib.vlImageGetWidth ();  	var height = VTFLib.vlImageGetHeight ();  	var image_len = width * height * 4;  	var fmt = VTFLib.vlImageGetFormat ();  	byte[] lpImageData = new byte[image_len];  	byte[] lpBmpData = new byte[bmpHeadersSize + image_len];  	fixed (byte* lpOutput = lpImageData) {  		// BGRA vs RGBA - slower 30-40% using this lib  		if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  			throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  		}  		fixed (byte* lpBmp = lpBmpData) {  			// BMP Header  			*(ushort*)lpBmp = 0x4D42;  			// bfType  			*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  			// biSize (header size)  			*(uint*)(lpBmp + 18) = width;  			// biWidth  			*(uint*)(lpBmp + 22) = height;  			// biHeight  			*(ushort*)(lpBmp + 28) = 32;  			// biBitCount  			// RGBA -> BGRA and FLIP-VERTICAL  			uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  			uint len = width * height;  			uint* pSrc = (uint*)lpOutput;  			// fastest way to convert bits from RGBA to BGRA  			for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  				if (j == width)// next line  				 {  					j = 0;  					// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  					lineOffsetDst -= width;  				}  				uint val = pSrc [i];  				pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  			}  		}  	}  	return Image.FromStream (new MemoryStream (lpBmpData)' false' false);  }  finally {  	VTFLib.vlDeleteImage (uiImage);  	Monitor.Exit (sync);  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpOutput = lpImageData) {  	// BGRA vs RGBA - slower 30-40% using this lib  	if (!VTFLib.vlImageConvert (VTFLib.vlImageGetData (1' 0' 0' 0)' lpOutput' width' height' fmt' VTFLib.ImageFormat.ImageFormatRGBA8888)) {  		throw new ArgumentException (Marshal.PtrToStringAnsi (VTFLib.vlGetLastError ()));  	}  	fixed (byte* lpBmp = lpBmpData) {  		// BMP Header  		*(ushort*)lpBmp = 0x4D42;  		// bfType  		*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  		// biSize (header size)  		*(uint*)(lpBmp + 18) = width;  		// biWidth  		*(uint*)(lpBmp + 22) = height;  		// biHeight  		*(ushort*)(lpBmp + 28) = 32;  		// biBitCount  		// RGBA -> BGRA and FLIP-VERTICAL  		uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  		uint len = width * height;  		uint* pSrc = (uint*)lpOutput;  		// fastest way to convert bits from RGBA to BGRA  		for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  			if (j == width)// next line  			 {  				j = 0;  				// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  				lineOffsetDst -= width;  			}  			uint val = pSrc [i];  			pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  		}  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: fixed (byte* lpBmp = lpBmpData) {  	// BMP Header  	*(ushort*)lpBmp = 0x4D42;  	// bfType  	*(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  	// biSize (header size)  	*(uint*)(lpBmp + 18) = width;  	// biWidth  	*(uint*)(lpBmp + 22) = height;  	// biHeight  	*(ushort*)(lpBmp + 28) = 32;  	// biBitCount  	// RGBA -> BGRA and FLIP-VERTICAL  	uint* pDest = (uint*)(lpBmp + bmpHeadersSize);  	uint len = width * height;  	uint* pSrc = (uint*)lpOutput;  	// fastest way to convert bits from RGBA to BGRA  	for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  		if (j == width)// next line  		 {  			j = 0;  			// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  			lineOffsetDst -= width;  		}  		uint val = pSrc [i];  		pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  	}  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: *(uint*)(lpBmp + 14) = bmpInfoHeadersSize;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: *(uint*)(lpBmp + 18) = width;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: *(uint*)(lpBmp + 22) = height;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: *(ushort*)(lpBmp + 28) = 32;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: *(ushort*)(lpBmp + 28) = 32;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  	if (j == width)// next line  	 {  		j = 0;  		// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  		lineOffsetDst -= width;  	}  	uint val = pSrc [i];  	pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: for (uint i = 0' j = 0' line = height - 1' lineOffsetDst = width * line; i < len; i++' j++) {  	if (j == width)// next line  	 {  		j = 0;  		// would be much faster if width would be always a power of two (lineOffsetDst = line << log2(width))  		lineOffsetDst -= width;  	}  	uint val = pSrc [i];  	pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  }  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  
Magic Number,Doto_Unlocker.VTF,Vtf,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VTF\Vtf.cs,VtfToImage,The following statement contains a magic number: pDest [lineOffsetDst + j] = (val >> 16 | (val << 16)) & 0x00ff00ff | (val & 0xff00ff00)/* G and A channels are unchanged */;  
Missing Default,Doto_Unlocker.VDF,VdfParser,C:\repos\Teq2_Doto-Content-Unlocker\File Formats\VDF\VdfParser.cs,Parse,The following switch statement is missing a default case: switch (el) {  case '"':  	if (lastToken != Token.Key) {  		// new key-value node  		currentNode = new VdfNode ();  		if (parentNode != null) {  			// is it first childnode?  			if (parentNode.ChildNodes == null)  				parentNode.ChildNodes = new List<VdfNode> ();  			// add this node to the list  			parentNode.ChildNodes.Add (currentNode);  		}  		else {  			// it's first node in the tree  			rootNode = currentNode;  		}  		int endOfKey = data.IndexOf ('"'' pos);  		if (endOfKey == -1)  			throw new VDFParserException ();  		// unclosed token  		currentNode.Key = data.Substring (pos' endOfKey - pos);  		pos = endOfKey + 1;  		lastToken = Token.Key;  	}  	else// add value to the node  	 {  		int endOfVal;  		for (int offset = pos; ; offset = endOfVal + 1) {  			endOfVal = data.IndexOf ('"'' offset);  			if (endOfVal == -1)  				throw new VDFParserException ();  			// unclosed token  			// skip \" sequence  			if (data [endOfVal - 1] != '\\')  				break;  		}  		currentNode.Val = data.Substring (pos' endOfVal - pos);  		pos = endOfVal + 1;  		lastToken = Token.Val;  	}  	break;  case '{':  	hierarchy.Push (parentNode);  	// save parent  	parentNode = currentNode;  	lastToken = Token.GroupStart;  	break;  case '}':  	if (parentNode != null)  		parentNode = hierarchy.Pop ();  	// restore parent  	else  		throw new VDFParserException ();  	// closing bracket without an open  	lastToken = Token.GroupEnd;  	break;  case '\n':  	lastToken = Token.None;  	break;  }  
