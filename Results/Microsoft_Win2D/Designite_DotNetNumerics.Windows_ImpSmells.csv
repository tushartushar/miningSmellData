Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Invert,The method has 147 lines of code.
Long Method,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The method has 162 lines of code.
Long Parameter List,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,Matrix3x2,The method has 6 parameters. Parameters: m11' m12' m21' m22' m31' m32
Long Parameter List,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Matrix4x4,The method has 16 parameters. Parameters: m11' m12' m13' m14' m21' m22' m23' m24' m31' m32' m33' m34' m41' m42' m43' m44
Long Parameter List,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateConstrainedBillboard,The method has 5 parameters. Parameters: objectPosition' cameraPosition' rotateAxis' cameraForwardVector' objectForwardVector
Long Parameter List,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreatePerspectiveOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' nearPlaneDistance' farPlaneDistance
Long Parameter List,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateOrthographicOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNearPlane' zFarPlane
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromAxisAngle,The length of the statement  "            result.M11 = xx + ca * ( 1.0f - xx );   result.M12 = xy - ca * xy + sa * z;     result.M13 = xz - ca * xz - sa * y;     result.M14 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromAxisAngle,The length of the statement  "            result.M21 = xy - ca * xy - sa * z;     result.M22 = yy + ca * ( 1.0f - yy );   result.M23 = yz - ca * yz + sa * x;     result.M24 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromAxisAngle,The length of the statement  "            result.M31 = xz - ca * xz + sa * y;     result.M32 = yz - ca * yz - sa * x;     result.M33 = zz + ca * ( 1.0f - zz );   result.M34 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromAxisAngle,The length of the statement  "            result.M41 = 0.0f;                      result.M42 = 0.0f;                      result.M43 = 0.0f;                      result.M44 = 1.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromQuaternion,The length of the statement  "            result.M11 = 1.0f - 2.0f * (yy + zz);   result.M12 = 2.0f * (xy + wz);          result.M13 = 2.0f * (xz - wy);          result.M14 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromQuaternion,The length of the statement  "            result.M21 = 2.0f * (xy - wz);          result.M22 = 1.0f - 2.0f * (zz + xx);   result.M23 = 2.0f * (yz + wx);          result.M24 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromQuaternion,The length of the statement  "            result.M31 = 2.0f * (xz + wy);          result.M32 = 2.0f * (yz - wx);          result.M33 = 1.0f - 2.0f * (yy + xx);   result.M34 = 0.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,CreateFromQuaternion,The length of the statement  "            result.M41 = 0.0f;                      result.M42 = 0.0f;                      result.M43 = 0.0f;                      result.M44 = 1.0f; " is 138.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Add,The length of the statement  "            result.M11 = value1.M11 + value2.M11; result.M12 = value1.M12 + value2.M12; result.M13 = value1.M13 + value2.M13; result.M14 = value1.M14 + value2.M14; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Add,The length of the statement  "            result.M21 = value1.M21 + value2.M21; result.M22 = value1.M22 + value2.M22; result.M23 = value1.M23 + value2.M23; result.M24 = value1.M24 + value2.M24; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Add,The length of the statement  "            result.M31 = value1.M31 + value2.M31; result.M32 = value1.M32 + value2.M32; result.M33 = value1.M33 + value2.M33; result.M34 = value1.M34 + value2.M34; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Add,The length of the statement  "            result.M41 = value1.M41 + value2.M41; result.M42 = value1.M42 + value2.M42; result.M43 = value1.M43 + value2.M43; result.M44 = value1.M44 + value2.M44; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Subtract,The length of the statement  "            result.M11 = value1.M11 - value2.M11; result.M12 = value1.M12 - value2.M12; result.M13 = value1.M13 - value2.M13; result.M14 = value1.M14 - value2.M14; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Subtract,The length of the statement  "            result.M21 = value1.M21 - value2.M21; result.M22 = value1.M22 - value2.M22; result.M23 = value1.M23 - value2.M23; result.M24 = value1.M24 - value2.M24; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Subtract,The length of the statement  "            result.M31 = value1.M31 - value2.M31; result.M32 = value1.M32 - value2.M32; result.M33 = value1.M33 - value2.M33; result.M34 = value1.M34 - value2.M34; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Subtract,The length of the statement  "            result.M41 = value1.M41 - value2.M41; result.M42 = value1.M42 - value2.M42; result.M43 = value1.M43 - value2.M43; result.M44 = value1.M44 - value2.M44; " is 151.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Multiply,The length of the statement  "            result.M11 = value1.M11 * value2; result.M12 = value1.M12 * value2; result.M13 = value1.M13 * value2; result.M14 = value1.M14 * value2; " is 135.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Multiply,The length of the statement  "            result.M21 = value1.M21 * value2; result.M22 = value1.M22 * value2; result.M23 = value1.M23 * value2; result.M24 = value1.M24 * value2; " is 135.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Multiply,The length of the statement  "            result.M31 = value1.M31 * value2; result.M32 = value1.M32 * value2; result.M33 = value1.M33 * value2; result.M34 = value1.M34 * value2; " is 135.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Multiply,The length of the statement  "            result.M41 = value1.M41 * value2; result.M42 = value1.M42 * value2; result.M43 = value1.M43 * value2; result.M44 = value1.M44 * value2; " is 135.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Equals,The length of the statement  "            return (M11 == other.M11 && M22 == other.M22 && M33 == other.M33 && M44 == other.M44 && // Check diagonal element first for early out. " is 134.
Long Statement,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,ToString,The length of the statement  "            return String.Format(ci' "{{ {{M11:{0} M12:{1} M13:{2} M14:{3}}} {{M21:{4} M22:{5} M23:{6} M24:{7}}} {{M31:{8} M32:{9} M33:{10} M34:{11}}} {{M41:{12} M42:{13} M43:{14} M44:{15}}} }}"' " is 183.
Long Statement,System.Numerics,Quaternion,C:\repos\Microsoft_Win2D\numerics\DotNet\Quaternion.cs,ToString,The length of the statement  "            return String.Format(ci' "{{X:{0} Y:{1} Z:{2} W:{3}}}"' X.ToString(ci)' Y.ToString(ci)' Z.ToString(ci)' W.ToString(ci)); " is 120.
Long Statement,System.Numerics,Vector4,C:\repos\Microsoft_Win2D\numerics\DotNet\Vector4.cs,ToString,The length of the statement  "            return String.Format(ci' "{{X:{0} Y:{1} Z:{2} W:{3}}}"' X.ToString(ci)' Y.ToString(ci)' Z.ToString(ci)' W.ToString(ci)); " is 120.
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: radians = (float)SM.IEEERemainder(radians' SM.PI * 2);
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: radians = (float)SM.IEEERemainder(radians' SM.PI * 2);
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix3x2,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix3x2.cs,CreateRotation,The following statement contains a magic number: if (radians > -epsilon && radians < epsilon)              {                  // Exact case for zero rotation.                  c = 1;                  s = 0;              }              else if (radians > SM.PI / 2 - epsilon && radians < SM.PI / 2 + epsilon)              {                  // Exact case for 90 degree rotation.                  c = 0;                  s = 1;              }              else if (radians < -SM.PI + epsilon || radians > SM.PI - epsilon)              {                  // Exact case for 180 degree rotation.                  c = -1;                  s = 0;              }              else if (radians > -SM.PI / 2 - epsilon && radians < -SM.PI / 2 + epsilon)              {                  // Exact case for 270 degree rotation.                  c = 0;                  s = -1;              }              else              {                  // Arbitrary rotation.                  c = (float)SM.Cos(radians);                  s = (float)SM.Sin(radians);              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
Magic Number,System.Numerics,Matrix4x4,C:\repos\Microsoft_Win2D\numerics\DotNet\Matrix4x4.cs,Decompose,The following statement contains a magic number: unsafe              {                  fixed (float* pfScales = &scale.X)                  {                      const float EPSILON = 0.0001f;                      float det;                        VectorBasis vectorBasis;                      Vector3** pVectorBasis = (Vector3**)&vectorBasis;                        Matrix4x4 matTemp = Matrix4x4.Identity;                      CanonicalBasis canonicalBasis = new CanonicalBasis();                      Vector3* pCanonicalBasis = &canonicalBasis.Row0;                        canonicalBasis.Row0 = new Vector3(1.0f' 0.0f' 0.0f);                      canonicalBasis.Row1 = new Vector3(0.0f' 1.0f' 0.0f);                      canonicalBasis.Row2 = new Vector3(0.0f' 0.0f' 1.0f);                        translation.X = matrix.M41;                      translation.Y = matrix.M42;                      translation.Z = matrix.M43;                        pVectorBasis[0] = (Vector3*)&matTemp.M11;                      pVectorBasis[1] = (Vector3*)&matTemp.M21;                      pVectorBasis[2] = (Vector3*)&matTemp.M31;                        *(pVectorBasis[0]) = new Vector3(matrix.M11' matrix.M12' matrix.M13);                      *(pVectorBasis[1]) = new Vector3(matrix.M21' matrix.M22' matrix.M23);                      *(pVectorBasis[2]) = new Vector3(matrix.M31' matrix.M32' matrix.M33);                        scale.X = pVectorBasis[0]->Length();                      scale.Y = pVectorBasis[1]->Length();                      scale.Z = pVectorBasis[2]->Length();                        uint a' b' c;                      #region Ranking                      float x = pfScales[0]' y = pfScales[1]' z = pfScales[2];                      if (x < y)                      {                          if (y < z)                          {                              a = 2;                              b = 1;                              c = 0;                          }                          else                          {                              a = 1;                                if (x < z)                              {                                  b = 2;                                  c = 0;                              }                              else                              {                                  b = 0;                                  c = 2;                              }                          }                      }                      else                      {                          if (x < z)                          {                              a = 2;                              b = 0;                              c = 1;                          }                          else                          {                              a = 0;                                if (y < z)                              {                                  b = 2;                                  c = 1;                              }                              else                              {                                  b = 1;                                  c = 2;                              }                          }                      }                      #endregion                        if (pfScales[a] < EPSILON)                      {                          *(pVectorBasis[a]) = pCanonicalBasis[a];                      }                        *pVectorBasis[a] = Vector3.Normalize(*pVectorBasis[a]);                        if (pfScales[b] < EPSILON)                      {                          uint cc;                          float fAbsX' fAbsY' fAbsZ;                            fAbsX = (float)SM.Abs(pVectorBasis[a]->X);                          fAbsY = (float)SM.Abs(pVectorBasis[a]->Y);                          fAbsZ = (float)SM.Abs(pVectorBasis[a]->Z);                            #region Ranking                          if (fAbsX < fAbsY)                          {                              if (fAbsY < fAbsZ)                              {                                  cc = 0;                              }                              else                              {                                  if (fAbsX < fAbsZ)                                  {                                      cc = 0;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          else                          {                              if (fAbsX < fAbsZ)                              {                                  cc = 1;                              }                              else                              {                                  if (fAbsY < fAbsZ)                                  {                                      cc = 1;                                  }                                  else                                  {                                      cc = 2;                                  }                              }                          }                          #endregion                            *pVectorBasis[b] = Vector3.Cross(*pVectorBasis[a]' *(pCanonicalBasis + cc));                      }                        *pVectorBasis[b] = Vector3.Normalize(*pVectorBasis[b]);                        if (pfScales[c] < EPSILON)                      {                          *pVectorBasis[c] = Vector3.Cross(*pVectorBasis[a]' *pVectorBasis[b]);                      }                        *pVectorBasis[c] = Vector3.Normalize(*pVectorBasis[c]);                        det = matTemp.GetDeterminant();                        // use Kramer's rule to check for handedness of coordinate system                      if (det < 0.0f)                      {                          // switch coordinate system by negating the scale and inverting the basis vector on the x-axis                          pfScales[a] = -pfScales[a];                          *pVectorBasis[a] = -(*pVectorBasis[a]);                            det = -det;                      }                        det -= 1.0f;                      det *= det;                        if ((EPSILON < det))                      {                          // Non-SRT matrix encountered                          rotation = Quaternion.Identity;                          result = false;                      }                      else                      {                          // generate the quaternion from the matrix                          rotation = Quaternion.CreateFromRotationMatrix(matTemp);                      }                  }              }
