Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,Cyclomatic complexity of the method is 60
Long Statement,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadInt32,The length of the statement  "	return (((code [byteIndex++] | (code [byteIndex++] << 8)) | (code [byteIndex++] << 0x10)) | (code [byteIndex++] << 0x18)); " is 122.
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: while (byteIndex < code.Length) {  	OpCode opCode;  	ushort opValue = code [byteIndex++];  	if (opValue != 0xfe) {  		opCode = m_singleByteOpCodes [(int)opValue];  	}  	else {  		opValue = code [byteIndex++];  		opCode = m_multiByteOpCodes [(int)opValue];  	}  	int metadataToken;  	int startingIndex = byteIndex;  	switch (opCode.OperandType) {  	case OperandType.InlineField:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  		break;  	case OperandType.InlineMethod:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  		break;  	case OperandType.InlineType:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  		break;  	case OperandType.InlineString:  		metadataToken = ReadInt32 (code' ref byteIndex);  		m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  		break;  	case OperandType.InlineBrTarget:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineSig:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineTok:  		metadataToken = ReadInt32 (code' ref byteIndex);  		MemberInfo memberInfo = module.ResolveMember (metadataToken);  		if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  			Type type = memberInfo as Type;  			m_types.Add (startingIndex' type.TypeHandle);  		}  		else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  			MethodBase m = memberInfo as MethodBase;  			m_methods.Add (startingIndex' m);  		}  		else if (memberInfo.MemberType == MemberTypes.Field) {  			FieldInfo f = memberInfo as FieldInfo;  			m_fields.Add (startingIndex' f.FieldHandle);  		}  		break;  	case OperandType.InlineI:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.InlineI8:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineR:  		byteIndex = byteIndex + 8;  		break;  	case OperandType.InlineSwitch:  		int count = ReadInt32 (code' ref byteIndex);  		byteIndex = byteIndex + (count * 4);  		break;  	case OperandType.InlineVar:  		byteIndex = byteIndex + 2;  		break;  	case OperandType.ShortInlineBrTarget:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineI:  		byteIndex = byteIndex + 1;  		break;  	case OperandType.ShortInlineR:  		byteIndex = byteIndex + 4;  		break;  	case OperandType.ShortInlineVar:  		byteIndex = byteIndex + 1;  		break;  	}  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 4;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 4;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 4;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 8;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 8;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + (count * 4);  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 2;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following statement contains a magic number: byteIndex = byteIndex + 4;  
Magic Number,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadInt32,The following statement contains a magic number: return (((code [byteIndex++] | (code [byteIndex++] << 8)) | (code [byteIndex++] << 0x10)) | (code [byteIndex++] << 0x18));  
Magic Number,ExpressionEval.MsilConversion,IlTokenResolver,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlTokenResolver.cs,OverwriteInt32,The following statement contains a magic number: code [offset++] = (byte)(tokenValue >> 8);  
Magic Number,ExpressionEval.MsilConversion,IlTokenResolver,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlTokenResolver.cs,OverwriteInt32,The following statement contains a magic number: code [offset++] = (byte)(tokenValue >> 16);  
Magic Number,ExpressionEval.MsilConversion,IlTokenResolver,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlTokenResolver.cs,OverwriteInt32,The following statement contains a magic number: code [offset] = (byte)(tokenValue >> 24);  
Missing Default,ExpressionEval.MsilConversion,IlReader,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.MsilConversion\IlReader.cs,ReadCode,The following switch statement is missing a default case: switch (opCode.OperandType) {  case OperandType.InlineField:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_fields.Add (startingIndex' module.ResolveField (metadataToken).FieldHandle);  	break;  case OperandType.InlineMethod:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_methods.Add (startingIndex' module.ResolveMethod (metadataToken));  	break;  case OperandType.InlineType:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_types.Add (startingIndex' module.ResolveType (metadataToken).TypeHandle);  	break;  case OperandType.InlineString:  	metadataToken = ReadInt32 (code' ref byteIndex);  	m_literalStrings.Add (startingIndex' module.ResolveString (metadataToken));  	break;  case OperandType.InlineBrTarget:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineSig:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineTok:  	metadataToken = ReadInt32 (code' ref byteIndex);  	MemberInfo memberInfo = module.ResolveMember (metadataToken);  	if (memberInfo.MemberType == MemberTypes.TypeInfo || memberInfo.MemberType == MemberTypes.NestedType) {  		Type type = memberInfo as Type;  		m_types.Add (startingIndex' type.TypeHandle);  	}  	else if (memberInfo.MemberType == MemberTypes.Method || memberInfo.MemberType == MemberTypes.Constructor) {  		MethodBase m = memberInfo as MethodBase;  		m_methods.Add (startingIndex' m);  	}  	else if (memberInfo.MemberType == MemberTypes.Field) {  		FieldInfo f = memberInfo as FieldInfo;  		m_fields.Add (startingIndex' f.FieldHandle);  	}  	break;  case OperandType.InlineI:  	byteIndex = byteIndex + 4;  	break;  case OperandType.InlineI8:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineR:  	byteIndex = byteIndex + 8;  	break;  case OperandType.InlineSwitch:  	int count = ReadInt32 (code' ref byteIndex);  	byteIndex = byteIndex + (count * 4);  	break;  case OperandType.InlineVar:  	byteIndex = byteIndex + 2;  	break;  case OperandType.ShortInlineBrTarget:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineI:  	byteIndex = byteIndex + 1;  	break;  case OperandType.ShortInlineR:  	byteIndex = byteIndex + 4;  	break;  case OperandType.ShortInlineVar:  	byteIndex = byteIndex + 1;  	break;  }  
