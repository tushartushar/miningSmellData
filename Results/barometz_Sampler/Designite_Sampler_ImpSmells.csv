Implementation smell,Namespace,Class,File,Method,Description
Long Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The method has 105 lines of code.
Long Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The method has 136 lines of code.
Long Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The method has 167 lines of code.
Complex Method,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,sample_SampleChanged,Cyclomatic complexity of the method is 11
Complex Method,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,exportGraphToolStripMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm_FormClosing,Cyclomatic complexity of the method is 9
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,Cyclomatic complexity of the method is 10
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,Cyclomatic complexity of the method is 15
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,Cyclomatic complexity of the method is 10
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,Cyclomatic complexity of the method is 9
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,Cyclomatic complexity of the method is 11
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,Cyclomatic complexity of the method is 8
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,Cyclomatic complexity of the method is 42
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,Cyclomatic complexity of the method is 27
Complex Method,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,WAVFileModeStr,Cyclomatic complexity of the method is 12
Long Parameter List,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The method has 5 parameters.
Long Parameter List,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The method has 5 parameters.
Long Statement,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm_FormClosing,The length of the statement  "	switch (MessageBox.Show (Resources.Do_you_want_to_save_your_changes_' Application.ProductName' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question)) { " is 153.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_ByteArray,The length of the statement  "		throw new WAVFileReadException ("Read attempted in incorrect mode: " + WAVFileModeStr (mFileMode)' "WAVFile.GetNextSample_ByteArray()"); " is 136.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_8bit,The length of the statement  "		throw new WAVFileReadException ("Attempted to retrieve an 8-bit sample when audio is not 8-bit."' "WAVFile.GetNextSample_8bit()"); " is 130.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_16bit,The length of the statement  "		throw new WAVFileReadException ("Attempted to retrieve a 16-bit sample when audio is not 16-bit."' "WAVFile.GetNextSample_16bit()"); " is 132.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_ByteArray,The length of the statement  "			throw new WAVFileWriteException ("Write attempted in incorrect mode: " + WAVFileModeStr (mFileMode)' "WAVFile.AddSample_ByteArray()"); " is 134.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_8bit,The length of the statement  "		throw new WAVFileWriteException ("Attempted to add an 8-bit sample when audio file is not 8-bit."' "WAVFile.AddSample_8bit()"); " is 127.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_16bit,The length of the statement  "		throw new WAVFileWriteException ("Attempted to add a 16-bit sample when audio file is not 16-bit."' "WAVFile.AddSample_16bit()"); " is 129.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The length of the statement  "		throw new WAVFileSampleRateException ("Unsupported sample rate: " + pSampleRate.ToString ()' "WAVFile.Create()"' pSampleRate); " is 126.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The length of the statement  "		throw new WAVFileBitsPerSampleException ("Unsupported number of bits per sample: " + pBitsPerSample.ToString ()' "WAVFile.Create()"' pBitsPerSample); " is 149.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,FormatMatches,The length of the statement  "		retval = ((mNumChannels == pWAVFile.mNumChannels) && (mSampleRateHz == pWAVFile.mSampleRateHz) && (mBitsPerSample == pWAVFile.mBitsPerSample)); " is 143.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue_8bit,The length of the statement  "			throw new WAVFileReadException ("Attempt to get largest 8-bit sample from audio file that is not 8-bit."' "WAVFile.HighestSampleValue_8bit()"); " is 143.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The length of the statement  "			WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + " has unsupported bits/sample (" + srcFile.BitsPerSample.ToString () + ")"' "WAVFile.AdjustVolume_Copy()"' srcFile.BitsPerSample); " is 216.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The length of the statement  "			throw new WAVFileBitsPerSampleException (pFilename + " has unsupported bits/sample (" + bitsPerSample.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' bitsPerSample); " is 169.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The length of the statement  "			throw new WAVFileSampleRateException (pFilename + " has unsupported sample rate (" + sampleRate.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' sampleRate); " is 160.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy_8BitTo16Bit,The length of the statement  "			WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + ": 8 bits per sample required' and the file has " + srcFile.BitsPerSample.ToString () + " bits per sample."' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()"' srcFile.BitsPerSample); " is 261.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The length of the statement  "	return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000)); " is 293.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The length of the statement  "		throw new WAVFileBitsPerSampleException ("Unsupported number of bits per sample: " + firstFileAudioFormat.BitsPerSample.ToString ()' "WAVFile.MergeAudioFiles()"' firstFileAudioFormat.BitsPerSample); " is 198.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The length of the statement  "		throw new WAVFileSampleRateException ("Unsupported sample rate: " + firstFileAudioFormat.SampleRateHz.ToString ()' "WAVFile.MergeAudioFiles()"' firstFileAudioFormat.SampleRateHz); " is 179.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The length of the statement  "				throw new WAVFileAudioMergeException ("Unable to create temporary work directory (" + pTempDir + ")"' "WAVFile.MergeAudioFiles()"); " is 131.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The length of the statement  "			throw new WAVFileAudioMergeException ("Unable to create temporary work directory (" + pTempDir + "): " + exc.Message' "WAVFile.MergeAudioFiles()"); " is 147.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The length of the statement  "			throw new WAVFileAudioMergeException ("Unable to remove temp directory (" + pTempDir + "): " + retval' "WAVFile.MergeAudioFiles()"); " is 132.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SeekToAudioSample,The length of the statement  "			throw new WAVFileIOException ("Unable to to seek to sample " + pSampleNum.ToString () + ": " + exc.Message' "WAVFile.SeekToAudioSample()"); " is 139.
Long Statement,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SeekToAudioSample,The length of the statement  "			throw new WAVFileIOException ("Unable to to seek to sample " + pSampleNum.ToString () + ": " + exc.Message' "WAVFile.SeekToAudioSample()"); " is 139.
Complex Conditional,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The conditional expression  "(srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)"  is complex.
Complex Conditional,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The conditional expression  "(srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)"  is complex.
Complex Conditional,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The conditional expression  "(srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)"  is complex.
Complex Conditional,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The conditional expression  "(srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)"  is complex.
Empty Catch Block,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm_FormClosed,The method has an empty catch block.
Empty Catch Block,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm_FormClosed,The method has an empty catch block.
Empty Catch Block,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The method has an empty catch block.
Empty Catch Block,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The method has an empty catch block.
Empty Catch Block,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestBitsPerSample,The method has an empty catch block.
Empty Catch Block,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestNumChannels,The method has an empty catch block.
Magic Number,Sampler,AboutBox,C:\repos\barometz_Sampler\Sampler\AboutBox.cs,toggleLicenseText_Click,The following statement contains a magic number: if (splitContainer1.Panel2Collapsed) {  	Width = Width + LicenseText.Width + 4;  	splitContainer1.Panel2Collapsed = false;  	toggleLicenseText.Text = "Hide license details <<";  }  else {  	splitContainer1.Panel2Collapsed = true;  	Width = Width - LicenseText.Width - 4;  	toggleLicenseText.Text = "Show license details >>";  }  
Magic Number,Sampler,AboutBox,C:\repos\barometz_Sampler\Sampler\AboutBox.cs,toggleLicenseText_Click,The following statement contains a magic number: if (splitContainer1.Panel2Collapsed) {  	Width = Width + LicenseText.Width + 4;  	splitContainer1.Panel2Collapsed = false;  	toggleLicenseText.Text = "Hide license details <<";  }  else {  	splitContainer1.Panel2Collapsed = true;  	Width = Width - LicenseText.Width - 4;  	toggleLicenseText.Text = "Show license details >>";  }  
Magic Number,Sampler,AboutBox,C:\repos\barometz_Sampler\Sampler\AboutBox.cs,toggleLicenseText_Click,The following statement contains a magic number: Width = Width + LicenseText.Width + 4;  
Magic Number,Sampler,AboutBox,C:\repos\barometz_Sampler\Sampler\AboutBox.cs,toggleLicenseText_Click,The following statement contains a magic number: Width = Width - LicenseText.Width - 4;  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,sin,The following statement contains a magic number: return Math.Sin (t * frequency * 2 * Math.PI);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,triangle,The following statement contains a magic number: return (Math.Abs ((t + 0.75 * period) % period - (0.5 * period)) - 0.25 * period) / (0.25 * period);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,triangle,The following statement contains a magic number: return (Math.Abs ((t + 0.75 * period) % period - (0.5 * period)) - 0.25 * period) / (0.25 * period);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,triangle,The following statement contains a magic number: return (Math.Abs ((t + 0.75 * period) % period - (0.5 * period)) - 0.25 * period) / (0.25 * period);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,triangle,The following statement contains a magic number: return (Math.Abs ((t + 0.75 * period) % period - (0.5 * period)) - 0.25 * period) / (0.25 * period);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,sawtooth,The following statement contains a magic number: return 2 * (t / period - Math.Floor (0.5 + t / period));  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,sawtooth,The following statement contains a magic number: return 2 * (t / period - Math.Floor (0.5 + t / period));  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,square,The following statement contains a magic number: return Math.Sign (period / 2 - t % period);  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,noise,The following statement contains a magic number: val = (val >> 13) ^ val;  
Magic Number,Sampler,EvalContext,C:\repos\barometz_Sampler\Sampler\EvalContext.cs,noise,The following statement contains a magic number: return 1 - ((double)nn / 1073741823);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm,The following statement contains a magic number: _defaultRates = new Dictionary<uint' RadioButton> {  	{  		8000'  		rate8000  	}'  	{  		8363'  		rate8363  	}'  	{  		11025'  		rate11k  	}'  	{  		22050'  		rate22k  	}'  	{  		44100'  		rate44k  	}  };  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm,The following statement contains a magic number: _defaultRates = new Dictionary<uint' RadioButton> {  	{  		8000'  		rate8000  	}'  	{  		8363'  		rate8363  	}'  	{  		11025'  		rate11k  	}'  	{  		22050'  		rate22k  	}'  	{  		44100'  		rate44k  	}  };  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm,The following statement contains a magic number: _defaultRates = new Dictionary<uint' RadioButton> {  	{  		8000'  		rate8000  	}'  	{  		8363'  		rate8363  	}'  	{  		11025'  		rate11k  	}'  	{  		22050'  		rate22k  	}'  	{  		44100'  		rate44k  	}  };  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm,The following statement contains a magic number: _defaultRates = new Dictionary<uint' RadioButton> {  	{  		8000'  		rate8000  	}'  	{  		8363'  		rate8363  	}'  	{  		11025'  		rate11k  	}'  	{  		22050'  		rate22k  	}'  	{  		44100'  		rate44k  	}  };  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm,The following statement contains a magic number: _defaultRates = new Dictionary<uint' RadioButton> {  	{  		8000'  		rate8000  	}'  	{  		8363'  		rate8363  	}'  	{  		11025'  		rate11k  	}'  	{  		22050'  		rate22k  	}'  	{  		44100'  		rate44k  	}  };  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,StoreWAV,The following statement contains a magic number: if (sample.BitDepth == 8) {  	for (int i = 0; i < sample.SampleCount; i++) {  		// Need to add 128 because AddSample_8bit takes unsigned bytes.  		wav.AddSample_8bit ((byte)(sample.ValueAt (i * sample.Resolution) + 128));  	}  }  else// Assume 16-bit for now.   {  	for (int i = 0; i < sample.SampleCount; i++) {  		wav.AddSample_16bit ((short)sample.ValueAt (i * sample.Resolution));  	}  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,StoreWAV,The following statement contains a magic number: if (sample.BitDepth == 8) {  	for (int i = 0; i < sample.SampleCount; i++) {  		// Need to add 128 because AddSample_8bit takes unsigned bytes.  		wav.AddSample_8bit ((byte)(sample.ValueAt (i * sample.Resolution) + 128));  	}  }  else// Assume 16-bit for now.   {  	for (int i = 0; i < sample.SampleCount; i++) {  		wav.AddSample_16bit ((short)sample.ValueAt (i * sample.Resolution));  	}  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,StoreWAV,The following statement contains a magic number: for (int i = 0; i < sample.SampleCount; i++) {  	// Need to add 128 because AddSample_8bit takes unsigned bytes.  	wav.AddSample_8bit ((byte)(sample.ValueAt (i * sample.Resolution) + 128));  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,StoreWAV,The following statement contains a magic number: wav.AddSample_8bit ((byte)(sample.ValueAt (i * sample.Resolution) + 128));  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.ChartAreas [0].AxisX.Maximum = _sample.Length * 1000;  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.ChartAreas [0].AxisY.Interval = (_sample.LowerBound - 2) / -2.0;  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.ChartAreas [0].AxisY.Interval = (_sample.LowerBound - 2) / -2.0;  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: for (int i = 0; i < _sample.SampleCount; i++) {  	SampleChart.Series [0].Points.AddXY (i * 1000 * _sample.Resolution' _sample.ValueAt (i * _sample.Resolution));  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.Series [0].Points.AddXY (i * 1000 * _sample.Resolution' _sample.ValueAt (i * _sample.Resolution));  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.ChartAreas [0].AxisX.Interval = Math.Pow (10' Math.Floor (Math.Log10 (_sample.Length * 1000)));  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateChart,The following statement contains a magic number: SampleChart.ChartAreas [0].AxisX.Interval = Math.Pow (10' Math.Floor (Math.Log10 (_sample.Length * 1000)));  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateBitdepthUI,The following statement contains a magic number: if (_sample.BitDepth == 8) {  	BitDepth8.Checked = true;  }  else if (_sample.BitDepth == 16) {  	BitDepth16.Checked = true;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateBitdepthUI,The following statement contains a magic number: if (_sample.BitDepth == 8) {  	BitDepth8.Checked = true;  }  else if (_sample.BitDepth == 16) {  	BitDepth16.Checked = true;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateBitdepthUI,The following statement contains a magic number: if (_sample.BitDepth == 16) {  	BitDepth16.Checked = true;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateTimeUI,The following statement contains a magic number: Time.Minimum = Convert.ToDecimal (_sample.Resolution * 1000);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateTimeUI,The following statement contains a magic number: Time.Increment = Convert.ToDecimal (_sample.Resolution * 1000);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateTimeUI,The following statement contains a magic number: logTime.Minimum = Convert.ToInt32 (Math.Log10 (_sample.Resolution) * 10);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateTimeUI,The following statement contains a magic number: Time.Value = Convert.ToDecimal (_sample.Length * 1000);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,UpdateTimeUI,The following statement contains a magic number: logTime.Value = Convert.ToInt32 (Math.Log10 (_sample.Length) * 10);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,BitDepth_CheckedChanged,The following statement contains a magic number: if (sender as RadioButton == BitDepth8) {  	_sample.BitDepth = 8;  }  else if (sender as RadioButton == BitDepth16) {  	_sample.BitDepth = 16;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,BitDepth_CheckedChanged,The following statement contains a magic number: if (sender as RadioButton == BitDepth8) {  	_sample.BitDepth = 8;  }  else if (sender as RadioButton == BitDepth16) {  	_sample.BitDepth = 16;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,BitDepth_CheckedChanged,The following statement contains a magic number: _sample.BitDepth = 8;  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,BitDepth_CheckedChanged,The following statement contains a magic number: if (sender as RadioButton == BitDepth16) {  	_sample.BitDepth = 16;  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,BitDepth_CheckedChanged,The following statement contains a magic number: _sample.BitDepth = 16;  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,Time_ValueChanged,The following statement contains a magic number: if (sender as NumericUpDown != null) {  	_sample.Length = Convert.ToDouble ((sender as NumericUpDown).Value / 1000);  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,Time_ValueChanged,The following statement contains a magic number: _sample.Length = Convert.ToDouble ((sender as NumericUpDown).Value / 1000);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,logTime_Scroll,The following statement contains a magic number: if (Convert.ToInt32 (Math.Log10 (_sample.Length) * 10) != logTime.Value) {  	_sample.Length = Math.Pow (10' Convert.ToDouble (logTime.Value) / 10);  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,logTime_Scroll,The following statement contains a magic number: if (Convert.ToInt32 (Math.Log10 (_sample.Length) * 10) != logTime.Value) {  	_sample.Length = Math.Pow (10' Convert.ToDouble (logTime.Value) / 10);  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,logTime_Scroll,The following statement contains a magic number: if (Convert.ToInt32 (Math.Log10 (_sample.Length) * 10) != logTime.Value) {  	_sample.Length = Math.Pow (10' Convert.ToDouble (logTime.Value) / 10);  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,logTime_Scroll,The following statement contains a magic number: _sample.Length = Math.Pow (10' Convert.ToDouble (logTime.Value) / 10);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,logTime_Scroll,The following statement contains a magic number: _sample.Length = Math.Pow (10' Convert.ToDouble (logTime.Value) / 10);  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,exportGraphToolStripMenuItem_Click,The following statement contains a magic number: if (chartSaveFileDialog.ShowDialog () == DialogResult.OK) {  	try {  		switch (chartSaveFileDialog.FilterIndex) {  		case 1:  			SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Png);  			break;  		case 2:  			SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Bmp);  			break;  		}  	}  	catch (Exception ex) {  		FormatAndShowException (ex' Resources.Could_not_export_chart_image_to' chartSaveFileDialog.FileName);  	}  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,exportGraphToolStripMenuItem_Click,The following statement contains a magic number: try {  	switch (chartSaveFileDialog.FilterIndex) {  	case 1:  		SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Png);  		break;  	case 2:  		SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Bmp);  		break;  	}  }  catch (Exception ex) {  	FormatAndShowException (ex' Resources.Could_not_export_chart_image_to' chartSaveFileDialog.FileName);  }  
Magic Number,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,exportGraphToolStripMenuItem_Click,The following statement contains a magic number: switch (chartSaveFileDialog.FilterIndex) {  case 1:  	SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Png);  	break;  case 2:  	SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Bmp);  	break;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,WAVFile,The following statement contains a magic number: mDataStartPos = 44;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: try {  	mFileStream = File.Open (mFilename' FileMode.Open);  	mFileMode = pMode;  	// RIFF chunk (12 bytes total)  	// Read the header (first 4 bytes)  	byte[] buffer = new byte[4];  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mWAVHeader' 0);  	// Read the file size (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	//mFileSizeBytes = BitConverter.ToInt32(buffer' 0);  	// Read the RIFF type  	mFileStream.Read (buffer' 0' 4);  	buffer.CopyTo (mRIFFType' 0);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of format chunk (always 16)  	mFileStream.Read (buffer' 0' 4);  	// 2 bytes (value always 1)  	mFileStream.Read (buffer' 0' 2);  	// # of channels (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  	// Sample rate (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mSampleRateHz = BitConverter.ToInt32 (buffer' 0);  	// Bytes per second (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mBytesPerSec = BitConverter.ToInt32 (buffer' 0);  	// Bytes per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  	// Bits per sample (2 bytes)  	mFileStream.Read (buffer' 2' 2);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 2' 2);  	mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  	// Data chunk  	// "data" (ASCII characters)  	mFileStream.Read (buffer' 0' 4);  	// Length of data to follow (4 bytes)  	mFileStream.Read (buffer' 0' 4);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mDataSizeBytes = BitConverter.ToInt32 (buffer' 0);  	// Total of 44 bytes read up to this point.  	// The data size should be file size - 36 bytes.  If not' then set  	// it to that.  	if (mDataSizeBytes != FileSizeBytes - 36)  		mDataSizeBytes = (int)(FileSizeBytes - 36);  	// The rest of the file is the audio data' which  	// can be read by successive calls to NextSample().  	mNumSamplesRemaining = NumSamples;  }  catch (Exception exc) {  	retval = exc.Message;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mNumChannels = (BitConverter.IsLittleEndian ? buffer [2] : buffer [3]);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mBytesPerSample = BitConverter.ToInt16 (buffer' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: Array.Reverse (buffer' 2' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mBitsPerSample = BitConverter.ToInt16 (buffer' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mFileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (mDataSizeBytes != FileSizeBytes - 36)  	mDataSizeBytes = (int)(FileSizeBytes - 36);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: if (mDataSizeBytes != FileSizeBytes - 36)  	mDataSizeBytes = (int)(FileSizeBytes - 36);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Open,The following statement contains a magic number: mDataSizeBytes = (int)(FileSizeBytes - 36);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if (mFileStream != null) {  	// If in write or read/write mode' write the file size information to  	// the header.  	if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  		// File size: Offset 4' 4 bytes  		mFileStream.Seek (4' 0);  		// Note: Per the WAV file spec' we need to write file size - 8 bytes.  		// The header is 44 bytes' and 44 - 8 = 36' so we write  		// mDataBytesWritten + 36.  		// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  		int size = (int)FileSizeBytes - 8;  		byte[] buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  		// Data size: Offset 40' 4 bytes  		mFileStream.Seek (40' 0);  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  		size = (int)(FileSizeBytes - mDataStartPos);  		buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  	}  	mFileStream.Close ();  	mFileStream.Dispose ();  	mFileStream = null;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if (mFileStream != null) {  	// If in write or read/write mode' write the file size information to  	// the header.  	if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  		// File size: Offset 4' 4 bytes  		mFileStream.Seek (4' 0);  		// Note: Per the WAV file spec' we need to write file size - 8 bytes.  		// The header is 44 bytes' and 44 - 8 = 36' so we write  		// mDataBytesWritten + 36.  		// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  		int size = (int)FileSizeBytes - 8;  		byte[] buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  		// Data size: Offset 40' 4 bytes  		mFileStream.Seek (40' 0);  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  		size = (int)(FileSizeBytes - mDataStartPos);  		buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  	}  	mFileStream.Close ();  	mFileStream.Dispose ();  	mFileStream = null;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if (mFileStream != null) {  	// If in write or read/write mode' write the file size information to  	// the header.  	if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  		// File size: Offset 4' 4 bytes  		mFileStream.Seek (4' 0);  		// Note: Per the WAV file spec' we need to write file size - 8 bytes.  		// The header is 44 bytes' and 44 - 8 = 36' so we write  		// mDataBytesWritten + 36.  		// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  		int size = (int)FileSizeBytes - 8;  		byte[] buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  		// Data size: Offset 40' 4 bytes  		mFileStream.Seek (40' 0);  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  		size = (int)(FileSizeBytes - mDataStartPos);  		buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  	}  	mFileStream.Close ();  	mFileStream.Dispose ();  	mFileStream = null;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if (mFileStream != null) {  	// If in write or read/write mode' write the file size information to  	// the header.  	if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  		// File size: Offset 4' 4 bytes  		mFileStream.Seek (4' 0);  		// Note: Per the WAV file spec' we need to write file size - 8 bytes.  		// The header is 44 bytes' and 44 - 8 = 36' so we write  		// mDataBytesWritten + 36.  		// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  		int size = (int)FileSizeBytes - 8;  		byte[] buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  		// Data size: Offset 40' 4 bytes  		mFileStream.Seek (40' 0);  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  		size = (int)(FileSizeBytes - mDataStartPos);  		buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  	}  	mFileStream.Close ();  	mFileStream.Dispose ();  	mFileStream = null;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if (mFileStream != null) {  	// If in write or read/write mode' write the file size information to  	// the header.  	if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  		// File size: Offset 4' 4 bytes  		mFileStream.Seek (4' 0);  		// Note: Per the WAV file spec' we need to write file size - 8 bytes.  		// The header is 44 bytes' and 44 - 8 = 36' so we write  		// mDataBytesWritten + 36.  		// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  		int size = (int)FileSizeBytes - 8;  		byte[] buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  		// Data size: Offset 40' 4 bytes  		mFileStream.Seek (40' 0);  		//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  		size = (int)(FileSizeBytes - mDataStartPos);  		buffer = BitConverter.GetBytes (size);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (buffer);  		mFileStream.Write (buffer' 0' 4);  	}  	mFileStream.Close ();  	mFileStream.Dispose ();  	mFileStream = null;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  	// File size: Offset 4' 4 bytes  	mFileStream.Seek (4' 0);  	// Note: Per the WAV file spec' we need to write file size - 8 bytes.  	// The header is 44 bytes' and 44 - 8 = 36' so we write  	// mDataBytesWritten + 36.  	// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  	int size = (int)FileSizeBytes - 8;  	byte[] buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Data size: Offset 40' 4 bytes  	mFileStream.Seek (40' 0);  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  	size = (int)(FileSizeBytes - mDataStartPos);  	buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  	// File size: Offset 4' 4 bytes  	mFileStream.Seek (4' 0);  	// Note: Per the WAV file spec' we need to write file size - 8 bytes.  	// The header is 44 bytes' and 44 - 8 = 36' so we write  	// mDataBytesWritten + 36.  	// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  	int size = (int)FileSizeBytes - 8;  	byte[] buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Data size: Offset 40' 4 bytes  	mFileStream.Seek (40' 0);  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  	size = (int)(FileSizeBytes - mDataStartPos);  	buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  	// File size: Offset 4' 4 bytes  	mFileStream.Seek (4' 0);  	// Note: Per the WAV file spec' we need to write file size - 8 bytes.  	// The header is 44 bytes' and 44 - 8 = 36' so we write  	// mDataBytesWritten + 36.  	// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  	int size = (int)FileSizeBytes - 8;  	byte[] buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Data size: Offset 40' 4 bytes  	mFileStream.Seek (40' 0);  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  	size = (int)(FileSizeBytes - mDataStartPos);  	buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  	// File size: Offset 4' 4 bytes  	mFileStream.Seek (4' 0);  	// Note: Per the WAV file spec' we need to write file size - 8 bytes.  	// The header is 44 bytes' and 44 - 8 = 36' so we write  	// mDataBytesWritten + 36.  	// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  	int size = (int)FileSizeBytes - 8;  	byte[] buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Data size: Offset 40' 4 bytes  	mFileStream.Seek (40' 0);  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  	size = (int)(FileSizeBytes - mDataStartPos);  	buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: if ((mFileMode == WAVFileMode.WRITE) || (mFileMode == WAVFileMode.READ_WRITE)) {  	// File size: Offset 4' 4 bytes  	mFileStream.Seek (4' 0);  	// Note: Per the WAV file spec' we need to write file size - 8 bytes.  	// The header is 44 bytes' and 44 - 8 = 36' so we write  	// mDataBytesWritten + 36.  	// 2009-03-17: Now using FileSizeBytes - 8 (to avoid mDataBytesWritten).  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten+36)' 0' 4);  	int size = (int)FileSizeBytes - 8;  	byte[] buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Data size: Offset 40' 4 bytes  	mFileStream.Seek (40' 0);  	//mFileStream.Write(BitConverter.GetBytes(mDataBytesWritten)' 0' 4);  	size = (int)(FileSizeBytes - mDataStartPos);  	buffer = BitConverter.GetBytes (size);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: mFileStream.Seek (4' 0);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: mFileStream.Seek (40' 0);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Close,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_ByteArray,The following statement contains a magic number: try {  	int numBytes = mBitsPerSample / 8;  	// 8 bits per byte  	audioSample = new byte[numBytes];  	mFileStream.Read (audioSample' 0' numBytes);  	--mNumSamplesRemaining;  }  catch (Exception exc) {  	audioSample = null;  	throw new WAVFileReadException (exc.Message' "WAVFile.GetNextSample_ByteArray()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_8bit,The following statement contains a magic number: if (mBitsPerSample != 8)  	throw new WAVFileReadException ("Attempted to retrieve an 8-bit sample when audio is not 8-bit."' "WAVFile.GetNextSample_8bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSample_16bit,The following statement contains a magic number: if (mBitsPerSample != 16)  	throw new WAVFileReadException ("Attempted to retrieve a 16-bit sample when audio is not 16-bit."' "WAVFile.GetNextSample_16bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs16Bit,The following statement contains a magic number: if (mBitsPerSample == 8)  	sample_16bit = ScaleByteToShort (GetNextSample_8bit ());  else if (mBitsPerSample == 16)  	sample_16bit = GetNextSample_16bit ();  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs16Bit,The following statement contains a magic number: if (mBitsPerSample == 8)  	sample_16bit = ScaleByteToShort (GetNextSample_8bit ());  else if (mBitsPerSample == 16)  	sample_16bit = GetNextSample_16bit ();  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs16Bit,The following statement contains a magic number: if (mBitsPerSample == 16)  	sample_16bit = GetNextSample_16bit ();  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs8Bit,The following statement contains a magic number: if (mBitsPerSample == 8)  	sample_8bit = GetNextSample_8bit ();  else if (mBitsPerSample == 16)  	sample_8bit = ScaleShortToByte (GetNextSample_16bit ());  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs8Bit,The following statement contains a magic number: if (mBitsPerSample == 8)  	sample_8bit = GetNextSample_8bit ();  else if (mBitsPerSample == 16)  	sample_8bit = ScaleShortToByte (GetNextSample_16bit ());  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,GetNextSampleAs8Bit,The following statement contains a magic number: if (mBitsPerSample == 16)  	sample_8bit = ScaleShortToByte (GetNextSample_16bit ());  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_ByteArray,The following statement contains a magic number: if (pSample != null) {  	// We should be in write or read/write mode.  	if ((mFileMode != WAVFileMode.WRITE) && (mFileMode != WAVFileMode.READ_WRITE))  		throw new WAVFileWriteException ("Write attempted in incorrect mode: " + WAVFileModeStr (mFileMode)' "WAVFile.AddSample_ByteArray()");  	// Throw an exception if mFileStream is null  	if (mFileStream == null)  		throw new WAVFileWriteException ("Write attempted with null internal file stream."' "WAVFile.AddSample_ByteArray()");  	// If pSample contains an incorrect number of bytes for the  	// sample size' then throw an exception.  	if (pSample.GetLength (0) != (mBitsPerSample / 8))  		// 8 bits per byte  		throw new WAVFileWriteException ("Attempt to add an audio sample of incorrect size."' "WAVFile.AddSample_ByteArray()");  	try {  		int numBytes = pSample.GetLength (0);  		mFileStream.Write (pSample' 0' numBytes);  		//mDataBytesWritten += numBytes;  	}  	catch (Exception exc) {  		throw new WAVFileWriteException (exc.Message' "WAVFile.AddSample_ByteArray()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_ByteArray,The following statement contains a magic number: if (pSample.GetLength (0) != (mBitsPerSample / 8))  	// 8 bits per byte  	throw new WAVFileWriteException ("Attempt to add an audio sample of incorrect size."' "WAVFile.AddSample_ByteArray()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_8bit,The following statement contains a magic number: if (mBitsPerSample != 8)  	throw new WAVFileWriteException ("Attempted to add an 8-bit sample when audio file is not 8-bit."' "WAVFile.AddSample_8bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AddSample_16bit,The following statement contains a magic number: if (mBitsPerSample != 16)  	throw new WAVFileWriteException ("Attempted to add a 16-bit sample when audio file is not 16-bit."' "WAVFile.AddSample_16bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: try {  	// Create the file.  If pOverwrite is true' then use FileMode.Create to overwrite the  	// file if it exists.  Otherwise' use FileMode.CreateNew' which will throw a  	// System.IO.IOException if the file exists.  	if (pOverwrite)  		mFileStream = File.Open (pFilename' FileMode.Create);  	else  		mFileStream = File.Open (pFilename' FileMode.CreateNew);  	mFileMode = WAVFileMode.WRITE;  	// Set the member data from the parameters.  	mNumChannels = pStereo ? (byte)2 : (byte)1;  	mSampleRateHz = pSampleRate;  	mBitsPerSample = pBitsPerSample;  	// Write the parameters to the file header.  	// RIFF chunk (12 bytes total)  	// Write the chunk IDD ("RIFF"' 4 bytes)  	byte[] buffer = StrToByteArray ("RIFF");  	mFileStream.Write (buffer' 0' 4);  	if (mWAVHeader == null)  		mWAVHeader = new char[4];  	"RIFF".CopyTo (0' mWAVHeader' 0' 4);  	// File size size (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	// RIFF type ("WAVE")  	buffer = StrToByteArray ("WAVE");  	mFileStream.Write (buffer' 0' 4);  	if (mRIFFType == null)  		mRIFFType = new char[4];  	"WAVE".CopyTo (0' mRIFFType' 0' 4);  	// Format chunk (24 bytes total)  	// "fmt " (ASCII characters)  	buffer = StrToByteArray ("fmt ");  	mFileStream.Write (buffer' 0' 4);  	// Length of format chunk (always 16' 4 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 16;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// 2 bytes (always 1)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = 1;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// # of channels (2 bytes)  	Array.Clear (buffer' 0' buffer.GetLength (0));  	buffer [0] = mNumChannels;  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer' 0' 2);  	mFileStream.Write (buffer' 0' 2);  	// Sample rate (4 bytes)  	buffer = BitConverter.GetBytes (mSampleRateHz);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Calculate the # of bytes per sample: 1=8 bit Mono' 2=8 bit Stereo or  	// 16 bit Mono' 4=16 bit Stereo  	short bytesPerSample = 0;  	if (pStereo)  		bytesPerSample = (short)((mBitsPerSample / 8) * 2);  	else  		bytesPerSample = (short)(mBitsPerSample / 8);  	// Write the # of bytes per second (4 bytes)  	mBytesPerSec = mSampleRateHz * bytesPerSample;  	buffer = BitConverter.GetBytes (mBytesPerSec);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer);  	mFileStream.Write (buffer' 0' 4);  	// Write the # of bytes per sample (2 bytes)  	byte[] buffer_2bytes = BitConverter.GetBytes (bytesPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Bits per sample (2 bytes)  	buffer_2bytes = BitConverter.GetBytes (mBitsPerSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (buffer_2bytes);  	mFileStream.Write (buffer_2bytes' 0' 2);  	// Data chunk  	// "data" (ASCII characters)  	buffer = StrToByteArray ("data");  	mFileStream.Write (buffer' 0' 4);  	// Length of data to follow (4 bytes) - This will be 0 for now  	Array.Clear (buffer' 0' buffer.GetLength (0));  	mFileStream.Write (buffer' 0' 4);  	mDataSizeBytes = 0;  	// Total of 44 bytes written up to this point.  	// The rest of the file is the audio data  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.Create()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mNumChannels = pStereo ? (byte)2 : (byte)1;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (mWAVHeader == null)  	mWAVHeader = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mWAVHeader = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: "RIFF".CopyTo (0' mWAVHeader' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (mRIFFType == null)  	mRIFFType = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mRIFFType = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: "WAVE".CopyTo (0' mRIFFType' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: buffer [0] = 16;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: Array.Reverse (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (!BitConverter.IsLittleEndian)  	Array.Reverse (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: Array.Reverse (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (pStereo)  	bytesPerSample = (short)((mBitsPerSample / 8) * 2);  else  	bytesPerSample = (short)(mBitsPerSample / 8);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (pStereo)  	bytesPerSample = (short)((mBitsPerSample / 8) * 2);  else  	bytesPerSample = (short)(mBitsPerSample / 8);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: if (pStereo)  	bytesPerSample = (short)((mBitsPerSample / 8) * 2);  else  	bytesPerSample = (short)(mBitsPerSample / 8);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: bytesPerSample = (short)((mBitsPerSample / 8) * 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: bytesPerSample = (short)((mBitsPerSample / 8) * 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: bytesPerSample = (short)(mBitsPerSample / 8);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer_2bytes' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer_2bytes' 0' 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,Create,The following statement contains a magic number: mFileStream.Write (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: if (File.Exists (pFilename)) {  	try {  		FileStream fileStream = File.Open (pFilename' FileMode.Open);  		// For a WAV file' the first 4 bytes should be "RIFF"' and  		// the RIFF type (3rd set of 4 bytes) should be "WAVE".  		char[] fileID = new char[4];  		char[] RIFFType = new char[4];  		byte[] buffer = new byte[4];  		// Read the file ID (first 4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (fileID' 0);  		// Read the next 4 bytes (but we don't care about this)  		fileStream.Read (buffer' 0' 4);  		// Read the RIFF ID (4 bytes)  		fileStream.Read (buffer' 0' 4);  		buffer.CopyTo (RIFFType' 0);  		fileStream.Close ();  		String fileIDStr = new String (fileID);  		String RIFFTypeStr = new String (RIFFType);  		retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: try {  	FileStream fileStream = File.Open (pFilename' FileMode.Open);  	// For a WAV file' the first 4 bytes should be "RIFF"' and  	// the RIFF type (3rd set of 4 bytes) should be "WAVE".  	char[] fileID = new char[4];  	char[] RIFFType = new char[4];  	byte[] buffer = new byte[4];  	// Read the file ID (first 4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (fileID' 0);  	// Read the next 4 bytes (but we don't care about this)  	fileStream.Read (buffer' 0' 4);  	// Read the RIFF ID (4 bytes)  	fileStream.Read (buffer' 0' 4);  	buffer.CopyTo (RIFFType' 0);  	fileStream.Close ();  	String fileIDStr = new String (fileID);  	String RIFFTypeStr = new String (RIFFType);  	retval = ((fileIDStr == "RIFF") && (RIFFTypeStr == "WAVE"));  }  catch (Exception exc) {  	throw new WAVFileException (exc.Message' "WAVFile.IsWaveFile()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: fileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: fileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,IsWaveFile,The following statement contains a magic number: fileStream.Read (buffer' 0' 4);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: try {  	if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  		pBitsPerSample = audioFile.mBitsPerSample;  		if (audioFile.mBitsPerSample == 8) {  			byte sample = 0;  			byte highestSample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_8bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  			highestSampleValue = new byte[1];  			highestSampleValue [0] = highestSample;  		}  		else if (audioFile.mBitsPerSample == 16) {  			short sample = 0;  			short highestSample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_16bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  			highestSampleValue = BitConverter.GetBytes (highestSample);  			if (!BitConverter.IsLittleEndian)  				Array.Reverse (highestSampleValue);  		}  		audioFile.Close ();  	}  }  catch (Exception) {  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: try {  	if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  		pBitsPerSample = audioFile.mBitsPerSample;  		if (audioFile.mBitsPerSample == 8) {  			byte sample = 0;  			byte highestSample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_8bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  			highestSampleValue = new byte[1];  			highestSampleValue [0] = highestSample;  		}  		else if (audioFile.mBitsPerSample == 16) {  			short sample = 0;  			short highestSample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_16bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  			highestSampleValue = BitConverter.GetBytes (highestSample);  			if (!BitConverter.IsLittleEndian)  				Array.Reverse (highestSampleValue);  		}  		audioFile.Close ();  	}  }  catch (Exception) {  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  	pBitsPerSample = audioFile.mBitsPerSample;  	if (audioFile.mBitsPerSample == 8) {  		byte sample = 0;  		byte highestSample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_8bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  		highestSampleValue = new byte[1];  		highestSampleValue [0] = highestSample;  	}  	else if (audioFile.mBitsPerSample == 16) {  		short sample = 0;  		short highestSample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_16bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  		highestSampleValue = BitConverter.GetBytes (highestSample);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (highestSampleValue);  	}  	audioFile.Close ();  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  	pBitsPerSample = audioFile.mBitsPerSample;  	if (audioFile.mBitsPerSample == 8) {  		byte sample = 0;  		byte highestSample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_8bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  		highestSampleValue = new byte[1];  		highestSampleValue [0] = highestSample;  	}  	else if (audioFile.mBitsPerSample == 16) {  		short sample = 0;  		short highestSample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_16bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  		highestSampleValue = BitConverter.GetBytes (highestSample);  		if (!BitConverter.IsLittleEndian)  			Array.Reverse (highestSampleValue);  	}  	audioFile.Close ();  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: if (audioFile.mBitsPerSample == 8) {  	byte sample = 0;  	byte highestSample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_8bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  	highestSampleValue = new byte[1];  	highestSampleValue [0] = highestSample;  }  else if (audioFile.mBitsPerSample == 16) {  	short sample = 0;  	short highestSample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  	highestSampleValue = BitConverter.GetBytes (highestSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: if (audioFile.mBitsPerSample == 8) {  	byte sample = 0;  	byte highestSample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_8bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  	highestSampleValue = new byte[1];  	highestSampleValue [0] = highestSample;  }  else if (audioFile.mBitsPerSample == 16) {  	short sample = 0;  	short highestSample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  	highestSampleValue = BitConverter.GetBytes (highestSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue,The following statement contains a magic number: if (audioFile.mBitsPerSample == 16) {  	short sample = 0;  	short highestSample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  	highestSampleValue = BitConverter.GetBytes (highestSample);  	if (!BitConverter.IsLittleEndian)  		Array.Reverse (highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue_8bit,The following statement contains a magic number: if (highestSample != null) {  	if (bitsPerSample == 8)  		highestSampleVal = highestSample [0];  	else  		throw new WAVFileReadException ("Attempt to get largest 8-bit sample from audio file that is not 8-bit."' "WAVFile.HighestSampleValue_8bit()");  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValue_8bit,The following statement contains a magic number: if (bitsPerSample == 8)  	highestSampleVal = highestSample [0];  else  	throw new WAVFileReadException ("Attempt to get largest 8-bit sample from audio file that is not 8-bit."' "WAVFile.HighestSampleValue_8bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: try {  	WAVFile audioFile = new WAVFile ();  	if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  		if (audioFile.BitsPerSample == 8) {  			short sample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  				if (sample > highestSample)  					highestSample = sample;  			}  		}  		else if (audioFile.BitsPerSample == 16) {  			short sample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_16bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  		}  		audioFile.Close ();  	}  }  catch (Exception) {  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: try {  	WAVFile audioFile = new WAVFile ();  	if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  		if (audioFile.BitsPerSample == 8) {  			short sample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  				if (sample > highestSample)  					highestSample = sample;  			}  		}  		else if (audioFile.BitsPerSample == 16) {  			short sample = 0;  			for (int i = 0; i < audioFile.NumSamples; ++i) {  				sample = audioFile.GetNextSample_16bit ();  				if (sample > highestSample)  					highestSample = sample;  			}  		}  		audioFile.Close ();  	}  }  catch (Exception) {  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  	if (audioFile.BitsPerSample == 8) {  		short sample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  			if (sample > highestSample)  				highestSample = sample;  		}  	}  	else if (audioFile.BitsPerSample == 16) {  		short sample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_16bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  	}  	audioFile.Close ();  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: if (audioFile.Open (pFilename' WAVFileMode.READ) == "") {  	if (audioFile.BitsPerSample == 8) {  		short sample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  			if (sample > highestSample)  				highestSample = sample;  		}  	}  	else if (audioFile.BitsPerSample == 16) {  		short sample = 0;  		for (int i = 0; i < audioFile.NumSamples; ++i) {  			sample = audioFile.GetNextSample_16bit ();  			if (sample > highestSample)  				highestSample = sample;  		}  	}  	audioFile.Close ();  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: if (audioFile.BitsPerSample == 8) {  	short sample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  		if (sample > highestSample)  			highestSample = sample;  	}  }  else if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: if (audioFile.BitsPerSample == 8) {  	short sample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = ScaleByteToShort (audioFile.GetNextSample_8bit ());  		if (sample > highestSample)  			highestSample = sample;  	}  }  else if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,HighestSampleValueAs16Bit,The following statement contains a magic number: if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < audioFile.NumSamples; ++i) {  		sample = audioFile.GetNextSample_16bit ();  		if (sample > highestSample)  			highestSample = sample;  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has a supported number of bits/sample and sample rate.  If  	// not' then throw an exception.  	if (!SupportedBitsPerSample (srcFile.BitsPerSample)) {  		WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + " has unsupported bits/sample (" + srcFile.BitsPerSample.ToString () + ")"' "WAVFile.AdjustVolume_Copy()"' srcFile.BitsPerSample);  		srcFile.Close ();  		throw exc;  	}  	// Open the destination file and start copying the adjusted audio data to it.  	WAVFile destFile = new WAVFile ();  	destFile.Create (pDestFilename' srcFile.IsStereo' srcFile.SampleRateHz' srcFile.BitsPerSample);  	if (srcFile.BitsPerSample == 8) {  		byte sample = 0;  		for (int i = 0; i < srcFile.NumSamples; ++i) {  			// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  			// 1.0' then it would be good to avoid any binary roundoff error).  			sample = srcFile.GetNextSample_8bit ();  			if (pMultiplier != 1.0)  				sample = (byte)((double)sample * pMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (srcFile.BitsPerSample == 16) {  		short sample = 0;  		for (int i = 0; i < srcFile.NumSamples; ++i) {  			// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  			// 1.0' then it would be good to avoid any binary roundoff error).  			sample = srcFile.GetNextSample_16bit ();  			if (pMultiplier != 1.0)  				sample = (short)((double)sample * pMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	srcFile.Close ();  	destFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolume_Copy()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has a supported number of bits/sample and sample rate.  If  	// not' then throw an exception.  	if (!SupportedBitsPerSample (srcFile.BitsPerSample)) {  		WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + " has unsupported bits/sample (" + srcFile.BitsPerSample.ToString () + ")"' "WAVFile.AdjustVolume_Copy()"' srcFile.BitsPerSample);  		srcFile.Close ();  		throw exc;  	}  	// Open the destination file and start copying the adjusted audio data to it.  	WAVFile destFile = new WAVFile ();  	destFile.Create (pDestFilename' srcFile.IsStereo' srcFile.SampleRateHz' srcFile.BitsPerSample);  	if (srcFile.BitsPerSample == 8) {  		byte sample = 0;  		for (int i = 0; i < srcFile.NumSamples; ++i) {  			// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  			// 1.0' then it would be good to avoid any binary roundoff error).  			sample = srcFile.GetNextSample_8bit ();  			if (pMultiplier != 1.0)  				sample = (byte)((double)sample * pMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (srcFile.BitsPerSample == 16) {  		short sample = 0;  		for (int i = 0; i < srcFile.NumSamples; ++i) {  			// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  			// 1.0' then it would be good to avoid any binary roundoff error).  			sample = srcFile.GetNextSample_16bit ();  			if (pMultiplier != 1.0)  				sample = (short)((double)sample * pMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	srcFile.Close ();  	destFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolume_Copy()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The following statement contains a magic number: if (srcFile.BitsPerSample == 8) {  	byte sample = 0;  	for (int i = 0; i < srcFile.NumSamples; ++i) {  		// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  		// 1.0' then it would be good to avoid any binary roundoff error).  		sample = srcFile.GetNextSample_8bit ();  		if (pMultiplier != 1.0)  			sample = (byte)((double)sample * pMultiplier);  		destFile.AddSample_8bit (sample);  	}  }  else if (srcFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < srcFile.NumSamples; ++i) {  		// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  		// 1.0' then it would be good to avoid any binary roundoff error).  		sample = srcFile.GetNextSample_16bit ();  		if (pMultiplier != 1.0)  			sample = (short)((double)sample * pMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The following statement contains a magic number: if (srcFile.BitsPerSample == 8) {  	byte sample = 0;  	for (int i = 0; i < srcFile.NumSamples; ++i) {  		// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  		// 1.0' then it would be good to avoid any binary roundoff error).  		sample = srcFile.GetNextSample_8bit ();  		if (pMultiplier != 1.0)  			sample = (byte)((double)sample * pMultiplier);  		destFile.AddSample_8bit (sample);  	}  }  else if (srcFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < srcFile.NumSamples; ++i) {  		// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  		// 1.0' then it would be good to avoid any binary roundoff error).  		sample = srcFile.GetNextSample_16bit ();  		if (pMultiplier != 1.0)  			sample = (short)((double)sample * pMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy,The following statement contains a magic number: if (srcFile.BitsPerSample == 16) {  	short sample = 0;  	for (int i = 0; i < srcFile.NumSamples; ++i) {  		// Note: Only multiply the sample if pMultiplier is not 1.0 (if the multiplier is  		// 1.0' then it would be good to avoid any binary roundoff error).  		sample = srcFile.GetNextSample_16bit ();  		if (pMultiplier != 1.0)  			sample = (short)((double)sample * pMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has a supported number of bits/sample and sample rate.  If  	// not' then throw an exception.  	if (!SupportedBitsPerSample (audioFile.BitsPerSample)) {  		short bitsPerSample = audioFile.BitsPerSample;  		audioFile.Close ();  		throw new WAVFileBitsPerSampleException (pFilename + " has unsupported bits/sample (" + bitsPerSample.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' bitsPerSample);  	}  	if (!SupportedSampleRate (audioFile.SampleRateHz)) {  		int sampleRate = audioFile.SampleRateHz;  		audioFile.Close ();  		throw new WAVFileSampleRateException (pFilename + " has unsupported sample rate (" + sampleRate.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' sampleRate);  	}  	// Adjust the file volume  	if (audioFile.BitsPerSample == 8) {  		byte sample = 0;  		for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  			sample = (byte)((double)audioFile.GetNextSample_8bit () * pMultiplier);  			audioFile.SeekToAudioSample (sampleNum);  			audioFile.AddSample_8bit (sample);  		}  	}  	else if (audioFile.BitsPerSample == 16) {  		short sample = 0;  		for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  			sample = (short)((double)audioFile.GetNextSample_16bit () * pMultiplier);  			audioFile.SeekToAudioSample (sampleNum);  			audioFile.AddSample_16bit (sample);  		}  	}  	audioFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolumeInPlace()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has a supported number of bits/sample and sample rate.  If  	// not' then throw an exception.  	if (!SupportedBitsPerSample (audioFile.BitsPerSample)) {  		short bitsPerSample = audioFile.BitsPerSample;  		audioFile.Close ();  		throw new WAVFileBitsPerSampleException (pFilename + " has unsupported bits/sample (" + bitsPerSample.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' bitsPerSample);  	}  	if (!SupportedSampleRate (audioFile.SampleRateHz)) {  		int sampleRate = audioFile.SampleRateHz;  		audioFile.Close ();  		throw new WAVFileSampleRateException (pFilename + " has unsupported sample rate (" + sampleRate.ToString () + ")"' "WAVFile.AdjustVolumeInPlace()"' sampleRate);  	}  	// Adjust the file volume  	if (audioFile.BitsPerSample == 8) {  		byte sample = 0;  		for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  			sample = (byte)((double)audioFile.GetNextSample_8bit () * pMultiplier);  			audioFile.SeekToAudioSample (sampleNum);  			audioFile.AddSample_8bit (sample);  		}  	}  	else if (audioFile.BitsPerSample == 16) {  		short sample = 0;  		for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  			sample = (short)((double)audioFile.GetNextSample_16bit () * pMultiplier);  			audioFile.SeekToAudioSample (sampleNum);  			audioFile.AddSample_16bit (sample);  		}  	}  	audioFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolumeInPlace()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The following statement contains a magic number: if (audioFile.BitsPerSample == 8) {  	byte sample = 0;  	for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  		sample = (byte)((double)audioFile.GetNextSample_8bit () * pMultiplier);  		audioFile.SeekToAudioSample (sampleNum);  		audioFile.AddSample_8bit (sample);  	}  }  else if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  		sample = (short)((double)audioFile.GetNextSample_16bit () * pMultiplier);  		audioFile.SeekToAudioSample (sampleNum);  		audioFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The following statement contains a magic number: if (audioFile.BitsPerSample == 8) {  	byte sample = 0;  	for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  		sample = (byte)((double)audioFile.GetNextSample_8bit () * pMultiplier);  		audioFile.SeekToAudioSample (sampleNum);  		audioFile.AddSample_8bit (sample);  	}  }  else if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  		sample = (short)((double)audioFile.GetNextSample_16bit () * pMultiplier);  		audioFile.SeekToAudioSample (sampleNum);  		audioFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolumeInPlace,The following statement contains a magic number: if (audioFile.BitsPerSample == 16) {  	short sample = 0;  	for (int sampleNum = 0; sampleNum < audioFile.NumSamples; ++sampleNum) {  		sample = (short)((double)audioFile.GetNextSample_16bit () * pMultiplier);  		audioFile.SeekToAudioSample (sampleNum);  		audioFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy_8BitTo16Bit,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has 8 bits per sample.  If not' then throw an exception.  	if (srcFile.BitsPerSample != 8) {  		WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + ": 8 bits per sample required' and the file has " + srcFile.BitsPerSample.ToString () + " bits per sample."' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()"' srcFile.BitsPerSample);  		srcFile.Close ();  		throw exc;  	}  	// Open the destination file  	WAVFile destFile = new WAVFile ();  	destFile.Create (pDestFilename' srcFile.IsStereo' srcFile.SampleRateHz' 16' true);  	// Copy the data  	short sample_16bit = 0;  	while (srcFile.NumSamplesRemaining > 0) {  		// Scale the sample from 8-bit to 16 bits  		sample_16bit = ScaleByteToShort (srcFile.GetNextSample_8bit ());  		// Now' apply pMultiplier if it is not 1.0  		if (pMultiplier != 1.0)  			sample_16bit = (short)((double)sample_16bit * pMultiplier);  		// Save the sample to the destination file  		destFile.AddSample_16bit (sample_16bit);  	}  	srcFile.Close ();  	destFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy_8BitTo16Bit,The following statement contains a magic number: if (retval == "") {  	// Check to make sure the input file has 8 bits per sample.  If not' then throw an exception.  	if (srcFile.BitsPerSample != 8) {  		WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + ": 8 bits per sample required' and the file has " + srcFile.BitsPerSample.ToString () + " bits per sample."' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()"' srcFile.BitsPerSample);  		srcFile.Close ();  		throw exc;  	}  	// Open the destination file  	WAVFile destFile = new WAVFile ();  	destFile.Create (pDestFilename' srcFile.IsStereo' srcFile.SampleRateHz' 16' true);  	// Copy the data  	short sample_16bit = 0;  	while (srcFile.NumSamplesRemaining > 0) {  		// Scale the sample from 8-bit to 16 bits  		sample_16bit = ScaleByteToShort (srcFile.GetNextSample_8bit ());  		// Now' apply pMultiplier if it is not 1.0  		if (pMultiplier != 1.0)  			sample_16bit = (short)((double)sample_16bit * pMultiplier);  		// Save the sample to the destination file  		destFile.AddSample_16bit (sample_16bit);  	}  	srcFile.Close ();  	destFile.Close ();  }  else  	throw new WAVFileReadException (retval' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()");  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy_8BitTo16Bit,The following statement contains a magic number: if (srcFile.BitsPerSample != 8) {  	WAVFileBitsPerSampleException exc = new WAVFileBitsPerSampleException (pSrcFilename + ": 8 bits per sample required' and the file has " + srcFile.BitsPerSample.ToString () + " bits per sample."' "WAVFile.AdjustVolume_Copy_8BitTo16Bit()"' srcFile.BitsPerSample);  	srcFile.Close ();  	throw exc;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,AdjustVolume_Copy_8BitTo16Bit,The following statement contains a magic number: destFile.Create (pDestFilename' srcFile.IsStereo' srcFile.SampleRateHz' 16' true);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 8-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_8bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if (srcFile.IsStereo && !pStereo) {  	// 8-bit to 8-bit' stereo to mono: Average each 2 samples  	while (srcFile.NumSamplesRemaining > 0) {  		sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  		if (pVolumeMultiplier != 1.0)  			sample = (byte)((double)sample * pVolumeMultiplier);  		destFile.AddSample_8bit (sample);  	}  }  else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  	// 8-bit to 8-bit' stereo to stereo or mono to mono  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSample_8bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (byte)((double)sample * pVolumeMultiplier);  		destFile.AddSample_8bit (sample);  	}  }  else if (!srcFile.IsStereo && pStereo) {  	// 8-bit to 8-bit' mono to stereo: Write each sample twice  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSample_8bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (byte)((double)sample * pVolumeMultiplier);  		destFile.AddSample_8bit (sample);  		destFile.AddSample_8bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: while (srcFile.NumSamplesRemaining > 0) {  	sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  	if (pVolumeMultiplier != 1.0)  		sample = (byte)((double)sample * pVolumeMultiplier);  	destFile.AddSample_8bit (sample);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: sample = (byte)((short)((short)srcFile.GetNextSample_8bit () + (short)srcFile.GetNextSample_8bit ()) / 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 8) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 8-bit to 16 bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 8-bit to 16 bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 8-bit to 16 bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSampleAs16Bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if (srcFile.IsStereo && !pStereo) {  	// 8-bit to 16 bit' stereo to mono: Average each 2 samples  	while (srcFile.NumSamplesRemaining > 0) {  		sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  	// 8-bit to 16 bit' stereo to stereo or mono to mono  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSampleAs16Bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  else if (!srcFile.IsStereo && pStereo) {  	// 8-bit to 16 bit' mono to stereo: Write each sample twice  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSampleAs16Bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  		destFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: while (srcFile.NumSamplesRemaining > 0) {  	sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  	if (pVolumeMultiplier != 1.0)  		sample = (short)((double)sample * pVolumeMultiplier);  	destFile.AddSample_16bit (sample);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: sample = (short)((int)((int)srcFile.GetNextSampleAs16Bit () + (int)srcFile.GetNextSampleAs16Bit ()) / 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 8)) {  	byte sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 8-bit' stereo to mono: Average each 2 samples  		short sample_16bit = 0;  		while (srcFile.NumSamplesRemaining > 0) {  			sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  			if (pVolumeMultiplier != 1.0)  				sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  			sample = ScaleShortToByte (sample_16bit);  			destFile.AddSample_8bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 8-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 8-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  			if (pVolumeMultiplier != 1.0)  				sample = (byte)((double)sample * pVolumeMultiplier);  			destFile.AddSample_8bit (sample);  			destFile.AddSample_8bit (sample);  		}  	}  }  else if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if (srcFile.IsStereo && !pStereo) {  	// 16-bit to 8-bit' stereo to mono: Average each 2 samples  	short sample_16bit = 0;  	while (srcFile.NumSamplesRemaining > 0) {  		sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  		if (pVolumeMultiplier != 1.0)  			sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  		sample = ScaleShortToByte (sample_16bit);  		destFile.AddSample_8bit (sample);  	}  }  else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  	// 16-bit to 8-bit' stereo to stereo or mono to mono  	while (srcFile.NumSamplesRemaining > 0) {  		sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  		if (pVolumeMultiplier != 1.0)  			sample = (byte)((double)sample * pVolumeMultiplier);  		destFile.AddSample_8bit (sample);  	}  }  else if (!srcFile.IsStereo && pStereo) {  	// 16-bit to 8-bit' mono to stereo: Write each sample twice  	while (srcFile.NumSamplesRemaining > 0) {  		sample = ScaleShortToByte (srcFile.GetNextSample_16bit ());  		if (pVolumeMultiplier != 1.0)  			sample = (byte)((double)sample * pVolumeMultiplier);  		destFile.AddSample_8bit (sample);  		destFile.AddSample_8bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: while (srcFile.NumSamplesRemaining > 0) {  	sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  	if (pVolumeMultiplier != 1.0)  		sample_16bit = (short)((double)sample_16bit * pVolumeMultiplier);  	sample = ScaleShortToByte (sample_16bit);  	destFile.AddSample_8bit (sample);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: sample_16bit = (short)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit () / 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if ((srcFile.BitsPerSample == 16) && (pBitsPerSample == 16)) {  	short sample = 0;  	if (srcFile.IsStereo && !pStereo) {  		// 16-bit to 16-bit' stereo to mono: Average each 2 samples  		while (srcFile.NumSamplesRemaining > 0) {  			sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  		// 16-bit to 16-bit' stereo to stereo or mono to mono  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  		}  	}  	else if (!srcFile.IsStereo && pStereo) {  		// 16-bit to 16-bit' mono to stereo: Write each sample twice  		while (srcFile.NumSamplesRemaining > 0) {  			sample = srcFile.GetNextSample_16bit ();  			if (pVolumeMultiplier != 1.0)  				sample = (short)((double)sample * pVolumeMultiplier);  			destFile.AddSample_16bit (sample);  			destFile.AddSample_16bit (sample);  		}  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: if (srcFile.IsStereo && !pStereo) {  	// 16-bit to 16-bit' stereo to mono: Average each 2 samples  	while (srcFile.NumSamplesRemaining > 0) {  		sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  else if ((srcFile.IsStereo && pStereo) || (!srcFile.IsStereo && !pStereo)) {  	// 16-bit to 16-bit' stereo to stereo or mono to mono  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSample_16bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  	}  }  else if (!srcFile.IsStereo && pStereo) {  	// 16-bit to 16-bit' mono to stereo: Write each sample twice  	while (srcFile.NumSamplesRemaining > 0) {  		sample = srcFile.GetNextSample_16bit ();  		if (pVolumeMultiplier != 1.0)  			sample = (short)((double)sample * pVolumeMultiplier);  		destFile.AddSample_16bit (sample);  		destFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: while (srcFile.NumSamplesRemaining > 0) {  	sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  	if (pVolumeMultiplier != 1.0)  		sample = (short)((double)sample * pVolumeMultiplier);  	destFile.AddSample_16bit (sample);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,CopyAndConvert,The following statement contains a magic number: sample = (short)((int)((int)srcFile.GetNextSample_16bit () + (int)srcFile.GetNextSample_16bit ()) / 2);  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedSampleRate,The following statement contains a magic number: return (true || (pSampleRateHz == 8000) || (pSampleRateHz == 11025) || (pSampleRateHz == 16000) || (pSampleRateHz == 18900) || (pSampleRateHz == 22050) || (pSampleRateHz == 32000) || (pSampleRateHz == 37800) || (pSampleRateHz == 44056) || (pSampleRateHz == 44100) || (pSampleRateHz == 48000));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedBitsPerSample,The following statement contains a magic number: return ((pBitsPerSample == 8) || (pBitsPerSample == 16));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SupportedBitsPerSample,The following statement contains a magic number: return ((pBitsPerSample == 8) || (pBitsPerSample == 16));  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	// Get the highest sample value of all of the WAV files  	byte highestSample = HighestSampleValue_8bit (pFileList);  	highestSampleValue = (short)highestSample;  	byte difference = (byte)(highestSample - (byte.MaxValue / (byte)numTracks));  	multiplier = 1.0 - ((double)difference / (double)highestSample);  }  else if (highestBitsPerSample == 16) {  	// Get the highest sample value of all of the WAV files  	highestSampleValue = HighestSampleValueAs16Bit (pFileList);  	short difference = (short)(highestSampleValue - (short.MaxValue / (short)numTracks));  	multiplier = 1.0 - ((double)difference / (double)highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	// Get the highest sample value of all of the WAV files  	byte highestSample = HighestSampleValue_8bit (pFileList);  	highestSampleValue = (short)highestSample;  	byte difference = (byte)(highestSample - (byte.MaxValue / (byte)numTracks));  	multiplier = 1.0 - ((double)difference / (double)highestSample);  }  else if (highestBitsPerSample == 16) {  	// Get the highest sample value of all of the WAV files  	highestSampleValue = HighestSampleValueAs16Bit (pFileList);  	short difference = (short)(highestSampleValue - (short.MaxValue / (short)numTracks));  	multiplier = 1.0 - ((double)difference / (double)highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 16) {  	// Get the highest sample value of all of the WAV files  	highestSampleValue = HighestSampleValueAs16Bit (pFileList);  	short difference = (short)(highestSampleValue - (short.MaxValue / (short)numTracks));  	multiplier = 1.0 - ((double)difference / (double)highestSampleValue);  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte sample = 0;  	while (SamplesRemain (scaledAudioFiles)) {  		sample = 0;  		for (int i = 0; i < scaledAudioFiles.GetLength (0); ++i) {  			if (scaledAudioFiles [i].NumSamplesRemaining > 0)  				sample += scaledAudioFiles [i].GetNextSample_8bit ();  		}  		sample /= (byte)(scaledAudioFiles.GetLength (0));  		outputFile.AddSample_8bit (sample);  	}  }  else if (highestBitsPerSample == 16) {  	short sample = 0;  	while (SamplesRemain (scaledAudioFiles)) {  		sample = 0;  		for (int i = 0; i < scaledAudioFiles.GetLength (0); ++i) {  			if (scaledAudioFiles [i].NumSamplesRemaining > 0)  				sample += scaledAudioFiles [i].GetNextSampleAs16Bit ();  		}  		sample /= (short)(scaledAudioFiles.GetLength (0));  		outputFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte sample = 0;  	while (SamplesRemain (scaledAudioFiles)) {  		sample = 0;  		for (int i = 0; i < scaledAudioFiles.GetLength (0); ++i) {  			if (scaledAudioFiles [i].NumSamplesRemaining > 0)  				sample += scaledAudioFiles [i].GetNextSample_8bit ();  		}  		sample /= (byte)(scaledAudioFiles.GetLength (0));  		outputFile.AddSample_8bit (sample);  	}  }  else if (highestBitsPerSample == 16) {  	short sample = 0;  	while (SamplesRemain (scaledAudioFiles)) {  		sample = 0;  		for (int i = 0; i < scaledAudioFiles.GetLength (0); ++i) {  			if (scaledAudioFiles [i].NumSamplesRemaining > 0)  				sample += scaledAudioFiles [i].GetNextSampleAs16Bit ();  		}  		sample /= (short)(scaledAudioFiles.GetLength (0));  		outputFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 16) {  	short sample = 0;  	while (SamplesRemain (scaledAudioFiles)) {  		sample = 0;  		for (int i = 0; i < scaledAudioFiles.GetLength (0); ++i) {  			if (scaledAudioFiles [i].NumSamplesRemaining > 0)  				sample += scaledAudioFiles [i].GetNextSampleAs16Bit ();  		}  		sample /= (short)(scaledAudioFiles.GetLength (0));  		outputFile.AddSample_16bit (sample);  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte highestSampleVal = WAVFile.HighestSampleValue_8bit (pOutputFilename);  	byte maxValue = byte.MaxValue / 4 * 3;  	multiplier = (double)maxValue / (double)highestSampleVal;  }  else if (highestBitsPerSample == 16) {  	short finalMixFileHighestSample = WAVFile.HighestSampleValueAs16Bit (pOutputFilename);  	// Calculate the multiplier for adjusting the audio of the final mix file.  	//short difference = (short)(finalMixFileHighestSample - highestSampleValue);  	//multiplier = 1.0 - ((double)difference / (double)finalMixFileHighestSample);  	// This calculates the multiplier based on the highest sample value in the audio  	// file and the highest possible 16-bit sample value.  	multiplier = (double)short.MaxValue / (double)finalMixFileHighestSample;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte highestSampleVal = WAVFile.HighestSampleValue_8bit (pOutputFilename);  	byte maxValue = byte.MaxValue / 4 * 3;  	multiplier = (double)maxValue / (double)highestSampleVal;  }  else if (highestBitsPerSample == 16) {  	short finalMixFileHighestSample = WAVFile.HighestSampleValueAs16Bit (pOutputFilename);  	// Calculate the multiplier for adjusting the audio of the final mix file.  	//short difference = (short)(finalMixFileHighestSample - highestSampleValue);  	//multiplier = 1.0 - ((double)difference / (double)finalMixFileHighestSample);  	// This calculates the multiplier based on the highest sample value in the audio  	// file and the highest possible 16-bit sample value.  	multiplier = (double)short.MaxValue / (double)finalMixFileHighestSample;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte highestSampleVal = WAVFile.HighestSampleValue_8bit (pOutputFilename);  	byte maxValue = byte.MaxValue / 4 * 3;  	multiplier = (double)maxValue / (double)highestSampleVal;  }  else if (highestBitsPerSample == 16) {  	short finalMixFileHighestSample = WAVFile.HighestSampleValueAs16Bit (pOutputFilename);  	// Calculate the multiplier for adjusting the audio of the final mix file.  	//short difference = (short)(finalMixFileHighestSample - highestSampleValue);  	//multiplier = 1.0 - ((double)difference / (double)finalMixFileHighestSample);  	// This calculates the multiplier based on the highest sample value in the audio  	// file and the highest possible 16-bit sample value.  	multiplier = (double)short.MaxValue / (double)finalMixFileHighestSample;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 8) {  	byte highestSampleVal = WAVFile.HighestSampleValue_8bit (pOutputFilename);  	byte maxValue = byte.MaxValue / 4 * 3;  	multiplier = (double)maxValue / (double)highestSampleVal;  }  else if (highestBitsPerSample == 16) {  	short finalMixFileHighestSample = WAVFile.HighestSampleValueAs16Bit (pOutputFilename);  	// Calculate the multiplier for adjusting the audio of the final mix file.  	//short difference = (short)(finalMixFileHighestSample - highestSampleValue);  	//multiplier = 1.0 - ((double)difference / (double)finalMixFileHighestSample);  	// This calculates the multiplier based on the highest sample value in the audio  	// file and the highest possible 16-bit sample value.  	multiplier = (double)short.MaxValue / (double)finalMixFileHighestSample;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,MergeAudioFiles,The following statement contains a magic number: if (highestBitsPerSample == 16) {  	short finalMixFileHighestSample = WAVFile.HighestSampleValueAs16Bit (pOutputFilename);  	// Calculate the multiplier for adjusting the audio of the final mix file.  	//short difference = (short)(finalMixFileHighestSample - highestSampleValue);  	//multiplier = 1.0 - ((double)difference / (double)finalMixFileHighestSample);  	// This calculates the multiplier based on the highest sample value in the audio  	// file and the highest possible 16-bit sample value.  	multiplier = (double)short.MaxValue / (double)finalMixFileHighestSample;  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,SeekToAudioSample,The following statement contains a magic number: if (mFileStream != null) {  	// Figure out the byte position.  This will be mDataStartPos + however many  	// bytes per sample * pSampleNum.  	long bytesPerSample = mBitsPerSample / 8;  	try {  		mFileStream.Seek (mDataStartPos + (bytesPerSample * pSampleNum)' 0);  	}  	catch (System.IO.IOException exc) {  		throw new WAVFileIOException ("Unable to to seek to sample " + pSampleNum.ToString () + ": " + exc.Message' "WAVFile.SeekToAudioSample()");  	}  	catch (System.NotSupportedException exc) {  		throw new WAVFileIOException ("Unable to to seek to sample " + pSampleNum.ToString () + ": " + exc.Message' "WAVFile.SeekToAudioSample()");  	}  	catch (Exception exc) {  		throw new WAVFileException (exc.Message' "WAVFile.SeekToAudioSample()");  	}  }  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mWAVHeader = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mRIFFType = new char[4];  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mNumChannels = 2;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mSampleRateHz = 44100;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mBytesPerSec = 176400;  
Magic Number,EricOulashin,WAVFile,C:\repos\barometz_Sampler\Sampler\AudioMixer\WAVFile.cs,InitMembers,The following statement contains a magic number: mBitsPerSample = 16;  
Missing Default,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,sample_SampleChanged,The following switch statement is missing a default case: switch (e.Type) {  case SampleChangedEventArgs.ChangeType.BitDepth:  	UpdateBitdepthUI ();  	break;  case SampleChangedEventArgs.ChangeType.Length:  	UpdateTimeUI ();  	break;  case SampleChangedEventArgs.ChangeType.SampleRate:  	UpdateTimeUI ();  	UpdateSampleRateUI ();  	break;  }  
Missing Default,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,exportGraphToolStripMenuItem_Click,The following switch statement is missing a default case: switch (chartSaveFileDialog.FilterIndex) {  case 1:  	SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Png);  	break;  case 2:  	SampleChart.SaveImage (chartSaveFileDialog.FileName' ChartImageFormat.Bmp);  	break;  }  
Missing Default,Sampler,SamplerForm,C:\repos\barometz_Sampler\Sampler\SamplerForm.cs,SamplerForm_FormClosing,The following switch statement is missing a default case: switch (MessageBox.Show (Resources.Do_you_want_to_save_your_changes_' Application.ProductName' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question)) {  case DialogResult.Cancel:  	e.Cancel = true;  	break;  case DialogResult.No:  	break;  case DialogResult.Yes:  	if (SaveSample () != DialogResult.OK) {  		e.Cancel = true;  	}  	break;  }  
