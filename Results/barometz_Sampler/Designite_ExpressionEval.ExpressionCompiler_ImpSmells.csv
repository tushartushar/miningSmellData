Implementation smell,Namespace,Class,File,Method,Description
Long Statement,ExpressionEval.ExpressionCompiler,CSharpExpressionCompiler,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.ExpressionCompiler\CSharpExpressionCompiler.cs,CompileExpression,The length of the statement  "	string codeString = string.Format (source' className' functionType.FullName' returnTypeName' methodName' expression' functionType.Namespace' dynamicNamespace); " is 159.
Magic Number,ExpressionEval.ExpressionCompiler,CSharpExpressionCompiler,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.ExpressionCompiler\CSharpExpressionCompiler.cs,CompileExpression,The following statement contains a magic number: if (returnType.IsGenericType) {  	//check for nullable  	Type genericType = returnType.GetGenericTypeDefinition ();  	if (genericType == typeof(Nullable<>)) {  		//nullable so add ?  		Type nullableType = Nullable.GetUnderlyingType (returnType);  		returnTypeName = nullableType.FullName + "?";  	}  	else {  		//not nullable but is generic so get the list of types  		Type[] genericArgTypes = returnType.GetGenericArguments ();  		//get type name without the last 2 characters for generic type names  		returnTypeName = genericType.FullName.Substring (0' genericType.FullName.Length - 2) + "<";  		//loop through type arguments and build out return type  		foreach (Type genericArgType in genericArgTypes) {  			returnTypeName += genericArgType.FullName;  		}  		//add ending generic operator  		returnTypeName += ">";  	}  }  
Magic Number,ExpressionEval.ExpressionCompiler,CSharpExpressionCompiler,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.ExpressionCompiler\CSharpExpressionCompiler.cs,CompileExpression,The following statement contains a magic number: if (genericType == typeof(Nullable<>)) {  	//nullable so add ?  	Type nullableType = Nullable.GetUnderlyingType (returnType);  	returnTypeName = nullableType.FullName + "?";  }  else {  	//not nullable but is generic so get the list of types  	Type[] genericArgTypes = returnType.GetGenericArguments ();  	//get type name without the last 2 characters for generic type names  	returnTypeName = genericType.FullName.Substring (0' genericType.FullName.Length - 2) + "<";  	//loop through type arguments and build out return type  	foreach (Type genericArgType in genericArgTypes) {  		returnTypeName += genericArgType.FullName;  	}  	//add ending generic operator  	returnTypeName += ">";  }  
Magic Number,ExpressionEval.ExpressionCompiler,CSharpExpressionCompiler,C:\repos\barometz_Sampler\ExpressionEval\ExpressionEval.ExpressionCompiler\CSharpExpressionCompiler.cs,CompileExpression,The following statement contains a magic number: returnTypeName = genericType.FullName.Substring (0' genericType.FullName.Length - 2) + "<";  
