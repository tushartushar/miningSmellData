Implementation smell,Namespace,Class,File,Method,Description
Long Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The method has 115 lines of code.
Long Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The method has 125 lines of code.
Long Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,The method has 116 lines of code.
Long Method,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve3,The method has 133 lines of code.
Long Method,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,The method has 181 lines of code.
Long Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,InsertLeaf,The method has 119 lines of code.
Long Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,Balance,The method has 122 lines of code.
Long Method,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,The method has 368 lines of code.
Long Method,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The method has 142 lines of code.
Long Method,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,The method has 216 lines of code.
Long Method,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,Solve,The method has 181 lines of code.
Long Method,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,SolveTOI,The method has 111 lines of code.
Long Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,Solve,The method has 195 lines of code.
Long Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,SolveTOI,The method has 295 lines of code.
Long Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,InitializeVelocityConstraints,The method has 190 lines of code.
Long Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method has 332 lines of code.
Long Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,InitVelocityConstraints,The method has 118 lines of code.
Long Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The method has 103 lines of code.
Long Method,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2RevoluteJoint.cs,InitVelocityConstraints,The method has 107 lines of code.
Long Method,Box2D.Dynamics.Joints,b2WheelJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,The method has 114 lines of code.
Complex Method,Box2D.Collision,b2AABB,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2AABB.cs,RayCast,Cyclomatic complexity of the method is 9
Complex Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2GetPointStates,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,Cyclomatic complexity of the method is 9
Complex Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,Cyclomatic complexity of the method is 14
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,InsertLeaf,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,Balance,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,RebuildBottomUp,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,Cyclomatic complexity of the method is 36
Complex Method,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,Cyclomatic complexity of the method is 16
Complex Method,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2Body,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Body.cs,DestroyFixture,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2ContactManager,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2ContactManager.cs,Destroy,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Dynamics,b2ContactManager,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2ContactManager.cs,AddPair,Cyclomatic complexity of the method is 12
Complex Method,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,Solve,Cyclomatic complexity of the method is 20
Complex Method,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,SolveTOI,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DestroyBody,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,CreateJoint,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DestroyJoint,Cyclomatic complexity of the method is 14
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,Solve,Cyclomatic complexity of the method is 25
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,SolveTOI,Cyclomatic complexity of the method is 36
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,Cyclomatic complexity of the method is 20
Complex Method,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,Dump,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Contacts,b2Contact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2Contact.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Contacts,b2Contact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2Contact.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 12
Complex Method,Box2D.Dynamics.Joints,b2Joint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2Joint.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 11
Complex Method,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2RevoluteJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 10
Complex Method,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2RevoluteJoint.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 8
Complex Method,Box2D.Dynamics.Joints,b2WheelJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 9
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollideCircles,The method has 5 parameters. Parameters: manifold' circleA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The method has 5 parameters. Parameters: manifold' polygonA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The method has 5 parameters. Parameters: manifold' polyA' xfA' polyB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2EdgeSeparation,The method has 5 parameters. Parameters: poly1' xf1' edge1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollideEdgeAndCircle,The method has 5 parameters. Parameters: manifold' edgeA' xfA' circleB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollideEdgeAndPolygon,The method has 5 parameters. Parameters: manifold' edgeA' xfA' polygonB' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2ClipSegmentToLine,The method has 5 parameters. Parameters: vOut' vIn' normal' offset' vertexIndexA
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2TestOverlap,The method has 6 parameters. Parameters: shapeA' indexA' shapeB' indexB' xfA' xfB
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The method has 5 parameters. Parameters: edgeIndex' poly1' xf1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2FindIncidentEdge,The method has 6 parameters. Parameters: c' poly1' xf1' edge1' poly2' xf2
Long Parameter List,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,ReadCache,The method has 5 parameters. Parameters: cache' proxyA' transformA' proxyB' transformB
Long Parameter List,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,The method has 5 parameters. Parameters: manifold' edgeA' xfA' polygonB' xfB
Long Parameter List,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The method has 5 parameters. Parameters: manifold' xfA' radiusA' xfB' radiusB
Long Parameter List,Box2D.Collision,b2SeparationFunction,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Initialize,The method has 8 parameters. Parameters: cache' proxyA' sweepA' proxyB' sweepB' t1' xfA' xfB
Long Parameter List,Box2D.Dynamics.Joints,b2PulleyJointDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PullyJointDef.cs,Initialize,The method has 7 parameters. Parameters: bA' bB' groundA' groundB' anchorA' anchorB' r
Long Statement,Box2D.Collision,b2ClipVertex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,Dump,The length of the statement  "            System.Diagnostics.Debug.WriteLine("b2ClipVertex {{ v={0}'{1} - feature={4}@{2}'{5}@{3} }}"' v.x' v.y' id.indexA' id.indexB' id.typeA' id.typeB); " is 145.
Long Statement,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2TestOverlap,The length of the statement  "//            Console.WriteLine("{2} vs {3}: distance={0} after {1} iters"' output.distance' output.iterations' shapeA.ShapeType' shapeB.ShapeType); " is 148.
Long Statement,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The length of the statement  "            float dx = (xf2.q.c * poly2.Centroid.x - xf2.q.s * poly2.Centroid.y) + xf2.p.x - ((xf1.q.c * poly1.Centroid.x - xf1.q.s * poly1.Centroid.y) + xf1.p.x); " is 151.
Long Statement,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2FindMaxSeparation,The length of the statement  "            float dy = (xf2.q.s * poly2.Centroid.x + xf2.q.c * poly2.Centroid.y) + xf2.p.y - ((xf1.q.s * poly1.Centroid.x + xf1.q.c * poly1.Centroid.y) + xf1.p.y); " is 151.
Long Statement,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeMass,The length of the statement  "            massData.I += massData.mass * (b2Math.b2Dot(ref massData.center' ref massData.center) - b2Math.b2Dot(ref center' ref center)); " is 126.
Long Statement,Box2D.Common,b2Vec2,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Vec2.cs,Set,The length of the statement  "                System.Diagnostics.Debug.WriteLine("Invalid vector - this message is here for the sake of a breakpoint Set({0}'{1})"' x' y); " is 124.
Long Statement,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,SolveTOI,The length of the statement  "                m_TOIIsland = new b2Island(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener); " is 128.
Long Statement,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "                    // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires " is 120.
Long Statement,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveTOIPositionConstraints,The length of the statement  "                    float C = b2Math.b2Clamp(b2Settings.b2_toiBaugarte * (separation + b2Settings.b2_linearSlop)' -b2Settings.b2_maxLinearCorrection' 0.0f); " is 136.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The length of the statement  "                    C2 = b2Math.b2Clamp(translation - m_lowerTranslation + b2Settings.b2_linearSlop' -b2Settings.b2_maxLinearCorrection' 0.0f); " is 123.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The length of the statement  "                    C2 = b2Math.b2Clamp(translation - m_upperTranslation - b2Settings.b2_linearSlop' 0.0f' b2Settings.b2_maxLinearCorrection); " is 122.
Long Statement,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,GetJointSpeed,The length of the statement  "            float speed = b2Math.b2Dot(d' b2Math.b2Cross(wA' ref axis)) + b2Math.b2Dot(axis' vB + b2Math.b2Cross(wB' ref rB) - vA - b2Math.b2Cross(wA' ref rA)); " is 148.
Long Statement,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2RevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "                    float C = b2Math.b2Clamp(angle - m_lowerAngle' -b2Settings.b2_maxAngularCorrection' b2Settings.b2_maxAngularCorrection); " is 120.
Complex Conditional,Box2D.Dynamics,b2ContactManager,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2ContactManager.cs,AddPair,The conditional expression  "fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB"  is complex.
Complex Conditional,Box2D.Dynamics,b2ContactManager,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2ContactManager.cs,AddPair,The conditional expression  "fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA"  is complex.
Virtual Method Call from Constructor,Box2D.Collision.Shapes,b2ChainShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2ChainShape.cs,b2ChainShape,The constructor "b2ChainShape" calls a virtual method "CreateChain".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetJointType".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetJointType".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalXAxisA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetBodyB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorA".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalAnchorB".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetReferenceAngle".
Virtual Method Call from Constructor,Box2D.Dynamics.Joints,b2GearJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2GearJoint.cs,b2GearJoint,The constructor "b2GearJoint" calls a virtual method "GetLocalXAxisA".
Magic Number,Box2D.Collision,b2AABB,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2AABB.cs,RayCast,The following statement contains a magic number: i < 2
Magic Number,Box2D.Collision,b2BroadPhase,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2BroadPhase.cs,b2BroadPhase,The following statement contains a magic number: m_pairCapacity = 16;
Magic Number,Box2D.Collision,b2BroadPhase,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2BroadPhase.cs,b2BroadPhase,The following statement contains a magic number: m_moveCapacity = 16;
Magic Number,Box2D.Collision,b2BroadPhase,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2BroadPhase.cs,BufferMove,The following statement contains a magic number: m_moveCapacity *= 2;
Magic Number,Box2D.Collision,b2BroadPhase,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2BroadPhase.cs,QueryCallback,The following statement contains a magic number: m_pairCapacity *= 2;
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The following statement contains a magic number: manifold.localPoint.x = 0.5f * (v1.x + v2.x);
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygonAndCircle,The following statement contains a magic number: manifold.localPoint.y = 0.5f * (v1.y + v2.y);
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: const float k_relativeTol = 0.98f;
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: const float k_absoluteTol = 0.001f;
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: planePoint.x = 0.5f * (v11.x + v12.x);
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: planePoint.y = 0.5f * (v11.y + v12.y);
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: np < 2
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2CollidePolygons,The following statement contains a magic number: np < 2
Magic Number,Box2D.Collision,b2Collision,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Collision.cs,b2TestOverlap,The following statement contains a magic number: return output.distance < 10.0f * b2Settings.b2_epsilon;
Magic Number,Box2D.Collision,b2SimplexCache,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Defaults,The following statement contains a magic number: indexA = new int[3];
Magic Number,Box2D.Collision,b2SimplexCache,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Defaults,The following statement contains a magic number: indexB = new int[3];
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices = new b2SimplexVertex[3];
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices[2] = new b2SimplexVertex();
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Simplex,The following statement contains a magic number: m_vertices_2 = m_vertices[2];
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,ReadCache,The following statement contains a magic number: Debug.Assert(cache.count <= 3);
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,ReadCache,The following statement contains a magic number: metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < b2Settings.b2_epsilon
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,ReadCache,The following statement contains a magic number: metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < b2Settings.b2_epsilon
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetSearchDirection,The following statement contains a magic number: switch (m_count)              {                  case 1:                      dir.x = -m_vertices_0.w.x;                      dir.y = -m_vertices_0.w.y;                      return;                    case 2:                  {                      float e12x = m_vertices_1.w.x - m_vertices_0.w.x;                      float e12y = m_vertices_1.w.y - m_vertices_0.w.y;                        float sgn = e12x * -m_vertices_0.w.y - e12y * -m_vertices_0.w.x;                        if (sgn > 0.0f)                      {                          // Origin is left of e12.                          dir.x = -e12y;                          dir.y = e12x;                      }                      else                      {                          // Origin is right of e12.                          dir.x = e12y;                          dir.y = -e12x;                      }                      return;                  }                    default:                      Debug.Assert(false);                      dir = b2Vec2.Zero;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;                    case 1:                      point = m_vertices_0.w;                      return;                    case 2:                      point.x = m_vertices_0.a * m_vertices_0.w.x + m_vertices_1.a * m_vertices_1.w.x;                      point.y = m_vertices_0.a * m_vertices_0.w.y + m_vertices_1.a * m_vertices_1.w.y;                      return;                    case 3:                      point.x = 0;                      point.y = 0;                      return;                    default:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;                    case 1:                      point = m_vertices_0.w;                      return;                    case 2:                      point.x = m_vertices_0.a * m_vertices_0.w.x + m_vertices_1.a * m_vertices_1.w.x;                      point.y = m_vertices_0.a * m_vertices_0.w.y + m_vertices_1.a * m_vertices_1.w.y;                      return;                    case 3:                      point.x = 0;                      point.y = 0;                      return;                    default:                      Debug.Assert(false);                      point.x = 0;                      point.y = 0;                      return;              }
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (m_count)  			{  			case 0:      			Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  				  			case 1:                  pA = m_vertices_0.wA;                  pB = m_vertices_0.wB;  				break;  				  			case 2:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y;                  pB.x = m_vertices_0.a * m_vertices_0.wB.x + m_vertices_1.a * m_vertices_1.wB.x;                  pB.y = m_vertices_0.a * m_vertices_0.wB.y + m_vertices_1.a * m_vertices_1.wB.y;  				break;  				  			case 3:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x + m_vertices_2.a * m_vertices_2.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y + m_vertices_2.a * m_vertices_2.wA.y;  				pB = pA;  				break;  				  			default:  				Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (m_count)  			{  			case 0:      			Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  				  			case 1:                  pA = m_vertices_0.wA;                  pB = m_vertices_0.wB;  				break;  				  			case 2:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y;                  pB.x = m_vertices_0.a * m_vertices_0.wB.x + m_vertices_1.a * m_vertices_1.wB.x;                  pB.y = m_vertices_0.a * m_vertices_0.wB.y + m_vertices_1.a * m_vertices_1.wB.y;  				break;  				  			case 3:                  pA.x = m_vertices_0.a * m_vertices_0.wA.x + m_vertices_1.a * m_vertices_1.wA.x + m_vertices_2.a * m_vertices_2.wA.x;                  pA.y = m_vertices_0.a * m_vertices_0.wA.y + m_vertices_1.a * m_vertices_1.wA.y + m_vertices_2.a * m_vertices_2.wA.y;  				pB = pA;  				break;  				  			default:  				Debug.Assert(false);  			    pA = b2Vec2.Zero;  			    pB = b2Vec2.Zero;  				break;  			}
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetMetric,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      float x = m_vertices_0.w.x - m_vertices_1.w.x;                      float y = m_vertices_0.w.y - m_vertices_1.w.y;                      return (float) Math.Sqrt(x * x + y * y);                    case 3:                      float ax = m_vertices_1.w.x - m_vertices_0.w.x;                      float ay = m_vertices_1.w.y - m_vertices_0.w.y;                      float bx = m_vertices_2.w.x - m_vertices_0.w.x;                      float by = m_vertices_2.w.y - m_vertices_0.w.y;                      return ax * by - ay * bx;                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,GetMetric,The following statement contains a magic number: switch (m_count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      float x = m_vertices_0.w.x - m_vertices_1.w.x;                      float y = m_vertices_0.w.y - m_vertices_1.w.y;                      return (float) Math.Sqrt(x * x + y * y);                    case 3:                      float ax = m_vertices_1.w.x - m_vertices_0.w.x;                      float ay = m_vertices_1.w.y - m_vertices_0.w.y;                      float bx = m_vertices_2.w.x - m_vertices_0.w.x;                      float by = m_vertices_2.w.y - m_vertices_0.w.y;                      return ax * by - ay * bx;                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve2,The following statement contains a magic number: m_count = 2;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: m_count = 2;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: m_count = 2;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: m_count = 2;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,Solve3,The following statement contains a magic number: m_count = 3;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: int k_maxIters = 20;
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: switch (simplex.m_count)  				{  				case 1:  					break;  					  				case 2:  					simplex.Solve2();  					break;  					  				case 3:  					simplex.Solve3();  					break;  					  				default:  					Debug.Assert(false);  					break;  				}
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: switch (simplex.m_count)  				{  				case 1:  					break;  					  				case 2:  					simplex.Solve2();  					break;  					  				case 3:  					simplex.Solve3();  					break;  					  				default:  					Debug.Assert(false);  					break;  				}
Magic Number,Box2D.Collision,b2Simplex,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Distance.cs,b2Distance,The following statement contains a magic number: simplex.m_count == 3
Magic Number,Box2D.Collision,b2DistanceProxy,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DistanceProxy.cs,Create,The following statement contains a magic number: bp.m_buffer = new b2Vec2[2];
Magic Number,Box2D.Collision,b2DistanceProxy,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DistanceProxy.cs,Set,The following statement contains a magic number: switch (shape.ShapeType)              {                  case b2ShapeType.e_circle:                      {                          b2CircleShape circle = (b2CircleShape)shape;                          m_buffer[0] = circle.Position;                          m_vertices = m_buffer;                          m_count = 1;                          m_radius = circle.Radius;                      }                      break;                    case b2ShapeType.e_polygon:                      {                          b2PolygonShape polygon = (b2PolygonShape)shape;                          m_vertices = polygon.Vertices;                          m_count = polygon.VertexCount;                          m_radius = polygon.Radius;                      }                      break;                    case b2ShapeType.e_chain:                      {                          b2ChainShape chain = (b2ChainShape)shape;                          Debug.Assert(0 <= index && index < chain.Count);                            m_buffer[0] = chain.Vertices[index];                          if (index + 1 < chain.Count)                          {                              m_buffer[1] = chain.Vertices[index + 1];                          }                          else                          {                              m_buffer[1] = chain.Vertices[0];                          }                            m_vertices = m_buffer;                          m_count = 2;                          m_radius = chain.Radius;                      }                      break;                    case b2ShapeType.e_edge:                      {                          b2EdgeShape edge = (b2EdgeShape)shape;                          m_buffer[0] = edge.Vertex1;                          m_buffer[1] = edge.Vertex2;                          m_vertices = m_buffer;                          m_count = 2;                          m_radius = edge.Radius;                      }                      break;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Box2D.Collision,b2DistanceProxy,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DistanceProxy.cs,Set,The following statement contains a magic number: switch (shape.ShapeType)              {                  case b2ShapeType.e_circle:                      {                          b2CircleShape circle = (b2CircleShape)shape;                          m_buffer[0] = circle.Position;                          m_vertices = m_buffer;                          m_count = 1;                          m_radius = circle.Radius;                      }                      break;                    case b2ShapeType.e_polygon:                      {                          b2PolygonShape polygon = (b2PolygonShape)shape;                          m_vertices = polygon.Vertices;                          m_count = polygon.VertexCount;                          m_radius = polygon.Radius;                      }                      break;                    case b2ShapeType.e_chain:                      {                          b2ChainShape chain = (b2ChainShape)shape;                          Debug.Assert(0 <= index && index < chain.Count);                            m_buffer[0] = chain.Vertices[index];                          if (index + 1 < chain.Count)                          {                              m_buffer[1] = chain.Vertices[index + 1];                          }                          else                          {                              m_buffer[1] = chain.Vertices[0];                          }                            m_vertices = m_buffer;                          m_count = 2;                          m_radius = chain.Radius;                      }                      break;                    case b2ShapeType.e_edge:                      {                          b2EdgeShape edge = (b2EdgeShape)shape;                          m_buffer[0] = edge.Vertex1;                          m_buffer[1] = edge.Vertex2;                          m_vertices = m_buffer;                          m_count = 2;                          m_radius = edge.Radius;                      }                      break;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,b2DynamicTree,The following statement contains a magic number: m_nodeCapacity = 16;
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,AllocateNode,The following statement contains a magic number: m_nodeCapacity *= 2;
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,InsertLeaf,The following statement contains a magic number: float cost = 2.0f * combinedArea;
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,InsertLeaf,The following statement contains a magic number: float inheritanceCost = 2.0f * (combinedArea - area);
Magic Number,Box2D.Collision,b2DynamicTree<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2DynamicTree.cs,Balance,The following statement contains a magic number: A.IsLeaf() || A.height < 2
Magic Number,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,The following statement contains a magic number: m_radius = 2.0f * b2Settings.b2_polygonRadius;
Magic Number,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,The following statement contains a magic number: const float k_relativeTol = 0.98f;
Magic Number,Box2D.Collision,b2EPCollider,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2EPCollider.cs,Collide,The following statement contains a magic number: const float k_absoluteTol = 0.001f;
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following statement contains a magic number: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
Magic Number,Box2D.Collision,b2SeparationFunction,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Initialize,The following statement contains a magic number: Debug.Assert(0 < count && count < 3);
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: float target = Math.Max(b2Settings.b2_linearSlop' totalRadius - 3.0f * b2Settings.b2_linearSlop);
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: float tolerance = 0.25f * b2Settings.b2_linearSlop;
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: int k_maxIterations = 20;
Magic Number,Box2D.Collision,b2TimeOfImpact,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2TimeOfImpact.cs,Compute,The following statement contains a magic number: rootIterCount != 50
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2ChainShape.cs,CreateLoop,The following statement contains a magic number: PrevVertex = Vertices[Count - 2];
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2ChainShape.cs,GetChildEdge,The following statement contains a magic number: edge.Vertex3 = Vertices[index + 2];
Magic Number,Box2D.Collision.Shapes,b2ChainShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2ChainShape.cs,GetChildEdge,The following statement contains a magic number: index < Count - 2
Magic Number,Box2D.Collision.Shapes,b2CircleShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2CircleShape.cs,ComputeMass,The following statement contains a magic number: massData.I = massData.mass * (0.5f * Radius * Radius + Position.LengthSquared);
Magic Number,Box2D.Collision.Shapes,b2EdgeShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2EdgeShape.cs,ComputeMass,The following statement contains a magic number: massData.center = 0.5f * (Vertex1 + Vertex2);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: m_vertexCount = 4;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[2].Set(hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[3].Set(-hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[2].Set(0.0f' 1.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[3].Set(-1.0f' 0.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: m_vertexCount = 4;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[2].Set(hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Vertices[3].Set(-hx' hy);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[2].Set(0.0f' 1.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,SetAsBox,The following statement contains a magic number: Normals[3].Set(-1.0f' 0.0f);
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeCentroid,The following statement contains a magic number: float inv3 = 1.0f / 3.0f;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeCentroid,The following statement contains a magic number: float triangleArea = 0.5f * D;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeMass,The following statement contains a magic number: float k_inv3 = 1.0f / 3.0f;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeMass,The following statement contains a magic number: float triangleArea = 0.5f * D;
Magic Number,Box2D.Collision.Shapes,b2PolygonShape,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\Shapes\b2PolygonShape.cs,ComputeMass,The following statement contains a magic number: I += (0.25f * k_inv3 * D) * (intx2 + inty2);
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2InvSqrt,The following statement contains a magic number: float xhalf = x / 2f;
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2InvSqrt,The following statement contains a magic number: x = x * (1.5f - xhalf * x * x);
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Box2D.Common,b2Math,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Math.cs,b2NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Box2D.Common,b2Sweep,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Common\b2Sweep.cs,Normalize,The following statement contains a magic number: float twoPi = 2.0f * b2Settings.b2_pi;
Magic Number,Box2D.Dynamics,b2FixtureDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2FixtureDef.cs,Defaults,The following statement contains a magic number: friction = 0.2f;
Magic Number,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: m_bodyCapacity = 128;
Magic Number,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: m_contactCapacity = 128;
Magic Number,Box2D.Dynamics,b2Island,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2Island.cs,Reset,The following statement contains a magic number: m_jointCapacity = 128;
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: m_TOIIsland = new b2Island(2 * b2Settings.b2_maxTOIContacts' b2Settings.b2_maxTOIContacts' 0' m_contactManager.ContactListener);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,SolveTOI,The following statement contains a magic number: subStep.positionIterations = 20;
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawShape,The following statement contains a magic number: switch (fixture.ShapeType)              {                  case b2ShapeType.e_circle:                      {                          b2CircleShape circle = (b2CircleShape)fixture.Shape;                            b2Vec2 center = b2Math.b2Mul(ref xf' ref circle.Position);                          float radius = circle.Radius;                          b2Vec2 v = new b2Vec2(1.0f' 0.0f);                          b2Vec2 axis = b2Math.b2Mul(ref xf.q' ref v);                            m_debugDraw.DrawSolidCircle(center' radius' axis' color);                      }                      break;                    case b2ShapeType.e_edge:                      {                          b2EdgeShape edge = (b2EdgeShape)fixture.Shape;                          b2Vec2 v1 = b2Math.b2Mul(ref xf' ref edge.Vertex1);                          b2Vec2 v2 = b2Math.b2Mul(ref xf' ref edge.Vertex2);                          m_debugDraw.DrawSegment(v1' v2' color);                      }                      break;                    case b2ShapeType.e_chain:                      {                          b2ChainShape chain = (b2ChainShape)fixture.Shape;                          int count = chain.Count;                          b2Vec2[] vertices = chain.Vertices;                            b2Vec2 v1 = b2Math.b2Mul(ref xf' ref vertices[0]);                          for (int i = 1; i < count; ++i)                          {                              b2Vec2 v2 = b2Math.b2Mul(ref xf' ref vertices[i]);                              m_debugDraw.DrawSegment(v1' v2' color);                              m_debugDraw.DrawCircle(v1' 0.05f' color);                              v1 = v2;                          }                      }                      break;                    case b2ShapeType.e_polygon:                      {                          b2PolygonShape poly = (b2PolygonShape)fixture.Shape;                          int vertexCount = poly.VertexCount;                          var vertices = b2ArrayPool<b2Vec2>.Create(b2Settings.b2_maxPolygonVertices' true);                            for (int i = 0; i < vertexCount; ++i)                          {                              vertices[i] = b2Math.b2Mul(ref xf' ref poly.Vertices[i]);                          }                            m_debugDraw.DrawSolidPolygon(vertices' vertexCount' color);                            b2ArrayPool<b2Vec2>.Free(vertices);                      }                      break;                    default:                      break;              }
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawJoint,The following statement contains a magic number: b2Color color = new b2Color(0.5f' 0.8f' 0.8f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawJoint,The following statement contains a magic number: b2Color color = new b2Color(0.5f' 0.8f' 0.8f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawJoint,The following statement contains a magic number: b2Color color = new b2Color(0.5f' 0.8f' 0.8f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: DrawShape(f' ref b.Transform' new b2Color(0.5f' 0.5f' 0.3f));
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: DrawShape(f' ref b.Transform' new b2Color(0.5f' 0.5f' 0.3f));
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: DrawShape(f' ref b.Transform' new b2Color(0.5f' 0.5f' 0.3f));
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.3f' 0.9f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.3f' 0.9f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.3f' 0.9f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.9f' 0.3f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.9f' 0.3f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Color color = new b2Color(0.9f' 0.3f' 0.9f);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: b2Vec2[] vs = new b2Vec2[4];
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: vs[2].Set(aabb.UpperBound.x' aabb.UpperBound.y);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: vs[3].Set(aabb.LowerBound.x' aabb.UpperBound.y);
Magic Number,Box2D.Dynamics,b2World,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\b2World.cs,DrawDebugData,The following statement contains a magic number: m_debugDraw.DrawPolygon(vs' 4' color);
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,The following statement contains a magic number: var capacity = 4;
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,Init,The following statement contains a magic number: capacity *= 2;
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: float k_maxConditionNumber = 1000.0f;
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: vc.pointCount == 2
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: Debug.Assert(pointCount == 1 || pointCount == 2);
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolvePositionConstraints,The following statement contains a magic number: return minSeparation >= -3.0f * b2Settings.b2_linearSlop;
Magic Number,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveTOIPositionConstraints,The following statement contains a magic number: return minSeparation >= -1.5f * b2Settings.b2_linearSlop;
Magic Number,Box2D.Dynamics.Contacts,b2PositionSolverManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,b2PositionSolverManifold,The following statement contains a magic number: switch (pc.type)                  {                      case b2ManifoldType.e_circles:                          {                              b2Vec2 pointA;                              pointA.x = (xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y) + xfA.p.x;                              pointA.y = (xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y) + xfA.p.y;                                var lc = pc.points[0].localPoint;                              b2Vec2 pointB;                              pointB.x = (xfB.q.c * lc.x - xfB.q.s * lc.y) + xfB.p.x;                              pointB.y = (xfB.q.s * lc.x + xfB.q.c * lc.y) + xfB.p.y;                                normal = pointB - pointA;                              normal.Normalize();                              point = 0.5f * (pointA + pointB);                              b2Vec2 a = pointB - pointA;                              separation = a.x * normal.x + a.y * normal.y - pc.radiusA - pc.radiusB;                          }                          break;                        case b2ManifoldType.e_faceA:                          {                              normal.x = xfA.q.c * pc.localNormal.x - xfA.q.s * pc.localNormal.y;                              normal.y = xfA.q.s * pc.localNormal.x + xfA.q.c * pc.localNormal.y;                                b2Vec2 planePoint;                              planePoint.x = (xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y) + xfA.p.x;                              planePoint.y = (xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y) + xfA.p.y;                                var lc = pc.points[index].localPoint;                              b2Vec2 clipPoint;                              clipPoint.x = (xfB.q.c * lc.x - xfB.q.s * lc.y) + xfB.p.x;                              clipPoint.y = (xfB.q.s * lc.x + xfB.q.c * lc.y) + xfB.p.y;                                b2Vec2 rCP = clipPoint - planePoint;                              separation = rCP.x * normal.x + rCP.y * normal.y - pc.radiusA - pc.radiusB;                              point = clipPoint;                          }                          break;                        case b2ManifoldType.e_faceB:                          {                              normal.x = xfB.q.c * pc.localNormal.x - xfB.q.s * pc.localNormal.y;                              normal.y = xfB.q.s * pc.localNormal.x + xfB.q.c * pc.localNormal.y;                                                            b2Vec2 planePoint;                              planePoint.x = (xfB.q.c * pc.localPoint.x - xfB.q.s * pc.localPoint.y) + xfB.p.x;                              planePoint.y = (xfB.q.s * pc.localPoint.x + xfB.q.c * pc.localPoint.y) + xfB.p.y;                                var lc = pc.points[index].localPoint;                              b2Vec2 clipPoint;                              clipPoint.x = (xfA.q.c * lc.x - xfA.q.s * lc.y) + xfA.p.x;                              clipPoint.y = (xfA.q.s * lc.x + xfA.q.c * lc.y) + xfA.p.y;                                b2Vec2 rCP = clipPoint - planePoint;                              separation = rCP.x * normal.x + rCP.y * normal.y - pc.radiusA - pc.radiusB;                              point = clipPoint;                                // Ensure normal points from A to B                              normal = -normal;                          }                          break;                        default:                          throw new ArgumentException();                  }
Magic Number,Box2D.Dynamics.Joints,b2DistanceJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2DistanceJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float omega = 2.0f * (float)Math.PI * m_frequencyHz;
Magic Number,Box2D.Dynamics.Joints,b2DistanceJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2DistanceJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float d = 2.0f * m_mass * m_dampingRatio * omega;
Magic Number,Box2D.Dynamics.Joints,b2MouseJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2MouseJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float omega = 2.0f * b2Settings.b2_pi * m_frequencyHz;
Magic Number,Box2D.Dynamics.Joints,b2MouseJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2MouseJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float d = 2.0f * mass * m_dampingRatio * omega;
Magic Number,Box2D.Dynamics.Joints,b2MouseJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2MouseJoint.cs,InitVelocityConstraints,The following statement contains a magic number: wB *= 0.98f;
Magic Number,Box2D.Dynamics.Joints,b2MouseJointDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2MouseJointDef.cs,b2MouseJointDef,The following statement contains a magic number: frequencyHz = 5.0f;
Magic Number,Box2D.Dynamics.Joints,b2MouseJointDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2MouseJointDef.cs,b2MouseJointDef,The following statement contains a magic number: dampingRatio = 0.7f;
Magic Number,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,InitVelocityConstraints,The following statement contains a magic number: b2Math.b2Abs(m_upperTranslation - m_lowerTranslation) < 2.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2PrismaticJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PrismaticJoint.cs,SolvePositionConstraints,The following statement contains a magic number: b2Math.b2Abs(m_upperTranslation - m_lowerTranslation) < 2.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2PulleyJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PulleyJoint.cs,InitVelocityConstraints,The following statement contains a magic number: lengthA > 10.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2PulleyJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PulleyJoint.cs,InitVelocityConstraints,The following statement contains a magic number: lengthB > 10.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2PulleyJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PulleyJoint.cs,SolvePositionConstraints,The following statement contains a magic number: lengthA > 10.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2PulleyJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2PulleyJoint.cs,SolvePositionConstraints,The following statement contains a magic number: lengthB > 10.0f * b2Settings.b2_linearSlop
Magic Number,Box2D.Dynamics.Joints,b2RevoluteJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2RevoluteJoint.cs,InitVelocityConstraints,The following statement contains a magic number: b2Math.b2Abs(m_upperAngle - m_lowerAngle) < 2.0f * b2Settings.b2_angularSlop
Magic Number,Box2D.Dynamics.Joints,b2WeldJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WeldJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float omega = 2.0f * b2Settings.b2_pi * m_frequencyHz;
Magic Number,Box2D.Dynamics.Joints,b2WeldJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WeldJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float d = 2.0f * m * m_dampingRatio * omega;
Magic Number,Box2D.Dynamics.Joints,b2WheelJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float omega = 2.0f * (float)Math.PI * m_frequencyHz;
Magic Number,Box2D.Dynamics.Joints,b2WheelJoint,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJoint.cs,InitVelocityConstraints,The following statement contains a magic number: float dx = 2.0f * m_springMass * m_dampingRatio * omega;
Magic Number,Box2D.Dynamics.Joints,b2WheelJointDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJointDef.cs,b2WheelJointDef,The following statement contains a magic number: frequencyHz = 2.0f;
Magic Number,Box2D.Dynamics.Joints,b2WheelJointDef,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Joints\b2WheelJointDef.cs,b2WheelJointDef,The following statement contains a magic number: dampingRatio = 0.7f;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,b2Rope,The following statement contains a magic number: m_k3 = 0.1f;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,Initialize,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,Initialize,The following statement contains a magic number: b2Vec2 p3 = m_ps[i + 2];
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SetAngle,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: int count3 = m_count - 2;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: b2Vec2 p3 = m_ps[i + 2];
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: float m3 = m_ims[i + 2];
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: angle -= 2f * (float)Math.PI;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: angle += 2.0f * (float)Math.PI;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,SolveC3,The following statement contains a magic number: m_ps[i + 2] = p3;
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,Draw,The following statement contains a magic number: b2Color c = new b2Color(0.4f' 0.5f' 0.7f);
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,Draw,The following statement contains a magic number: b2Color c = new b2Color(0.4f' 0.5f' 0.7f);
Magic Number,Box2D.Rope,b2Rope,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Rope\b2Rope.cs,Draw,The following statement contains a magic number: b2Color c = new b2Color(0.4f' 0.5f' 0.7f);
Magic Number,Box2D,b2ArrayPool<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,Create,The following statement contains a magic number: var l = 2;
Magic Number,Box2D,PoolEntry,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,Add,The following statement contains a magic number: var newElements = new T[Elements.Length * 2][];
Magic Number,Box2D,b2ReusedObject<T>,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,Create,The following statement contains a magic number: _created = new T[_created.Length * 2];
Magic Number,Box2D,b2IntStack,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,b2IntStack,The following statement contains a magic number: _capacity = 128;
Magic Number,Box2D,b2IntStack,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,b2IntStack,The following statement contains a magic number: _array = b2ArrayPool<int>.Create(128' true);
Magic Number,Box2D,b2IntStack,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\b2InternalClasses.cs,Push,The following statement contains a magic number: _capacity *= 2;
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((212' 241)' (266' 295))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((214' 240)' (320' 346)' (268' 294))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((214' 238)' (370' 394)' (268' 292)' (320' 344))
Duplicate Code,Box2D.Dynamics.Contacts,b2ContactSolver,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Dynamics\Contacts\b2ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((318' 338)' (368' 388))
Missing Default,Box2D.Collision,b2WorldManifold,C:\research\architectureSmells\repos\mono_CocosSharp\box2d\Collision\b2Manifold.cs,Initialize,The following switch statement is missing a default case: switch (manifold.type)              {                  case b2ManifoldType.e_circles:                  {  #if false                                          normal.Set(1.0f' 0.0f);                      b2Vec2 pointA = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                      b2Vec2 pointB = b2Math.b2Mul(ref xfB' ref manifold.points[0].localPoint);                      if (b2Math.b2DistanceSquared(pointA' pointB) > b2Settings.b2_epsilonSqrd)                      {                          normal = pointB - pointA;                          normal.Normalize();                      }                                        b2Vec2 cA = pointA + radiusA * normal;                      b2Vec2 cB = pointB - radiusB * normal;                      points[0] = 0.5f * (cA + cB);  #else                                          normal.x = 1.0f;                      normal.y = 0.0f;                        var localPoint = manifold.points[0].localPoint;                        float pointAx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float pointAy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        float pointBx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                      float pointBy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                        float cx = pointAx - pointBx;                      float cy = pointAy - pointBy;                        float distance = (cx * cx + cy * cy);                        if (distance > b2Settings.b2_epsilonSqrd)                      {                          normal.x = pointBx - pointAx;                          normal.y = pointBy - pointAy;                          normal.Normalize();                      }                        float cAx = pointAx + radiusA * normal.x;                      float cAy = pointAy + radiusA * normal.y;                      float cBx = pointBx - radiusB * normal.x;                      float cBy = pointBy - radiusB * normal.y;                        b2Vec2 p;                      p.x = 0.5f * (cAx + cBx);                      p.y = 0.5f * (cAy + cBy);                        points[0] = p;  #endif                  }                      break;                    case b2ManifoldType.e_faceA:                  {  #if false                      normal = b2Math.b2Mul(xfA.q' manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfA' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfB' ref manifold.points[i].localPoint);                          b2Vec2 clipMinusPlane = clipPoint - planePoint;                          b2Vec2 cA = clipPoint + (radiusA - b2Math.b2Dot(ref clipMinusPlane' ref normal)) * normal;                          b2Vec2 cB = clipPoint - radiusB * normal;                          points[i] = 0.5f * (cA + cB);                      }  #else                      float normalx = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;                      float normaly = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;                        normal.x = normalx;                      normal.y = normaly;                        float planePointx = (xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y) + xfA.p.x;                      float planePointy = (xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y) + xfA.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfB.q.c * localPoint.x - xfB.q.s * localPoint.y) + xfB.p.x;                          float clipPointy = (xfB.q.s * localPoint.x + xfB.q.c * localPoint.y) + xfB.p.y;                            float clipMinusPlanex = clipPointx - planePointx;                          float clipMinusPlaney = clipPointy - planePointy;                            float d = clipMinusPlanex * normalx + clipMinusPlaney * normaly;                            float cAx = clipPointx + (radiusA - d) * normalx;                          float cAy = clipPointy + (radiusA - d) * normaly;                            float cBx = clipPointx - radiusB * normalx;                          float cBy = clipPointy - radiusB * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }  #endif                  }                  break;                    case b2ManifoldType.e_faceB:                  {  #if false                      normal = b2Math.b2Mul(ref xfB.q' ref manifold.localNormal);                      b2Vec2 planePoint = b2Math.b2Mul(ref xfB' ref manifold.localPoint);                                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          b2Vec2 clipPoint = b2Math.b2Mul(ref xfA' ref manifold.points[i].localPoint);                          b2Vec2 tmp = b2Vec2.Zero;                          tmp.x = clipPoint.x - planePoint.x;                          tmp.y = clipPoint.y - planePoint.y;                          // b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(clipPoint - planePoint' normal)) * normal;                           b2Vec2 cB = clipPoint + (radiusB - b2Math.b2Dot(ref tmp' ref normal)) * normal;                          b2Vec2 cA = clipPoint - radiusA * normal;                          points[i] = 0.5f * (cA + cB);                      }                                        // Ensure normal points from A to B.                      normal = -normal;  #else                      float normalx = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;                      float normaly = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;                        float planePointx = (xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y) + xfB.p.x;                      float planePointy = (xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y) + xfB.p.y;                        for (int i = 0; i < manifold.pointCount; ++i)                      {                          var localPoint = manifold.points[i].localPoint;                            float clipPointx = (xfA.q.c * localPoint.x - xfA.q.s * localPoint.y) + xfA.p.x;                          float clipPointy = (xfA.q.s * localPoint.x + xfA.q.c * localPoint.y) + xfA.p.y;                            float distx = clipPointx - planePointx;                          float disty = clipPointy - planePointy;                            var d = (distx * normalx + disty * normaly);                            float cBx = clipPointx + (radiusB - d) * normalx;                          float cBy = clipPointy + (radiusB - d) * normaly;                            float cAx = clipPointx - radiusA * normalx;                          float cAy = clipPointy - radiusA * normaly;                            b2Vec2 p;                          p.x = 0.5f * (cAx + cBx);                          p.y = 0.5f * (cAy + cBy);                            points[i] = p;                      }                        // Ensure normal points from A to B.                      normal.x = -normalx;                      normal.y = -normaly;  #endif                  }                      break;              }
