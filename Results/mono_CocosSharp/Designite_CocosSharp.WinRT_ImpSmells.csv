Implementation smell,Namespace,Class,File,Method,Description
Long Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchTouchEvent,The method has 176 lines of code.
Long Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithString,The method has 129 lines of code.
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchTouchEvent,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,VisitTarget,Cyclomatic complexity of the method is 12
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchEventToListeners,Cyclomatic complexity of the method is 13
Complex Method,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\actions\CCActionManager.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,InternalLoadFont,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithString,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,Cyclomatic complexity of the method is 9
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 5 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quads
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 6 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quadCount' quads
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CubicBezier,The method has 5 parameters. Parameters: a' b' c' d' t
Long Parameter List,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The method has 5 parameters. Parameters: leftButton' upButton' rightButton' downButton' player
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawIndexedPrimitives,The method has 7 parameters. Parameters: primitiveType' vertexData' vertexOffset' numVertices' indexData' indexOffset' primitiveCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawRawBuffer,The method has 6 parameters. Parameters: vertexBuffer' vStart' vCount' indexBuffer' iStart' iCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' colorFormat' depthFormat' usage
Long Parameter List,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,CCTexture2D,The method has 5 parameters. Parameters: pixelsWide' pixelsHigh' pixelFormat' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,CCTexture2D,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithRawData,The method has 6 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithRawData,The method has 7 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' ContentSizeInPixelsIn
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithString,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,LoadRawData,The method has 5 parameters. Parameters: data' width' height' pixelFormat' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,AddRawImage,The method has 7 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,AddRawImage,The method has 8 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap' contentSize
Long Identifier,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,,The length of the parameter AutorepeatIncreaseTimeIncrement is 31.
Long Identifier,CocosSharp,CCMacros,C:\repos\mono_CocosSharp\src\predefine\CCMacros.cs,,The length of the parameter CCDirectorStatsUpdateIntervalInSeconds is 38.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,GetListenerID,The length of the statement  "                // Touch listener is very special' it contains two kinds of listeners' EventListenerTouchOneByOne and EventListenerTouchAllAtOnce. " is 130.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "            Debug.Assert(fixedPriority != 0' "0 priority is forbidden for fixed priority since it's used for scene graph based priority."); " is 127.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "                CCLog.Log("-----  Add > --  Available > " + listener.IsAvailable + " ------{0}------{1}---------"' listener' listener.SceneGraphPriority); " is 138.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' nodePriorityMap[l.SceneGraphPriority]' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 244.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            //                    CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' -1' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 231.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "                return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound)); " is 141.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "            return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range); " is 128.
Long Statement,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The length of the statement  "            if (leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released) " is 192.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start' count); " is 124.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuadsBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2); " is 128.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CreateRenderTarget,The length of the statement  "            return new RenderTarget2D(graphicsDevice' width' height' false' (SurfaceFormat)colorFormat' (DepthFormat)depthFormat' 0' (RenderTargetUsage)usage); " is 147.
Long Statement,CocosSharp,CCVertexBuffer<T>,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(T)' data.Capacity' (BufferUsage)usage); " is 129.
Long Statement,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage); " is 145.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,Write,The length of the statement  "            writer.WriteDocType("plist"' "-//Apple Computer//DTD PLIST 1.0//EN"' "http://www.apple.com/DTDs/PropertyList-1.0.dtd"' null); " is 125.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryAsciiString,The length of the statement  "			return buffer.Count > 0 ? new PlistString(Encoding.UTF8.GetString(buffer.ToArray()' 0' buffer.Count)) : new PlistString(string.Empty); " is 134.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\support\CCUserDefault.cs,CreateXMLFile,The length of the statement  "            using (StreamWriter writeFile = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage))) " is 149.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\support\CCUserDefault.cs,Flush,The length of the statement  "    		using (StreamWriter stream = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage)))  " is 146.
Long Statement,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithRawData,The length of the statement  "            InitWithRawData(data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' new CCSize(pixelsWide' pixelsHigh)); " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,GenerateMipmap,The length of the statement  "                var target = new RenderTarget2D(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' PixelsWide' PixelsHigh' true' (SurfaceFormat)PixelFormat' " is 140.
Long Statement,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,AddImageAsync,The length of the statement  "                dataAsyncLoadedImages.Add(new DataAsyncStruct() { Data = data' AssetName = assetName' Format = format  ' Action = action}); " is 123.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The conditional expression  "leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released"  is complex.
Complex Conditional,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The conditional expression  "name == "key" || name == "integer" || name == "real" || name == "string""  is complex.
Complex Conditional,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,GetScissorRasterizerState,The conditional expression  "state.ScissorTestEnable == scissorEnabled &&                      currentState.CullMode == state.CullMode &&                      currentState.DepthBias == state.DepthBias &&                      currentState.FillMode == state.FillMode &&                      currentState.MultiSampleAntiAlias == state.MultiSampleAntiAlias &&                      currentState.SlopeScaleDepthBias == state.SlopeScaleDepthBias"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,Dispose,The conditional expression  "disposing && texture2D != null && !texture2D.IsDisposed && !managed"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "(data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d)"  is complex.
Virtual Method Call from Constructor,CocosSharp,CCRenderCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCRenderCommand.cs,CCRenderCommand,The constructor "CCRenderCommand" calls a virtual method "GenerateFlags".
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithStream,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,InitWithFile,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,Load,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,GetAssetStream,The method has an empty catch block.
Magic Number,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,StartAutorepeat,The following statement contains a magic number: TextFieldInFocus.Schedule(Repeater' AutorepeatDeltaTime' CCSchedulePriority.RepeatForever' AutorepeatDeltaTime * 3);
Magic Number,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,Repeater,The following statement contains a magic number: if ((autorepeatCount < AutorepeatIncreaseTimeIncrement) && (autorepeatCount % 3) != 0)                  return;
Magic Number,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,CCEventDispatcher,The following statement contains a magic number: toBeAddedListeners = new List<CCEventListener>(50);
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventTouch,C:\repos\mono_CocosSharp\src\events\CCEventTouch.cs,CCEventTouch,The following statement contains a magic number: Touches = new List<CCTouch> (5);
Magic Number,CocosSharp,ArrayPool<T>,C:\repos\mono_CocosSharp\src\platform\CCArrayPool.cs,Create,The following statement contains a magic number: if (pow)              {                  var l = 2;                  while (l < length)                   {                      l <<= 1;                  }                  length = l;              }
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: currentBatchedQuads = new CCRawList<CCV3F_C4B_T2F_Quad>(256' false);
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: quadCommands = new CCRawList<CCQuadCommand>(256' false);
Magic Number,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,GenerateMaterialId,The following statement contains a magic number: materialId = (uint)textureId << 12 | (uint)BlendType.GetHashCode();
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\actions\CCActionManager.cs,Update,The following statement contains a magic number: while (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\actions\CCActionManager.cs,RemoveAllActions,The following statement contains a magic number: if (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCV3F_T2F,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CCV3F_T2F,The following statement contains a magic number: var elements = new[]              {                  new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                  new VertexElement(12' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)              };
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<ushort>(GridSize.X * GridSize.Y * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = GridSize.X * GridSize.Y * 6;
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l2 = new CCVertex3F[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex2 = new CCPoint[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer = new CCVertexBuffer<CCV3F_T2F>(numQuads * 4' CCBufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer.Count = numQuads * 4;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<short>(numQuads * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = numQuads * 6;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: time = time * 2;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: if (time < 0.5f)              {                  time = time * 2;                  return (1 - BounceOut(1 - time)) * 0.5f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: return BounceOut(time * 2 - 1) * 0.5f + 0.5f;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToDegrees,The following statement contains a magic number: return (float)(radians * 57.295779513082320876798154814105);
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToRadians,The following statement contains a magic number: return (float)(degrees * 0.017453292519943295769236907684886);
Magic Number,CocosSharp,CCRandom,C:\repos\mono_CocosSharp\src\Math\CCRandom.cs,Float_Minus1_1,The following statement contains a magic number: return (float)(_random.NextDouble() * 2.0 - 1.0);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCDictMaker,C:\repos\mono_CocosSharp\src\platform\CCDictMaker.cs,ArrayWithContentsOfFile,The following statement contains a magic number: TextHandler(parser' System.Text.UTF8Encoding.UTF8.GetBytes("root")' 4);
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CCDrawManager,The following statement contains a magic number: matrixStack = new Matrix[100];
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskLayer + 1 == 8) //DepthFormat.Depth24Stencil8              {                  if (maskOnceLog)                  {                      CCLog.Log(                          @"Nesting more than 8 stencils is not supported.                           Everything will be drawn without stencil for this node and its childs."                          );                      maskOnceLog = false;                  }                  return false;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskState.AlphaTreshold < 1f)              {                  AlphaTestEffect.AlphaFunction = CompareFunction.Greater;                  AlphaTestEffect.ReferenceAlpha = (byte)(255 * maskState.AlphaTreshold);                    PushEffect(AlphaTestEffect);              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: while (tmp.Capacity < elementCount)              {                  tmp.Capacity = tmp.Capacity * 2;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: tmp.Count = elementCount * 4;
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\platform\CCDrawManager.cs,ReinitResource,The following statement contains a magic number: vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: byte[] magicHeader = new byte[8];
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: data.Read(magicHeader' 0' 8);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: if (BitConverter.ToInt64 (magicHeader' 0) == 3472403351741427810) {  				using (BinaryReader reader = new BinaryReader(data))  				{  					byte[] plistData = reader.ReadBytes((int) reader.BaseStream.Length);  					Root = ReadBinary(plistData);  				}    			} else {  				//allow DTD but not try to resolve it from web  				var settings = new XmlReaderSettings () {  					DtdProcessing = DtdProcessing.Ignore'  					//ProhibitDtd = false'  #if !NETFX_CORE  					XmlResolver = null'  #endif  				};  				using (var reader = XmlReader.Create(data' settings))  					LoadFromXml (reader);  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: offsetTableBytes = bList.GetRange((int)offsetTableOffset' bList.Count - (int)offsetTableOffset - 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseOffsetTable,The following statement contains a magic number: for (int i = 0; i < offsetTableBytes.Count; i += offsetByteSize)  			{  				byte[] buffer = offsetTableBytes.GetRange(i' offsetByteSize).ToArray();  				Array.Reverse(buffer);  				offsetTable.Add(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,GetCount,The following statement contains a magic number: if (headerByteTrail < 15)  			{  				count = headerByteTrail;  				newBytePosition = bytePosition + 1;  			}  			else  				count = ((PlistInteger)ParseBinaryInt(bytePosition + 1' out newBytePosition)).AsInt;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinary,The following statement contains a magic number: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryDate,The following statement contains a magic number: byte[] buffer = objectTable.GetRange(headerPosition + 1' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: return new PlistInteger(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: return new PlistReal((float)BitConverter.ToDouble(RegulateNullBytes(buffer' 8)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: charCount = charCount * 2;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: for (int i = 0; i < charCount; i+=2)  			{  				one = objectTable.GetRange(charStartPosition+i'1)[0];  				two = objectTable.GetRange(charStartPosition + i+1' 1)[0];    				if (BitConverter.IsLittleEndian)  				{  					buffer[i] = two;  					buffer[i + 1] = one;  				}  				else  				{  					buffer[i] = one;  					buffer[i + 1] = two;  				}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ConvertFromAppleTimeStamp,The following statement contains a magic number: DateTime origin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVertices = new CCV3F_C4B[bufferSize - bufferSize % 3];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVertices = new CCV3F_C4B[bufferSize - bufferSize % 2];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (triangleVerts.Count > 0)              {                  var triangle = triangleVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangle' 0' triangle.Length / 3);                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (lineVerts.Count > 0)              {                  var line = lineVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.LineList' line' 0' line.Length / 2);              }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,Push,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,Add,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,Insert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,FastInsert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				//Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[count] = Elements[index];  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: R = (byte)CCMathHelper.Clamp(red * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: G = (byte)CCMathHelper.Clamp(green * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: B = (byte)CCMathHelper.Clamp(blue * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: A = (byte)CCMathHelper.Clamp(alpha * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCV3F_C4B,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCV3F_C4B,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCV3F_C4B_T2F,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F_Quad,C:\repos\mono_CocosSharp\src\predefine\CCTypes.cs,CCV3F_C4B_T2F_Quad,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\support\CCUtils.cs,SplitWithForm,The following statement contains a magic number: do  			{  				if (pStr == null)  				{  					break;  				}  				  				// string is empty  				string content = pStr;  				if (content.Length == 0)  				{  					break;  				}  				  				int nPosLeft = content.IndexOf('{');  				int nPosRight = content.IndexOf('}');  				  				// don't have '{' and '}'  				if (nPosLeft == -1 || nPosRight == -1)  				{  					break;  				}  				// '}' is before '{'  				if (nPosLeft > nPosRight)  				{  					break;  				}  				  				string pointStr = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);  				// nothing between '{' and '}'  				if (pointStr.Length == 0)  				{  					break;  				}  				  				int nPos1 = pointStr.IndexOf('{');  				int nPos2 = pointStr.IndexOf('}');  				// contain '{' or '}'   				if (nPos1 != -1 || nPos2 != -1) break;  				  				Split(pointStr' "'"' strs);  				if (strs.Count != 2 || strs[0].Length == 0 || strs[1].Length == 0)  				{  					strs.Clear();  					break;  				}  				  				bRet = true;  			} while (false);
Magic Number,CocosSharp,CCRectConverter,C:\repos\mono_CocosSharp\src\support\Converters\CCRectConverter.cs,CCRectFromString,The following statement contains a magic number: do              {                  if (rectSpec == null)                  {                      break;                  }                    string content = rectSpec;                    // find the first '{' and the third '}'                  int nPosLeft = content.IndexOf('{');                  int nPosRight = content.IndexOf('}');                  for (int i = 1; i < 3; ++i)                  {                      if (nPosRight == -1)                      {                          break;                      }                      nPosRight = content.IndexOf('}'' nPosRight + 1);                  }                  if (nPosLeft == -1 || nPosRight == -1)                  {                      break;                  }                  content = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);                  int nPointEnd = content.IndexOf('}');                  if (nPointEnd == -1)                  {                      break;                  }                  nPointEnd = content.IndexOf('''' nPointEnd);                  if (nPointEnd == -1)                  {                      break;                  }                    // get the point string and size string                  string pointStr = content.Substring(0' nPointEnd);                  string sizeStr = content.Substring(nPointEnd + 1);                  //' content.Length - nPointEnd                  // split the string with '''                  List<string> pointInfo = new List<string>();                    if (!CCUtils.SplitWithForm(pointStr' pointInfo))                  {                      break;                  }                  List<string> sizeInfo = new List<string>();                  if (!CCUtils.SplitWithForm(sizeStr' sizeInfo))                  {                      break;                  }                    float x = CCUtils.CCParseFloat(pointInfo[0]);                  float y = CCUtils.CCParseFloat(pointInfo[1]);                  float width = CCUtils.CCParseFloat(sizeInfo[0]);                  float height = CCUtils.CCParseFloat(sizeInfo[1]);                    result = new CCRect(x' y' width' height);              } while (false);
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: var m = new float[16];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[4] = t.C;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[12] = t.Tx;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[5] = t.D;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[13] = t.Ty;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.C = m[4];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Tx = m[12];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.D = m[5];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Ty = m[13];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var data = new byte[8];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var dataLen = stream.Read(data' 0' 8);
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 3)              {                  if (data[0] == 0x47 && data[1] == 0x49 && data[1] == 0x46)                  {                      return CCImageFormat.Gif;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if ((data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d))                  {                      return CCImageFormat.Tiff;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if (data[0] == 0xff && data[1] == 0xd8)                  {                      return CCImageFormat.Jpg;                  }              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: CCLog.Log("{0} textures' for {1} KB ({2:00.00} MB)"' count' total / 1024' total / (1024f * 1024f));
Missing Default,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case VirtualKey.Escape:                      e.Handled = true;                      DetachWithIME();                      break;              }
Missing Default,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,ConvertKey,The following switch statement is missing a default case: switch (key)              {                    case CCKeys.A: return ConvertToChar('a'' shift' capsLock);                  case CCKeys.B: return ConvertToChar('b'' shift' capsLock);                  case CCKeys.C: return ConvertToChar('c'' shift' capsLock);                  case CCKeys.D: return ConvertToChar('d'' shift' capsLock);                  case CCKeys.E: return ConvertToChar('e'' shift' capsLock);                  case CCKeys.F: return ConvertToChar('f'' shift' capsLock);                  case CCKeys.G: return ConvertToChar('g'' shift' capsLock);                  case CCKeys.H: return ConvertToChar('h'' shift' capsLock);                  case CCKeys.I: return ConvertToChar('i'' shift' capsLock);                  case CCKeys.J: return ConvertToChar('j'' shift' capsLock);                  case CCKeys.K: return ConvertToChar('k'' shift' capsLock);                  case CCKeys.L: return ConvertToChar('l'' shift' capsLock);                  case CCKeys.M: return ConvertToChar('m'' shift' capsLock);                  case CCKeys.N: return ConvertToChar('n'' shift' capsLock);                  case CCKeys.O: return ConvertToChar('o'' shift' capsLock);                  case CCKeys.P: return ConvertToChar('p'' shift' capsLock);                  case CCKeys.Q: return ConvertToChar('q'' shift' capsLock);                  case CCKeys.R: return ConvertToChar('r'' shift' capsLock);                  case CCKeys.S: return ConvertToChar('s'' shift' capsLock);                  case CCKeys.T: return ConvertToChar('t'' shift' capsLock);                  case CCKeys.U: return ConvertToChar('u'' shift' capsLock);                  case CCKeys.V: return ConvertToChar('v'' shift' capsLock);                  case CCKeys.W: return ConvertToChar('w'' shift' capsLock);                  case CCKeys.X: return ConvertToChar('x'' shift' capsLock);                  case CCKeys.Y: return ConvertToChar('y'' shift' capsLock);                  case CCKeys.Z: return ConvertToChar('z'' shift' capsLock);                    case CCKeys.D0: return (shift) ? ')' : '0';                  case CCKeys.D1: return (shift) ? '!' : '1';                  case CCKeys.D2: return (shift) ? '@' : '2';                  case CCKeys.D3: return (shift) ? '#' : '3';                  case CCKeys.D4: return (shift) ? '$' : '4';                  case CCKeys.D5: return (shift) ? '%' : '5';                  case CCKeys.D6: return (shift) ? '^' : '6';                  case CCKeys.D7: return (shift) ? '&' : '7';                  case CCKeys.D8: return (shift) ? '*' : '8';                  case CCKeys.D9: return (shift) ? '(' : '9';                    case CCKeys.Add: return '+';                  case CCKeys.Divide: return '/';                  case CCKeys.Multiply: return '*';                  case CCKeys.Subtract: return '-';                    case CCKeys.Space: return ' ';                  case CCKeys.Enter: return '\n';                    case CCKeys.Decimal: if (numLock && !shift) return '.'; break;                  case CCKeys.NumPad0: if (numLock && !shift) return '0'; break;                  case CCKeys.NumPad1: if (numLock && !shift) return '1'; break;                  case CCKeys.NumPad2: if (numLock && !shift) return '2'; break;                  case CCKeys.NumPad3: if (numLock && !shift) return '3'; break;                  case CCKeys.NumPad4: if (numLock && !shift) return '4'; break;                  case CCKeys.NumPad5: if (numLock && !shift) return '5'; break;                  case CCKeys.NumPad6: if (numLock && !shift) return '6'; break;                  case CCKeys.NumPad7: if (numLock && !shift) return '7'; break;                  case CCKeys.NumPad8: if (numLock && !shift) return '8'; break;                  case CCKeys.NumPad9: if (numLock && !shift) return '9'; break;                    case CCKeys.OemBackslash: return shift ? '|' : '\\';                  case CCKeys.OemCloseBrackets: return shift ? '}' : ']';                  case CCKeys.OemComma: return shift ? '<' : ''';                  case CCKeys.OemMinus: return shift ? '_' : '-';                  case CCKeys.OemOpenBrackets: return shift ? '{' : '[';                  case CCKeys.OemPeriod: return shift ? '>' : '.';                  case CCKeys.OemPipe: return shift ? '|' : '\\';                  case CCKeys.OemPlus: return shift ? '+' : '=';                  case CCKeys.OemQuestion: return shift ? '?' : '/';                  case CCKeys.OemQuotes: return shift ? '"' : '\'';                  case CCKeys.OemSemicolon: return shift ? ':' : ';';                  case CCKeys.OemTilde: return shift ? '~' : '`';              }
Missing Default,CocosSharp,CCOGLES,C:\repos\mono_CocosSharp\src\platform\CCOGLES.cs,GetXNABlend,The following switch statement is missing a default case: switch (glBlend)              {                  case GL_ZERO:                      return Blend.Zero;                  case GL_ONE:                      return Blend.One;                  case GL_SRC_COLOR:                      return Blend.SourceColor;                  case GL_ONE_MINUS_SRC_COLOR:                      return Blend.InverseSourceColor;                  case GL_SRC_ALPHA:                      return Blend.SourceAlpha;                  case GL_ONE_MINUS_SRC_ALPHA:                      return Blend.InverseSourceAlpha;                  case GL_DST_ALPHA:                      return Blend.DestinationAlpha;                  case GL_ONE_MINUS_DST_ALPHA:                      return Blend.InverseDestinationAlpha;                    /* BlendingFactorSrc */                  /*      GL_ZERO */                  /*      GL_ONE */                  case GL_DST_COLOR:                      return Blend.DestinationColor;                  case GL_ONE_MINUS_DST_COLOR:                      return Blend.InverseDestinationColor;                  case GL_SRC_ALPHA_SATURATE:                      return Blend.SourceAlphaSaturation;              }
Missing Default,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\platform\PList\PlistDocument.cs,ParseBinary,The following switch statement is missing a default case: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Missing Default,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\support\CCUserDefault.cs,ParseXMLFile,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.Element:  						key = reader.Name;  						break;  					case XmlNodeType.Text:  						values.Add(key' reader.Value);  						break;  					case XmlNodeType.XmlDeclaration:  					case XmlNodeType.ProcessingInstruction:  						break;  					case XmlNodeType.Comment:  						break;  					case XmlNodeType.EndElement:  						break;  					}
