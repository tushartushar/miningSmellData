Implementation smell,Namespace,Class,File,Method,Description
Long Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchTouchEvent,The method has 176 lines of code.
Long Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The method has 116 lines of code.
Long Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The method has 116 lines of code.
Long Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,The method has 123 lines of code.
Long Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,LayoutLabel,The method has 168 lines of code.
Long Method,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The method has 114 lines of code.
Long Method,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The method has 141 lines of code.
Long Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The method has 115 lines of code.
Long Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,The method has 129 lines of code.
Long Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_fast,The method has 100 lines of code.
Long Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,The method has 129 lines of code.
Long Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The method has 149 lines of code.
Long Method,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method has 502 lines of code.
Long Method,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method has 357 lines of code.
Long Method,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The method has 243 lines of code.
Long Method,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The method has 174 lines of code.
Long Method,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The method has 201 lines of code.
Complex Method,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchTouchEvent,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,VisitTarget,Cyclomatic complexity of the method is 12
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,Cyclomatic complexity of the method is 13
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,Cyclomatic complexity of the method is 22
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Unschedule,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,PauseAllTargets,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,Cyclomatic complexity of the method is 22
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Unschedule,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,PauseAllTargets,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,UpdateTransform,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,LayoutLabel,Cyclomatic complexity of the method is 21
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCLayer,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayer.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCNodeGrid,C:\repos\mono_CocosSharp\src\Nodes\Other\CCNodeGrid.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,UpdateGravityParticles,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,UpdateRadialParticles,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMaskedSprite,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCMaskedSprite.cs,CollidesWith,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadAppleDictionary,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseMultilineShape,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,SetTileGID,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 15
Complex Method,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 21
Complex Method,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,CocosSharp,CCOrbitCamera,C:\repos\mono_CocosSharp\src\Actions\Camera\CCOrbitCamera.cs,CCOrbitCamera,The method has 7 parameters. Parameters: t' radius' deltaRadius' angleZ' deltaAngleZ' angleX' deltaAngleX
Long Parameter List,CocosSharp,CCRipple3D,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCRipple3D.cs,CCRipple3D,The method has 6 parameters. Parameters: duration' gridSize' position' radius' waves' amplitude
Long Parameter List,CocosSharp,CCTwirl,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCTwirl.cs,CCTwirl,The method has 5 parameters. Parameters: duration' gridSize' position' twirls' amplitude
Long Parameter List,CocosSharp,CCWaves,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,CCWaves,The method has 6 parameters. Parameters: duration' gridSize' waves' amplitude' horizontal' vertical
Long Parameter List,CocosSharp,CCActionTween,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCActionTween.cs,CCActionTween,The method has 5 parameters. Parameters: duration' key' from' to' tweenAction
Long Parameter List,CocosSharp,CCTimer,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,CCTimer,The method has 6 parameters. Parameters: scheduler' target' selector' seconds' repeat' delay
Long Parameter List,CocosSharp,CCTimer,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,CCTimer,The method has 6 parameters. Parameters: scheduler' target' selector' seconds' repeat' delay
Long Parameter List,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Schedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Schedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCAffineTransform,C:\repos\mono_CocosSharp\src\Math\CCAffineTransform.cs,CCAffineTransform,The method has 7 parameters. Parameters: a' b' c' d' tx' ty' tz
Long Parameter List,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,LineIntersect,The method has 6 parameters. Parameters: A' B' C' D' S' T
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Transform,The method has 6 parameters. Parameters: sourceArray' sourceIndex' matrix' destinationArray' destinationIndex' length
Long Parameter List,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,AddLazySchedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,lazySchedule,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,lazySchedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-Renderer81.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-Renderer81.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-Renderer81.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' size' alignment' imageOffset
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 6 parameters. Parameters: str' fntFile' size' alignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' size' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' dimensions' hAlignment' vAlignement
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' dimensions' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' size' dimensions' labelFormat
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 6 parameters. Parameters: str' fntFile' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' size' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,InitBMFont,The method has 7 parameters. Parameters: theString' fntFile' dimensions' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,InitSpriteFont,The method has 7 parameters. Parameters: theString' fntFile' fontSize' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabelAtlas.cs,CCLabelAtlas,The method has 5 parameters. Parameters: label' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabelAtlas.cs,CCLabelAtlas,The method has 5 parameters. Parameters: label' texture' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCMenuItemLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelAtlas,The method has 7 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap' updatable' target
Long Parameter List,CocosSharp,CCMenuItemLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelAtlas,The method has 5 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidArc,The method has 5 parameters. Parameters: pos' radius' startAngle' sweepAngle' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSegment,The method has 5 parameters. Parameters: from' to' radius' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSegment,The method has 5 parameters. Parameters: from' to' radius' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawLine,The method has 5 parameters. Parameters: from' to' lineWidth' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The method has 6 parameters. Parameters: x' y' width' height' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipticalArc,The method has 6 parameters. Parameters: arcRect' lambda1' lambda2' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipticalArc,The method has 9 parameters. Parameters: x' y' width' height' lambda1' lambda2' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCubicBezier,The method has 7 parameters. Parameters: origin' control1' control2' destination' segments' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawQuadBezier,The method has 6 parameters. Parameters: origin' control' destination' segments' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method has 6 parameters. Parameters: verts' count' fillColor' borderWidth' borderColor' closePolygon
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method has 6 parameters. Parameters: verts' count' fillColor' borderWidth' borderColor' closePolygon
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The method has 11 parameters. Parameters: start' x' y' width' height' startAngle' endAngle' antialiasing' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The method has 11 parameters. Parameters: x' y' width' height' startAngle' sweepAngle' convert_units' antialiasing' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,StringData,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,StringData,The method has 5 parameters. Parameters: x' y' s' args' color
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' path
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The method has 5 parameters. Parameters: fade' minSegIn' strokeIn' color' texture
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineIntersect,The method has 9 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Dx' Dy' T
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The method has 5 parameters. Parameters: points' stroke' vertices' offset' nuPoints
Long Parameter List,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,CCRenderTexture,The method has 5 parameters. Parameters: contentSize' textureSizeInPixels' colorFormat' depthFormat' usage
Long Parameter List,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,BeginWithClear,The method has 6 parameters. Parameters: r' g' b' a' depth' stencil
Long Parameter List,CocosSharp,CCSpriteFrame,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrame.cs,CCSpriteFrame,The method has 5 parameters. Parameters: contentSize' texture' textureRectInPxls' rotated' offsetInPxls
Long Parameter List,CocosSharp,CCSpriteFrame,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrame.cs,CCSpriteFrame,The method has 6 parameters. Parameters: contentSize' texture' textureRectInPxls' originalSizeInPxls' rotated' offsetInPxls
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 5 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 6 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' labelFormat
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 6 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' vAlignment
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 7 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' vAlignment' labelFormat
Long Parameter List,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,CCTileMapLayer,The method has 5 parameters. Parameters: tileSetInfos' layerInfo' mapInfo' layerSize' totalNumberOfTiles
Long Parameter List,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,CCTileMapLayer,The method has 6 parameters. Parameters: tileSetInfos' layerInfo' mapInfo' layerSize' totalNumberOfTiles' tileCapacity
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawIndexedPrimitives,The method has 7 parameters. Parameters: primitiveType' vertexData' vertexOffset' numVertices' indexData' indexOffset' primitiveCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawRawBuffer,The method has 6 parameters. Parameters: vertexBuffer' vStart' vCount' indexBuffer' iStart' iCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' colorFormat' depthFormat' usage
Long Parameter List,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The method has 5 parameters. Parameters: leftButton' upButton' rightButton' downButton' player
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 5 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quads
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 6 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quadCount' quads
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CubicBezier,The method has 5 parameters. Parameters: a' b' c' d' t
Long Parameter List,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,CCTexture2D,The method has 5 parameters. Parameters: pixelsWide' pixelsHigh' pixelFormat' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,CCTexture2D,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The method has 6 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The method has 7 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' ContentSizeInPixelsIn
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,LoadRawData,The method has 5 parameters. Parameters: data' width' height' pixelFormat' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddRawImage,The method has 7 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddRawImage,The method has 8 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap' contentSize
Long Parameter List,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,CocosSharp.Compression.Zlib,Config,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,CocosSharp.Compression.Zlib,StaticTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter cameraCenterPositionWorldspaceIn is 32.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,UpdatePerspectiveCameraTargetBounds,The length of the parameter targetVisibleBoundsWorldspaceIn is 31.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,UpdatePerspectiveCameraTargetBounds,The length of the parameter targetVisibleDimensionsWorldspaceIn is 35.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter defaultNearAndFarOrthoClipping is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter defaultNearAndFarPerspClipping is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter orthographicViewSizeWorldspace is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter nearAndFarOrthographicZClipping is 31.
Long Identifier,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-Renderer81.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,,The length of the parameter ParticleStartSizeEqualToEndSize is 31.
Long Identifier,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,,The length of the parameter ParticleStartRadiusEqualToEndRadius is 35.
Long Identifier,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,,The length of the parameter SceneNodeContainerToBeModified is 30.
Long Identifier,CocosSharp,CCSprite,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSprite.cs,,The length of the parameter unflippedOffsetPositionFromCenter is 33.
Long Identifier,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,,The length of the parameter activeTileAnimationActionStates is 31.
Long Identifier,CocosSharp,CCMacros,C:\repos\mono_CocosSharp\src\Predefine\CCMacros.cs,,The length of the parameter CCDirectorStatsUpdateIntervalInSeconds is 38.
Long Statement,CocosSharp,CCCallFuncNState,C:\repos\mono_CocosSharp\src\Actions\Instants\callfunc\CCCallFuncN.cs,Execute,The length of the statement  "            //    CCScriptEngineManager::sharedManager()->getScriptEngine()->executeFunctionWithobject(m_nScriptHandler' m_pTarget' "CCNode"); " is 130.
Long Statement,CocosSharp,CCAnimateState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCAnimate.cs,Update,The length of the statement  "                        //TODO: [[NSNotificationCenter defaultCenter] postNotificationName:CCAnimationFrameDisplayedNotification object:target_ userInfo:dict]; " is 135.
Long Statement,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.cs,UpdateViewport,The length of the statement  "            defaultViewMatrix = XnaMatrix.CreateLookAt(new CCPoint3(center' 300.0f).XnaVector' new CCPoint3(center' 0.0f).XnaVector' Vector3.Up); " is 133.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,GetListenerID,The length of the statement  "                // Touch listener is very special' it contains two kinds of listeners' EventListenerTouchOneByOne and EventListenerTouchAllAtOnce. " is 130.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "            Debug.Assert(fixedPriority != 0' "0 priority is forbidden for fixed priority since it's used for scene graph based priority."); " is 127.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "                CCLog.Log("-----  Add > --  Available > " + listener.IsAvailable + " ------{0}------{1}---------"' listener' listener.SceneGraphPriority); " is 138.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' nodePriorityMap[l.SceneGraphPriority]' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 244.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            //                    CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' -1' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 231.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunAction,The length of the statement  "            return ActionManager != null ? ActionManager.AddAction(action' this' !IsRunning) : AddLazyAction(action' this' !IsRunning); " is 123.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActionAsync,The length of the statement  "            state = ActionManager != null ? ActionManager.AddAction (asyncAction' this' !IsRunning) : AddLazyAction(asyncAction' this' !IsRunning); " is 135.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActions,The length of the statement  "            return ActionManager != null ? ActionManager.AddAction (action' this' !IsRunning) : AddLazyAction(action' this' !IsRunning); " is 124.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActionsAsync,The length of the statement  "            state = ActionManager != null ? ActionManager.AddAction (asyncAction' this' !IsRunning) : AddLazyAction(asyncAction' this' !IsRunning); " is 135.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,AttachSchedules,The length of the statement  "                        scheduler.Schedule(schedule.Selector' schedule.Target' schedule.Interval' schedule.Repeat' schedule.Delay' schedule.Paused); " is 124.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1'4'3'2 spacing=0'0 outline=0 " is 131.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0'0'0'0 spacing=1'1 " is 122.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseImageFileName,The length of the statement  "                throw (new ContentLoadException("Invalid page ID for FNT descriptor. Line=" + line + "' value=" + value + "' indices=" + index + "'" + index2)); " is 144.
Long Statement,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,SaveToFile,The length of the statement  "                //// Use InitializeFromFilename to write to a file. If there is need to write inside the memory' use InitializeFromMemory.  " is 122.
Long Statement,CocosSharp,CCLayer,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayer.cs,ScreenToWorldspace,The length of the statement  "            CCPoint worldSizeRatio = new CCPoint(size.Width / viewportRectInPixels.Size.Width' size.Height / viewportRectInPixels.Size.Height); " is 131.
Long Statement,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The length of the statement  "            var color = new Color(DisplayedColor.R / 255.0f' DisplayedColor.G / 255.0f' DisplayedColor.B / 255.0f' DisplayedOpacity / 255.0f); " is 130.
Long Statement,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,RenderBatch,The length of the statement  "                    DrawManager.XnaGraphicsDevice.SamplerStates[0] = textureExists ? geometryPacket.Texture.SamplerState : SamplerState.PointClamp; " is 127.
Long Statement,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The length of the statement  "                vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255); " is 129.
Long Statement,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,InitParticle,The length of the statement  "                particleGrav.TangentialAccel = GravityMode.TangentialAccel + GravityMode.TangentialAccelVar * CCRandom.Float_Minus1_1(); " is 120.
Long Statement,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,OnConfigLoad,The length of the statement  "						CCTextureCache.SharedTextureCache.AddImageAsync(imageBytes' config.TextureName' CCSurfaceFormat.Color' (loadedTexture) => " is 121.
Long Statement,CocosSharp,CCDirector,C:\repos\mono_CocosSharp\src\Nodes\Scenes\CCDirector.cs,PopScene,The length of the statement  "                End(); // This should not happen here b/c we need to capture the current state and just deactivate the game (for Android). " is 122.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: Animation '{0}' found in dictionary without any frames - cannot add to animation cache."' " is 120.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                            "cocos2d: CCAnimationCache: Animation '{0}' refers to frame '%s' which is not currently in the CCSpriteFrameCache. This frame will not be added to the animation."' " is 163.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: None of the frames for animation '{0}' were found in the CCSpriteFrameCache. Animation is not being added to the Animation Cache."' " is 162.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: An animation in your dictionary refers to a frame which is not in the CCSpriteFrameCache. Some or all of the frames for the animation '{0}' may be missing."' " is 188.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion2,The length of the statement  "                        "CocosSharp: CCAnimationCache: Animation '{0}' found in dictionary without any frames - cannot add to animation cache."' " is 120.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion2,The length of the statement  "                            "cocos2d: CCAnimationCache: Animation '{0}' refers to frame '{1}' which is not currently in the CCSpriteFrameCache. This frame will not be added to the animation."' " is 164.
Long Statement,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The length of the statement  "                            "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag"); " is 162.
Long Statement,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The length of the statement  "                throw (new Microsoft.Xna.Framework.Content.ContentLoadException("Failed to load the particle definition file from stream")); " is 124.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadAppleDictionary,The length of the statement  "                    CCLog.Log ("texture {0} rect {1} rotated {2} offset {3}' sourcesize {4}"' name' textureRect' textureRotated' spriteOffset' spriteSourceSize); " is 141.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The length of the statement  "                            "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag"); " is 162.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The length of the statement  "                        new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)' " is 126.
Long Statement,CocosSharp,CCTileMap,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMap.cs,TilesetsForLayer,The length of the statement  "                    short tilesetLastGid = (short)(tilesetIdx < tilesets.Count - 1 ? tilesets[tilesetIdx + 1].FirstGid - 1 : short.MaxValue); " is 121.
Long Statement,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParsePropertyElement,The length of the statement  "                CCLog.Log("CCTileMapInfo: ParsePropertyElement: Parent element is unsupported. Cannot add property named '{0}' with value '{1}'"' " is 129.
Long Statement,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,InitialiseDrawBuffer,The length of the statement  "            CCTileMapDrawBufferManager drawBufferManager = new CCTileMapDrawBufferManager(LayerSize.Row' LayerSize.Column' this' tileSetInfo); " is 130.
Long Statement,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuadAt,The length of the statement  "            if (drawBufferManager.TileSetInfo.FirstGid <= tileGID.Gid && drawBufferManager.TileSetInfo.LastGid >= tileGID.Gid || tileGID.Gid == 0) " is 134.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start' count); " is 124.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2); " is 128.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CreateRenderTarget,The length of the statement  "            return new RenderTarget2D(graphicsDevice' width' height' false' (SurfaceFormat)colorFormat' (DepthFormat)depthFormat' 0' (RenderTargetUsage)usage); " is 147.
Long Statement,CocosSharp,CCVertexBuffer<T>,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(T)' data.Capacity' (BufferUsage)usage); " is 129.
Long Statement,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage); " is 145.
Long Statement,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The length of the statement  "            if (leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released) " is 192.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,Write,The length of the statement  "            writer.WriteDocType("plist"' "-//Apple Computer//DTD PLIST 1.0//EN"' "http://www.apple.com/DTDs/PropertyList-1.0.dtd"' null); " is 125.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryAsciiString,The length of the statement  "			return buffer.Count > 0 ? new PlistString(Encoding.UTF8.GetString(buffer.ToArray()' 0' buffer.Count)) : new PlistString(string.Empty); " is 134.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "                return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound)); " is 141.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "            return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range); " is 128.
Long Statement,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The length of the statement  "                    texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"]; " is 161.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,CreateXMLFile,The length of the statement  "            using (StreamWriter writeFile = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage))) " is 149.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,Flush,The length of the statement  "    		using (StreamWriter stream = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage)))  " is 146.
Long Statement,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The length of the statement  "            InitWithRawData(data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' new CCSize(pixelsWide' pixelsHigh)); " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,GenerateMipmap,The length of the statement  "                var target = new RenderTarget2D(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' PixelsWide' PixelsHigh' true' (SurfaceFormat)PixelFormat' " is 140.
Long Statement,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddImageAsync,The length of the statement  "                dataAsyncLoadedImages.Add(new DataAsyncStruct() { Data = data' AssetName = assetName' Format = format  ' Action = action}); " is 123.
Long Statement,CocosSharp.Compression.Zlib,ZStream,C:\repos\mono_CocosSharp\src\Platform\Zlib\ZStream.cs,FlushPending,The length of the statement  "                //System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.cs,LoadGame,The conditional expression  "viewInitialised && platformInitialised && !gameLoaded && viewCreated != null"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,LineIntersect,The conditional expression  "(A.X == B.X && A.Y == B.Y) || (C.X == D.X && C.Y == D.Y)"  is complex.
Complex Conditional,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,SegmentIntersect,The conditional expression  "LineIntersect(A' B' C' D' ref S' ref T)                  && (S >= 0.0f && S <= 1.0f && T >= 0.0f && T <= 1.0f)"  is complex.
Complex Conditional,CocosSharp,CCRect,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,ContainsPoint,The conditional expression  "point.X >= rect.MinX && point.X <= rect.MaxX && point.Y >= rect.MinY &&                  point.Y <= rect.MaxY"  is complex.
Complex Conditional,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,VisitRenderer,The conditional expression  "triangleVertices.Count > 0                  || lineVertices.Count > 0                   || (spriteFont != null && stringData != null && stringData.Count > 0)"  is complex.
Complex Conditional,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineIntersect,The conditional expression  "(Ax == Bx && Ay == By) || (Cx == Dx && Cy == Dy)"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,updateColors,The conditional expression  "Color.R != PlaceHolderTextColor.R ||                      Color.G != PlaceHolderTextColor.G ||                      Color.B != PlaceHolderTextColor.B ||                      Opacity != PlaceHolderTextColor.A"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,updateColors,The conditional expression  "Color.R != defaultTextColor.R ||                      Color.G != defaultTextColor.G ||                      Color.B != defaultTextColor.B ||                      Opacity != defaultTextColor.A"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,TouchBegan,The conditional expression  "pos.X >= 0 && pos.X < ContentSize.Width && pos.Y >= 0 && pos.Y <= ContentSize.Height"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,TouchEnded,The conditional expression  "pos.X >= 0 && pos.X < ContentSize.Width && pos.Y >= 0 && pos.Y <= ContentSize.Height"  is complex.
Complex Conditional,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The conditional expression  "(MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1)"  is complex.
Complex Conditional,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The conditional expression  "(MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1)"  is complex.
Complex Conditional,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,GetScissorRasterizerState,The conditional expression  "state.ScissorTestEnable == scissorEnabled &&                      currentState.CullMode == state.CullMode &&                      currentState.DepthBias == state.DepthBias &&                      currentState.FillMode == state.FillMode &&                      currentState.MultiSampleAntiAlias == state.MultiSampleAntiAlias &&                      currentState.SlopeScaleDepthBias == state.SlopeScaleDepthBias"  is complex.
Complex Conditional,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The conditional expression  "leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released"  is complex.
Complex Conditional,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The conditional expression  "name == "key" || name == "integer" || name == "real" || name == "string""  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,Dispose,The conditional expression  "disposing && texture2D != null && !texture2D.IsDisposed && !managed"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "(data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d)"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 &&                          (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 ||                  level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) ||                  (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,CocosSharp.Compression.Zlib,ZStream,C:\repos\mono_CocosSharp\src\Platform\Zlib\ZStream.cs,FlushPending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index ||                  dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Virtual Method Call from Constructor,CocosSharp,CCGridActionState,C:\repos\mono_CocosSharp\src\Actions\Grid\CCGridAction.cs,CCGridActionState,The constructor "CCGridActionState" calls a virtual method "Reuse".
Virtual Method Call from Constructor,CocosSharp,CCTileMap,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMap.cs,CCTileMap,The constructor "CCTileMap" calls a virtual method "AddChild".
Virtual Method Call from Constructor,CocosSharp,CCRenderCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCRenderCommand.cs,CCRenderCommand,The constructor "CCRenderCommand" calls a virtual method "GenerateFlags".
Empty Catch Block,CocosSharp,CCMusicPlayer,C:\repos\mono_CocosSharp\src\Audio\CCMusicPlayer.cs,Dispose,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseImageFileName,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CCLabel,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,InitBMFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,InitSpriteFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContent,C:\repos\mono_CocosSharp\src\Platform\CCContent.cs,LoadContentFile,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContent,C:\repos\mono_CocosSharp\src\Platform\CCContent.cs,LoadContentFile,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,Load,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,GetAssetStream,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithStream,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithFile,The method has an empty catch block.
Empty Catch Block,CocosSharp.Compression.Zlib,ZOutputStream,C:\repos\mono_CocosSharp\src\Platform\Zlib\ZOutputStream.cs,Finish,The method has an empty catch block.
Empty Catch Block,CocosSharp.Compression.Zlib,ZOutputStream,C:\repos\mono_CocosSharp\src\Platform\Zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,CocosSharp,CCFollow,C:\repos\mono_CocosSharp\src\Actions\Base\CCFollow.cs,CCFollow,The following statement contains a magic number: if (UsingBoundary)              {                  float leftBoundary = -((rect.Origin.X + rect.Size.Width) - FullScreenSize.X - viewportBounds.Origin.X);                  float rightBoundary = -rect.Origin.X;                  float topBoundary = -rect.Origin.Y;                  float bottomBoundary = -((rect.Origin.Y + rect.Size.Height) - FullScreenSize.Y - viewportBounds.Origin.Y);                    if (rightBoundary < leftBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      rightBoundary = leftBoundary = (leftBoundary + rightBoundary) / 2;                  }                  if (topBoundary < bottomBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      topBoundary = bottomBoundary = (topBoundary + bottomBoundary) / 2;                  }                    if ((topBoundary == bottomBoundary) && (leftBoundary == rightBoundary))                  {                      BoundaryFullyCovered = true;                  }                    Boundary = new CCFollowBoundary (bottomBoundary' leftBoundary' rightBoundary' topBoundary);              }
Magic Number,CocosSharp,CCFollow,C:\repos\mono_CocosSharp\src\Actions\Base\CCFollow.cs,CCFollow,The following statement contains a magic number: if (UsingBoundary)              {                  float leftBoundary = -((rect.Origin.X + rect.Size.Width) - FullScreenSize.X - viewportBounds.Origin.X);                  float rightBoundary = -rect.Origin.X;                  float topBoundary = -rect.Origin.Y;                  float bottomBoundary = -((rect.Origin.Y + rect.Size.Height) - FullScreenSize.Y - viewportBounds.Origin.Y);                    if (rightBoundary < leftBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      rightBoundary = leftBoundary = (leftBoundary + rightBoundary) / 2;                  }                  if (topBoundary < bottomBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      topBoundary = bottomBoundary = (topBoundary + bottomBoundary) / 2;                  }                    if ((topBoundary == bottomBoundary) && (leftBoundary == rightBoundary))                  {                      BoundaryFullyCovered = true;                  }                    Boundary = new CCFollowBoundary (bottomBoundary' leftBoundary' rightBoundary' topBoundary);              }
Magic Number,CocosSharp,CCCardinalSplineToState,C:\repos\mono_CocosSharp\src\Actions\Catmull\CCCardinalSplineTo.cs,Update,The following statement contains a magic number: CCPoint pp3 = Points [Math.Min (c' Math.Max (p + 2' 0))];
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,Update,The following statement contains a magic number: while (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,RemoveAllActions,The following statement contains a magic number: if (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCEaseInOutState,C:\repos\mono_CocosSharp\src\Actions\Ease\CCEaseInOut.cs,Update,The following statement contains a magic number: time *= 2;
Magic Number,CocosSharp,CCEaseInOutState,C:\repos\mono_CocosSharp\src\Actions\Ease\CCEaseInOut.cs,Update,The following statement contains a magic number: if (time < 1)              {                  InnerActionState.Update (0.5f * (float)Math.Pow (time' actionRate));              }              else              {                  InnerActionState.Update (1.0f - 0.5f * (float)Math.Pow (2 - time' actionRate));              }
Magic Number,CocosSharp,CCLiquidState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCLiquid.cs,Update,The following statement contains a magic number: for (i = 1; i < GridSize.X; ++i)              {                  for (j = 1; j < GridSize.Y; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X = (v.X +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude *                              AmplitudeRate));                      v.Y = (v.Y +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude *                              AmplitudeRate));                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCLiquidState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCLiquid.cs,Update,The following statement contains a magic number: for (i = 1; i < GridSize.X; ++i)              {                  for (j = 1; j < GridSize.Y; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X = (v.X +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude *                              AmplitudeRate));                      v.Y = (v.Y +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude *                              AmplitudeRate));                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: float deltaAy = (tt * tt * 500);
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: float ay = -100 - deltaAy;
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: for (int i = 0; i <= GridSize.X; ++i)              {                  for (int j = 0; j <= GridSize.Y; ++j)                  {                      // Get original vertex                      CCVertex3F p = OriginalVertex (i' j);                        var R = (float)Math.Sqrt ((p.X * p.X) + ((p.Y - ay) * (p.Y - ay)));                      float r = R * sinTheta;                      var alpha = (float)Math.Asin (p.X / R);                      float beta = alpha / sinTheta;                      var cosBeta = (float)Math.Cos (beta);                        // If beta > PI then we've wrapped around the cone                      // Reduce the radius to stop these points interfering with others                      if (beta <= MathHelper.Pi)                      {                          p.X = (r * (float)Math.Sin (beta));                      }                      else                      {                          // Force X = 0 to stop wrapped                          // points                          p.X = 0;                      }                        p.Y = (R + ay - (r * (1 - cosBeta) * sinTheta));                        // We scale z here to avoid the animation being                      // too much bigger than the screen due to perspective transform                      p.Z = (r * (1 - cosBeta) * cosTheta) / 7; // "100" didn't work for                        //    Stop z coord from dropping beneath underlying page in a transition                      // issue #751                      if (p.Z < 0.5f)                      {                          p.Z = 0.5f;                      }                        // Set new coords                      SetVertex (i' j' ref p);                  }              }
Magic Number,CocosSharp,CCRipple3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCRipple3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        CCPoint diff = Position - new CCPoint (v.X' v.Y);                      float r = diff.Length;                        if (r < Radius)                      {                          r = Radius - r;                          float r1 = r / Radius;                          float rate = r1 * r1;                          v.Z += ((float)Math.Sin (time * MathHelper.Pi * Waves * 2 + r * 0.1f) * Amplitude *                              AmplitudeRate * rate);                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCTwirlState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCTwirl.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        avg.X = i - (GridSize.X / 2.0f);                      avg.Y = j - (GridSize.Y / 2.0f);                        var r = (float)Math.Sqrt ((avg.X * avg.X + avg.Y * avg.Y));                        float amp = 0.1f * Amplitude * AmplitudeRate;                      float a = r * (float)Math.Cos ((float)Math.PI / 2.0f + time * (float)Math.PI * twirls * 2) * amp;                        float dx = (float)Math.Sin (a) * (v.Y - c.Y) + (float)Math.Cos (a) * (v.X - c.X);                      float dy = (float)Math.Cos (a) * (v.Y - c.Y) - (float)Math.Sin (a) * (v.X - c.X);                        v.X = c.X + dx;                      v.Y = c.Y + dy;                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWavesState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        if (Vertical)                      {                          v.X = (v.X +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude * ampRate));                      }                        if (Horizontal)                      {                          v.Y = (v.Y +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude * ampRate));                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWavesState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        if (Vertical)                      {                          v.X = (v.X +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude * ampRate));                      }                        if (Horizontal)                      {                          v.Y = (v.Y +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude * ampRate));                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWaves3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.Z += ((float)Math.Sin ((float)Math.PI * time * Waves * 2 + (v.Y + v.X) * .01f) * Amplitude *                          AmplitudeRate);                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCAccelDeccelAmplitudeState,C:\repos\mono_CocosSharp\src\Actions\Grid\CCAccelDeccelAmplitude.cs,Update,The following statement contains a magic number: float f = time * 2;
Magic Number,CocosSharp,CCBlinkState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCBlink.cs,Update,The following statement contains a magic number: if (Target != null && !IsDone)              {                  float slice = 1.0f / Times;                  // float m = fmodf(time' slice);                  float m = time % slice;                  Target.Visible = m > (slice / 2);              }
Magic Number,CocosSharp,CCFadeInState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCFadeIn.cs,Update,The following statement contains a magic number: if (pRGBAProtocol != null)              {                  pRGBAProtocol.Opacity = (byte)(255 * time);              }
Magic Number,CocosSharp,CCFadeOutState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCFadeOut.cs,Update,The following statement contains a magic number: if (pRGBAProtocol != null)              {                  pRGBAProtocol.Opacity = (byte)(255 * (1 - time));              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX > 180)              {                  DiffAngleX -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX > 180)              {                  DiffAngleX -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX < -180)              {                  DiffAngleX += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX < -180)              {                  DiffAngleX += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY > 180)              {                  DiffAngleY -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY > 180)              {                  DiffAngleY -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY < -180)              {                  DiffAngleY += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY < -180)              {                  DiffAngleY += 360;              }
Magic Number,CocosSharp,CCSequence,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSequence.cs,CCSequence,The following statement contains a magic number: Actions = new CCFiniteTimeAction[2];
Magic Number,CocosSharp,CCSequence,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSequence.cs,CCSequence,The following statement contains a magic number: Actions = new CCFiniteTimeAction[2];
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX > 180)              {                  DeltaX -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX > 180)              {                  DeltaX -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX < -180)              {                  DeltaX += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX < -180)              {                  DeltaX += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY > 180)              {                  DeltaY -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY > 180)              {                  DeltaY -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY < -180)              {                  DeltaY += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY < -180)              {                  DeltaY += 360;              }
Magic Number,CocosSharp,CCProgressToState,C:\repos\mono_CocosSharp\src\Actions\ProgressTimer\CCProgressTo.cs,CCProgressToState,The following statement contains a magic number: if (PercentFrom == 100)              {                  PercentFrom = 0;              }
Magic Number,CocosSharp,CCFadeOutBLTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutBLTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow ((n.X + n.Y) / (pos.X + pos.Y)' 6);
Magic Number,CocosSharp,CCFadeOutDownTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutDownTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow (n.Y / pos.Y' 6);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow ((pos.X + pos.Y) / (px + py)' 6);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TransformTile,The following statement contains a magic number: float dx = (step.X / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TransformTile,The following statement contains a magic number: float dy = (step.Y / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCFadeOutUpTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutUpTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow (pos.Y / fy' 6);
Magic Number,CocosSharp,CCFadeOutUpTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutUpTiles.cs,TransformTile,The following statement contains a magic number: float dy = (step.Y / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: float sinz = ((float)Math.Sin ((float)Math.PI * time * NumberOfJumps * 2) * Amplitude * AmplitudeRate);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: float sinz2 = (float)(Math.Sin ((float)Math.PI * (time * NumberOfJumps * 2 + 1)) * Amplitude * AmplitudeRate);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; i++)              {                  for (j = 0; j < GridSize.Y; j++)                  {                      CCQuad3 coords = OriginalTile (i' j);                        if (((i + j) % 2) == 0)                      {                          coords.BottomLeft.Z += sinz;                          coords.BottomRight.Z += sinz;                          coords.TopLeft.Z += sinz;                          coords.TopRight.Z += sinz;                      }                      else                      {                          coords.BottomLeft.Z += sinz2;                          coords.BottomRight.Z += sinz2;                          coords.TopLeft.Z += sinz2;                          coords.TopRight.Z += sinz2;                      }                        SetTile (i' j' ref coords);                  }              }
Magic Number,CocosSharp,CCShakyTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCShakyTiles3D.cs,Update,The following statement contains a magic number: var doubleRange = Range * 2;
Magic Number,CocosSharp,CCShatteredTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCShatteredTiles3D.cs,Update,The following statement contains a magic number: var doubleRange = Range * 2;
Magic Number,CocosSharp,CCSplitColsState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCSplitCols.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; ++i)              {                  CCQuad3 coords = OriginalTile (i' 0);                  float direction = 1;                    if ((i % 2) == 0)                  {                      direction = -1;                  }                    coords.BottomLeft.Y += direction * height * time;                  coords.BottomRight.Y += direction * height * time;                  coords.TopLeft.Y += direction * height * time;                  coords.TopRight.Y += direction * height * time;                    SetTile (i' 0' ref coords);              }
Magic Number,CocosSharp,CCSplitRowsState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCSplitRows.cs,Update,The following statement contains a magic number: for (j = 0; j < GridSize.Y; ++j) {                  CCQuad3 coords = OriginalTile (0' j);                  float direction = 1;                    if ((j % 2) == 0) {                      direction = -1;                  }                    coords.BottomLeft.X += direction * width * time;                  coords.BottomRight.X += direction * width * time;                  coords.TopLeft.X += direction * width * time;                  coords.TopRight.X += direction * width * time;                    SetTile (0' j' ref coords);              }
Magic Number,CocosSharp,CCWavesTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCWavesTiles3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; i++)              {                  for (j = 0; j < GridSize.Y; j++)                  {                      CCQuad3 coords = OriginalTile (i' j);                      CCVertex3F bl = coords.BottomLeft;                      CCVertex3F br = coords.BottomRight;                      CCVertex3F tl = coords.TopLeft;                      CCVertex3F tr = coords.TopRight;                        bl.Z = ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + (bl.Y + bl.X) * .01f) * Amplitude * AmplitudeRate);                      br.Z = bl.Z;                      tl.Z = bl.Z;                      tr.Z = bl.Z;                        coords.BottomLeft = bl;                      coords.BottomRight = br;                      coords.TopLeft = tl;                      coords.TopRight = tr;                        SetTile (i' j' ref coords);                  }              }
Magic Number,CocosSharp,CCV3F_T2F,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CCV3F_T2F,The following statement contains a magic number: var elements = new[]              {                  new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                  new VertexElement(12' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)              };
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<ushort>(GridSize.X * GridSize.Y * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = GridSize.X * GridSize.Y * 6;
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l2 = new CCVertex3F[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex2 = new CCPoint[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer = new CCVertexBuffer<CCV3F_T2F>(numQuads * 4' CCBufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer.Count = numQuads * 4;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<short>(numQuads * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = numQuads * 6;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.cs,UpdateViewport,The following statement contains a magic number: if (resolutionPolicy != CCViewResolutionPolicy.Custom)              {                  float resolutionScaleX = width / (float)DesignResolution.Width;                  float resolutionScaleY = height / (float)DesignResolution.Height;                    switch (resolutionPolicy)                  {                      case CCViewResolutionPolicy.NoBorder:                          resolutionScaleX = resolutionScaleY = Math.Max(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.ShowAll:                          resolutionScaleX = resolutionScaleY = Math.Min(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.FixedHeight:                          resolutionScaleX = resolutionScaleY;                          designResolution.Width = (int)Math.Ceiling(width / resolutionScaleX);                          break;                      case CCViewResolutionPolicy.FixedWidth:                          resolutionScaleY = resolutionScaleX;                          designResolution.Height = (int)Math.Ceiling(height / resolutionScaleY);                          break;                      default:                          break;                  }                    float viewPortW = DesignResolution.Width * resolutionScaleX;                  float viewPortH = DesignResolution.Height * resolutionScaleY;                    CCRect viewPortRect = new CCRect((width - viewPortW) / 2' (height - viewPortH) / 2'                       viewPortW' viewPortH);                    viewportRatio = new CCRect(                      ((viewPortRect.Origin.X) / width)'                      ((viewPortRect.Origin.Y) / height)'                      ((viewPortRect.Size.Width) / width)'                      ((viewPortRect.Size.Height) / height)                  );              }
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.cs,UpdateViewport,The following statement contains a magic number: if (resolutionPolicy != CCViewResolutionPolicy.Custom)              {                  float resolutionScaleX = width / (float)DesignResolution.Width;                  float resolutionScaleY = height / (float)DesignResolution.Height;                    switch (resolutionPolicy)                  {                      case CCViewResolutionPolicy.NoBorder:                          resolutionScaleX = resolutionScaleY = Math.Max(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.ShowAll:                          resolutionScaleX = resolutionScaleY = Math.Min(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.FixedHeight:                          resolutionScaleX = resolutionScaleY;                          designResolution.Width = (int)Math.Ceiling(width / resolutionScaleX);                          break;                      case CCViewResolutionPolicy.FixedWidth:                          resolutionScaleY = resolutionScaleX;                          designResolution.Height = (int)Math.Ceiling(height / resolutionScaleY);                          break;                      default:                          break;                  }                    float viewPortW = DesignResolution.Width * resolutionScaleX;                  float viewPortH = DesignResolution.Height * resolutionScaleY;                    CCRect viewPortRect = new CCRect((width - viewPortW) / 2' (height - viewPortH) / 2'                       viewPortW' viewPortH);                    viewportRatio = new CCRect(                      ((viewPortRect.Origin.X) / width)'                      ((viewPortRect.Origin.Y) / height)'                      ((viewPortRect.Size.Width) / width)'                      ((viewPortRect.Size.Height) / height)                  );              }
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.cs,UpdateViewport,The following statement contains a magic number: defaultProjMatrix = XnaMatrix.CreateOrthographic(ViewSize.Width' ViewSize.Height' 1024f' -1024);
Magic Number,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,CCEventDispatcher,The following statement contains a magic number: toBeAddedListeners = new List<CCEventListener>(50);
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventTouch,C:\repos\mono_CocosSharp\src\Events\CCEventTouch.cs,CCEventTouch,The following statement contains a magic number: Touches = new List<CCTouch> (5);
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The following statement contains a magic number: try              {                  if (TimeScale != 1.0f)                  {                      dt *= TimeScale;                  }                    LinkedListNode<ListEntry> next;                    // updates with priority < 0                  //foreach (ListEntry entry in _updatesNegList)                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority == 0                  //foreach (ListEntry entry in _updates0List)                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // Iterate over all the custom selectors                  var count = hashForTimers.Count;                  if (count > 0)                  {                      if (tmpSelectorArray.Length < count)                      {                          tmpSelectorArray = new ICCUpdatable[tmpSelectorArray.Length * 2];                      }                      hashForTimers.Keys.CopyTo(tmpSelectorArray' 0);                        for (int i = 0; i < count; i++)                      {                          ICCUpdatable key = tmpSelectorArray[i];                          if (!hashForTimers.ContainsKey(key))                          {                              continue;                          }                          HashTimeEntry elt = hashForTimers[key];                            currentTarget = elt;                          isCurrentTargetSalvaged = false;                            if (!currentTarget.Paused)                          {                              // The 'timers' array may change while inside this loop                              for (elt.TimerIndex = 0; elt.TimerIndex < elt.Timers.Count; ++elt.TimerIndex)                              {                                  elt.CurrentTimer = elt.Timers[elt.TimerIndex];      							if(elt.CurrentTimer != null) {      	                            elt.CurrentTimerSalvaged = false;        	                            elt.CurrentTimer.Update(dt);        	                            elt.CurrentTimer = null;      							}                              }                          }                            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)                          if (isCurrentTargetSalvaged && currentTarget.Timers.Count == 0)                          {                              RemoveHashElement(currentTarget);                          }                      }                  }                    // delete all updates that are marked for deletion                  // updates with priority < 0                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesNegList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority == 0                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updates0List.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesPosList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }              }              finally              {                  // Always do this just in case there is a problem                    isUpdateHashLocked = false;                  currentTarget = null;              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,The following statement contains a magic number: if (tmpHashSelectorArray.Length < count)              {                  tmpHashSelectorArray = new HashTimeEntry[tmpHashSelectorArray.Length * 2];              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The following statement contains a magic number: try              {                  if (TimeScale != 1.0f)                  {                      dt *= TimeScale;                  }                    LinkedListNode<ListEntry> next;                    // updates with priority < 0                  //foreach (ListEntry entry in _updatesNegList)                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority == 0                  //foreach (ListEntry entry in _updates0List)                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // Iterate over all the custom selectors                  var count = hashForTimers.Count;                  if (count > 0)                  {                      if (tmpSelectorArray.Length < count)                      {                          tmpSelectorArray = new ICCUpdatable[tmpSelectorArray.Length * 2];                      }                      hashForTimers.Keys.CopyTo(tmpSelectorArray' 0);                        for (int i = 0; i < count; i++)                      {                          ICCUpdatable key = tmpSelectorArray[i];                          if (!hashForTimers.ContainsKey(key))                          {                              continue;                          }                          HashTimeEntry elt = hashForTimers[key];                            currentTarget = elt;                          isCurrentTargetSalvaged = false;                            if (!currentTarget.Paused)                          {                              // The 'timers' array may change while inside this loop                              for (elt.TimerIndex = 0; elt.TimerIndex < elt.Timers.Count; ++elt.TimerIndex)                              {                                  elt.CurrentTimer = elt.Timers[elt.TimerIndex];      							if(elt.CurrentTimer != null) {      	                            elt.CurrentTimerSalvaged = false;        	                            elt.CurrentTimer.Update(dt);        	                            elt.CurrentTimer = null;      							}                              }                          }                            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)                          if (isCurrentTargetSalvaged && currentTarget.Timers.Count == 0)                          {                              RemoveHashElement(currentTarget);                          }                      }                  }                    // delete all updates that are marked for deletion                  // updates with priority < 0                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesNegList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority == 0                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updates0List.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesPosList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }              }              finally              {                  // Always do this just in case there is a problem                    isUpdateHashLocked = false;                  currentTarget = null;              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,The following statement contains a magic number: if (tmpHashSelectorArray.Length < count)              {                  tmpHashSelectorArray = new HashTimeEntry[tmpHashSelectorArray.Length * 2];              }
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,CCNode,The following statement contains a magic number: displayedOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,CCNode,The following statement contains a magic number: RealOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,UpdateCascadeOpacity,The following statement contains a magic number: byte parentOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,DisableCascadeOpacity,The following statement contains a magic number: foreach(CCNode node in Children.Elements)              {                  node.UpdateDisplayedOpacity(255);              }
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: Padding.Bottom = CocosSharp.CCUtils.CCParseInt(temp[2]);
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: Padding.Left = CocosSharp.CCUtils.CCParseInt(temp[3]);
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseKerningEntry,The following statement contains a magic number: try              {                  var element = new CCKerningHashElement();                  element.Amount = amount;                  element.Key = (first << 16) | (second & 0xffff);                  GlyphKernings.Add(element.Key' element);              }              catch (Exception)              {                  CocosSharp.CCLog.Log("Failed to parse font line: {0}"' line);              }
Magic Number,CocosSharp,CCFontFNT,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCFontFNT.cs,GetHorizontalKerningForChars,The following statement contains a magic number: int key = (firstChar << 16) | (secondChar & 0xffff);
Magic Number,CocosSharp,FileFontFileEnumerator,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-FontUtilities-Win8.cs,MoveNext,The following statement contains a magic number: if (moveNext)              {                  if (_currentFontFile != null)                      _currentFontFile.Dispose();                    _currentFontFile = new FontFile(_factory' keyStream.PositionPointer' 4' _loader);                  keyStream.Position += 4;              }
Magic Number,CocosSharp,FileFontFileEnumerator,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-FontUtilities-Win8.cs,MoveNext,The following statement contains a magic number: if (moveNext)              {                  if (_currentFontFile != null)                      _currentFontFile.Dispose();                    _currentFontFile = new FontFile(_factory' keyStream.PositionPointer' 4' _loader);                  keyStream.Position += 4;              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,The following statement contains a magic number: if (dimensions.Width <= 0)              {                  dimensions.Width = 8388608;                  layoutAvailable = false;              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,The following statement contains a magic number: if (dimensions.Height <= 0)              {                  dimensions.Height = 8388608;                  layoutAvailable = false;              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,The following statement contains a magic number: if (!layoutAvailable)              {                  if (dimensions.Width == 8388608)                  {                      dimensions.Width = boundingRect.Width;                  }                  if (dimensions.Height == 8388608)                  {                      dimensions.Height = boundingRect.Height;                  }              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,CreateTextSprite,The following statement contains a magic number: if (!layoutAvailable)              {                  if (dimensions.Width == 8388608)                  {                      dimensions.Width = boundingRect.Width;                  }                  if (dimensions.Height == 8388608)                  {                      dimensions.Height = boundingRect.Height;                  }              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,Reset,The following statement contains a magic number: systemFontSize = 12;
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,IncreaseAtlasCapacity,The following statement contains a magic number: int quantity = (TextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsPhone81.cs,IncreaseAtlasCapacity,The following statement contains a magic number: int quantity = (TextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,RenderLayer,The following statement contains a magic number: if(Camera != null)              {                  if (verticesPositionDirty)                      UpdateVerticesPosition();                                    var drawManager = DrawManager;                    bool depthTest = drawManager.DepthTest;                    // We're drawing a quad at z=0                  // We need to ensure depth testing is off so that the layer color doesn't obscure anything                  drawManager.DepthTest = false;                  drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                  drawManager.DrawPrimitives(PrimitiveType.TriangleStrip'  SquareVertices' 0' 2);                  drawManager.DepthTest = depthTest;              }
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The following statement contains a magic number: SquareVertices[2].Color = color;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The following statement contains a magic number: SquareVertices[3].Color = color;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[2].Position.X = SquareVertices[0].Position.X;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[2].Position.Y = SquareVertices[0].Position.Y + visibleBounds.Size.Height;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[3].Position.X = SquareVertices[0].Position.X + visibleBounds.Size.Width;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[3].Position.Y = SquareVertices[0].Position.Y + visibleBounds.Size.Height;
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: double c = Math.Sqrt(2.0);
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: SquareVertices[2].Color = new Color(                  (byte) (E.R + (S.R - E.R) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.G + (S.G - E.G) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.B + (S.B - E.B) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.A + (S.A - E.A) * ((c + u.X - u.Y) / (2.0f * c)))                  );
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: SquareVertices[3].Color = new Color(                  (byte) (E.R + (S.R - E.R) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.G + (S.G - E.G) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.B + (S.B - E.B) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.A + (S.A - E.A) * ((c - u.X - u.Y) / (2.0f * c)))                  );
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawDot,The following statement contains a magic number: var segments = 10 * (float)Math.Sqrt(radius);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCircle,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidCircle,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidArc,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawRect,The following statement contains a magic number: DrawPolygon(pt' 4' cf' borderWidth' bc);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The following statement contains a magic number: DrawEllipticalArc(rect' 0' 360' false' lineWidth' color);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The following statement contains a magic number: DrawEllipticalArc(x'y'width'height'0'360'false' lineWidth' color);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCardinalSpline,The following statement contains a magic number: for (int i = 0; i < segments + 1; i++)              {                  float dt = (float) i / segments;                    // border                  if (dt == 1)                  {                      p = count - 1;                      lt = 1;                  }                  else                  {                      p = (int) (dt / deltaT);                      lt = (dt - deltaT * p) / deltaT;                  }                    // Interpolate                      int c = config.Count - 1;                  CCPoint pp0 = config[Math.Min(c' Math.Max(p - 1' 0))];                  CCPoint pp1 = config[Math.Min(c' Math.Max(p + 0' 0))];                  CCPoint pp2 = config[Math.Min(c' Math.Max(p + 1' 0))];                  CCPoint pp3 = config[Math.Min(c' Math.Max(p + 2' 0))];                    vertices[i] = CCSplineMath.CCCardinalSplineAt(pp0' pp1' pp2' pp3' tension' lt);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: if (outline)              {                  var extrude = new ExtrudeVerts[polycount];                    for (int i = 0; i < polycount; i++)                  {                      var v0 = verts[(i - 1 + polycount) % polycount];                      var v1 = verts[i];                      var v2 = verts[(i + 1) % polycount];                        var n1 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v1 - v0));                      var n2 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v2 - v1));                        var offset = (n1 + n2) * (1.0f / (CCPoint.Dot(n1' n2) + 1.0f));                      extrude[i] = new ExtrudeVerts() { offset = offset' n = n2 };                  }                    for (int i = 0; i < polycount - 2; i++)                  {                      var v0 = verts[0];                      var v1 = verts[i + 1];                      var v2 = verts[i + 2];                        AddTriangleVertex(new CCV3F_C4B(v0' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v1' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v2' colorFill)); //__t(v2fzero)                  }                    for (int i = 0; i < polycount - 1; i++)                  {                      int j = (i + 1) % polycount;                      var v0 = verts[i];                      var v1 = verts[j];                        var offset0 = extrude[i].offset;                      var offset1 = extrude[j].offset;                        var inner0 = (v0 - (offset0 * borderWidth));                      var inner1 = (v1 - (offset1 * borderWidth));                      var outer0 = (v0 + (offset0 * borderWidth));                      var outer1 = (v1 + (offset1 * borderWidth));                        AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                         AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                   }                    if (closePolygon)                  {                      for (int i = polycount - 1; i < polycount; i++)                      {                          int j = (i + 1) % polycount;                          var v0 = verts[i];                          var v1 = verts[j];                            var offset0 = extrude[i].offset;                          var offset1 = extrude[j].offset;                            var inner0 = (v0 - (offset0 * borderWidth));                          var inner1 = (v1 - (offset1 * borderWidth));                          var outer0 = (v0 + (offset0 * borderWidth));                          var outer1 = (v1 + (offset1 * borderWidth));                            AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                             AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                       }                  }              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: if (outline)              {                  var extrude = new ExtrudeVerts[polycount];                    for (int i = 0; i < polycount; i++)                  {                      var v0 = verts[(i - 1 + polycount) % polycount];                      var v1 = verts[i];                      var v2 = verts[(i + 1) % polycount];                        var n1 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v1 - v0));                      var n2 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v2 - v1));                        var offset = (n1 + n2) * (1.0f / (CCPoint.Dot(n1' n2) + 1.0f));                      extrude[i] = new ExtrudeVerts() { offset = offset' n = n2 };                  }                    for (int i = 0; i < polycount - 2; i++)                  {                      var v0 = verts[0];                      var v1 = verts[i + 1];                      var v2 = verts[i + 2];                        AddTriangleVertex(new CCV3F_C4B(v0' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v1' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v2' colorFill)); //__t(v2fzero)                  }                    for (int i = 0; i < polycount - 1; i++)                  {                      int j = (i + 1) % polycount;                      var v0 = verts[i];                      var v1 = verts[j];                        var offset0 = extrude[i].offset;                      var offset1 = extrude[j].offset;                        var inner0 = (v0 - (offset0 * borderWidth));                      var inner1 = (v1 - (offset1 * borderWidth));                      var outer0 = (v0 + (offset0 * borderWidth));                      var outer1 = (v1 + (offset1 * borderWidth));                        AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                         AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                   }                    if (closePolygon)                  {                      for (int i = polycount - 1; i < polycount; i++)                      {                          int j = (i + 1) % polycount;                          var v0 = verts[i];                          var v1 = verts[j];                            var offset0 = extrude[i].offset;                          var offset1 = extrude[j].offset;                            var inner0 = (v0 - (offset0 * borderWidth));                          var inner1 = (v1 - (offset1 * borderWidth));                          var outer0 = (v0 + (offset0 * borderWidth));                          var outer1 = (v1 + (offset1 * borderWidth));                            AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                             AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                       }                  }              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = triangleVertsCount / 3;                  // submit the draw call to the graphics card                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangleVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = triangleVertsCount / 3;                  // submit the draw call to the graphics card                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangleVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = lineVertsCount / 2;                  // submit the draw call to the graphics card                   DrawManager.DrawPrimitives(PrimitiveType.LineList' lineVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = lineVertsCount / 2;                  // submit the draw call to the graphics card                   DrawManager.DrawPrimitives(PrimitiveType.LineList' lineVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float rx = width / 2;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float ry = height / 2;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float alpha = startAngle * PI / 180;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float beta = endAngle * PI / 180;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (Math.Abs(beta - alpha) > PI)              {                  if (beta > alpha)                      beta -= 2 * PI;                  else                      alpha -= 2 * PI;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (Math.Abs(beta - alpha) > PI)              {                  if (beta > alpha)                      beta -= 2 * PI;                  else                      alpha -= 2 * PI;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (start)              {                  /* starting point */                  double sx = cx + rx * cos_alpha;                  double sy = cy + ry * sin_alpha;                  if (isPieSlice)                   {                      destinationPoint.X = (float)sx;                      destinationPoint.Y = (float)sy;                        DrawPolygon(new CCPoint[] {startPoint'destinationPoint}' 2' CCColor4B.Transparent' lineWidth' color);                  }                    startPoint.X = (float)sx;                  startPoint.Y = (float)sy;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,CCGeometryNode,The following statement contains a magic number: indicesArray = new CCRawList<short>(bufferSize * 2);
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,FlushVertexArray,The following statement contains a magic number: var numberIndices = instance.PrimitiveType == PrimitiveType.TriangleList ? numberOfIndices / 3 : numberOfIndices / 2;
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,FlushVertexArray,The following statement contains a magic number: var numberIndices = instance.PrimitiveType == PrimitiveType.TriangleList ? numberOfIndices / 3 : numberOfIndices / 2;
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The following statement contains a magic number: maxPoints = (int) (fade * 60.0f) + 2;
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The following statement contains a magic number: vertices = new CCV3F_C4B_T2F[(maxPoints + 1) * 2];
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,RenderMotionStreak,The following statement contains a magic number: drawManager.DrawPrimitives(PrimitiveType.TriangleStrip' vertices' 0' numOfPoints * 2 - 2);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,RenderMotionStreak,The following statement contains a magic number: drawManager.DrawPrimitives(PrimitiveType.TriangleStrip' vertices' 0' numOfPoints * 2 - 2);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: float rad70 = MathHelper.ToRadians(70);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: float rad170 = MathHelper.ToRadians(170);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPoints; i++)              {                  idx = i * 2;                  CCPoint p1 = points[i];                  CCPoint perpVector;                    if (i == 0)                  {                      perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(p1 - points[i + 1]));                  }                  else if (i == nuPointsMinus)                  {                      perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(points[i - 1] - p1));                  }                  else                  {                      CCPoint p2 = points[i + 1];                      CCPoint p0 = points[i - 1];                        CCPoint p2p1 = CCPoint.Normalize(p2 - p1);                      CCPoint p0p1 = CCPoint.Normalize(p0 - p1);                        // Calculate angle between vectors                      var angle = (float) Math.Acos(CCPoint.Dot(p2p1' p0p1));                        if (angle < rad70)                      {                          perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(CCPoint.Midpoint(p2p1' p0p1)));                      }                      else if (angle < rad170)                      {                          perpVector = CCPoint.Normalize(CCPoint.Midpoint(p2p1' p0p1));                      }                      else                      {                          perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(p2 - p0));                      }                  }                    perpVector = perpVector * stroke;                    vertices[idx].Vertices = new CCVertex3F(p1.X + perpVector.X' p1.Y + perpVector.Y' 0);                  vertices[idx + 1].Vertices = new CCVertex3F(p1.X - perpVector.X' p1.Y - perpVector.Y' 0);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPointsMinus; i++)              {                  idx = i * 2;                  int idx1 = idx + 2;                    CCVertex3F p1 = vertices[idx].Vertices;                  CCVertex3F p2 = vertices[idx + 1].Vertices;                  CCVertex3F p3 = vertices[idx1].Vertices;                  CCVertex3F p4 = vertices[idx1 + 1].Vertices;                    float s;                  bool fixVertex = !VertexLineIntersect(p1.X' p1.Y' p4.X' p4.Y' p2.X' p2.Y' p3.X' p3.Y' out s);                  if (!fixVertex)                  {                      if (s < 0.0f || s > 1.0f)                      {                          fixVertex = true;                      }                  }                    if (fixVertex)                  {                      vertices[idx1].Vertices = p4;                      vertices[idx1 + 1].Vertices = p3;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPointsMinus; i++)              {                  idx = i * 2;                  int idx1 = idx + 2;                    CCVertex3F p1 = vertices[idx].Vertices;                  CCVertex3F p2 = vertices[idx + 1].Vertices;                  CCVertex3F p3 = vertices[idx1].Vertices;                  CCVertex3F p4 = vertices[idx1 + 1].Vertices;                    float s;                  bool fixVertex = !VertexLineIntersect(p1.X' p1.Y' p4.X' p4.Y' p2.X' p2.Y' p3.X' p3.Y' out s);                  if (!fixVertex)                  {                      if (s < 0.0f || s > 1.0f)                      {                          fixVertex = true;                      }                  }                    if (fixVertex)                  {                      vertices[idx1].Vertices = p4;                      vertices[idx1 + 1].Vertices = p3;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,TintWithColor,The following statement contains a magic number: for (int i = 0; i < numOfPoints * 2; i++)              {                  vertices[i].Colors = new CCColor4B(colors.R' colors.G' colors.B' 255);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,TintWithColor,The following statement contains a magic number: for (int i = 0; i < numOfPoints * 2; i++)              {                  vertices[i].Colors = new CCColor4B(colors.R' colors.G' colors.B' 255);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints >= maxPoints)              {                  appendNewPoint = false;              }                else if (numOfPoints > 0)              {                  bool a1 = pointVertexes[numOfPoints - 1].DistanceSquared(ref positionR) < minSeg;                  bool a2 = (numOfPoints != 1) && (pointVertexes[numOfPoints - 2].DistanceSquared(ref positionR) < (minSeg * 2.0f));                    if (a1 || a2)                  {                      appendNewPoint = false;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints > 0 && previousNumOfPoints != numOfPoints)              {                  float texDelta = 1.0f / numOfPoints;                  for (i = 0; i < numOfPoints; i++)                  {                      vertices[i * 2].TexCoords = new CCTex2F(0' texDelta * i);                      vertices[i * 2 + 1].TexCoords = new CCTex2F(1' texDelta * i);                  }                    previousNumOfPoints = numOfPoints;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints > 0 && previousNumOfPoints != numOfPoints)              {                  float texDelta = 1.0f / numOfPoints;                  for (i = 0; i < numOfPoints; i++)                  {                      vertices[i * 2].TexCoords = new CCTex2F(0' texDelta * i);                      vertices[i * 2 + 1].TexCoords = new CCTex2F(1' texDelta * i);                  }                    previousNumOfPoints = numOfPoints;              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RenderProgress,The following statement contains a magic number: if (vertexData != null && sprite != null)               {                  DrawManager.BindTexture(Sprite.Texture);                  DrawManager.BlendFunc(Sprite.BlendFunc);                    DrawManager.DrawIndexedPrimitives(PrimitiveType.TriangleList' vertexData' 0'                       vertexData.Length' vertexIndices' 0' vertexData.Length - 2);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,BoundaryTexCoord,The following statement contains a magic number: if (index < ProgressTextureCoordsCount)              {                  if (ReverseDirection)                  {                      return new CCPoint((ProgressTextureCoords >> (7 - (index << 1))) & 1'                          (ProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1);                  }                  return new CCPoint((ProgressTextureCoords >> ((index << 1) + 1)) & 1'                      (ProgressTextureCoords >> (index << 1)) & 1);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,BoundaryTexCoord,The following statement contains a magic number: if (index < ProgressTextureCoordsCount)              {                  if (ReverseDirection)                  {                      return new CCPoint((ProgressTextureCoords >> (7 - (index << 1))) & 1'                          (ProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1);                  }                  return new CCPoint((ProgressTextureCoords >> ((index << 1) + 1)) & 1'                      (ProgressTextureCoords >> (index << 1)) & 1);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (vertexData != null && vertexData.Length != index + 3)              {                  sameIndexCount = false;                  vertexData = null;              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (vertexData == null)              {                  sameIndexCount = false;                  vertexData = new CCV3F_C4B_T2F[index + 3];              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (!sameIndexCount)              {                  //    First we populate the array with the m_tMidpoint' then all                  //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(Midpoint);                  vertexData[0].Vertices = VertexFromAlphaPoint(Midpoint);                    vertexData[1].TexCoords = TextureCoordFromAlphaPoint(topMid);                  vertexData[1].Vertices = VertexFromAlphaPoint(topMid);                    for (int i = 0; i < index; ++i)                  {                      CCPoint alphaPoint = BoundaryTexCoord(i);                      vertexData[i + 2].TexCoords = TextureCoordFromAlphaPoint(alphaPoint);                      vertexData[i + 2].Vertices = VertexFromAlphaPoint(alphaPoint);                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (!sameIndexCount)              {                  //    First we populate the array with the m_tMidpoint' then all                  //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(Midpoint);                  vertexData[0].Vertices = VertexFromAlphaPoint(Midpoint);                    vertexData[1].TexCoords = TextureCoordFromAlphaPoint(topMid);                  vertexData[1].Vertices = VertexFromAlphaPoint(topMid);                    for (int i = 0; i < index; ++i)                  {                      CCPoint alphaPoint = BoundaryTexCoord(i);                      vertexData[i + 2].TexCoords = TextureCoordFromAlphaPoint(alphaPoint);                      vertexData[i + 2].Vertices = VertexFromAlphaPoint(alphaPoint);                  }              }
Magic Number,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,CCRenderTexture,The following statement contains a magic number: renderProjMatrix =                   Matrix.CreateOrthographic(contentSize.Width' contentSize.Height' 1024f' -1024);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: ParallaxArray = new List<CCPointObject>(5);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: lastPosition = new CCPoint(-100' -100);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: lastPosition = new CCPoint(-100' -100);
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: AngleVar = 20;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.Gravity = new CCPoint (0' -90);
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.Speed = 180;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.SpeedVar = 50;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: gravityMode.Speed = 20;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: gravityMode.SpeedVar = 5;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.RadialAccel = -80;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.Speed = 60;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.TangentialAccel = 80;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.RadialAccel = -60;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.Speed = 80;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.TangentialAccel = 15;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: Life = 2;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(-200' 200);
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(-200' 200);
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Speed = 15;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.SpeedVar = 5;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: Life = 12;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.RadialAccel = -380;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.Speed = 150;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.TangentialAccel = 45;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: LifeVar = 2;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: gravityMode.Speed = 70;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: gravityMode.SpeedVar = 40;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: PositionVar = new CCPoint(20' 0);
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: gravityMode.Speed = 25;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: Life = 45;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: LifeVar = 15;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: Angle = -90;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: EmissionRate = 10;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: gravityMode.Speed = 5;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: Angle = -90;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: EmissionRate = 20;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(10' -10);
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(10' -10);
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Speed = 130;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.SpeedVar = 30;
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: foreach (var pair in configs)  			{  				var texture = pair.Value.Texture.XNATexture;    				if (texture != null)  				{  					var bytes = texture.Width * texture.Height * 4;  					CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);  					total += bytes;  				}    				count++;  			}
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: foreach (var pair in configs)  			{  				var texture = pair.Value.Texture.XNATexture;    				if (texture != null)  				{  					var bytes = texture.Width * texture.Height * 4;  					CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);  					total += bytes;  				}    				count++;  			}
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: CCLog.Log("{0} particle systems' for {1} KB ({2:00.00} MB)"' count' total / 1024' total / (1024f * 1024f));
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: float size_2 = particle.Size / 2;
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Opacity = 255;
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(outTexture.Sprite' 3);
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(fadeLayer' 3);
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: var a = (CCFiniteTimeAction) new CCSequence                                             (                                                 new CCShow()'                                                 new CCFadeIn (Duration / 2)'                                                 new CCCallFunc((HideOutShowIn))'                                                 new CCFadeOut  (Duration / 2)                                             );
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: var a = (CCFiniteTimeAction) new CCSequence                                             (                                                 new CCShow()'                                                 new CCFadeIn (Duration / 2)'                                                 new CCCallFunc((HideOutShowIn))'                                                 new CCFadeOut  (Duration / 2)                                             );
Magic Number,CocosSharp,CCTransitionFadeTR,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFadeTR.cs,InitialiseScenes,The following statement contains a magic number: var x = (int) (12 * aspect);
Magic Number,CocosSharp,CCTransitionFadeTR,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFadeTR.cs,InitialiseScenes,The following statement contains a magic number: int y = 12;
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCFiniteTimeAction scaleIn = new CCScaleTo(Duration / 4' 1.0f);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCFiniteTimeAction scaleOut = new CCScaleTo(Duration / 4' 0.5f);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: delay = new CCDelayTime (Duration / 2);
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,InitialiseScenes,The following statement contains a magic number: texture.BeginWithClear(0' 0' 0' 255);
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(node' 2);
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,SetupTransition,The following statement contains a magic number: From = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,SetupTransition,The following statement contains a magic number: To = 100;
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionShrinkGrow,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionShrinkGrow.cs,InitialiseScenes,The following statement contains a magic number: InSceneNodeContainer.AnchorPoint = new CCPoint(2 / 3.0f' 0.5f);
Magic Number,CocosSharp,CCTransitionTurnOffTiles,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionTurnOffTiles.cs,InitialiseScenes,The following statement contains a magic number: var x = (int) (12 * aspect);
Magic Number,CocosSharp,CCTransitionTurnOffTiles,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionTurnOffTiles.cs,InitialiseScenes,The following statement contains a magic number: int y = 12;
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,AddAnimations,The following statement contains a magic number: if (properties != null)              {                  int version = properties["format"].AsInt;                  PlistArray spritesheets = properties["spritesheets"].AsArray;                    foreach (PlistObjectBase pObj in spritesheets)                  {                      string name = pObj.AsString;                      CCSpriteFrameCache.SharedSpriteFrameCache.AddSpriteFrames(name);                  }                    switch (version)                  {                      case 1:                          ParseVersion1(animations);                          break;                        case 2:                          ParseVersion2(animations);                          break;                        default:                          Debug.Assert(false' "Invalid animation format");                          break;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: if (format < 0 || format > 3)              {                  throw (new NotSupportedException("PList format " + format + " is not supported."));              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: if (format < 0 || format > 3)              {                  throw (new NotSupportedException("PList format " + format + " is not supported."));              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,CCTileMapInfo,The following statement contains a magic number: ObjectGroups = new List<CCTileMapObjectGroup>(4);
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,StartElement,The following statement contains a magic number: if (atts != null && atts[0] != null)              {                  for (int i = 0; i + 1 < atts.Length; i += 2)                  {                      string key = atts[i];                      string value = atts[i + 1];                      currentAttributeDict.Add(key' value);                  }              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseMultilineShape,The following statement contains a magic number: for (int i = 0; i < pointPairs.Length; i++)  	        {  		        string pointPair = pointPairs[i];  		        string[] pointCoords = pointPair.Split(''');  		        if (pointCoords.Length != 2)  			        return;    				// Adjust the offsets relative to the parent object. When adjusting the coordinates'  				// correct y position. Tiled uses inverted y-coordinate system where top is y=0.  				// We have to invert the y coordinate to make it move in the correct direction relative to the parent.  		        points[i].X = float.Parse(pointCoords[0]) + objectXOffset;  		        points[i].Y = float.Parse(pointCoords[1]) * -1 + objectYOffset;    		        sb.Append(ToFloatString(points[i].X));  		        sb.Append("'");  		        sb.Append(ToFloatString(points[i].Y));  		        sb.Append(" ");  	        }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,GenerateMinVertexZ,The following statement contains a magic number: if (useAutomaticVertexZ)              {                  switch (MapType)                  {                      case CCTileMapType.Iso:                          minVertexZ = -(LayerSize.Column + LayerSize.Row - 2);                          break;                      case CCTileMapType.Ortho:                          minVertexZ = -(LayerSize.Row - 1);                          break;                      case CCTileMapType.Staggered:                          minVertexZ = -(LayerSize.Row - 1);                          break;                      default:                          break;                  }              }              else                  minVertexZ = defaultTileVertexZ;
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The following statement contains a magic number: if (MapType == CCTileMapType.Hex || MapType == CCTileMapType.Staggered)              {                  CCPoint oddTransformedPoint = nodeToTileCoordsTransformOdd.Transform(offsetDiff).RoundToInteger();                    if ((MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1))                      transformedPoint = oddTransformedPoint;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The following statement contains a magic number: if (MapType == CCTileMapType.Hex || MapType == CCTileMapType.Staggered)              {                  CCPoint oddTransformedPoint = nodeToTileCoordsTransformOdd.Transform(offsetDiff).RoundToInteger();                    if ((MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1))                      transformedPoint = oddTransformedPoint;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The following statement contains a magic number: if ((MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1))                  return tileCoordsToNodeTransformOdd.Transform(tileCoords.Point);
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The following statement contains a magic number: if ((MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1))                  return tileCoordsToNodeTransformOdd.Transform(tileCoords.Point);
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ReplaceTileGIDQuad,The following statement contains a magic number: for (int i = 0' N = IndexBufferSize; i < N; i += 6)                  {                      int tileIndex = (indices[i] / NumOfCornersPerQuad) + TileStartIndex;                      var gidAndFlag = TileMapLayer.TileGIDAndFlagsArray[tileIndex];                        /*                      So here we're updating the underlying quadvertexbuffer after each quad change                      The alternative is to determine the min/max tile index and call QuadsVertexBuffer.UpdateBuffer() over that range.                      The assumption is that replacing tile gid quads is primarily used for animating tiles that share a common original gid.                      In particular' we would expect that animated tiles are small in number and/or sparsely spread out across the tile map                      e.g. Water tiles/trees/character/light source etc.                      So it's likely updating over a range would unnecessarily update a large number of unchanged quads                      */                      if (gidAndFlag.Gid == originalGid)                      {                          var replacementQuadGid = new CCTileGidAndFlags(gidOfQuadToUse' gidAndFlag.Flags);                          UpdateQuad(tileIndex' ref replacementQuadGid' true);                      }                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,The following statement contains a magic number: QuadsVertexBuffer.Data.Elements[adjustedStartVertexIndex + 2] = quad.TopRight;
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,The following statement contains a magic number: QuadsVertexBuffer.Data.Elements[adjustedStartVertexIndex + 3] = quad.BottomRight;
Magic Number,CocosSharp,CCTileSetInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileSetInfo.cs,TextureRectForGID,The following statement contains a magic number: if (gid != 0)              {                  // Rect offset relative to first gid                  gid -= FirstGid;                  rect.Size = TileTexelSize;                  var max_x = (int)((TilesheetSize.Width - BorderWidth * 2 + TileSpacing) / (TileTexelSize.Width + TileSpacing));                  rect.Origin.X = (gid % max_x) * (TileTexelSize.Width + TileSpacing) + BorderWidth;                  rect.Origin.Y = (gid / max_x) * (TileTexelSize.Height + TileSpacing) + BorderWidth;              }
Magic Number,CocosSharp,ArrayPool<T>,C:\repos\mono_CocosSharp\src\Platform\CCArrayPool.cs,Create,The following statement contains a magic number: if (pow)              {                  var l = 2;                  while (l < length)                   {                      l <<= 1;                  }                  length = l;              }
Magic Number,CocosSharp,CCDictMaker,C:\repos\mono_CocosSharp\src\Platform\CCDictMaker.cs,ArrayWithContentsOfFile,The following statement contains a magic number: TextHandler(parser' System.Text.UTF8Encoding.UTF8.GetBytes("root")' 4);
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CCDrawManager,The following statement contains a magic number: matrixStack = new Matrix[100];
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskLayer + 1 == 8) //DepthFormat.Depth24Stencil8              {                  if (maskOnceLog)                  {                      CCLog.Log(                          @"Nesting more than 8 stencils is not supported.                           Everything will be drawn without stencil for this node and its childs."                          );                      maskOnceLog = false;                  }                  return false;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskState.AlphaTreshold < 1f)              {                  AlphaTestEffect.AlphaFunction = CompareFunction.Greater;                  AlphaTestEffect.ReferenceAlpha = (byte)(255 * maskState.AlphaTreshold);                    PushEffect(AlphaTestEffect);              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: while (tmp.Capacity < elementCount)              {                  tmp.Capacity = tmp.Capacity * 2;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: tmp.Count = elementCount * 4;
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The following statement contains a magic number: vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage);
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVertices = new CCV3F_C4B[bufferSize - bufferSize % 3];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVertices = new CCV3F_C4B[bufferSize - bufferSize % 2];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (triangleVerts.Count > 0)              {                  var triangle = triangleVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangle' 0' triangle.Length / 3);                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (lineVerts.Count > 0)              {                  var line = lineVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.LineList' line' 0' line.Length / 2);              }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Push,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Add,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Insert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,FastInsert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				//Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[count] = Elements[index];  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: byte[] magicHeader = new byte[8];
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: data.Read(magicHeader' 0' 8);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: if (BitConverter.ToInt64 (magicHeader' 0) == 3472403351741427810) {  				using (BinaryReader reader = new BinaryReader(data))  				{  					byte[] plistData = reader.ReadBytes((int) reader.BaseStream.Length);  					Root = ReadBinary(plistData);  				}    			} else {  				//allow DTD but not try to resolve it from web  				var settings = new XmlReaderSettings () {  					DtdProcessing = DtdProcessing.Ignore'  					//ProhibitDtd = false'  #if !NETFX_CORE  					XmlResolver = null'  #endif  				};  				using (var reader = XmlReader.Create(data' settings))  					LoadFromXml (reader);  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: offsetTableBytes = bList.GetRange((int)offsetTableOffset' bList.Count - (int)offsetTableOffset - 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseOffsetTable,The following statement contains a magic number: for (int i = 0; i < offsetTableBytes.Count; i += offsetByteSize)  			{  				byte[] buffer = offsetTableBytes.GetRange(i' offsetByteSize).ToArray();  				Array.Reverse(buffer);  				offsetTable.Add(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,GetCount,The following statement contains a magic number: if (headerByteTrail < 15)  			{  				count = headerByteTrail;  				newBytePosition = bytePosition + 1;  			}  			else  				count = ((PlistInteger)ParseBinaryInt(bytePosition + 1' out newBytePosition)).AsInt;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinary,The following statement contains a magic number: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDate,The following statement contains a magic number: byte[] buffer = objectTable.GetRange(headerPosition + 1' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: return new PlistInteger(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: return new PlistReal((float)BitConverter.ToDouble(RegulateNullBytes(buffer' 8)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: charCount = charCount * 2;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: for (int i = 0; i < charCount; i+=2)  			{  				one = objectTable.GetRange(charStartPosition+i'1)[0];  				two = objectTable.GetRange(charStartPosition + i+1' 1)[0];    				if (BitConverter.IsLittleEndian)  				{  					buffer[i] = two;  					buffer[i + 1] = one;  				}  				else  				{  					buffer[i] = one;  					buffer[i + 1] = two;  				}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ConvertFromAppleTimeStamp,The following statement contains a magic number: DateTime origin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: R = (byte)CCMathHelper.Clamp(red * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: G = (byte)CCMathHelper.Clamp(green * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: B = (byte)CCMathHelper.Clamp(blue * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: A = (byte)CCMathHelper.Clamp(alpha * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCV3F_C4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B_T2F,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F_Quad,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B_T2F_Quad,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: currentBatchedQuads = new CCRawList<CCV3F_C4B_T2F_Quad>(256' false);
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: quadCommands = new CCRawList<CCQuadCommand>(256' false);
Magic Number,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,GenerateMaterialId,The following statement contains a magic number: materialId = (uint)textureId << 12 | (uint)BlendType.GetHashCode();
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: time = time * 2;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: if (time < 0.5f)              {                  time = time * 2;                  return (1 - BounceOut(1 - time)) * 0.5f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: return BounceOut(time * 2 - 1) * 0.5f + 0.5f;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschьtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToDegrees,The following statement contains a magic number: return (float)(radians * 57.295779513082320876798154814105);
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToRadians,The following statement contains a magic number: return (float)(degrees * 0.017453292519943295769236907684886);
Magic Number,CocosSharp,CCRandom,C:\repos\mono_CocosSharp\src\Math\CCRandom.cs,Float_Minus1_1,The following statement contains a magic number: return (float)(_random.NextDouble() * 2.0 - 1.0);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Draw,The following statement contains a magic number: if (isEnabled) {                  totalFrames++;                  totalDrawCount++;                  totalDrawTime += (float)stopwatch.Elapsed.TotalMilliseconds - startTime;                    if (isGCEnabled && !gcWeakRef.IsAlive) {                      gcCounter++;                      gcWeakRef = new WeakReference (new object ());                  }                    if (isInitialized) {                      if (deltaAll > 1.0f) {                          var mem = GC.GetTotalMemory (false);                          var upd = totalUpdateTime / updateCount;                          var drw = totalDrawTime / totalDrawCount;                          var fps = totalDrawCount / deltaAll;                            fpsLabel.Text =        String.Format ("             {0:0} FPS"' fps);                          updateTimeLabel.Text = String.Format ("Update time: {0:0.000} ms"' upd);                          drawTimeLabel.Text =   String.Format ("Draw time:   {0:0.000} ms"' drw);                          drawCallLabel.Text =   String.Format ("Drawcalls:   {0}"' gameView.DrawManager.DrawCount);                          memoryLabel.Text =     String.Format ("Memory:      {0} B ({1} kB)"' mem' mem / 1024);                          gcLabel.Text =         String.Format ("Garbage:     #{0}"' gcCounter);                            deltaAll = totalDrawTime = totalUpdateTime = 0;                          totalDrawCount = updateCount = 0;                            drawTimeLabel.Color = drw > 16.666f ? warnColor : whiteColor;                          updateTimeLabel.Color = upd > 16.666f ? warnColor : whiteColor;                          fpsLabel.Color = fps < 30 ? warnColor : whiteColor;                      }                        var scene = gameView.Director.RunningScene;                      drawCallLabel.Scene = scene;                      fpsLabel.Scene = scene;                      updateTimeLabel.Scene = scene;                      drawTimeLabel.Scene = scene;                      memoryLabel.Scene = scene;                      gcLabel.Scene = scene;                        drawCallLabel.Visit ();                      fpsLabel.Visit ();                      updateTimeLabel.Visit ();                      drawTimeLabel.Visit ();                      memoryLabel.Visit ();                      gcLabel.Visit ();                  }              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Draw,The following statement contains a magic number: if (isEnabled) {                  totalFrames++;                  totalDrawCount++;                  totalDrawTime += (float)stopwatch.Elapsed.TotalMilliseconds - startTime;                    if (isGCEnabled && !gcWeakRef.IsAlive) {                      gcCounter++;                      gcWeakRef = new WeakReference (new object ());                  }                    if (isInitialized) {                      if (deltaAll > 1.0f) {                          var mem = GC.GetTotalMemory (false);                          var upd = totalUpdateTime / updateCount;                          var drw = totalDrawTime / totalDrawCount;                          var fps = totalDrawCount / deltaAll;                            fpsLabel.Text =        String.Format ("             {0:0} FPS"' fps);                          updateTimeLabel.Text = String.Format ("Update time: {0:0.000} ms"' upd);                          drawTimeLabel.Text =   String.Format ("Draw time:   {0:0.000} ms"' drw);                          drawCallLabel.Text =   String.Format ("Drawcalls:   {0}"' gameView.DrawManager.DrawCount);                          memoryLabel.Text =     String.Format ("Memory:      {0} B ({1} kB)"' mem' mem / 1024);                          gcLabel.Text =         String.Format ("Garbage:     #{0}"' gcCounter);                            deltaAll = totalDrawTime = totalUpdateTime = 0;                          totalDrawCount = updateCount = 0;                            drawTimeLabel.Color = drw > 16.666f ? warnColor : whiteColor;                          updateTimeLabel.Color = upd > 16.666f ? warnColor : whiteColor;                          fpsLabel.Color = fps < 30 ? warnColor : whiteColor;                      }                        var scene = gameView.Director.RunningScene;                      drawCallLabel.Scene = scene;                      fpsLabel.Scene = scene;                      updateTimeLabel.Scene = scene;                      drawTimeLabel.Scene = scene;                      memoryLabel.Scene = scene;                      gcLabel.Scene = scene;                        drawCallLabel.Visit ();                      fpsLabel.Visit ();                      updateTimeLabel.Visit ();                      drawTimeLabel.Visit ();                      memoryLabel.Visit ();                      gcLabel.Visit ();                  }              }
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,SplitWithForm,The following statement contains a magic number: do  			{  				if (pStr == null)  				{  					break;  				}  				  				// string is empty  				string content = pStr;  				if (content.Length == 0)  				{  					break;  				}  				  				int nPosLeft = content.IndexOf('{');  				int nPosRight = content.IndexOf('}');  				  				// don't have '{' and '}'  				if (nPosLeft == -1 || nPosRight == -1)  				{  					break;  				}  				// '}' is before '{'  				if (nPosLeft > nPosRight)  				{  					break;  				}  				  				string pointStr = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);  				// nothing between '{' and '}'  				if (pointStr.Length == 0)  				{  					break;  				}  				  				int nPos1 = pointStr.IndexOf('{');  				int nPos2 = pointStr.IndexOf('}');  				// contain '{' or '}'   				if (nPos1 != -1 || nPos2 != -1) break;  				  				Split(pointStr' "'"' strs);  				if (strs.Count != 2 || strs[0].Length == 0 || strs[1].Length == 0)  				{  					strs.Clear();  					break;  				}  				  				bRet = true;  			} while (false);
Magic Number,CocosSharp,CCRectConverter,C:\repos\mono_CocosSharp\src\Support\Converters\CCRectConverter.cs,CCRectFromString,The following statement contains a magic number: do              {                  if (rectSpec == null)                  {                      break;                  }                    string content = rectSpec;                    // find the first '{' and the third '}'                  int nPosLeft = content.IndexOf('{');                  int nPosRight = content.IndexOf('}');                  for (int i = 1; i < 3; ++i)                  {                      if (nPosRight == -1)                      {                          break;                      }                      nPosRight = content.IndexOf('}'' nPosRight + 1);                  }                  if (nPosLeft == -1 || nPosRight == -1)                  {                      break;                  }                  content = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);                  int nPointEnd = content.IndexOf('}');                  if (nPointEnd == -1)                  {                      break;                  }                  nPointEnd = content.IndexOf('''' nPointEnd);                  if (nPointEnd == -1)                  {                      break;                  }                    // get the point string and size string                  string pointStr = content.Substring(0' nPointEnd);                  string sizeStr = content.Substring(nPointEnd + 1);                  //' content.Length - nPointEnd                  // split the string with '''                  List<string> pointInfo = new List<string>();                    if (!CCUtils.SplitWithForm(pointStr' pointInfo))                  {                      break;                  }                  List<string> sizeInfo = new List<string>();                  if (!CCUtils.SplitWithForm(sizeStr' sizeInfo))                  {                      break;                  }                    float x = CCUtils.CCParseFloat(pointInfo[0]);                  float y = CCUtils.CCParseFloat(pointInfo[1]);                  float width = CCUtils.CCParseFloat(sizeInfo[0]);                  float height = CCUtils.CCParseFloat(sizeInfo[1]);                    result = new CCRect(x' y' width' height);              } while (false);
Magic Number,CocosSharp,CCImageTGA,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,CCImageTGA,The following statement contains a magic number: for (int i = 0; i < tex.Height / 2; i++)  			{  				Array.Copy(ImageData' i * tex.Width' tmp' 0' tex.Width);  				Array.Copy(ImageData' (tex.Height - i - 1) * tex.Width' ImageData' i * tex.Width' tex.Width);  				Array.Copy(tmp' 0' ImageData' (tex.Height - i - 1) * tex.Width' tex.Width);  			}
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,ReadShort,The following statement contains a magic number: return (short)(buffer[position] | buffer[position + 1] << 8);
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: int headerSkip = (1 + 2) * 6;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: int headerSkip = (1 + 2) * 6;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: mode = psInfo.PixelDepth / 8;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: var m = new float[16];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[4] = t.C;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[12] = t.Tx;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[5] = t.D;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[13] = t.Ty;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.C = m[4];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Tx = m[12];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.D = m[5];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Ty = m[13];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var data = new byte[8];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var dataLen = stream.Read(data' 0' 8);
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 3)              {                  if (data[0] == 0x47 && data[1] == 0x49 && data[1] == 0x46)                  {                      return CCImageFormat.Gif;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if ((data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d))                  {                      return CCImageFormat.Tiff;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if (data[0] == 0xff && data[1] == 0xd8)                  {                      return CCImageFormat.Jpg;                  }              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\Textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\Textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: CCLog.Log("{0} textures' for {1} KB ({2:00.00} MB)"' count' total / 1024' total / (1024f * 1024f));
Magic Number,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff);                          s2 += s1;                      } while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      s1 += (buf[index++] & 0xff);                      s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff);                          s2 += s1;                      } while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < L_CODES; i++)                  dyn_ltree[i * 2] = 0;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < D_CODES; i++)                  dyn_dtree[i * 2] = 0;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < BL_CODES; i++)                  bl_tree[i * 2] = 0;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138;                  min_count = 3;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138;                  min_count = 3;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short) SupportClass.Identity(0xffff);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138;                  min_count = 3;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138;                  min_count = 3;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen;                  nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      } while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree);                          count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0;                  prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138;                      min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6;                      min_count = 3;                  }                  else                  {                      max_count = 7;                      min_count = 4;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte) (SupportClass.URShift(w' 8)));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte) (b >> 8));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte) dist;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff;                      lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  } while (lx < last_lit);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff;                      lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  } while (lx < last_lit);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff;                      lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  } while (lx < last_lit);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2];                  n++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2];                  n++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2];                  n++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2];                  n++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < LITERALS)              {                  bin_freq += dyn_ltree[n * 2];                  n++;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte) (bin_freq > (SupportClass.URShift(ascii_freq' 2)) ? Z_BINARY : Z_ASCII);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte) bi_buf);                  bi_buf = (short) (SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte) bi_buf);                  bi_buf = (short) (SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte) bi_buf);                  bi_buf = (short) (SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte) bi_buf);                  bi_buf = (short) (SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  put_short(bi_buf);              }              else if (bi_valid > 0)              {                  put_byte((byte) bi_buf);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)              {                  max_block_size = pending_buf_size - 5;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)              {                  max_block_size = pending_buf_size - 5;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short) strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 &&                          (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) &                                      hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short) strstart;                          }                      } while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short) strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 &&                          (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) &                                      hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short) strstart;                          }                      } while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short) strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 &&                          (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) &                                      hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short) strstart;                          }                      } while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= good_match)              {                  chain_length >>= 2;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: do              {                  match = cur_match;                    // Skip to next match if the match length cannot increase                  // or if the match length is less than 2:                  if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] || window[++match] != window[scan + 1])                      continue;                    // The check at best_len-1 can be removed because it will be made                  // again later. (This heuristic is not always a win.)                  // It is not necessary to compare scan[2] and match[2] since they                  // are always equal when the other bytes match' given that                  // the hash keys are equal and that HASH_BITS >= 8.                  scan += 2;                  match++;                    // We check for insufficient lookahead only every 8th comparison;                  // the 256th check will be made at strstart+258.                  do                  {                  } while (window[++scan] == window[++match] && window[++scan] == window[++match] &&                           window[++scan] == window[++match] && window[++scan] == window[++match] &&                           window[++scan] == window[++match] && window[++scan] == window[++match] &&                           window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);                    len = MAX_MATCH - (strend - scan);                  scan = strend - MAX_MATCH;                    if (len > best_len)                  {                      match_start = cur_match;                      best_len = len;                      if (len >= nice_match)                          break;                      scan_end1 = window[scan + best_len - 1];                      scan_end = window[scan + best_len];                  }              } while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)                  level = 6;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 ||                  level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 ||                  level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 ||                  level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION)              {                  _level = 6;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                      // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int) (strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,CocosSharp.Compression.Zlib,Deflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0;                                  m = (q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write;                                  m = (q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0;                                      m = (q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t;                          n -= t;                          q += t;                          m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                            {                              b = SupportClass.URShift(b' (14));                              k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3));                                  k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                  int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == - 1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t));                                  k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b;                                          bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t));                                  k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i));                                  k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b;                                      bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  } while (--j != 0);                                  index = i;                              }                          }                            tb[0] = - 1;                          {                              var bl = new int[1];                              var bd = new int[1];                              var tl = new int[1];                              var td = new int[1];                                  bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl'                                                                td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index;                          n = z.avail_in;                          b = bitb;                          k = bitk;                          q = write;                          m = (q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write;                          m = (q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b;                              bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            bitb = b;                          bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                          // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START: // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index;                              n = z.avail_in;                              b = s.bitb;                              k = s.bitk;                              q = s.write;                              m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN: // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case LENEXT: // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST: // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case DISTEXT: // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY: // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q;                                      r = s.inflate_flush(z' r);                                      q = s.write;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0;                                          m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b;                                          s.bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index;                                          z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++];                              m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT: // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q;                                  r = s.inflate_flush(z' r);                                  q = s.write;                                  m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0;                                      m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b;                                      s.bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index;                                      z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte) lit;                          m--;                            mode = START;                          break;                        case WASH: // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q;                          r = s.inflate_flush(z' r);                          q = s.write;                          m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b;                              s.bitk = k;                              z.avail_in = n;                              z.total_in += p - z.next_in_index;                              z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          case BADCODE: // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                          default:                          r = Z_STREAM_ERROR;                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k;                      k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]);                      k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                            b >>= e;                          k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e);                                  k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++];                                          c--; // minimum count is three'                                          s.window[q++] = s.window[r++];                                          c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2;                                          r += 2;                                          c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      } while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              } while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e;                                              r += e;                                              e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      } while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c;                                      r += c;                                      c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n;                                  c = (k >> 3) < c ? k >> 3 : c;                                  n += c;                                  p -= c;                                  k -= (c << 3);                                    s.bitb = b;                                  s.bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          } while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]);                              k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n;                          c = (k >> 3) < c ? k >> 3 : c;                          n += c;                          p -= c;                          k -= (c << 3);                            s.bitb = b;                          s.bitk = k;                          z.avail_in = n;                          z.total_in += p - z.next_in_index;                          z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  } while (true);              } while (m >= 258 && n >= 10);
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)              {                  inflateEnd(z);                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)              {                  inflateEnd(z);                  return Z_STREAM_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r;                          r = f;                            z.avail_in--;                          z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.next_in[p] == mark[m])                  {                      m++;                  }                  else if (z.next_in[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++;                  n--;              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.next_in[p] == mark[m])                  {                      m++;                  }                  else if (z.next_in[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++;                  n--;              }
Magic Number,CocosSharp.Compression.Zlib,Inflate,C:\repos\mono_CocosSharp\src\Platform\Zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4)              {                  return Z_DATA_ERROR;              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: var r = new int[3];
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte) j; // bits in this table                              r[1] = (byte) l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte) (k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte) (v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: var v = new int[19];
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: var v = new int[288];
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,CocosSharp.Compression.Zlib,InfTree,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || (bd[0] == 0 && nl > 257))              {                  if (r == Z_DATA_ERROR)                  {                      z.msg = "oversubscribed distance tree";                  }                  else if (r == Z_BUF_ERROR)                  {                      z.msg = "incomplete distance tree";                      r = Z_DATA_ERROR;                  }                  else if (r != Z_MEM_ERROR)                  {                      z.msg = "empty distance tree with lengths";                      r = Z_DATA_ERROR;                  }                  return r;              }
Magic Number,CocosSharp.Compression.Zlib,SupportClass,C:\repos\mono_CocosSharp\src\Platform\Zlib\SupportClass.cs,URShift,The following statement contains a magic number: if (number >= 0)                  return number >> bits;              else                  return (number >> bits) + (2 << ~bits);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length;                      overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length;                      overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length;                      overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length;                      overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length;                      overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do              {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              } while (overflow > 0);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do              {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              } while (overflow > 0);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)                  s.pqdownheap(tree' n);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte) (Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              } while (s.heap_len >= 2);
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));              }
Magic Number,CocosSharp.Compression.Zlib,Tree,C:\repos\mono_CocosSharp\src\Platform\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));              }
Magic Number,CocosSharp.Compression.Zlib,ZInputStream,C:\repos\mono_CocosSharp\src\Platform\Zlib\ZInputStream.cs,Skip,The following statement contains a magic number: int len = 512;
Duplicate Code,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method contains a code clone-set at the following line numbers (starting from the method definition): ((60' 80)' (85' 105))
Duplicate Code,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,OnConfigLoad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((40' 65)' (83' 108))
Duplicate Code,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46)' (29' 48))
Duplicate Code,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 45)' (19' 47))
Duplicate Code,CocosSharp.Compression.Zlib,Adler32,C:\repos\mono_CocosSharp\src\Platform\Zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 36)' (21' 40)' (23' 42)' (25' 44)' (27' 46)' (29' 48))
Duplicate Code,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 49)' (274' 294))
Duplicate Code,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((30' 49)' (121' 140))
Duplicate Code,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((30' 49)' (121' 140)' (223' 242)' (275' 294)' (348' 367)' (390' 409))
Duplicate Code,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((30' 49)' (223' 242)' (348' 367)' (390' 409))
Duplicate Code,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((121' 141)' (223' 243)' (275' 295)' (348' 368)' (390' 410))
Duplicate Code,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((60' 82)' (163' 185))
Duplicate Code,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((61' 80)' (131' 150))
Duplicate Code,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((61' 80)' (131' 150)' (164' 183)' (220' 239))
Duplicate Code,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((61' 80)' (220' 239)' (131' 150)' (164' 183))
Duplicate Code,CocosSharp.Compression.Zlib,InfCodes,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((130' 149)' (219' 238))
Missing Default,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AddedToScene,The following switch statement is missing a default case: switch(alignmentState.Alignment)                  {                      case Alignment.Vertical:                          AlignItemsVertically(alignmentState.Padding);                          break;                      case Alignment.Horizontal:                          AlignItemsHorizontally(alignmentState.Padding);                          break;                      case Alignment.Column:                          AlignItemsInColumns(alignmentState.NumberOfItemsPer);                          break;                      case Alignment.Row:                          AlignItemsInRows(alignmentState.NumberOfItemsPer);                          break;                  }
Missing Default,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following switch statement is missing a default case: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Missing Default,CocosSharp,CCOGLES,C:\repos\mono_CocosSharp\src\Platform\CCOGLES.cs,GetXNABlend,The following switch statement is missing a default case: switch (glBlend)              {                  case GL_ZERO:                      return Blend.Zero;                  case GL_ONE:                      return Blend.One;                  case GL_SRC_COLOR:                      return Blend.SourceColor;                  case GL_ONE_MINUS_SRC_COLOR:                      return Blend.InverseSourceColor;                  case GL_SRC_ALPHA:                      return Blend.SourceAlpha;                  case GL_ONE_MINUS_SRC_ALPHA:                      return Blend.InverseSourceAlpha;                  case GL_DST_ALPHA:                      return Blend.DestinationAlpha;                  case GL_ONE_MINUS_DST_ALPHA:                      return Blend.InverseDestinationAlpha;                    /* BlendingFactorSrc */                  /*      GL_ZERO */                  /*      GL_ONE */                  case GL_DST_COLOR:                      return Blend.DestinationColor;                  case GL_ONE_MINUS_DST_COLOR:                      return Blend.InverseDestinationColor;                  case GL_SRC_ALPHA_SATURATE:                      return Blend.SourceAlphaSaturation;              }
Missing Default,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinary,The following switch statement is missing a default case: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Missing Default,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,ParseXMLFile,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.Element:  						key = reader.Name;  						break;  					case XmlNodeType.Text:  						values.Add(key' reader.Value);  						break;  					case XmlNodeType.XmlDeclaration:  					case XmlNodeType.ProcessingInstruction:  						break;  					case XmlNodeType.Comment:  						break;  					case XmlNodeType.EndElement:  						break;  					}
Missing Default,CocosSharp,ZipUtils,C:\repos\mono_CocosSharp\src\Support\ZipSupport\ZipUtils.cs,Inflate,The following switch statement is missing a default case: switch (format)               {              case CompressionFormat.Zlib:                    try {                      try {                          using (var deflateStream = new ZlibStream (dataStream' MonoGame.Utilities.CompressionMode.Decompress))                           {                              outputBytes = StreamToByteArray(deflateStream);                          }                      }                       catch (Exception exc)                       {                          CCLog.Log ("Error decompressing image data: " + exc.Message);                      }                    }                   catch (Exception exc)                   {                      CCLog.Log ("Error decompressing image data: " + exc.Message);                  }                  break;              case CompressionFormat.Gzip:                    try                   {                      #if !WINDOWS_PHONE                      using (var gzipInputStream = new GZipInputStream(dataStream' System.IO.Compression.CompressionMode.Decompress))                      #else                      using (var gzipInputStream = new GZipInputStream(dataStream))                      #endif                      {                          outputBytes = StreamToByteArray(gzipInputStream);                      }                  }                   catch (Exception exc)                   {                      CCLog.Log ("Error decompressing image data: " + exc.Message);                  }                  break;              }
Missing Default,CocosSharp.Compression.Zlib,InfBlocks,C:\repos\mono_CocosSharp\src\Platform\Zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))                          {                              case 0: // stored                                   {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                    {                                      b = SupportClass.URShift(b' (t));                                      k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1: // fixed                                  {                                      var bl = new int[1];                                      var bd = new int[1];                                      var tl = new int[1][];                                      var td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2: // dynamic                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3: // illegal                                    {                                      b = SupportClass.URShift(b' (3));                                      k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b;                                  bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index;                                  z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }
