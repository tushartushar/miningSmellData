Implementation smell,Namespace,Class,File,Method,Description
Long Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,The method has 123 lines of code.
Long Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,LayoutLabel,The method has 168 lines of code.
Long Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchTouchEvent,The method has 176 lines of code.
Long Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The method has 116 lines of code.
Long Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The method has 116 lines of code.
Long Method,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The method has 114 lines of code.
Long Method,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The method has 141 lines of code.
Long Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The method has 115 lines of code.
Long Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,The method has 129 lines of code.
Complex Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,LayoutLabel,Cyclomatic complexity of the method is 21
Complex Method,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchTouchEvent,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,VisitTarget,Cyclomatic complexity of the method is 12
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,UpdateListeners,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,Cyclomatic complexity of the method is 13
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,Cyclomatic complexity of the method is 22
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Unschedule,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,PauseAllTargets,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,Cyclomatic complexity of the method is 22
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Unschedule,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,PauseAllTargets,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,UpdateTransform,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTLTextLayout,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCTextLayout.cs,SuggestLineBreak,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCLayer,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayer.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,CocosSharp,CCNodeGrid,C:\repos\mono_CocosSharp\src\Nodes\Other\CCNodeGrid.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,UpdateGravityParticles,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,UpdateRadialParticles,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCMaskedSprite,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCMaskedSprite.cs,CollidesWith,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadAppleDictionary,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseMultilineShape,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,SetTileGID,Cyclomatic complexity of the method is 8
Complex Method,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,Cyclomatic complexity of the method is 9
Complex Method,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,Cyclomatic complexity of the method is 10
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,Cyclomatic complexity of the method is 14
Complex Method,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,Cyclomatic complexity of the method is 9
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' size' alignment' imageOffset
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 6 parameters. Parameters: str' fntFile' size' alignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' size' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' dimensions' hAlignment' vAlignement
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' dimensions' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 5 parameters. Parameters: str' fntFile' size' dimensions' labelFormat
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 6 parameters. Parameters: str' fntFile' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has 7 parameters. Parameters: str' fntFile' size' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,InitBMFont,The method has 7 parameters. Parameters: theString' fntFile' dimensions' hAlignment' vAlignment' imageOffset' texture
Long Parameter List,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,InitSpriteFont,The method has 7 parameters. Parameters: theString' fntFile' fontSize' dimensions' labelFormat' imageOffset' texture
Long Parameter List,CocosSharp,CCOrbitCamera,C:\repos\mono_CocosSharp\src\Actions\Camera\CCOrbitCamera.cs,CCOrbitCamera,The method has 7 parameters. Parameters: t' radius' deltaRadius' angleZ' deltaAngleZ' angleX' deltaAngleX
Long Parameter List,CocosSharp,CCRipple3D,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCRipple3D.cs,CCRipple3D,The method has 6 parameters. Parameters: duration' gridSize' position' radius' waves' amplitude
Long Parameter List,CocosSharp,CCTwirl,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCTwirl.cs,CCTwirl,The method has 5 parameters. Parameters: duration' gridSize' position' twirls' amplitude
Long Parameter List,CocosSharp,CCWaves,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,CCWaves,The method has 6 parameters. Parameters: duration' gridSize' waves' amplitude' horizontal' vertical
Long Parameter List,CocosSharp,CCActionTween,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCActionTween.cs,CCActionTween,The method has 5 parameters. Parameters: duration' key' from' to' tweenAction
Long Parameter List,CocosSharp,CCTimer,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,CCTimer,The method has 6 parameters. Parameters: scheduler' target' selector' seconds' repeat' delay
Long Parameter List,CocosSharp,CCTimer,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,CCTimer,The method has 6 parameters. Parameters: scheduler' target' selector' seconds' repeat' delay
Long Parameter List,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Schedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Schedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCAffineTransform,C:\repos\mono_CocosSharp\src\Math\CCAffineTransform.cs,CCAffineTransform,The method has 7 parameters. Parameters: a' b' c' d' tx' ty' tz
Long Parameter List,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,LineIntersect,The method has 6 parameters. Parameters: A' B' C' D' S' T
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,CocosSharp,CCVector2,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,Transform,The method has 6 parameters. Parameters: sourceArray' sourceIndex' matrix' destinationArray' destinationIndex' length
Long Parameter List,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,AddLazySchedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,lazySchedule,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,lazySchedule,The method has 6 parameters. Parameters: selector' target' interval' repeat' delay' paused
Long Parameter List,CocosSharp,CCLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabelAtlas.cs,CCLabelAtlas,The method has 5 parameters. Parameters: label' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabelAtlas.cs,CCLabelAtlas,The method has 5 parameters. Parameters: label' texture' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCMenuItemLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelAtlas,The method has 7 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap' updatable' target
Long Parameter List,CocosSharp,CCMenuItemLabelAtlas,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelAtlas,The method has 5 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidArc,The method has 5 parameters. Parameters: pos' radius' startAngle' sweepAngle' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSegment,The method has 5 parameters. Parameters: from' to' radius' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSegment,The method has 5 parameters. Parameters: from' to' radius' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawLine,The method has 5 parameters. Parameters: from' to' lineWidth' color' lineCap
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The method has 6 parameters. Parameters: x' y' width' height' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipticalArc,The method has 6 parameters. Parameters: arcRect' lambda1' lambda2' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipticalArc,The method has 9 parameters. Parameters: x' y' width' height' lambda1' lambda2' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCubicBezier,The method has 7 parameters. Parameters: origin' control1' control2' destination' segments' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawQuadBezier,The method has 6 parameters. Parameters: origin' control' destination' segments' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method has 6 parameters. Parameters: verts' count' fillColor' borderWidth' borderColor' closePolygon
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method has 6 parameters. Parameters: verts' count' fillColor' borderWidth' borderColor' closePolygon
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The method has 11 parameters. Parameters: start' x' y' width' height' startAngle' endAngle' antialiasing' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The method has 11 parameters. Parameters: x' y' width' height' startAngle' sweepAngle' convert_units' antialiasing' isPieSlice' lineWidth' color
Long Parameter List,CocosSharp,StringData,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,StringData,The method has 5 parameters. Parameters: x' y' s' args' color
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' path
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The method has 5 parameters. Parameters: fade' minSegIn' strokeIn' color' texture
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineIntersect,The method has 9 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Dx' Dy' T
Long Parameter List,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The method has 5 parameters. Parameters: points' stroke' vertices' offset' nuPoints
Long Parameter List,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,CCRenderTexture,The method has 5 parameters. Parameters: contentSize' textureSizeInPixels' colorFormat' depthFormat' usage
Long Parameter List,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,BeginWithClear,The method has 6 parameters. Parameters: r' g' b' a' depth' stencil
Long Parameter List,CocosSharp,CCSpriteFrame,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrame.cs,CCSpriteFrame,The method has 5 parameters. Parameters: contentSize' texture' textureRectInPxls' rotated' offsetInPxls
Long Parameter List,CocosSharp,CCSpriteFrame,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrame.cs,CCSpriteFrame,The method has 6 parameters. Parameters: contentSize' texture' textureRectInPxls' originalSizeInPxls' rotated' offsetInPxls
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 5 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 6 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' labelFormat
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 6 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' vAlignment
Long Parameter List,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,CCTextField,The method has 7 parameters. Parameters: text' fontName' fontSize' dimensions' hAlignment' vAlignment' labelFormat
Long Parameter List,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,CCTileMapLayer,The method has 5 parameters. Parameters: tileSetInfos' layerInfo' mapInfo' layerSize' totalNumberOfTiles
Long Parameter List,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,CCTileMapLayer,The method has 6 parameters. Parameters: tileSetInfos' layerInfo' mapInfo' layerSize' totalNumberOfTiles' tileCapacity
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawIndexedPrimitives,The method has 7 parameters. Parameters: primitiveType' vertexData' vertexOffset' numVertices' indexData' indexOffset' primitiveCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawRawBuffer,The method has 6 parameters. Parameters: vertexBuffer' vStart' vCount' indexBuffer' iStart' iCount
Long Parameter List,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' colorFormat' depthFormat' usage
Long Parameter List,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The method has 5 parameters. Parameters: leftButton' upButton' rightButton' downButton' player
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 5 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quads
Long Parameter List,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,CCQuadCommand,The method has 6 parameters. Parameters: globalDepth' worldTransform' texture' blendType' quadCount' quads
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CubicBezier,The method has 5 parameters. Parameters: a' b' c' d' t
Long Parameter List,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,CCTexture2D,The method has 5 parameters. Parameters: pixelsWide' pixelsHigh' pixelFormat' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,CCTexture2D,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The method has 6 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The method has 7 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' ContentSizeInPixelsIn
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithString,The method has 6 parameters. Parameters: text' dimensions' hAlignment' vAlignment' fontName' fontSize
Long Parameter List,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,LoadRawData,The method has 5 parameters. Parameters: data' width' height' pixelFormat' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddRawImage,The method has 7 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap
Long Parameter List,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddRawImage,The method has 8 parameters. Parameters: data' width' height' assetName' format' premultiplied' mipMap' contentSize
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CreateRenderTarget,The method has 5 parameters. Parameters: width' height' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabel,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,RenderLabelToStream,The method has 8 parameters. Parameters: imageWidth' imageHeight' foregroundColor' origin' textLayout' dpi' format' alpha
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The method has 7 parameters. Parameters: amplitude' x' y' radX' radY' sigmaX' sigmaY
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 6 parameters. Parameters: value1' value2' value3' amount1' amount2' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Barycentric,The method has 5 parameters. Parameters: value1' value2' value3' amount1' amount2
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 6 parameters. Parameters: value1' tangent1' value2' tangent2' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Hermite,The method has 5 parameters. Parameters: value1' tangent1' value2' tangent2' amount
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 6 parameters. Parameters: value1' value2' value3' value4' amount' result
Long Parameter List,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The method has 5 parameters. Parameters: value1' value2' value3' value4' amount
Long Identifier,CocosSharp,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\Platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,,The length of the parameter AutorepeatIncreaseTimeIncrement is 31.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter targetVisibleDimensionsWorldspace is 33.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,CCCamera,The length of the parameter cameraCenterPositionWorldspaceIn is 32.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,UpdatePerspectiveCameraTargetBounds,The length of the parameter targetVisibleBoundsWorldspaceIn is 31.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,UpdatePerspectiveCameraTargetBounds,The length of the parameter targetVisibleDimensionsWorldspaceIn is 35.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter defaultNearAndFarOrthoClipping is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter defaultNearAndFarPerspClipping is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter orthographicViewSizeWorldspace is 30.
Long Identifier,CocosSharp,CCCamera,C:\repos\mono_CocosSharp\src\Camera\CCCamera.cs,,The length of the parameter nearAndFarOrthographicZClipping is 31.
Long Identifier,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,,The length of the parameter ParticleStartSizeEqualToEndSize is 31.
Long Identifier,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,,The length of the parameter ParticleStartRadiusEqualToEndRadius is 35.
Long Identifier,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,,The length of the parameter SceneNodeContainerToBeModified is 30.
Long Identifier,CocosSharp,CCSprite,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSprite.cs,,The length of the parameter unflippedOffsetPositionFromCenter is 33.
Long Identifier,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,,The length of the parameter activeTileAnimationActionStates is 31.
Long Identifier,CocosSharp,CCMacros,C:\repos\mono_CocosSharp\src\Predefine\CCMacros.cs,,The length of the parameter CCDirectorStatsUpdateIntervalInSeconds is 38.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Identifier,SharpDX,CCLabel_Renderer81,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,,The length of the parameter d2dResourceCreationDeviceContext is 32.
Long Statement,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,AddIncomingMouse,The length of the statement  "                    var mouse = new CCEventMouse(((buttons == CCMouseButton.None) ? CCMouseEventType.MOUSE_MOVE : CCMouseEventType.MOUSE_DOWN)' " is 123.
Long Statement,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,UpdateViewport,The length of the statement  "            defaultViewMatrix = XnaMatrix.CreateLookAt(new CCPoint3(center' 300.0f).XnaVector' new CCPoint3(center' 0.0f).XnaVector' Vector3.Up); " is 133.
Long Statement,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,SaveToFile,The length of the statement  "                //// Use InitializeFromFilename to write to a file. If there is need to write inside the memory' use InitializeFromMemory.  " is 122.
Long Statement,CocosSharp,CCCallFuncNState,C:\repos\mono_CocosSharp\src\Actions\Instants\callfunc\CCCallFuncN.cs,Execute,The length of the statement  "            //    CCScriptEngineManager::sharedManager()->getScriptEngine()->executeFunctionWithobject(m_nScriptHandler' m_pTarget' "CCNode"); " is 130.
Long Statement,CocosSharp,CCAnimateState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCAnimate.cs,Update,The length of the statement  "                        //TODO: [[NSNotificationCenter defaultCenter] postNotificationName:CCAnimationFrameDisplayedNotification object:target_ userInfo:dict]; " is 135.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,GetListenerID,The length of the statement  "                // Touch listener is very special' it contains two kinds of listeners' EventListenerTouchOneByOne and EventListenerTouchAllAtOnce. " is 130.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "            Debug.Assert(fixedPriority != 0' "0 priority is forbidden for fixed priority since it's used for scene graph based priority."); " is 127.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,AddEventListener,The length of the statement  "                CCLog.Log("-----  Add > --  Available > " + listener.IsAvailable + " ------{0}------{1}---------"' listener' listener.SceneGraphPriority); " is 138.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' nodePriorityMap[l.SceneGraphPriority]' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 244.
Long Statement,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,SortEventListenersOfSceneGraphPriority,The length of the statement  "            //                    CCLog.Log("listener priority: node ({0}[{1}])' priority {2}' localZ {3}' globalZ {4}"' l.SceneGraphPriority' l.SceneGraphPriority.Name' -1' l.SceneGraphPriority.LocalZOrder' l.SceneGraphPriority.GlobalZOrder); " is 231.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunAction,The length of the statement  "            return ActionManager != null ? ActionManager.AddAction(action' this' !IsRunning) : AddLazyAction(action' this' !IsRunning); " is 123.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActionAsync,The length of the statement  "            state = ActionManager != null ? ActionManager.AddAction (asyncAction' this' !IsRunning) : AddLazyAction(asyncAction' this' !IsRunning); " is 135.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActions,The length of the statement  "            return ActionManager != null ? ActionManager.AddAction (action' this' !IsRunning) : AddLazyAction(action' this' !IsRunning); " is 124.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,RunActionsAsync,The length of the statement  "            state = ActionManager != null ? ActionManager.AddAction (asyncAction' this' !IsRunning) : AddLazyAction(asyncAction' this' !IsRunning); " is 135.
Long Statement,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,AttachSchedules,The length of the statement  "                        scheduler.Schedule(schedule.Selector' schedule.Target' schedule.Interval' schedule.Repeat' schedule.Delay' schedule.Paused); " is 124.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1'4'3'2 spacing=0'0 outline=0 " is 131.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0'0'0'0 spacing=1'1 " is 122.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseImageFileName,The length of the statement  "                throw (new ContentLoadException("Invalid page ID for FNT descriptor. Line=" + line + "' value=" + value + "' indices=" + index + "'" + index2)); " is 144.
Long Statement,CocosSharp,CCLayer,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayer.cs,ScreenToWorldspace,The length of the statement  "            CCPoint worldSizeRatio = new CCPoint(size.Width / viewportRectInPixels.Size.Width' size.Height / viewportRectInPixels.Size.Height); " is 131.
Long Statement,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The length of the statement  "            var color = new Color(DisplayedColor.R / 255.0f' DisplayedColor.G / 255.0f' DisplayedColor.B / 255.0f' DisplayedOpacity / 255.0f); " is 130.
Long Statement,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,RenderBatch,The length of the statement  "                    DrawManager.XnaGraphicsDevice.SamplerStates[0] = textureExists ? geometryPacket.Texture.SamplerState : SamplerState.PointClamp; " is 127.
Long Statement,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The length of the statement  "                vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255); " is 129.
Long Statement,CocosSharp,CCParticleSystem,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystem.cs,InitParticle,The length of the statement  "                particleGrav.TangentialAccel = GravityMode.TangentialAccel + GravityMode.TangentialAccelVar * CCRandom.Float_Minus1_1(); " is 120.
Long Statement,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,OnConfigLoad,The length of the statement  "						CCTextureCache.SharedTextureCache.AddImageAsync(imageBytes' config.TextureName' CCSurfaceFormat.Color' (loadedTexture) => " is 121.
Long Statement,CocosSharp,CCDirector,C:\repos\mono_CocosSharp\src\Nodes\Scenes\CCDirector.cs,PopScene,The length of the statement  "                End(); // This should not happen here b/c we need to capture the current state and just deactivate the game (for Android). " is 122.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: Animation '{0}' found in dictionary without any frames - cannot add to animation cache."' " is 120.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                            "cocos2d: CCAnimationCache: Animation '{0}' refers to frame '%s' which is not currently in the CCSpriteFrameCache. This frame will not be added to the animation."' " is 163.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: None of the frames for animation '{0}' were found in the CCSpriteFrameCache. Animation is not being added to the Animation Cache."' " is 162.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion1,The length of the statement  "                        "CocosSharp: CCAnimationCache: An animation in your dictionary refers to a frame which is not in the CCSpriteFrameCache. Some or all of the frames for the animation '{0}' may be missing."' " is 188.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion2,The length of the statement  "                        "CocosSharp: CCAnimationCache: Animation '{0}' found in dictionary without any frames - cannot add to animation cache."' " is 120.
Long Statement,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,ParseVersion2,The length of the statement  "                            "cocos2d: CCAnimationCache: Animation '{0}' refers to frame '{1}' which is not currently in the CCSpriteFrameCache. This frame will not be added to the animation."' " is 164.
Long Statement,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The length of the statement  "                            "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag"); " is 162.
Long Statement,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The length of the statement  "                throw (new Microsoft.Xna.Framework.Content.ContentLoadException("Failed to load the particle definition file from stream")); " is 124.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadAppleDictionary,The length of the statement  "                    CCLog.Log ("texture {0} rect {1} rotated {2} offset {3}' sourcesize {4}"' name' textureRect' textureRotated' spriteOffset' spriteSourceSize); " is 141.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The length of the statement  "                            "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag"); " is 162.
Long Statement,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The length of the statement  "                        new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)' " is 126.
Long Statement,CocosSharp,CCTileMap,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMap.cs,TilesetsForLayer,The length of the statement  "                    short tilesetLastGid = (short)(tilesetIdx < tilesets.Count - 1 ? tilesets[tilesetIdx + 1].FirstGid - 1 : short.MaxValue); " is 121.
Long Statement,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParsePropertyElement,The length of the statement  "                CCLog.Log("CCTileMapInfo: ParsePropertyElement: Parent element is unsupported. Cannot add property named '{0}' with value '{1}'"' " is 129.
Long Statement,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,InitialiseDrawBuffer,The length of the statement  "            CCTileMapDrawBufferManager drawBufferManager = new CCTileMapDrawBufferManager(LayerSize.Row' LayerSize.Column' this' tileSetInfo); " is 130.
Long Statement,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuadAt,The length of the statement  "            if (drawBufferManager.TileSetInfo.FirstGid <= tileGID.Gid && drawBufferManager.TileSetInfo.LastGid >= tileGID.Gid || tileGID.Gid == 0) " is 134.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start' count); " is 124.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The length of the statement  "                graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2); " is 128.
Long Statement,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CreateRenderTarget,The length of the statement  "            return new RenderTarget2D(graphicsDevice' width' height' false' (SurfaceFormat)colorFormat' (DepthFormat)depthFormat' 0' (RenderTargetUsage)usage); " is 147.
Long Statement,CocosSharp,CCVertexBuffer<T>,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(T)' data.Capacity' (BufferUsage)usage); " is 129.
Long Statement,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The length of the statement  "            vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage); " is 145.
Long Statement,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The length of the statement  "            if (leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released) " is 192.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,Write,The length of the statement  "            writer.WriteDocType("plist"' "-//Apple Computer//DTD PLIST 1.0//EN"' "http://www.apple.com/DTDs/PropertyList-1.0.dtd"' null); " is 125.
Long Statement,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryAsciiString,The length of the statement  "			return buffer.Count > 0 ? new PlistString(Encoding.UTF8.GetString(buffer.ToArray()' 0' buffer.Count)) : new PlistString(string.Empty); " is 134.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "                return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound)); " is 141.
Long Statement,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The length of the statement  "            return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range); " is 128.
Long Statement,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The length of the statement  "                    texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"]; " is 161.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,CreateXMLFile,The length of the statement  "            using (StreamWriter writeFile = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage))) " is 149.
Long Statement,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,Flush,The length of the statement  "    		using (StreamWriter stream = new StreamWriter(new IsolatedStorageFileStream(XML_FILE_NAME' FileMode.Create' FileAccess.Write' myIsolatedStorage)))  " is 146.
Long Statement,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithRawData,The length of the statement  "            InitWithRawData(data' pixelFormat' pixelsWide' pixelsHigh' premultipliedAlpha' mipMap' new CCSize(pixelsWide' pixelsHigh)); " is 123.
Long Statement,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,GenerateMipmap,The length of the statement  "                var target = new RenderTarget2D(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' PixelsWide' PixelsHigh' true' (SurfaceFormat)PixelFormat' " is 140.
Long Statement,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,AddImageAsync,The length of the statement  "                dataAsyncLoadedImages.Add(new DataAsyncStruct() { Data = data' AssetName = assetName' Format = format  ' Action = action}); " is 123.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The length of the statement  "            // Original from Bruce Dawson: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ " is 121.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.X = 0.5f * ((((2.0f * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2.0f * value1.X) - (5.0f * value2.X)) + (4.0f * value3.X)) - value4.X) * squared)) + ((((-value1.X + (3.0f * value2.X)) - (3.0f * value3.X)) + value4.X) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Y = 0.5f * ((((2.0f * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2.0f * value1.Y) - (5.0f * value2.Y)) + (4.0f * value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (3.0f * value2.Y)) - (3.0f * value3.Y)) + value4.Y) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.Z = 0.5f * ((((2.0f * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2.0f * value1.Z) - (5.0f * value2.Z)) + (4.0f * value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (3.0f * value2.Z)) - (3.0f * value3.Z)) + value4.Z) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,CatmullRom,The length of the statement  "            result.W = 0.5f * ((((2.0f * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2.0f * value1.W) - (5.0f * value2.W)) + (4.0f * value3.W)) - value4.W) * squared)) + ((((-value1.W + (3.0f * value2.W)) - (3.0f * value3.W)) + value4.W) * cubed)); " is 246.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1} Z:{2} W:{3}"' X.ToString(format' CultureInfo.CurrentCulture)' " is 123.
Long Statement,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "                Y.ToString(format' CultureInfo.CurrentCulture)' Z.ToString(format' CultureInfo.CurrentCulture)' W.ToString(format' CultureInfo.CurrentCulture)); " is 144.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthogonalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "            //q4 = (m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3) / |m4 - (q1  m4) * q1 - (q2  m4) * q2 - (q3  m4) * q3| " is 120.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Orthonormalize,The length of the statement  "                throw new ArgumentOutOfRangeException("destination"' "The destination array must be of same length or larger length than the source array."); " is 141.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "X:{0} Y:{1}"' X.ToString(format' CultureInfo.CurrentCulture)' Y.ToString(format' CultureInfo.CurrentCulture)); " is 160.
Long Statement,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToString,The length of the statement  "            return string.Format(formatProvider' "X:{0} Y:{1}"' X.ToString(format' formatProvider)' Y.ToString(format' formatProvider)); " is 124.
Complex Conditional,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,LoadGame,The conditional expression  "viewInitialised && platformInitialised && !gameLoaded && viewCreated != null"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,DispatchEventToListeners,The conditional expression  "l.IsEnabled && !l.IsPaused && l.IsRegistered && onEvent(l)"  is complex.
Complex Conditional,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,LineIntersect,The conditional expression  "(A.X == B.X && A.Y == B.Y) || (C.X == D.X && C.Y == D.Y)"  is complex.
Complex Conditional,CocosSharp,CCPoint,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,SegmentIntersect,The conditional expression  "LineIntersect(A' B' C' D' ref S' ref T)                  && (S >= 0.0f && S <= 1.0f && T >= 0.0f && T <= 1.0f)"  is complex.
Complex Conditional,CocosSharp,CCRect,C:\repos\mono_CocosSharp\src\Math\CCGeometry.cs,ContainsPoint,The conditional expression  "point.X >= rect.MinX && point.X <= rect.MaxX && point.Y >= rect.MinY &&                  point.Y <= rect.MaxY"  is complex.
Complex Conditional,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,VisitRenderer,The conditional expression  "triangleVertices.Count > 0                  || lineVertices.Count > 0                   || (spriteFont != null && stringData != null && stringData.Count > 0)"  is complex.
Complex Conditional,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineIntersect,The conditional expression  "(Ax == Bx && Ay == By) || (Cx == Dx && Cy == Dy)"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,updateColors,The conditional expression  "Color.R != PlaceHolderTextColor.R ||                      Color.G != PlaceHolderTextColor.G ||                      Color.B != PlaceHolderTextColor.B ||                      Opacity != PlaceHolderTextColor.A"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,updateColors,The conditional expression  "Color.R != defaultTextColor.R ||                      Color.G != defaultTextColor.G ||                      Color.B != defaultTextColor.B ||                      Opacity != defaultTextColor.A"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,TouchBegan,The conditional expression  "pos.X >= 0 && pos.X < ContentSize.Width && pos.Y >= 0 && pos.Y <= ContentSize.Height"  is complex.
Complex Conditional,CocosSharp,CCTextField,C:\repos\mono_CocosSharp\src\Nodes\TextInput\CCTextField.cs,TouchEnded,The conditional expression  "pos.X >= 0 && pos.X < ContentSize.Width && pos.Y >= 0 && pos.Y <= ContentSize.Height"  is complex.
Complex Conditional,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The conditional expression  "(MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1)"  is complex.
Complex Conditional,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The conditional expression  "(MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1)"  is complex.
Complex Conditional,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,GetScissorRasterizerState,The conditional expression  "state.ScissorTestEnable == scissorEnabled &&                      currentState.CullMode == state.CullMode &&                      currentState.DepthBias == state.DepthBias &&                      currentState.FillMode == state.FillMode &&                      currentState.MultiSampleAntiAlias == state.MultiSampleAntiAlias &&                      currentState.SlopeScaleDepthBias == state.SlopeScaleDepthBias"  is complex.
Complex Conditional,CocosSharp,CCFocusManager,C:\repos\mono_CocosSharp\src\Platform\CCFocusManager.cs,SharedApplication_GamePadDPadUpdate,The conditional expression  "leftButton == CCGamePadButtonStatus.Released || upButton == CCGamePadButtonStatus.Released || rightButton == CCGamePadButtonStatus.Released || downButton == CCGamePadButtonStatus.Released"  is complex.
Complex Conditional,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The conditional expression  "name == "key" || name == "integer" || name == "real" || name == "string""  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,Dispose,The conditional expression  "disposing && texture2D != null && !texture2D.IsDisposed && !managed"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A"  is complex.
Complex Conditional,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The conditional expression  "(data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d)"  is complex.
Virtual Method Call from Constructor,CocosSharp,CCGridActionState,C:\repos\mono_CocosSharp\src\Actions\Grid\CCGridAction.cs,CCGridActionState,The constructor "CCGridActionState" calls a virtual method "Reuse".
Virtual Method Call from Constructor,CocosSharp,CCTileMap,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMap.cs,CCTileMap,The constructor "CCTileMap" calls a virtual method "AddChild".
Virtual Method Call from Constructor,CocosSharp,CCRenderCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCRenderCommand.cs,CCRenderCommand,The constructor "CCRenderCommand" calls a virtual method "GenerateFlags".
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CCLabel,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,InitBMFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,InitSpriteFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCMusicPlayer,C:\repos\mono_CocosSharp\src\Audio\CCMusicPlayer.cs,Dispose,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseImageFileName,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContent,C:\repos\mono_CocosSharp\src\Platform\CCContent.cs,LoadContentFile,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContent,C:\repos\mono_CocosSharp\src\Platform\CCContent.cs,LoadContentFile,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,Load,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCContentManager,C:\repos\mono_CocosSharp\src\Platform\CCContentManager.cs,GetAssetStream,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,TryLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCSpriteFontCache,C:\repos\mono_CocosSharp\src\Platform\CCSpriteFontCache.cs,InternalLoadFont,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithStream,The method has an empty catch block.
Empty Catch Block,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,InitWithFile,The method has an empty catch block.
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,UpdateViewport,The following statement contains a magic number: if (resolutionPolicy != CCViewResolutionPolicy.Custom)              {                  float resolutionScaleX = width / (float)DesignResolution.Width;                  float resolutionScaleY = height / (float)DesignResolution.Height;                    switch (resolutionPolicy)                  {                      case CCViewResolutionPolicy.NoBorder:                          resolutionScaleX = resolutionScaleY = Math.Max(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.ShowAll:                          resolutionScaleX = resolutionScaleY = Math.Min(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.FixedHeight:                          resolutionScaleX = resolutionScaleY;                          designResolution.Width = (int)Math.Ceiling(width / resolutionScaleX);                          break;                      case CCViewResolutionPolicy.FixedWidth:                          resolutionScaleY = resolutionScaleX;                          designResolution.Height = (int)Math.Ceiling(height / resolutionScaleY);                          break;                      default:                          break;                  }                    float viewPortW = DesignResolution.Width * resolutionScaleX;                  float viewPortH = DesignResolution.Height * resolutionScaleY;                    CCRect viewPortRect = new CCRect((width - viewPortW) / 2' (height - viewPortH) / 2'                       viewPortW' viewPortH);                    viewportRatio = new CCRect(                      ((viewPortRect.Origin.X) / width)'                      ((viewPortRect.Origin.Y) / height)'                      ((viewPortRect.Size.Width) / width)'                      ((viewPortRect.Size.Height) / height)                  );              }
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,UpdateViewport,The following statement contains a magic number: if (resolutionPolicy != CCViewResolutionPolicy.Custom)              {                  float resolutionScaleX = width / (float)DesignResolution.Width;                  float resolutionScaleY = height / (float)DesignResolution.Height;                    switch (resolutionPolicy)                  {                      case CCViewResolutionPolicy.NoBorder:                          resolutionScaleX = resolutionScaleY = Math.Max(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.ShowAll:                          resolutionScaleX = resolutionScaleY = Math.Min(resolutionScaleX' resolutionScaleY);                          break;                      case CCViewResolutionPolicy.FixedHeight:                          resolutionScaleX = resolutionScaleY;                          designResolution.Width = (int)Math.Ceiling(width / resolutionScaleX);                          break;                      case CCViewResolutionPolicy.FixedWidth:                          resolutionScaleY = resolutionScaleX;                          designResolution.Height = (int)Math.Ceiling(height / resolutionScaleY);                          break;                      default:                          break;                  }                    float viewPortW = DesignResolution.Width * resolutionScaleX;                  float viewPortH = DesignResolution.Height * resolutionScaleY;                    CCRect viewPortRect = new CCRect((width - viewPortW) / 2' (height - viewPortH) / 2'                       viewPortW' viewPortH);                    viewportRatio = new CCRect(                      ((viewPortRect.Origin.X) / width)'                      ((viewPortRect.Origin.Y) / height)'                      ((viewPortRect.Size.Width) / width)'                      ((viewPortRect.Size.Height) / height)                  );              }
Magic Number,CocosSharp,CCGameView,C:\repos\mono_CocosSharp\src\EmbeddableView\CCGameView.Desktop.cs,UpdateViewport,The following statement contains a magic number: defaultProjMatrix = XnaMatrix.CreateOrthographic(ViewSize.Width' ViewSize.Height' 1024f' -1024);
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,CocosSharp,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,The following statement contains a magic number: if (dimensions.Width <= 0)              {                  dimensions.Width = 8388608;                  layoutAvailable = false;              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,The following statement contains a magic number: if (dimensions.Height <= 0)              {                  dimensions.Height = 8388608;                  layoutAvailable = false;              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,The following statement contains a magic number: if (!layoutAvailable)              {                  if (dimensions.Width == 8388608)                  {                      dimensions.Width = boundingRect.Width;                  }                  if (dimensions.Height == 8388608)                  {                      dimensions.Height = boundingRect.Height;                  }              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,CreateTextSprite,The following statement contains a magic number: if (!layoutAvailable)              {                  if (dimensions.Width == 8388608)                  {                      dimensions.Width = boundingRect.Width;                  }                  if (dimensions.Height == 8388608)                  {                      dimensions.Height = boundingRect.Height;                  }              }
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,Reset,The following statement contains a magic number: systemFontSize = 12;
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,IncreaseAtlasCapacity,The following statement contains a magic number: int quantity = (TextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,CocosSharp,CCLabel,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-WindowsUAP.cs,IncreaseAtlasCapacity,The following statement contains a magic number: int quantity = (TextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\Platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,StartAutorepeat,The following statement contains a magic number: TextFieldInFocus.Schedule(Repeater' AutorepeatDeltaTime' CCSchedulePriority.RepeatForever' AutorepeatDeltaTime * 3);
Magic Number,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\Platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,Repeater,The following statement contains a magic number: if ((autorepeatCount < AutorepeatIncreaseTimeIncrement) && (autorepeatCount % 3) != 0)                  return;
Magic Number,CocosSharp,CCFollow,C:\repos\mono_CocosSharp\src\Actions\Base\CCFollow.cs,CCFollow,The following statement contains a magic number: if (UsingBoundary)              {                  float leftBoundary = -((rect.Origin.X + rect.Size.Width) - FullScreenSize.X - viewportBounds.Origin.X);                  float rightBoundary = -rect.Origin.X;                  float topBoundary = -rect.Origin.Y;                  float bottomBoundary = -((rect.Origin.Y + rect.Size.Height) - FullScreenSize.Y - viewportBounds.Origin.Y);                    if (rightBoundary < leftBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      rightBoundary = leftBoundary = (leftBoundary + rightBoundary) / 2;                  }                  if (topBoundary < bottomBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      topBoundary = bottomBoundary = (topBoundary + bottomBoundary) / 2;                  }                    if ((topBoundary == bottomBoundary) && (leftBoundary == rightBoundary))                  {                      BoundaryFullyCovered = true;                  }                    Boundary = new CCFollowBoundary (bottomBoundary' leftBoundary' rightBoundary' topBoundary);              }
Magic Number,CocosSharp,CCFollow,C:\repos\mono_CocosSharp\src\Actions\Base\CCFollow.cs,CCFollow,The following statement contains a magic number: if (UsingBoundary)              {                  float leftBoundary = -((rect.Origin.X + rect.Size.Width) - FullScreenSize.X - viewportBounds.Origin.X);                  float rightBoundary = -rect.Origin.X;                  float topBoundary = -rect.Origin.Y;                  float bottomBoundary = -((rect.Origin.Y + rect.Size.Height) - FullScreenSize.Y - viewportBounds.Origin.Y);                    if (rightBoundary < leftBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      rightBoundary = leftBoundary = (leftBoundary + rightBoundary) / 2;                  }                  if (topBoundary < bottomBoundary)                  {                      // screen width is larger than world's boundary width                      //set both in the middle of the world                      topBoundary = bottomBoundary = (topBoundary + bottomBoundary) / 2;                  }                    if ((topBoundary == bottomBoundary) && (leftBoundary == rightBoundary))                  {                      BoundaryFullyCovered = true;                  }                    Boundary = new CCFollowBoundary (bottomBoundary' leftBoundary' rightBoundary' topBoundary);              }
Magic Number,CocosSharp,CCCardinalSplineToState,C:\repos\mono_CocosSharp\src\Actions\Catmull\CCCardinalSplineTo.cs,Update,The following statement contains a magic number: CCPoint pp3 = Points [Math.Min (c' Math.Max (p + 2' 0))];
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,Update,The following statement contains a magic number: while (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCActionManager,C:\repos\mono_CocosSharp\src\Actions\CCActionManager.cs,RemoveAllActions,The following statement contains a magic number: if (tmpKeysArray.Length < count)              {                  tmpKeysArray = new CCNode[tmpKeysArray.Length * 2];              }
Magic Number,CocosSharp,CCEaseInOutState,C:\repos\mono_CocosSharp\src\Actions\Ease\CCEaseInOut.cs,Update,The following statement contains a magic number: time *= 2;
Magic Number,CocosSharp,CCEaseInOutState,C:\repos\mono_CocosSharp\src\Actions\Ease\CCEaseInOut.cs,Update,The following statement contains a magic number: if (time < 1)              {                  InnerActionState.Update (0.5f * (float)Math.Pow (time' actionRate));              }              else              {                  InnerActionState.Update (1.0f - 0.5f * (float)Math.Pow (2 - time' actionRate));              }
Magic Number,CocosSharp,CCLiquidState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCLiquid.cs,Update,The following statement contains a magic number: for (i = 1; i < GridSize.X; ++i)              {                  for (j = 1; j < GridSize.Y; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X = (v.X +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude *                              AmplitudeRate));                      v.Y = (v.Y +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude *                              AmplitudeRate));                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCLiquidState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCLiquid.cs,Update,The following statement contains a magic number: for (i = 1; i < GridSize.X; ++i)              {                  for (j = 1; j < GridSize.Y; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X = (v.X +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude *                              AmplitudeRate));                      v.Y = (v.Y +                          ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude *                              AmplitudeRate));                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: float deltaAy = (tt * tt * 500);
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: float ay = -100 - deltaAy;
Magic Number,CocosSharp,CCPageTurn3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCPageTurn3D.cs,Update,The following statement contains a magic number: for (int i = 0; i <= GridSize.X; ++i)              {                  for (int j = 0; j <= GridSize.Y; ++j)                  {                      // Get original vertex                      CCVertex3F p = OriginalVertex (i' j);                        var R = (float)Math.Sqrt ((p.X * p.X) + ((p.Y - ay) * (p.Y - ay)));                      float r = R * sinTheta;                      var alpha = (float)Math.Asin (p.X / R);                      float beta = alpha / sinTheta;                      var cosBeta = (float)Math.Cos (beta);                        // If beta > PI then we've wrapped around the cone                      // Reduce the radius to stop these points interfering with others                      if (beta <= MathHelper.Pi)                      {                          p.X = (r * (float)Math.Sin (beta));                      }                      else                      {                          // Force X = 0 to stop wrapped                          // points                          p.X = 0;                      }                        p.Y = (R + ay - (r * (1 - cosBeta) * sinTheta));                        // We scale z here to avoid the animation being                      // too much bigger than the screen due to perspective transform                      p.Z = (r * (1 - cosBeta) * cosTheta) / 7; // "100" didn't work for                        //    Stop z coord from dropping beneath underlying page in a transition                      // issue #751                      if (p.Z < 0.5f)                      {                          p.Z = 0.5f;                      }                        // Set new coords                      SetVertex (i' j' ref p);                  }              }
Magic Number,CocosSharp,CCRipple3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCRipple3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        CCPoint diff = Position - new CCPoint (v.X' v.Y);                      float r = diff.Length;                        if (r < Radius)                      {                          r = Radius - r;                          float r1 = r / Radius;                          float rate = r1 * r1;                          v.Z += ((float)Math.Sin (time * MathHelper.Pi * Waves * 2 + r * 0.1f) * Amplitude *                              AmplitudeRate * rate);                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCShaky3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCShaky3D.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.X += (CCRandom.Next () % (Range * 2)) - Range;                      v.Y += (CCRandom.Next () % (Range * 2)) - Range;                        if (Shake)                      {                          v.Z += (CCRandom.Next () % (Range * 2)) - Range;                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCTwirlState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCTwirl.cs,Update,The following statement contains a magic number: for (i = 0; i < (GridSize.X + 1); ++i)              {                  for (j = 0; j < (GridSize.Y + 1); ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        avg.X = i - (GridSize.X / 2.0f);                      avg.Y = j - (GridSize.Y / 2.0f);                        var r = (float)Math.Sqrt ((avg.X * avg.X + avg.Y * avg.Y));                        float amp = 0.1f * Amplitude * AmplitudeRate;                      float a = r * (float)Math.Cos ((float)Math.PI / 2.0f + time * (float)Math.PI * twirls * 2) * amp;                        float dx = (float)Math.Sin (a) * (v.Y - c.Y) + (float)Math.Cos (a) * (v.X - c.X);                      float dy = (float)Math.Cos (a) * (v.Y - c.Y) - (float)Math.Sin (a) * (v.X - c.X);                        v.X = c.X + dx;                      v.Y = c.Y + dy;                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWavesState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        if (Vertical)                      {                          v.X = (v.X +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude * ampRate));                      }                        if (Horizontal)                      {                          v.Y = (v.Y +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude * ampRate));                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWavesState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                        if (Vertical)                      {                          v.X = (v.X +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.Y * .01f) * Amplitude * ampRate));                      }                        if (Horizontal)                      {                          v.Y = (v.Y +                              ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + v.X * .01f) * Amplitude * ampRate));                      }                        SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCWaves3DState,C:\repos\mono_CocosSharp\src\Actions\Grid3d\CCWaves3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X + 1; ++i)              {                  for (j = 0; j < GridSize.Y + 1; ++j)                  {                      CCVertex3F v = OriginalVertex (i' j);                      v.Z += ((float)Math.Sin ((float)Math.PI * time * Waves * 2 + (v.Y + v.X) * .01f) * Amplitude *                          AmplitudeRate);                      SetVertex (i' j' ref v);                  }              }
Magic Number,CocosSharp,CCAccelDeccelAmplitudeState,C:\repos\mono_CocosSharp\src\Actions\Grid\CCAccelDeccelAmplitude.cs,Update,The following statement contains a magic number: float f = time * 2;
Magic Number,CocosSharp,CCBlinkState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCBlink.cs,Update,The following statement contains a magic number: if (Target != null && !IsDone)              {                  float slice = 1.0f / Times;                  // float m = fmodf(time' slice);                  float m = time % slice;                  Target.Visible = m > (slice / 2);              }
Magic Number,CocosSharp,CCFadeInState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCFadeIn.cs,Update,The following statement contains a magic number: if (pRGBAProtocol != null)              {                  pRGBAProtocol.Opacity = (byte)(255 * time);              }
Magic Number,CocosSharp,CCFadeOutState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCFadeOut.cs,Update,The following statement contains a magic number: if (pRGBAProtocol != null)              {                  pRGBAProtocol.Opacity = (byte)(255 * (1 - time));              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX > 180)              {                  DiffAngleX -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX > 180)              {                  DiffAngleX -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX < -180)              {                  DiffAngleX += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleX < -180)              {                  DiffAngleX += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY > 180)              {                  DiffAngleY -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY > 180)              {                  DiffAngleY -= 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY < -180)              {                  DiffAngleY += 360;              }
Magic Number,CocosSharp,CCRotateToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCRotateTo.cs,CCRotateToState,The following statement contains a magic number: if (DiffAngleY < -180)              {                  DiffAngleY += 360;              }
Magic Number,CocosSharp,CCSequence,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSequence.cs,CCSequence,The following statement contains a magic number: Actions = new CCFiniteTimeAction[2];
Magic Number,CocosSharp,CCSequence,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSequence.cs,CCSequence,The following statement contains a magic number: Actions = new CCFiniteTimeAction[2];
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX > 180)              {                  DeltaX -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX > 180)              {                  DeltaX -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX < -180)              {                  DeltaX += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaX < -180)              {                  DeltaX += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY > 180)              {                  DeltaY -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY > 180)              {                  DeltaY -= 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY < -180)              {                  DeltaY += 360;              }
Magic Number,CocosSharp,CCSkewToState,C:\repos\mono_CocosSharp\src\Actions\Intervals\CCSkewTo.cs,CCSkewToState,The following statement contains a magic number: if (DeltaY < -180)              {                  DeltaY += 360;              }
Magic Number,CocosSharp,CCProgressToState,C:\repos\mono_CocosSharp\src\Actions\ProgressTimer\CCProgressTo.cs,CCProgressToState,The following statement contains a magic number: if (PercentFrom == 100)              {                  PercentFrom = 0;              }
Magic Number,CocosSharp,CCFadeOutBLTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutBLTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow ((n.X + n.Y) / (pos.X + pos.Y)' 6);
Magic Number,CocosSharp,CCFadeOutDownTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutDownTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow (n.Y / pos.Y' 6);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow ((pos.X + pos.Y) / (px + py)' 6);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TransformTile,The following statement contains a magic number: float dx = (step.X / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCFadeOutTRTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutTRTiles.cs,TransformTile,The following statement contains a magic number: float dy = (step.Y / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCFadeOutUpTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutUpTiles.cs,TestFunc,The following statement contains a magic number: return (float)Math.Pow (pos.Y / fy' 6);
Magic Number,CocosSharp,CCFadeOutUpTilesState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCFadeOutUpTiles.cs,TransformTile,The following statement contains a magic number: float dy = (step.Y / 2) * (1.0f - distance);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: float sinz = ((float)Math.Sin ((float)Math.PI * time * NumberOfJumps * 2) * Amplitude * AmplitudeRate);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: float sinz2 = (float)(Math.Sin ((float)Math.PI * (time * NumberOfJumps * 2 + 1)) * Amplitude * AmplitudeRate);
Magic Number,CocosSharp,CCJumpTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCJumpTiles3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; i++)              {                  for (j = 0; j < GridSize.Y; j++)                  {                      CCQuad3 coords = OriginalTile (i' j);                        if (((i + j) % 2) == 0)                      {                          coords.BottomLeft.Z += sinz;                          coords.BottomRight.Z += sinz;                          coords.TopLeft.Z += sinz;                          coords.TopRight.Z += sinz;                      }                      else                      {                          coords.BottomLeft.Z += sinz2;                          coords.BottomRight.Z += sinz2;                          coords.TopLeft.Z += sinz2;                          coords.TopRight.Z += sinz2;                      }                        SetTile (i' j' ref coords);                  }              }
Magic Number,CocosSharp,CCShakyTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCShakyTiles3D.cs,Update,The following statement contains a magic number: var doubleRange = Range * 2;
Magic Number,CocosSharp,CCShatteredTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCShatteredTiles3D.cs,Update,The following statement contains a magic number: var doubleRange = Range * 2;
Magic Number,CocosSharp,CCSplitColsState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCSplitCols.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; ++i)              {                  CCQuad3 coords = OriginalTile (i' 0);                  float direction = 1;                    if ((i % 2) == 0)                  {                      direction = -1;                  }                    coords.BottomLeft.Y += direction * height * time;                  coords.BottomRight.Y += direction * height * time;                  coords.TopLeft.Y += direction * height * time;                  coords.TopRight.Y += direction * height * time;                    SetTile (i' 0' ref coords);              }
Magic Number,CocosSharp,CCSplitRowsState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCSplitRows.cs,Update,The following statement contains a magic number: for (j = 0; j < GridSize.Y; ++j) {                  CCQuad3 coords = OriginalTile (0' j);                  float direction = 1;                    if ((j % 2) == 0) {                      direction = -1;                  }                    coords.BottomLeft.X += direction * width * time;                  coords.BottomRight.X += direction * width * time;                  coords.TopLeft.X += direction * width * time;                  coords.TopRight.X += direction * width * time;                    SetTile (0' j' ref coords);              }
Magic Number,CocosSharp,CCWavesTiles3DState,C:\repos\mono_CocosSharp\src\Actions\TiledGrid\CCWavesTiles3D.cs,Update,The following statement contains a magic number: for (i = 0; i < GridSize.X; i++)              {                  for (j = 0; j < GridSize.Y; j++)                  {                      CCQuad3 coords = OriginalTile (i' j);                      CCVertex3F bl = coords.BottomLeft;                      CCVertex3F br = coords.BottomRight;                      CCVertex3F tl = coords.TopLeft;                      CCVertex3F tr = coords.TopRight;                        bl.Z = ((float)Math.Sin (time * (float)Math.PI * Waves * 2 + (bl.Y + bl.X) * .01f) * Amplitude * AmplitudeRate);                      br.Z = bl.Z;                      tl.Z = bl.Z;                      tr.Z = bl.Z;                        coords.BottomLeft = bl;                      coords.BottomRight = br;                      coords.TopLeft = tl;                      coords.TopRight = tr;                        SetTile (i' j' ref coords);                  }              }
Magic Number,CocosSharp,CCV3F_T2F,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CCV3F_T2F,The following statement contains a magic number: var elements = new[]              {                  new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                  new VertexElement(12' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)              };
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<ushort>(GridSize.X * GridSize.Y * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = GridSize.X * GridSize.Y * 6;
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var l2 = new CCVertex3F[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex1 = new int[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: var tex2 = new CCPoint[4];
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; ++x)              {                  for (int y = 0; y < GridSize.Y; ++y)                  {                      float x1 = x * Step.X;                      float x2 = x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y1 + Step.Y;                        var a = (short) (x * (GridSize.Y + 1) + y);                      var b = (short) ((x + 1) * (GridSize.Y + 1) + y);                      var c = (short) ((x + 1) * (GridSize.Y + 1) + (y + 1));                      var d = (short) (x * (GridSize.Y + 1) + (y + 1));                        int idx = ((y * GridSize.X) + x) * 6;                        idxArray[idx + 0] = (ushort) a;                      idxArray[idx + 1] = (ushort) b;                      idxArray[idx + 2] = (ushort) d;                      idxArray[idx + 3] = (ushort) b;                      idxArray[idx + 4] = (ushort) c;                      idxArray[idx + 5] = (ushort) d;                        //var tempidx = new short[6] {a' d' b' b' d' c};                      //Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);                        l1[0] = a;                      l1[1] = b;                      l1[2] = c;                      l1[3] = d;                        //var e = new Vector3(x1' y1' 0);                      //var f = new Vector3(x2' y1' 0);                      //var g = new Vector3(x2' y2' 0);                      //var h = new Vector3(x1' y2' 0);                        l2[0] = new CCVertex3F(x1' y1' 0);                      l2[1] = new CCVertex3F(x2' y1' 0);                      l2[2] = new CCVertex3F(x2' y2' 0);                      l2[3] = new CCVertex3F(x1' y2' 0);                        tex1[0] = a;                      tex1[1] = b;                      tex1[2] = c;                      tex1[3] = d;                        tex2[0] = new CCPoint(x1' y1);                      tex2[1] = new CCPoint(x2' y1);                      tex2[2] = new CCPoint(x2' y2);                      tex2[3] = new CCPoint(x1' y2);                        for (int i = 0; i < 4; ++i)                      {                          vertArray[l1[i]].Vertices = l2[i];                            vertArray[tex1[i]].TexCoords.U = tex2[i].X / width;                            if (TextureFlipped)                          {                              vertArray[tex1[i]].TexCoords.V = tex2[i].Y / height;                          }                          else                          {                              vertArray[tex1[i]].TexCoords.V = (imageH - tex2[i].Y) / height;                          }                      }                  }              }
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCGridBase,C:\repos\mono_CocosSharp\src\Effects\CCGridBase.cs,NextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Blit,The following statement contains a magic number: drawManager.DrawBuffer(vertexBuffer' indexBuffer' 0' Indices.Length / 3);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,Reuse,The following statement contains a magic number: if (ReuseGrid > 0)              {                  int numQuads = GridSize.X * GridSize.Y;                    CCQuad3[] orig = OriginalVertices;                  CCV3F_T2F[] verts = Vertices;                    for (int i = 0; i < numQuads; i++)                  {                      int i4 = i * 4;                      orig[i].BottomLeft = verts[i4 + 0].Vertices;                      orig[i].BottomRight = verts[i4 + 1].Vertices;                      orig[i].TopLeft = verts[i4 + 2].Vertices;                      orig[i].TopRight = verts[i4 + 3].Vertices;                  }                    --ReuseGrid;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer = new CCVertexBuffer<CCV3F_T2F>(numQuads * 4' CCBufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: vertexBuffer.Count = numQuads * 4;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer = new CCIndexBuffer<short>(numQuads * 6' BufferUsage.WriteOnly);
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: indexBuffer.Count = numQuads * 6;
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < GridSize.X; x++)              {                  for (int y = 0; y < GridSize.Y; y++)                  {                      float x1 = x * Step.X;                      float x2 = x == GridSize.X - 1 ? width : x1 + Step.X;                      float y1 = y * Step.Y;                      float y2 = y == GridSize.Y - 1 ? height : y1 + Step.Y;                        vertArray[index + 0].Vertices = new CCVertex3F(x1' y1' 0);                      vertArray[index + 1].Vertices = new CCVertex3F(x2' y1' 0);                      vertArray[index + 2].Vertices = new CCVertex3F(x1' y2' 0);                      vertArray[index + 3].Vertices = new CCVertex3F(x2' y2' 0);                        float newY1 = y1;                      float newY2 = y2;                        if (!TextureFlipped)                      {                          newY1 = imageH - y1;                          newY2 = imageH - y2;                      }                        vertArray[index + 0].TexCoords = new CCTex2F(x1 / width' newY1 / height);                      vertArray[index + 1].TexCoords = new CCTex2F(x2 / width' newY1 / height);                      vertArray[index + 2].TexCoords = new CCTex2F(x1 / width' newY2 / height);                      vertArray[index + 3].TexCoords = new CCTex2F(x2 / width' newY2 / height);                        index += 4;                  }              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int x = 0; x < numQuads; x++)              {                  int i6 = x * 6;                  int i4 = x * 4;                  idxArray[i6 + 0] = (short) (i4 + 0);                  idxArray[i6 + 1] = (short) (i4 + 2);                  idxArray[i6 + 2] = (short) (i4 + 1);                    idxArray[i6 + 3] = (short) (i4 + 1);                  idxArray[i6 + 4] = (short) (i4 + 2);                  idxArray[i6 + 5] = (short) (i4 + 3);              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCTiledGrid3D,C:\repos\mono_CocosSharp\src\Effects\CCTiledGrid3D.cs,CalculateVertexPoints,The following statement contains a magic number: for (int i = 0; i < numQuads; i++)              {                  int i4 = i * 4;                  OriginalVertices[i].BottomLeft = vertArray[i4 + 0].Vertices;                  OriginalVertices[i].BottomRight = vertArray[i4 + 1].Vertices;                  OriginalVertices[i].TopLeft = vertArray[i4 + 2].Vertices;                  OriginalVertices[i].TopRight = vertArray[i4 + 3].Vertices;              }
Magic Number,CocosSharp,CCEventDispatcher,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,CCEventDispatcher,The following statement contains a magic number: toBeAddedListeners = new List<CCEventListener>(50);
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventListenerVector,C:\repos\mono_CocosSharp\src\Events\CCEventDispatcher.cs,PushBack,The following statement contains a magic number: if (listener.FixedPriority == 0)                  {                      if (sceneGraphListeners == null)                       {                          sceneGraphListeners = new List<CCEventListener> (100);                      }                        sceneGraphListeners.Add(listener);                  }                  else                  {                      if (fixedListeners == null)                       {                          fixedListeners = new List<CCEventListener> (100);                      }                          fixedListeners.Add(listener);                  }
Magic Number,CocosSharp,CCEventTouch,C:\repos\mono_CocosSharp\src\Events\CCEventTouch.cs,CCEventTouch,The following statement contains a magic number: Touches = new List<CCTouch> (5);
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The following statement contains a magic number: try              {                  if (TimeScale != 1.0f)                  {                      dt *= TimeScale;                  }                    LinkedListNode<ListEntry> next;                    // updates with priority < 0                  //foreach (ListEntry entry in _updatesNegList)                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority == 0                  //foreach (ListEntry entry in _updates0List)                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // Iterate over all the custom selectors                  var count = hashForTimers.Count;                  if (count > 0)                  {                      if (tmpSelectorArray.Length < count)                      {                          tmpSelectorArray = new ICCUpdatable[tmpSelectorArray.Length * 2];                      }                      hashForTimers.Keys.CopyTo(tmpSelectorArray' 0);                        for (int i = 0; i < count; i++)                      {                          ICCUpdatable key = tmpSelectorArray[i];                          if (!hashForTimers.ContainsKey(key))                          {                              continue;                          }                          HashTimeEntry elt = hashForTimers[key];                            currentTarget = elt;                          isCurrentTargetSalvaged = false;                            if (!currentTarget.Paused)                          {                              // The 'timers' array may change while inside this loop                              for (elt.TimerIndex = 0; elt.TimerIndex < elt.Timers.Count; ++elt.TimerIndex)                              {                                  elt.CurrentTimer = elt.Timers[elt.TimerIndex];      							if(elt.CurrentTimer != null) {      	                            elt.CurrentTimerSalvaged = false;        	                            elt.CurrentTimer.Update(dt);        	                            elt.CurrentTimer = null;      							}                              }                          }                            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)                          if (isCurrentTargetSalvaged && currentTarget.Timers.Count == 0)                          {                              RemoveHashElement(currentTarget);                          }                      }                  }                    // delete all updates that are marked for deletion                  // updates with priority < 0                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesNegList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority == 0                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updates0List.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesPosList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }              }              finally              {                  // Always do this just in case there is a problem                    isUpdateHashLocked = false;                  currentTarget = null;              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,The following statement contains a magic number: if (tmpHashSelectorArray.Length < count)              {                  tmpHashSelectorArray = new HashTimeEntry[tmpHashSelectorArray.Length * 2];              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,Update,The following statement contains a magic number: try              {                  if (TimeScale != 1.0f)                  {                      dt *= TimeScale;                  }                    LinkedListNode<ListEntry> next;                    // updates with priority < 0                  //foreach (ListEntry entry in _updatesNegList)                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority == 0                  //foreach (ListEntry entry in _updates0List)                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (!node.Value.Paused && !node.Value.MarkedForDeletion)                      {                          node.Value.Target.Update(dt);                      }                  }                    // Iterate over all the custom selectors                  var count = hashForTimers.Count;                  if (count > 0)                  {                      if (tmpSelectorArray.Length < count)                      {                          tmpSelectorArray = new ICCUpdatable[tmpSelectorArray.Length * 2];                      }                      hashForTimers.Keys.CopyTo(tmpSelectorArray' 0);                        for (int i = 0; i < count; i++)                      {                          ICCUpdatable key = tmpSelectorArray[i];                          if (!hashForTimers.ContainsKey(key))                          {                              continue;                          }                          HashTimeEntry elt = hashForTimers[key];                            currentTarget = elt;                          isCurrentTargetSalvaged = false;                            if (!currentTarget.Paused)                          {                              // The 'timers' array may change while inside this loop                              for (elt.TimerIndex = 0; elt.TimerIndex < elt.Timers.Count; ++elt.TimerIndex)                              {                                  elt.CurrentTimer = elt.Timers[elt.TimerIndex];      							if(elt.CurrentTimer != null) {      	                            elt.CurrentTimerSalvaged = false;        	                            elt.CurrentTimer.Update(dt);        	                            elt.CurrentTimer = null;      							}                              }                          }                            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)                          if (isCurrentTargetSalvaged && currentTarget.Timers.Count == 0)                          {                              RemoveHashElement(currentTarget);                          }                      }                  }                    // delete all updates that are marked for deletion                  // updates with priority < 0                  for (LinkedListNode<ListEntry> node = updatesNegList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesNegList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority == 0                  for (LinkedListNode<ListEntry> node = updates0List.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updates0List.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }                    // updates with priority > 0                  for (LinkedListNode<ListEntry> node = updatesPosList.First; node != null; node = next)                  {                      next = node.Next;                      if (node.Value.MarkedForDeletion)                      {                          updatesPosList.Remove(node);                          RemoveUpdateFromHash(node.Value);                      }                  }              }              finally              {                  // Always do this just in case there is a problem                    isUpdateHashLocked = false;                  currentTarget = null;              }
Magic Number,CocosSharp,CCScheduler,C:\repos\mono_CocosSharp\src\Events\CCScheduler.cs,UnscheduleAll,The following statement contains a magic number: if (tmpHashSelectorArray.Length < count)              {                  tmpHashSelectorArray = new HashTimeEntry[tmpHashSelectorArray.Length * 2];              }
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,CCNode,The following statement contains a magic number: displayedOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,CCNode,The following statement contains a magic number: RealOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,UpdateCascadeOpacity,The following statement contains a magic number: byte parentOpacity = 255;
Magic Number,CocosSharp,CCNode,C:\repos\mono_CocosSharp\src\Nodes\CCNode.cs,DisableCascadeOpacity,The following statement contains a magic number: foreach(CCNode node in Children.Elements)              {                  node.UpdateDisplayedOpacity(255);              }
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: Padding.Bottom = CocosSharp.CCUtils.CCParseInt(temp[2]);
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: Padding.Left = CocosSharp.CCUtils.CCParseInt(temp[3]);
Magic Number,CocosSharp,CCBMFontConfiguration,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCBMFontConfiguration.cs,parseKerningEntry,The following statement contains a magic number: try              {                  var element = new CCKerningHashElement();                  element.Amount = amount;                  element.Key = (first << 16) | (second & 0xffff);                  GlyphKernings.Add(element.Key' element);              }              catch (Exception)              {                  CocosSharp.CCLog.Log("Failed to parse font line: {0}"' line);              }
Magic Number,CocosSharp,CCFontFNT,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCFontFNT.cs,GetHorizontalKerningForChars,The following statement contains a magic number: int key = (firstChar << 16) | (secondChar & 0xffff);
Magic Number,CocosSharp,FileFontFileEnumerator,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-FontUtilities-Win8.cs,MoveNext,The following statement contains a magic number: if (moveNext)              {                  if (_currentFontFile != null)                      _currentFontFile.Dispose();                    _currentFontFile = new FontFile(_factory' keyStream.PositionPointer' 4' _loader);                  keyStream.Position += 4;              }
Magic Number,CocosSharp,FileFontFileEnumerator,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-FontUtilities-Win8.cs,MoveNext,The following statement contains a magic number: if (moveNext)              {                  if (_currentFontFile != null)                      _currentFontFile.Dispose();                    _currentFontFile = new FontFile(_factory' keyStream.PositionPointer' 4' _loader);                  keyStream.Position += 4;              }
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,RenderLayer,The following statement contains a magic number: if(Camera != null)              {                  if (verticesPositionDirty)                      UpdateVerticesPosition();                                    var drawManager = DrawManager;                    bool depthTest = drawManager.DepthTest;                    // We're drawing a quad at z=0                  // We need to ensure depth testing is off so that the layer color doesn't obscure anything                  drawManager.DepthTest = false;                  drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                  drawManager.DrawPrimitives(PrimitiveType.TriangleStrip'  SquareVertices' 0' 2);                  drawManager.DepthTest = depthTest;              }
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The following statement contains a magic number: SquareVertices[2].Color = color;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateColor,The following statement contains a magic number: SquareVertices[3].Color = color;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[2].Position.X = SquareVertices[0].Position.X;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[2].Position.Y = SquareVertices[0].Position.Y + visibleBounds.Size.Height;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[3].Position.X = SquareVertices[0].Position.X + visibleBounds.Size.Width;
Magic Number,CocosSharp,CCLayerColor,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerColor.cs,UpdateVerticesPosition,The following statement contains a magic number: SquareVertices[3].Position.Y = SquareVertices[0].Position.Y + visibleBounds.Size.Height;
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: double c = Math.Sqrt(2.0);
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: SquareVertices[2].Color = new Color(                  (byte) (E.R + (S.R - E.R) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.G + (S.G - E.G) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.B + (S.B - E.B) * ((c + u.X - u.Y) / (2.0f * c)))'                  (byte) (E.A + (S.A - E.A) * ((c + u.X - u.Y) / (2.0f * c)))                  );
Magic Number,CocosSharp,CCLayerGradient,C:\repos\mono_CocosSharp\src\Nodes\Layers\CCLayerGradient.cs,UpdateColor,The following statement contains a magic number: SquareVertices[3].Color = new Color(                  (byte) (E.R + (S.R - E.R) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.G + (S.G - E.G) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.B + (S.B - E.B) * ((c - u.X - u.Y) / (2.0f * c)))'                  (byte) (E.A + (S.A - E.A) * ((c - u.X - u.Y) / (2.0f * c)))                  );
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInColumns,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          Debug.Assert (row < numOfItemsPerRow.Length);                            rowColumns = numOfItemsPerRow[row];                          // can not have zero columns on a row                          Debug.Assert (rowColumns > 0' "");                            float tmp = item.ContentSize.Height;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            ++columnsOccupied;                          if (columnsOccupied >= rowColumns)                           {                              height += rowHeight + (int)DefaultPadding;                                columnsOccupied = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }                    // check if too many rows/columns for available menu items                  Debug.Assert(columnsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    row = 0;                  rowHeight = 0;                  rowColumns = 0;                  float w = 0.0f;                  float x = 0.0f;                  float y = (height / 2f);                    foreach (CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (rowColumns == 0)                           {                              rowColumns = numOfItemsPerRow[row];                              if (rowColumns == 0) {                                  throw (new ArgumentException ("Can not have a zero column size for a row."));                              }                              w = (menuSize.Width - 2 * DefaultPadding) / rowColumns; // 1 + rowColumns                              x = w / 2f; // center of column                          }                            float tmp = item.ContentSize.Height * item.ScaleY;                          rowHeight = (int)((rowHeight >= tmp || float.IsNaN (tmp)) ? rowHeight : tmp);                            item.Position                           = new CCPoint(DefaultPadding + x - (menuSize.Width - 2 * DefaultPadding) / 2'                               y - item.ContentSize.Height * item.ScaleY / 2);                            x += w;                          ++columnsOccupied;                            if (columnsOccupied >= rowColumns)                           {                              y -= rowHeight + DefaultPadding;                                columnsOccupied = 0;                              rowColumns = 0;                              rowHeight = 0;                              ++row;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AlignItemsInRows,The following statement contains a magic number: if (menuItems != null && menuItems.Count > 0)              {                  foreach (CCMenuItem item in menuItems)                  {                      if(item.Visible)                       {                          // check if too many menu items for the amount of rows/columns                          Debug.Assert (column < numOfItemsPerColumn.Length' "");                            columnRows = numOfItemsPerColumn[column];                          // can't have zero rows on a column                          Debug.Assert (columnRows > 0' "");                            float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                              columnHeight += (int)(item.ContentSize.Height * item.ScaleY + DefaultPadding);                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              columnWidths.Add(columnWidth);                              columnHeights.Add(columnHeight);                              width += columnWidth + DefaultPadding * 2.0f;                                rowsOccupied = 0;                              columnWidth = 0;                              columnHeight = -DefaultPadding;                              ++column;                          }                      }                  }                    // check if too many rows/columns for available menu items.                  Debug.Assert(rowsOccupied == 0' "");                    CCSize menuSize = ContentSize;                    column = 0;                  columnWidth = 0;                  columnRows = 0;                  float x = (-width / 2f);                  float y = 0.0f;                    foreach(CCMenuItem item in menuItems)                  {                      if (item.Visible)                       {                          if (columnRows == 0)                           {                              columnRows = numOfItemsPerColumn[column];                              y = columnHeights [column];                          }                            // columnWidth = fmaxf(columnWidth' [item contentSize].width);                          float tmp = item.ContentSize.Width * item.ScaleX;                          columnWidth = (int)((columnWidth >= tmp || float.IsNaN (tmp)) ? columnWidth : tmp);                            item.Position = new CCPoint (x + columnWidths [column] / 2' y - menuSize.Height / 2);                          y -= item.ContentSize.Height * item.ScaleY + 10;                          ++rowsOccupied;                            if (rowsOccupied >= columnRows)                           {                              x += columnWidth + 5;                              rowsOccupied = 0;                              columnRows = 0;                              columnWidth = 0;                              ++column;                          }                      }                  }              }
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCMenuItemLabelBase,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenuItemLabel.cs,CCMenuItemLabelBase,The following statement contains a magic number: DisabledColor = new CCColor3B(126' 126' 126);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawDot,The following statement contains a magic number: var segments = 10 * (float)Math.Sqrt(radius);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCircle,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidCircle,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawSolidArc,The following statement contains a magic number: int segments = (int)(10 * (float)Math.Sqrt(radius));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawRect,The following statement contains a magic number: DrawPolygon(pt' 4' cf' borderWidth' bc);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The following statement contains a magic number: DrawEllipticalArc(rect' 0' 360' false' lineWidth' color);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawEllipse,The following statement contains a magic number: DrawEllipticalArc(x'y'width'height'0'360'false' lineWidth' color);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawCardinalSpline,The following statement contains a magic number: for (int i = 0; i < segments + 1; i++)              {                  float dt = (float) i / segments;                    // border                  if (dt == 1)                  {                      p = count - 1;                      lt = 1;                  }                  else                  {                      p = (int) (dt / deltaT);                      lt = (dt - deltaT * p) / deltaT;                  }                    // Interpolate                      int c = config.Count - 1;                  CCPoint pp0 = config[Math.Min(c' Math.Max(p - 1' 0))];                  CCPoint pp1 = config[Math.Min(c' Math.Max(p + 0' 0))];                  CCPoint pp2 = config[Math.Min(c' Math.Max(p + 1' 0))];                  CCPoint pp3 = config[Math.Min(c' Math.Max(p + 2' 0))];                    vertices[i] = CCSplineMath.CCCardinalSplineAt(pp0' pp1' pp2' pp3' tension' lt);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: var numberOfTriangles = outline ? (3 * polycount - 2) : (polycount - 2);
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: if (outline)              {                  var extrude = new ExtrudeVerts[polycount];                    for (int i = 0; i < polycount; i++)                  {                      var v0 = verts[(i - 1 + polycount) % polycount];                      var v1 = verts[i];                      var v2 = verts[(i + 1) % polycount];                        var n1 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v1 - v0));                      var n2 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v2 - v1));                        var offset = (n1 + n2) * (1.0f / (CCPoint.Dot(n1' n2) + 1.0f));                      extrude[i] = new ExtrudeVerts() { offset = offset' n = n2 };                  }                    for (int i = 0; i < polycount - 2; i++)                  {                      var v0 = verts[0];                      var v1 = verts[i + 1];                      var v2 = verts[i + 2];                        AddTriangleVertex(new CCV3F_C4B(v0' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v1' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v2' colorFill)); //__t(v2fzero)                  }                    for (int i = 0; i < polycount - 1; i++)                  {                      int j = (i + 1) % polycount;                      var v0 = verts[i];                      var v1 = verts[j];                        var offset0 = extrude[i].offset;                      var offset1 = extrude[j].offset;                        var inner0 = (v0 - (offset0 * borderWidth));                      var inner1 = (v1 - (offset1 * borderWidth));                      var outer0 = (v0 + (offset0 * borderWidth));                      var outer1 = (v1 + (offset1 * borderWidth));                        AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                         AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                   }                    if (closePolygon)                  {                      for (int i = polycount - 1; i < polycount; i++)                      {                          int j = (i + 1) % polycount;                          var v0 = verts[i];                          var v1 = verts[j];                            var offset0 = extrude[i].offset;                          var offset1 = extrude[j].offset;                            var inner0 = (v0 - (offset0 * borderWidth));                          var inner1 = (v1 - (offset1 * borderWidth));                          var outer0 = (v0 + (offset0 * borderWidth));                          var outer1 = (v1 + (offset1 * borderWidth));                            AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                             AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                       }                  }              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The following statement contains a magic number: if (outline)              {                  var extrude = new ExtrudeVerts[polycount];                    for (int i = 0; i < polycount; i++)                  {                      var v0 = verts[(i - 1 + polycount) % polycount];                      var v1 = verts[i];                      var v2 = verts[(i + 1) % polycount];                        var n1 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v1 - v0));                      var n2 = CCPoint.Normalize(CCPoint.PerpendicularCCW(v2 - v1));                        var offset = (n1 + n2) * (1.0f / (CCPoint.Dot(n1' n2) + 1.0f));                      extrude[i] = new ExtrudeVerts() { offset = offset' n = n2 };                  }                    for (int i = 0; i < polycount - 2; i++)                  {                      var v0 = verts[0];                      var v1 = verts[i + 1];                      var v2 = verts[i + 2];                        AddTriangleVertex(new CCV3F_C4B(v0' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v1' colorFill)); //__t(v2fzero)                      AddTriangleVertex(new CCV3F_C4B(v2' colorFill)); //__t(v2fzero)                  }                    for (int i = 0; i < polycount - 1; i++)                  {                      int j = (i + 1) % polycount;                      var v0 = verts[i];                      var v1 = verts[j];                        var offset0 = extrude[i].offset;                      var offset1 = extrude[j].offset;                        var inner0 = (v0 - (offset0 * borderWidth));                      var inner1 = (v1 - (offset1 * borderWidth));                      var outer0 = (v0 + (offset0 * borderWidth));                      var outer1 = (v1 + (offset1 * borderWidth));                        AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                         AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                       AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                   }                    if (closePolygon)                  {                      for (int i = polycount - 1; i < polycount; i++)                      {                          int j = (i + 1) % polycount;                          var v0 = verts[i];                          var v1 = verts[j];                            var offset0 = extrude[i].offset;                          var offset1 = extrude[j].offset;                            var inner0 = (v0 - (offset0 * borderWidth));                          var inner1 = (v1 - (offset1 * borderWidth));                          var outer0 = (v0 + (offset0 * borderWidth));                          var outer1 = (v1 + (offset1 * borderWidth));                            AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(inner1' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                             AddTriangleVertex(new CCV3F_C4B(inner0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer0' borderFill));                           AddTriangleVertex(new CCV3F_C4B(outer1' borderFill));                       }                  }              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = triangleVertsCount / 3;                  // submit the draw call to the graphics card                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangleVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = triangleVertsCount / 3;                  // submit the draw call to the graphics card                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangleVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = lineVertsCount / 2;                  // submit the draw call to the graphics card                   DrawManager.DrawPrimitives(PrimitiveType.LineList' lineVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  var drawManager = DrawManager;                    drawManager.TextureEnabled = false;                  drawManager.BlendFunc(BlendFunc);                    int primitiveCount = lineVertsCount / 2;                  // submit the draw call to the graphics card                   DrawManager.DrawPrimitives(PrimitiveType.LineList' lineVertices.Elements' 0' primitiveCount);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float rx = width / 2;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float ry = height / 2;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float alpha = startAngle * PI / 180;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: float beta = endAngle * PI / 180;
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (Math.Abs(beta - alpha) > PI)              {                  if (beta > alpha)                      beta -= 2 * PI;                  else                      alpha -= 2 * PI;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (Math.Abs(beta - alpha) > PI)              {                  if (beta > alpha)                      beta -= 2 * PI;                  else                      alpha -= 2 * PI;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: bcp = (float)(4.0 / 3.0 * (1 - Math.Cos(delta / 2)) / Math.Sin(delta / 2));
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arc,The following statement contains a magic number: if (start)              {                  /* starting point */                  double sx = cx + rx * cos_alpha;                  double sy = cy + ry * sin_alpha;                  if (isPieSlice)                   {                      destinationPoint.X = (float)sx;                      destinationPoint.Y = (float)sy;                        DrawPolygon(new CCPoint[] {startPoint'destinationPoint}' 2' CCColor4B.Transparent' lineWidth' color);                  }                    startPoint.X = (float)sx;                  startPoint.Y = (float)sy;              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  float current = startAngle + drawn;                  float additional;                    if (enough)                   {                      if (isPieSlice)                       {                          startPoint.X = x + (width / 2);                          startPoint.Y = y + (height / 2);                          DrawPolygon(new CCPoint[] {destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);                      }                      return;                  }                    additional = endAngle - current; /* otherwise' add the remainder */                  if (additional > 90)                  {                      additional = 90.0f;                  }                  else                  {                      /* a near zero value will introduce bad artefact in the drawing (#78999) */                      if (( additional >= -0.0001f) && (additional <= 0.0001f))                          return;                      enough = true;                  }                    make_arc((i == 0)'    /* only move to the starting pt in the 1st iteration */                      x' y' width' height'   /* bounding rectangle */                      current' current + additional' antialiasing' isPieSlice' lineWidth' color);                    drawn += additional;                }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,make_arcs,The following statement contains a magic number: if (isPieSlice) {                  startPoint.X = x + (width / 2);                  startPoint.Y = y + (height / 2);                  DrawPolygon (new CCPoint[] { destinationPoint' startPoint}' 2' CCColor4B.Transparent' lineWidth' color);              }
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,CCGeometryNode,The following statement contains a magic number: indicesArray = new CCRawList<short>(bufferSize * 2);
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,FlushVertexArray,The following statement contains a magic number: var numberIndices = instance.PrimitiveType == PrimitiveType.TriangleList ? numberOfIndices / 3 : numberOfIndices / 2;
Magic Number,CocosSharp,CCGeometryNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCGeometryNode.cs,FlushVertexArray,The following statement contains a magic number: var numberIndices = instance.PrimitiveType == PrimitiveType.TriangleList ? numberOfIndices / 3 : numberOfIndices / 2;
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The following statement contains a magic number: maxPoints = (int) (fade * 60.0f) + 2;
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,CCMotionStreak,The following statement contains a magic number: vertices = new CCV3F_C4B_T2F[(maxPoints + 1) * 2];
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,RenderMotionStreak,The following statement contains a magic number: drawManager.DrawPrimitives(PrimitiveType.TriangleStrip' vertices' 0' numOfPoints * 2 - 2);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,RenderMotionStreak,The following statement contains a magic number: drawManager.DrawPrimitives(PrimitiveType.TriangleStrip' vertices' 0' numOfPoints * 2 - 2);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: float rad70 = MathHelper.ToRadians(70);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: float rad170 = MathHelper.ToRadians(170);
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPoints; i++)              {                  idx = i * 2;                  CCPoint p1 = points[i];                  CCPoint perpVector;                    if (i == 0)                  {                      perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(p1 - points[i + 1]));                  }                  else if (i == nuPointsMinus)                  {                      perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(points[i - 1] - p1));                  }                  else                  {                      CCPoint p2 = points[i + 1];                      CCPoint p0 = points[i - 1];                        CCPoint p2p1 = CCPoint.Normalize(p2 - p1);                      CCPoint p0p1 = CCPoint.Normalize(p0 - p1);                        // Calculate angle between vectors                      var angle = (float) Math.Acos(CCPoint.Dot(p2p1' p0p1));                        if (angle < rad70)                      {                          perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(CCPoint.Midpoint(p2p1' p0p1)));                      }                      else if (angle < rad170)                      {                          perpVector = CCPoint.Normalize(CCPoint.Midpoint(p2p1' p0p1));                      }                      else                      {                          perpVector = CCPoint.PerpendicularCCW(CCPoint.Normalize(p2 - p0));                      }                  }                    perpVector = perpVector * stroke;                    vertices[idx].Vertices = new CCVertex3F(p1.X + perpVector.X' p1.Y + perpVector.Y' 0);                  vertices[idx + 1].Vertices = new CCVertex3F(p1.X - perpVector.X' p1.Y - perpVector.Y' 0);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPointsMinus; i++)              {                  idx = i * 2;                  int idx1 = idx + 2;                    CCVertex3F p1 = vertices[idx].Vertices;                  CCVertex3F p2 = vertices[idx + 1].Vertices;                  CCVertex3F p3 = vertices[idx1].Vertices;                  CCVertex3F p4 = vertices[idx1 + 1].Vertices;                    float s;                  bool fixVertex = !VertexLineIntersect(p1.X' p1.Y' p4.X' p4.Y' p2.X' p2.Y' p3.X' p3.Y' out s);                  if (!fixVertex)                  {                      if (s < 0.0f || s > 1.0f)                      {                          fixVertex = true;                      }                  }                    if (fixVertex)                  {                      vertices[idx1].Vertices = p4;                      vertices[idx1 + 1].Vertices = p3;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,VertexLineToPolygon,The following statement contains a magic number: for (int i = offset; i < nuPointsMinus; i++)              {                  idx = i * 2;                  int idx1 = idx + 2;                    CCVertex3F p1 = vertices[idx].Vertices;                  CCVertex3F p2 = vertices[idx + 1].Vertices;                  CCVertex3F p3 = vertices[idx1].Vertices;                  CCVertex3F p4 = vertices[idx1 + 1].Vertices;                    float s;                  bool fixVertex = !VertexLineIntersect(p1.X' p1.Y' p4.X' p4.Y' p2.X' p2.Y' p3.X' p3.Y' out s);                  if (!fixVertex)                  {                      if (s < 0.0f || s > 1.0f)                      {                          fixVertex = true;                      }                  }                    if (fixVertex)                  {                      vertices[idx1].Vertices = p4;                      vertices[idx1 + 1].Vertices = p3;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,TintWithColor,The following statement contains a magic number: for (int i = 0; i < numOfPoints * 2; i++)              {                  vertices[i].Colors = new CCColor4B(colors.R' colors.G' colors.B' 255);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,TintWithColor,The following statement contains a magic number: for (int i = 0; i < numOfPoints * 2; i++)              {                  vertices[i].Colors = new CCColor4B(colors.R' colors.G' colors.B' 255);              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: for (i = 0; i < numOfPoints; i++)              {                  pointState[i] -= delta;                    if (pointState[i] <= 0)                  {                      mov++;                  }                  else                  {                      newIdx = i - mov;                        if (mov > 0)                      {                          // Move data                          pointState[newIdx] = pointState[i];                            // Move point                          pointVertexes[newIdx] = pointVertexes[i];                            // Move vertices                          i2 = i * 2;                          newIdx2 = newIdx * 2;                          vertices[newIdx2].Vertices = vertices[i2].Vertices;                          vertices[newIdx2 + 1].Vertices = vertices[i2 + 1].Vertices;                            // Move color                          vertices[newIdx2].Colors = vertices[i2].Colors;                          vertices[newIdx2 + 1].Colors = vertices[i2 + 1].Colors;                      }                      else                      {                          newIdx2 = newIdx * 2;                      }                        vertices[newIdx2].Colors.A = vertices[newIdx2 + 1].Colors.A = (byte) (pointState[newIdx] * 255.0f);                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints >= maxPoints)              {                  appendNewPoint = false;              }                else if (numOfPoints > 0)              {                  bool a1 = pointVertexes[numOfPoints - 1].DistanceSquared(ref positionR) < minSeg;                  bool a2 = (numOfPoints != 1) && (pointVertexes[numOfPoints - 2].DistanceSquared(ref positionR) < (minSeg * 2.0f));                    if (a1 || a2)                  {                      appendNewPoint = false;                  }              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (appendNewPoint)              {                  pointVertexes[numOfPoints] = positionR;                  pointState[numOfPoints] = 1.0f;                    // Color asignation                  int offset = numOfPoints * 2;                  vertices[offset].Colors = vertices[offset + 1].Colors = new CCColor4B(DisplayedColor.R' DisplayedColor.G' DisplayedColor.B' 255);                    // Generate polygon                  if (numOfPoints > 0 && FastMode)                  {                      if (numOfPoints > 1)                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' numOfPoints' 1);                      }                      else                      {                          VertexLineToPolygon(pointVertexes' stroke' vertices' 0' 2);                      }                  }                    numOfPoints++;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints > 0 && previousNumOfPoints != numOfPoints)              {                  float texDelta = 1.0f / numOfPoints;                  for (i = 0; i < numOfPoints; i++)                  {                      vertices[i * 2].TexCoords = new CCTex2F(0' texDelta * i);                      vertices[i * 2 + 1].TexCoords = new CCTex2F(1' texDelta * i);                  }                    previousNumOfPoints = numOfPoints;              }
Magic Number,CocosSharp,CCMotionStreak,C:\repos\mono_CocosSharp\src\Nodes\Other\CCMotionStreak.cs,Update,The following statement contains a magic number: if (numOfPoints > 0 && previousNumOfPoints != numOfPoints)              {                  float texDelta = 1.0f / numOfPoints;                  for (i = 0; i < numOfPoints; i++)                  {                      vertices[i * 2].TexCoords = new CCTex2F(0' texDelta * i);                      vertices[i * 2 + 1].TexCoords = new CCTex2F(1' texDelta * i);                  }                    previousNumOfPoints = numOfPoints;              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RenderProgress,The following statement contains a magic number: if (vertexData != null && sprite != null)               {                  DrawManager.BindTexture(Sprite.Texture);                  DrawManager.BlendFunc(Sprite.BlendFunc);                    DrawManager.DrawIndexedPrimitives(PrimitiveType.TriangleList' vertexData' 0'                       vertexData.Length' vertexIndices' 0' vertexData.Length - 2);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,BoundaryTexCoord,The following statement contains a magic number: if (index < ProgressTextureCoordsCount)              {                  if (ReverseDirection)                  {                      return new CCPoint((ProgressTextureCoords >> (7 - (index << 1))) & 1'                          (ProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1);                  }                  return new CCPoint((ProgressTextureCoords >> ((index << 1) + 1)) & 1'                      (ProgressTextureCoords >> (index << 1)) & 1);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,BoundaryTexCoord,The following statement contains a magic number: if (index < ProgressTextureCoordsCount)              {                  if (ReverseDirection)                  {                      return new CCPoint((ProgressTextureCoords >> (7 - (index << 1))) & 1'                          (ProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1);                  }                  return new CCPoint((ProgressTextureCoords >> ((index << 1) + 1)) & 1'                      (ProgressTextureCoords >> (index << 1)) & 1);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,RefreshVertexIndices,The following statement contains a magic number: if (vertexData != null)               {                  int count = (vertexData.Length - 2);                  int i3;                  vertexIndices = new short[count * 3];                    if (Type == CCProgressTimerType.Radial)                   {                      // Fan                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = 0;                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }                   else if (Type == CCProgressTimerType.Bar)                   {                      // Triangle strip                      for (int i = 0; i < count; i++)                       {                          i3 = i * 3;                          vertexIndices [i3 + 0] = (short)(i + 0);                          vertexIndices [i3 + 1] = (short)(i + 1);                          vertexIndices [i3 + 2] = (short)(i + 2);                      }                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateBar,The following statement contains a magic number: if (!ReverseDirection)              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[4];                  }                  //    TOPLEFT                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    //    BOTLEFT                  vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    //    TOPRIGHT                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    //    BOTRIGHT                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }              else              {                  if (vertexData == null)                  {                      vertexData = new CCV3F_C4B_T2F[8];                        // TOPLEFT 1                      vertexData[0].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 1));                      vertexData[0].Vertices = VertexFromAlphaPoint(new CCPoint(0' 1));                        // BOTLEFT 1                      vertexData[1].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(0' 0));                      vertexData[1].Vertices = VertexFromAlphaPoint(new CCPoint(0' 0));                        // TOPRIGHT 2                      vertexData[6].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 1));                      vertexData[6].Vertices = VertexFromAlphaPoint(new CCPoint(1' 1));                        // BOTRIGHT 2                      vertexData[7].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(1' 0));                      vertexData[7].Vertices = VertexFromAlphaPoint(new CCPoint(1' 0));                  }                    // TOPRIGHT 1                  vertexData[2].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' max.Y));                  vertexData[2].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' max.Y));                    // BOTRIGHT 1                  vertexData[3].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(min.X' min.Y));                  vertexData[3].Vertices = VertexFromAlphaPoint(new CCPoint(min.X' min.Y));                    // TOPLEFT 2                  vertexData[4].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' max.Y));                  vertexData[4].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' max.Y));                    // BOTLEFT 2                  vertexData[5].TexCoords = TextureCoordFromAlphaPoint(new CCPoint(max.X' min.Y));                  vertexData[5].Vertices = VertexFromAlphaPoint(new CCPoint(max.X' min.Y));              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (alpha == 0f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is zero then the hit point is top mid and the index is 0.                  hit = topMid;                  index = 0;              }              else if (alpha == 1f)              {                  //    More efficient since we don't always need to check intersection                  //    If the alpha is one then the hit point is top mid and the index is 4.                  hit = topMid;                  index = 4;              }              else              {                  //    We run a for loop checking the edges of the texture to find the                  //    intersection point                  //    We loop through five points since the top is split in half                    float min_t = float.MaxValue;                    for (int i = 0; i <= ProgressTextureCoordsCount; ++i)                  {                      int pIndex = (i + (ProgressTextureCoordsCount - 1)) % ProgressTextureCoordsCount;                        CCPoint edgePtA = BoundaryTexCoord(i % ProgressTextureCoordsCount);                      CCPoint edgePtB = BoundaryTexCoord(pIndex);                        //    Remember that the top edge is split in half for the 12 o'clock position                      //    Let's deal with that here by finding the correct endpoints                      if (i == 0)                      {                          edgePtB = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                      else if (i == 4)                      {                          edgePtA = CCPoint.Lerp(edgePtA' edgePtB' 1 - Midpoint.X);                      }                        //    s and t are returned by ccpLineIntersect                      float s = 0' t = 0;                      if (CCPoint.LineIntersect(edgePtA' edgePtB' Midpoint' percentagePt' ref s' ref t))                      {                          //    Since our hit test is on rays we have to deal with the top edge                          //    being in split in half so we have to test as a segment                          if ((i == 0 || i == 4))                          {                              //    s represents the point between edgePtA--edgePtB                              if (!(0f <= s && s <= 1f))                              {                                  continue;                              }                          }                          //    As long as our t isn't negative we are at least finding a                          //    correct hitpoint from m_tMidpoint to percentagePt.                          if (t >= 0f)                          {                              //    Because the percentage line and all the texture edges are                              //    rays we should only account for the shortest intersection                              if (t < min_t)                              {                                  min_t = t;                                  index = i;                              }                          }                      }                  }                    //    Now that we have the minimum magnitude we can use that to find our intersection                  hit = Midpoint + ((percentagePt - Midpoint) * min_t);              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (vertexData != null && vertexData.Length != index + 3)              {                  sameIndexCount = false;                  vertexData = null;              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (vertexData == null)              {                  sameIndexCount = false;                  vertexData = new CCV3F_C4B_T2F[index + 3];              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (!sameIndexCount)              {                  //    First we populate the array with the m_tMidpoint' then all                  //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(Midpoint);                  vertexData[0].Vertices = VertexFromAlphaPoint(Midpoint);                    vertexData[1].TexCoords = TextureCoordFromAlphaPoint(topMid);                  vertexData[1].Vertices = VertexFromAlphaPoint(topMid);                    for (int i = 0; i < index; ++i)                  {                      CCPoint alphaPoint = BoundaryTexCoord(i);                      vertexData[i + 2].TexCoords = TextureCoordFromAlphaPoint(alphaPoint);                      vertexData[i + 2].Vertices = VertexFromAlphaPoint(alphaPoint);                  }              }
Magic Number,CocosSharp,CCProgressTimer,C:\repos\mono_CocosSharp\src\Nodes\Other\CCProgressTimer.cs,UpdateRadial,The following statement contains a magic number: if (!sameIndexCount)              {                  //    First we populate the array with the m_tMidpoint' then all                  //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint                  vertexData[0].TexCoords = TextureCoordFromAlphaPoint(Midpoint);                  vertexData[0].Vertices = VertexFromAlphaPoint(Midpoint);                    vertexData[1].TexCoords = TextureCoordFromAlphaPoint(topMid);                  vertexData[1].Vertices = VertexFromAlphaPoint(topMid);                    for (int i = 0; i < index; ++i)                  {                      CCPoint alphaPoint = BoundaryTexCoord(i);                      vertexData[i + 2].TexCoords = TextureCoordFromAlphaPoint(alphaPoint);                      vertexData[i + 2].Vertices = VertexFromAlphaPoint(alphaPoint);                  }              }
Magic Number,CocosSharp,CCRenderTexture,C:\repos\mono_CocosSharp\src\Nodes\Other\CCRenderTexture.cs,CCRenderTexture,The following statement contains a magic number: renderProjMatrix =                   Matrix.CreateOrthographic(contentSize.Width' contentSize.Height' 1024f' -1024);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: ParallaxArray = new List<CCPointObject>(5);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: lastPosition = new CCPoint(-100' -100);
Magic Number,CocosSharp,CCParallaxNode,C:\repos\mono_CocosSharp\src\Nodes\Parallax\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: lastPosition = new CCPoint(-100' -100);
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFire,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFire,The following statement contains a magic number: if (config == null)               {                  config = new CCParticleSystemConfig ();                  config.ParticleSystemType = CCParticleSystemType.Internal;                    config.Duration = ParticleDurationInfinity;                  config.Life = 3;                  config.LifeVar = 0.25f;                  config.Position = position;                  config.PositionVar = new CCPoint(40' 20);                  config.Angle = 90;                  config.AngleVar = 10;                  config.StartSize = 54.0f;                  config.StartSizeVar = 10.0f;                  config.EndSize = ParticleStartSizeEqualToEndSize;                    config.EmitterMode = CCEmitterMode.Gravity;                    CCColor4F cstartColor = new CCColor4F();                  cstartColor.R = 0.76f;                  cstartColor.G = 0.25f;                  cstartColor.B = 0.12f;                  cstartColor.A = 1.0f;                  config.StartColor = cstartColor;                    CCColor4F cstartColorVar = new CCColor4F();                  cstartColorVar.R = 0.0f;                  cstartColorVar.G = 0.0f;                  cstartColorVar.B = 0.0f;                  cstartColorVar.A = 0.0f;                  config.StartColorVar = cstartColorVar;                    CCColor4F cendColor = new CCColor4F();                  cendColor.R = 0.0f;                  cendColor.G = 0.0f;                  cendColor.B = 0.0f;                  cendColor.A = 1.0f;                  config.EndColor = cendColor;                    CCColor4F cendColorVar = new CCColor4F();                  cendColorVar.R = 0.0f;                  cendColorVar.G = 0.0f;                  cendColorVar.B = 0.0f;                  cendColorVar.A = 0.0f;                  config.EndColorVar = cendColorVar;                    config.Gravity = new CCPoint(0' 0);                  config.GravityRadialAccel = 0;                  config.GravityRadialAccelVar = 0;                  config.GravitySpeed = 60;                  config.GravitySpeedVar = 20;                    config.Texture = CCParticleExample.DefaultTexture;                }
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: AngleVar = 20;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.Gravity = new CCPoint (0' -90);
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.Speed = 180;
Magic Number,CocosSharp,CCParticleFireworks,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFireworks,The following statement contains a magic number: gravityMode.SpeedVar = 50;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: gravityMode.Speed = 20;
Magic Number,CocosSharp,CCParticleSun,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSun,The following statement contains a magic number: gravityMode.SpeedVar = 5;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.RadialAccel = -80;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.Speed = 60;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleGalaxy,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleGalaxy,The following statement contains a magic number: gravityMode.TangentialAccel = 80;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.RadialAccel = -60;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.Speed = 80;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleFlower,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleFlower,The following statement contains a magic number: gravityMode.TangentialAccel = 15;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: Life = 2;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(-200' 200);
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(-200' 200);
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.Speed = 15;
Magic Number,CocosSharp,CCParticleMeteor,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleMeteor,The following statement contains a magic number: gravityMode.SpeedVar = 5;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: Life = 12;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.RadialAccel = -380;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.Speed = 150;
Magic Number,CocosSharp,CCParticleSpiral,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSpiral,The following statement contains a magic number: gravityMode.TangentialAccel = 45;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: LifeVar = 2;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: AngleVar = 360;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: gravityMode.Speed = 70;
Magic Number,CocosSharp,CCParticleExplosion,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleExplosion,The following statement contains a magic number: gravityMode.SpeedVar = 40;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: Life = 4;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: PositionVar = new CCPoint(20' 0);
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: Angle = 90;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: gravityMode.Speed = 25;
Magic Number,CocosSharp,CCParticleSmoke,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSmoke,The following statement contains a magic number: gravityMode.SpeedVar = 10;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: Life = 45;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: LifeVar = 15;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: Angle = -90;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: EmissionRate = 10;
Magic Number,CocosSharp,CCParticleSnow,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleSnow,The following statement contains a magic number: gravityMode.Speed = 5;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: Angle = -90;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: AngleVar = 5;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: EmissionRate = 20;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(10' -10);
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Gravity = new CCPoint(10' -10);
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.Speed = 130;
Magic Number,CocosSharp,CCParticleRain,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleExamples.cs,CCParticleRain,The following statement contains a magic number: gravityMode.SpeedVar = 30;
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: foreach (var pair in configs)  			{  				var texture = pair.Value.Texture.XNATexture;    				if (texture != null)  				{  					var bytes = texture.Width * texture.Height * 4;  					CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);  					total += bytes;  				}    				count++;  			}
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: foreach (var pair in configs)  			{  				var texture = pair.Value.Texture.XNATexture;    				if (texture != null)  				{  					var bytes = texture.Width * texture.Height * 4;  					CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);  					total += bytes;  				}    				count++;  			}
Magic Number,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,DumpCachedInfo,The following statement contains a magic number: CCLog.Log("{0} particle systems' for {1} KB ({2:00.00} MB)"' count' total / 1024' total / (1024f * 1024f));
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: if(OpacityModifyRGB)              {                  color.R = (byte) (particle.Color.R * particle.Color.A * 255);                  color.G = (byte) (particle.Color.G * particle.Color.A * 255);                  color.B = (byte) (particle.Color.B * particle.Color.A * 255);                  color.A = (byte)(particle.Color.A * 255);              }              else              {                  color.R = (byte)(particle.Color.R * 255);                  color.G = (byte)(particle.Color.G * 255);                  color.B = (byte)(particle.Color.B * 255);                  color.A = (byte)(particle.Color.A * 255);              }
Magic Number,CocosSharp,CCParticleSystemQuad,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemQuad.cs,UpdateQuad,The following statement contains a magic number: float size_2 = particle.Size / 2;
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: outTexSprite.Opacity = 255;
Magic Number,CocosSharp,CCTransitionCrossFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionCrossFade.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(outTexture.Sprite' 3);
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(fadeLayer' 3);
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: var a = (CCFiniteTimeAction) new CCSequence                                             (                                                 new CCShow()'                                                 new CCFadeIn (Duration / 2)'                                                 new CCCallFunc((HideOutShowIn))'                                                 new CCFadeOut  (Duration / 2)                                             );
Magic Number,CocosSharp,CCTransitionFade,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFade.cs,InitialiseScenes,The following statement contains a magic number: var a = (CCFiniteTimeAction) new CCSequence                                             (                                                 new CCShow()'                                                 new CCFadeIn (Duration / 2)'                                                 new CCCallFunc((HideOutShowIn))'                                                 new CCFadeOut  (Duration / 2)                                             );
Magic Number,CocosSharp,CCTransitionFadeTR,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFadeTR.cs,InitialiseScenes,The following statement contains a magic number: var x = (int) (12 * aspect);
Magic Number,CocosSharp,CCTransitionFadeTR,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFadeTR.cs,InitialiseScenes,The following statement contains a magic number: int y = 12;
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCJumpBy jump = new CCJumpBy (Duration / 4' new CCPoint(-bounds.Size.Width' 0)' bounds.Size.Width / 4' 2);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCFiniteTimeAction scaleIn = new CCScaleTo(Duration / 4' 1.0f);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: CCFiniteTimeAction scaleOut = new CCScaleTo(Duration / 4' 0.5f);
Magic Number,CocosSharp,CCTransitionJumpZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionJumpZoom.cs,InitialiseScenes,The following statement contains a magic number: delay = new CCDelayTime (Duration / 2);
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionPageTurn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionPageTurn.cs,InitialiseScenes,The following statement contains a magic number: if (bounds.Size.Width > bounds.Size.Height)              {                  x = 16;                  y = 12;              }              else              {                  x = 12;                  y = 16;              }
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,InitialiseScenes,The following statement contains a magic number: texture.BeginWithClear(0' 0' 0' 255);
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,InitialiseScenes,The following statement contains a magic number: Layer.AddChild(node' 2);
Magic Number,CocosSharp,CCTransitionProgress,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,SetupTransition,The following statement contains a magic number: From = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressRadialCW,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressHorizontal,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressVertical,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressInOut,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,SetupTransition,The following statement contains a magic number: To = 100;
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Percentage = 100;
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionProgressOutIn,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionProgress.cs,ProgressTimerNodeWithRenderTexture,The following statement contains a magic number: node.Position = new CCPoint(bounds.Origin.X + bounds.Size.Width / 2' bounds.Size.Height / 2);
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionRotoZoom,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionRotoZoom.cs,InitialiseScenes,The following statement contains a magic number: rotozoom = new CCSequence(                  new CCSpawn(                      new CCScaleBy(Duration / 2' 0.001f)'                      new CCRotateBy(Duration / 2' 360 * 2)                  )'                  new CCDelayTime(Duration / 2)              );
Magic Number,CocosSharp,CCTransitionShrinkGrow,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionShrinkGrow.cs,InitialiseScenes,The following statement contains a magic number: InSceneNodeContainer.AnchorPoint = new CCPoint(2 / 3.0f' 0.5f);
Magic Number,CocosSharp,CCTransitionTurnOffTiles,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionTurnOffTiles.cs,InitialiseScenes,The following statement contains a magic number: var x = (int) (12 * aspect);
Magic Number,CocosSharp,CCTransitionTurnOffTiles,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionTurnOffTiles.cs,InitialiseScenes,The following statement contains a magic number: int y = 12;
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipAngular,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipAngular.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;                    inAngleX = -45;                  outAngleX = 45;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;                    inAngleX = 45;                  outAngleX = -45;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipX,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipX.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.RightOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCTransitionZoomFlipY,C:\repos\mono_CocosSharp\src\Nodes\Scenes\Transitions\CCTransitionZoomFlipY.cs,InitialiseScenes,The following statement contains a magic number: if (Orientation == CCTransitionOrientation.UpOver)              {                  inDeltaZ = 90;                  inAngleZ = 270;                  outDeltaZ = 90;                  outAngleZ = 0;              }              else              {                  inDeltaZ = -90;                  inAngleZ = 90;                  outDeltaZ = -90;                  outAngleZ = 0;              }
Magic Number,CocosSharp,CCAnimationCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCAnimationCache.cs,AddAnimations,The following statement contains a magic number: if (properties != null)              {                  int version = properties["format"].AsInt;                  PlistArray spritesheets = properties["spritesheets"].AsArray;                    foreach (PlistObjectBase pObj in spritesheets)                  {                      string name = pObj.AsString;                      CCSpriteFrameCache.SharedSpriteFrameCache.AddSpriteFrames(name);                  }                    switch (version)                  {                      case 1:                          ParseVersion1(animations);                          break;                        case 2:                          ParseVersion2(animations);                          break;                        default:                          Debug.Assert(false' "Invalid animation format");                          break;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: if (format < 0 || format > 3)              {                  throw (new NotSupportedException("PList format " + format + " is not supported."));              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteFrameCache,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteFrameCache.cs,AddSpriteFrames,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x=0f' y=0f' w=0f' h=0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                      // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          pobTexture'                          new CCRect(x' y' w' h)'                          new CCSize(ow' oh)'                          false'                          new CCPoint(ox' oy)                      );                  }                  else if (format == 1 || format == 2)                  {                      CCRect frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        CCPoint offset = CCPoint.Parse(frameDict["offset"].AsString);                      CCSize sourceSize = CCSize.Parse (frameDict["sourceSize"].AsString);                        // create frame                      spriteFrame = new CCSpriteFrame(                          sourceSize'                           pobTexture'                          frame'                          sourceSize'                          rotated'                          offset                      );                  }                  else if (format == 3)                  {                      // get values                      CCSize spriteSize = CCSize.Parse (frameDict["spriteSize"].AsString);                      CCPoint spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      CCSize spriteSourceSize = CCSize.Parse (frameDict["spriteSourceSize"].AsString);                      CCRect textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                      bool textureRotated = false;                      if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      PlistArray aliases = frameDict["aliases"].AsArray;                      string frameKey = pair.Key;                        foreach (PlistObjectBase item2 in aliases)                      {                          string oneAlias = item2.AsString;                          if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                          if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' frameKey);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          pobTexture'                          new CCRect(textureRect.Origin.X' textureRect.Origin.Y' spriteSize.Width' spriteSize.Height)'                          spriteSourceSize'                          textureRotated'                          spriteOffset                      );                  }                    // add sprite frame                  string key = pair.Key;                  if (!AllowFrameOverwrite && spriteFrames.ContainsKey(key))                  {                      CCLog.Log("Frame named " + key + " already exists in the animation cache. Not overwriting existing record.");                  }                  else if (AllowFrameOverwrite || !spriteFrames.ContainsKey(key))                  {                      spriteFrames[key] = spriteFrame;                  }              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: if (format < 0 || format > 3)              {                  throw (new NotSupportedException("PList format " + format + " is not supported."));              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCSpriteSheet,C:\repos\mono_CocosSharp\src\Nodes\Sprites\CCSpriteSheet.cs,LoadCocos2DDictionary,The following statement contains a magic number: foreach (var pair in framesDict)              {                  PlistDictionary frameDict = pair.Value.AsDictionary;                  CCSpriteFrame spriteFrame = null;                    if (format == 0)                  {                      float x = 0f' y = 0f' w = 0f' h = 0f;                      x = frameDict["x"].AsFloat;                      y = frameDict["y"].AsFloat;                      w = frameDict["width"].AsFloat;                      h = frameDict["height"].AsFloat;                      float ox = 0f' oy = 0f;                      ox = frameDict["offsetX"].AsFloat;                      oy = frameDict["offsetY"].AsFloat;                      int ow = 0' oh = 0;                      ow = frameDict["originalWidth"].AsInt;                      oh = frameDict["originalHeight"].AsInt;                      // check ow/oh                      if (ow == 0 || oh == 0)                      {                          CCLog.Log(                              "cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist or check the 'format' metatag");                      }                      // abs ow/oh                      ow = Math.Abs(ow);                      oh = Math.Abs(oh);                        // create frame                      spriteFrame = new CCSpriteFrame(                          new CCSize(ow' oh)'                          texture'                          new CCRect(x + ox' y + oy' w' h)'                          false                      );                  }                  else if (format == 1 || format == 2)                  {                      var frame = CCRect.Parse(frameDict["frame"].AsString);                      bool rotated = false;                        // rotation                      if (format == 2)                      {                          if (frameDict.ContainsKey("rotated"))                          {                              rotated = frameDict["rotated"].AsBool;                          }                      }                        var offset = CCPoint.Parse(frameDict["offset"].AsString);                      var sourceSize = CCSize.Parse(frameDict["sourceSize"].AsString);                        frame.Origin += offset;                        // create frame                      spriteFrame = new CCSpriteFrame(sourceSize' texture' frame' rotated );                  }                  else if (format == 3)                  {                      var spriteSize = CCSize.Parse(frameDict["spriteSize"].AsString);                      var spriteOffset = CCPoint.Parse(frameDict["spriteOffset"].AsString);                      var spriteSourceSize = CCSize.Parse(frameDict["spriteSourceSize"].AsString);                      var textureRect = CCRect.Parse(frameDict["textureRect"].AsString);                        bool textureRotated = false;                        if (frameDict.ContainsKey("textureRotated"))                      {                          textureRotated = frameDict["textureRotated"].AsBool;                      }                        // get aliases                      var aliases = frameDict["aliases"].AsArray;                        for (int i = 0; i < aliases.Count; i++ )                      {                          string oneAlias = aliases[i].AsString;                            if (spriteFramesAliases.ContainsKey(oneAlias))                          {                              if (spriteFramesAliases[oneAlias] != null)                              {                                  CCLog.Log("CocosSharp: WARNING: an alias with name {0} already exists"' oneAlias);                              }                          }                            if (!spriteFramesAliases.ContainsKey(oneAlias))                          {                              spriteFramesAliases.Add(oneAlias' pair.Key);                          }                      }                        // create frame                      spriteFrame = new CCSpriteFrame(                          spriteSourceSize'                          texture'                          new CCRect(textureRect.Origin.X + spriteOffset.X' textureRect.Origin.Y + spriteOffset.Y' spriteSize.Width' spriteSize.Height)'                          textureRotated                      );                  }                    spriteFrame.TextureFilename = pair.Key;                  spriteFrames[pair.Key] = spriteFrame;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,CCTileMapInfo,The following statement contains a magic number: ObjectGroups = new List<CCTileMapObjectGroup>(4);
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,StartElement,The following statement contains a magic number: if (atts != null && atts[0] != null)              {                  for (int i = 0; i + 1 < atts.Length; i += 2)                  {                      string key = atts[i];                      string value = atts[i + 1];                      currentAttributeDict.Add(key' value);                  }              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseMultilineShape,The following statement contains a magic number: for (int i = 0; i < pointPairs.Length; i++)  	        {  		        string pointPair = pointPairs[i];  		        string[] pointCoords = pointPair.Split(''');  		        if (pointCoords.Length != 2)  			        return;    				// Adjust the offsets relative to the parent object. When adjusting the coordinates'  				// correct y position. Tiled uses inverted y-coordinate system where top is y=0.  				// We have to invert the y coordinate to make it move in the correct direction relative to the parent.  		        points[i].X = float.Parse(pointCoords[0]) + objectXOffset;  		        points[i].Y = float.Parse(pointCoords[1]) * -1 + objectYOffset;    		        sb.Append(ToFloatString(points[i].X));  		        sb.Append("'");  		        sb.Append(ToFloatString(points[i].Y));  		        sb.Append(" ");  	        }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapInfo.cs,ParseDataEndElement,The following statement contains a magic number: if ((tileDataCompressionType & CCTileDataCompressionType.Base64) != 0)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    if ((tileDataCompressionType & (CCTileDataCompressionType.Gzip | CCTileDataCompressionType.Zlib)) != 0)                  {                      if ((tileDataCompressionType & CCTileDataCompressionType.Gzip) != 0)                      {                          try                          {                              encoded = ZipUtils.Inflate(new MemoryStream(currentString)' ZipUtils.CompressionFormat.Gzip);                          }                          catch (Exception ex)                          {                              CCLog.Log("failed to decompress embedded data object in TMX file.");                              CCLog.Log(ex.ToString());                          }                      }                        if ((tileDataCompressionType & CCTileDataCompressionType.Zlib) != 0)                      {                          encoded = ZipUtils.Inflate (new MemoryStream (currentString)' ZipUtils.CompressionFormat.Zlib);                      }                  }                  else                  {                      encoded = currentString;                  }                    // encoded could be null because the compressed data could not be decompressed                  if (encoded != null)                  {                      for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                      {                          int i4 = i * 4;                            uint gidAndFlags = (uint)(                              (uint)encoded[i4] |                              (uint)encoded[(int)(i4 + 1)] << 8 |                              (uint)encoded[(int)(i4 + 2)] << 16 |                              (uint)encoded[(int)(i4 + 3)] << 24);                              layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                      }                  }                    currentString = null;              }              else if(tileDataCompressionType == CCTileDataCompressionType.Csv)              {                  storingCharacters = false;                    int layersCount = Layers != null ? Layers.Count : 0;                  CCTileLayerInfo layer = layersCount > 0 ? Layers[layersCount - 1] : null;                    var str = System.Text.Encoding.UTF8.GetString(currentString' 0' currentString.Length).Split(''');                    for (int i = 0; i < layer.TileGIDAndFlags.Length; i++)                  {                      uint gidAndFlags = uint.Parse(str[i]);                      layer.TileGIDAndFlags[i] = CCTileMapFileEncodedTileFlags.DecodeGidAndFlags(gidAndFlags);                  }                    currentString = null;              }                  else if((tileDataCompressionType & CCTileDataCompressionType.None) != 0)              {                  currentXmlTileIndex = 0;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,GenerateMinVertexZ,The following statement contains a magic number: if (useAutomaticVertexZ)              {                  switch (MapType)                  {                      case CCTileMapType.Iso:                          minVertexZ = -(LayerSize.Column + LayerSize.Row - 2);                          break;                      case CCTileMapType.Ortho:                          minVertexZ = -(LayerSize.Row - 1);                          break;                      case CCTileMapType.Staggered:                          minVertexZ = -(LayerSize.Row - 1);                          break;                      default:                          break;                  }              }              else                  minVertexZ = defaultTileVertexZ;
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateTileCoordsToNodeTransform,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      // Note: For an orthographic map' top-left represents the origin (0'0)                      // Moving right increases the column                      // Moving left increases the row                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Iso:                      // Note: For an isometric map' top-right tile represents the origin (0'0)                      // Moving left increases the column                      // Moving right increases the row                      float xOffset = (LayerSize.Column - 1) * (width / 2);                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width / 2' -height / 2' 0.0f' 0.0f'                              -width / 2' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              xOffset' yOffset' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Hex:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              height * (float)Math.Sqrt(0.75)' 0.0f' 0.0f' 0.0f'                              0.0f ' -height' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset - height/2' 0.0f' 1.0f                          ));                      break;                  case CCTileMapType.Staggered:                      tileCoordsToNodeTransform = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              0.0f' yOffset / 2' 0.0f' 1.0f                          ));                        tileCoordsToNodeTransformOdd = new CCAffineTransform(new Matrix                          (                              width' 0.0f' 0.0f' 0.0f'                              0.0f' -height / 2' 0.0f' 0.0f'                              0.0f' 0.0f' 1.0f' 0.0f'                              width / 2' yOffset / 2' 0.0f' 1.0f                          ));                      break;                  default:                      tileCoordsToNodeTransform = CCAffineTransform.Identity;                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The following statement contains a magic number: if (MapType == CCTileMapType.Hex || MapType == CCTileMapType.Staggered)              {                  CCPoint oddTransformedPoint = nodeToTileCoordsTransformOdd.Transform(offsetDiff).RoundToInteger();                    if ((MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1))                      transformedPoint = oddTransformedPoint;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ClosestTileCoordAtNodePosition,The following statement contains a magic number: if (MapType == CCTileMapType.Hex || MapType == CCTileMapType.Staggered)              {                  CCPoint oddTransformedPoint = nodeToTileCoordsTransformOdd.Transform(offsetDiff).RoundToInteger();                    if ((MapType == CCTileMapType.Hex && oddTransformedPoint.X % 2 == 1) ||                      (MapType == CCTileMapType.Staggered && oddTransformedPoint.Y % 2 == 1))                      transformedPoint = oddTransformedPoint;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The following statement contains a magic number: if ((MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1))                  return tileCoordsToNodeTransformOdd.Transform(tileCoords.Point);
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,TilePosition,The following statement contains a magic number: if ((MapType == CCTileMapType.Hex && tileCoords.Column % 2 == 1) ||                  (MapType == CCTileMapType.Staggered && tileCoords.Row % 2 == 1))                  return tileCoordsToNodeTransformOdd.Transform(tileCoords.Point);
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following statement contains a magic number: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,AddTileRange,The following statement contains a magic number: for (int tileIndex = startTileIndex; tileIndex <= endTileIndex; tileIndex++)                  {                      if (TileMapLayer.TileGIDAndFlagsArray[tileIndex].Gid == 0)                          continue;                        ushort quadVertIndex = (ushort)((tileIndex - TileStartIndex) * NumOfCornersPerQuad);                        int indexBufferOffset = IndexBufferSize;                      var indices = IndexBuffer.Data.Elements;                        indices[(int)(indexBufferOffset + 0)] = (ushort)(quadVertIndex + 0);                      indices[(int)(indexBufferOffset + 1)] = (ushort)(quadVertIndex + 1);                      indices[(int)(indexBufferOffset + 2)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 3)] = (ushort)(quadVertIndex + 3);                      indices[(int)(indexBufferOffset + 4)] = (ushort)(quadVertIndex + 2);                      indices[(int)(indexBufferOffset + 5)] = (ushort)(quadVertIndex + 1);                        IndexBufferSize += NumOfVerticesPerQuad;                      NumberOfVisiblePrimitives += NumOfPrimitivesPerQuad;                      NumberOfVisibleVertices += NumOfCornersPerQuad;                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,ReplaceTileGIDQuad,The following statement contains a magic number: for (int i = 0' N = IndexBufferSize; i < N; i += 6)                  {                      int tileIndex = (indices[i] / NumOfCornersPerQuad) + TileStartIndex;                      var gidAndFlag = TileMapLayer.TileGIDAndFlagsArray[tileIndex];                        /*                      So here we're updating the underlying quadvertexbuffer after each quad change                      The alternative is to determine the min/max tile index and call QuadsVertexBuffer.UpdateBuffer() over that range.                      The assumption is that replacing tile gid quads is primarily used for animating tiles that share a common original gid.                      In particular' we would expect that animated tiles are small in number and/or sparsely spread out across the tile map                      e.g. Water tiles/trees/character/light source etc.                      So it's likely updating over a range would unnecessarily update a large number of unchanged quads                      */                      if (gidAndFlag.Gid == originalGid)                      {                          var replacementQuadGid = new CCTileGidAndFlags(gidOfQuadToUse' gidAndFlag.Flags);                          UpdateQuad(tileIndex' ref replacementQuadGid' true);                      }                  }
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,The following statement contains a magic number: QuadsVertexBuffer.Data.Elements[adjustedStartVertexIndex + 2] = quad.TopRight;
Magic Number,CocosSharp,CCTileMapVertAndIndexBuffer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,UpdateQuad,The following statement contains a magic number: QuadsVertexBuffer.Data.Elements[adjustedStartVertexIndex + 3] = quad.BottomRight;
Magic Number,CocosSharp,CCTileSetInfo,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileSetInfo.cs,TextureRectForGID,The following statement contains a magic number: if (gid != 0)              {                  // Rect offset relative to first gid                  gid -= FirstGid;                  rect.Size = TileTexelSize;                  var max_x = (int)((TilesheetSize.Width - BorderWidth * 2 + TileSpacing) / (TileTexelSize.Width + TileSpacing));                  rect.Origin.X = (gid % max_x) * (TileTexelSize.Width + TileSpacing) + BorderWidth;                  rect.Origin.Y = (gid / max_x) * (TileTexelSize.Height + TileSpacing) + BorderWidth;              }
Magic Number,CocosSharp,ArrayPool<T>,C:\repos\mono_CocosSharp\src\Platform\CCArrayPool.cs,Create,The following statement contains a magic number: if (pow)              {                  var l = 2;                  while (l < length)                   {                      l <<= 1;                  }                  length = l;              }
Magic Number,CocosSharp,CCDictMaker,C:\repos\mono_CocosSharp\src\Platform\CCDictMaker.cs,ArrayWithContentsOfFile,The following statement contains a magic number: TextHandler(parser' System.Text.UTF8Encoding.UTF8.GetBytes("root")' 4);
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CCDrawManager,The following statement contains a magic number: matrixStack = new Matrix[100];
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,InitializeRawQuadBuffers,The following statement contains a magic number: for (int i = 0; i < MaxNumQuads; i++)               {                  quadsIndices [i6 + 0] = (short)(i4 + 0);                  quadsIndices [i6 + 1] = (short)(i4 + 1);                  quadsIndices [i6 + 2] = (short)(i4 + 2);                  quadsIndices [i6 + 3] = (short)(i4 + 3);                  quadsIndices [i6 + 4] = (short)(i4 + 2);                  quadsIndices [i6 + 5] = (short)(i4 + 1);                    i4 += 4;                  i6 += 6;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuads,The following statement contains a magic number: while (n > 0)               {                  int nIteration = Math.Min (n' MaxNumQuads);                    int i4 = 0;                  for (int i = start' N = start + nIteration; i < N; i++)                  {                      quadsVertices[i4 + 0] = quads[i].TopLeft;                      quadsVertices[i4 + 1] = quads[i].BottomLeft;                      quadsVertices[i4 + 2] = quads[i].TopRight;                      quadsVertices[i4 + 3] = quads[i].BottomRight;                        i4 += 4;                  }                    EffectPassCollection passes = currentEffect.CurrentTechnique.Passes;                  for (int i = 0; i < passes.Count; i++)                   {                      passes[i].Apply();                      graphicsDevice.DrawUserIndexedPrimitives(                          PrimitiveType.TriangleList' quadsVertices' 0' nIteration * NumOfVerticesPerQuad' quadsIndices' 0' nIteration * 2);                  }                    n -= nIteration;                  start += nIteration;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,DrawQuadsBuffer,The following statement contains a magic number: for (int i = 0; i < passes.Count; i++)              {                  passes[i].Apply();                  graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' vertexBuffer.VertexBuffer.VertexCount' start * 6' n * 2);              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,CheckQuadsIndexBuffer,The following statement contains a magic number: if (quadsIndexBuffer == null || quadsIndexBuffer.Capacity < capacity * 6)              {                  capacity = Math.Max(capacity' DefaultQuadBufferSize);                    if (quadsIndexBuffer == null)                  {                      quadsIndexBuffer = new CCIndexBuffer<short>(capacity * 6' BufferUsage.WriteOnly);                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    if (quadsIndexBuffer.Capacity < capacity * 6)                  {                      quadsIndexBuffer.Capacity = capacity * 6;                      quadsIndexBuffer.Count = quadsIndexBuffer.Capacity;                  }                    var indices = quadsIndexBuffer.Data.Elements;                    int i6 = 0;                  int i4 = 0;                    for (int i = 0; i < capacity; ++i)                  {                      indices[i6 + 0] = (short)(i4 + 0);                      indices[i6 + 1] = (short)(i4 + 2);                      indices[i6 + 2] = (short)(i4 + 1);                        indices[i6 + 3] = (short)(i4 + 1);                      indices[i6 + 4] = (short)(i4 + 2);                      indices[i6 + 5] = (short)(i4 + 3);                        i6 += 6;                      i4 += 4;                  }                    quadsIndexBuffer.UpdateBuffer();              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskLayer + 1 == 8) //DepthFormat.Depth24Stencil8              {                  if (maskOnceLog)                  {                      CCLog.Log(                          @"Nesting more than 8 stencils is not supported.                           Everything will be drawn without stencil for this node and its childs."                          );                      maskOnceLog = false;                  }                  return false;              }
Magic Number,CocosSharp,CCDrawManager,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,BeginDrawMask,The following statement contains a magic number: if (maskState.AlphaTreshold < 1f)              {                  AlphaTestEffect.AlphaFunction = CompareFunction.Greater;                  AlphaTestEffect.ReferenceAlpha = (byte)(255 * maskState.AlphaTreshold);                    PushEffect(AlphaTestEffect);              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: while (tmp.Capacity < elementCount)              {                  tmp.Capacity = tmp.Capacity * 2;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: tmp.Count = elementCount * 4;
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: for (int i = startIndex; i < startIndex + elementCount; i++)              {                  vertices[i4 + 0] = quads[i].TopLeft;                  vertices[i4 + 1] = quads[i].BottomLeft;                  vertices[i4 + 2] = quads[i].TopRight;                  vertices[i4 + 3] = quads[i].BottomRight;                    i4 += 4;              }
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,UpdateBuffer,The following statement contains a magic number: vertexBuffer.SetData(vertexByteSize * startIndex * 4' vertices' 0' elementCount * 4' vertexByteSize);
Magic Number,CocosSharp,CCQuadVertexBuffer,C:\repos\mono_CocosSharp\src\Platform\CCDrawManager.cs,ReinitResource,The following statement contains a magic number: vertexBuffer = new VertexBuffer(CCDrawManager.SharedDrawManager.XnaGraphicsDevice' typeof(CCV3F_C4B_T2F)' data.Capacity * 4' (BufferUsage)usage);
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCFileUtils,C:\repos\mono_CocosSharp\src\Platform\CCFileUtils.cs,GetFileBytes,The following statement contains a magic number: using (var stream = TitleContainer.OpenStream(filename))              {                  var buffer = new byte[1024];                  var ms = new MemoryStream();                    int readed = 0;                    readed = stream.Read(buffer' 0' 1024);                  while (readed > 0)                  {                      ms.Write(buffer' 0' readed);                      readed = stream.Read(buffer' 0' 1024);                  }                    return ms.ToArray();              }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVertices = new CCV3F_C4B[bufferSize - bufferSize % 3];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVertices = new CCV3F_C4B[bufferSize - bufferSize % 2];
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: triangleVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,CCPrimitiveBatch,The following statement contains a magic number: lineVerts = new CCRawList<CCV3F_C4B[]>(100' true);
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (triangleVerts.Count > 0)              {                  var triangle = triangleVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.TriangleList' triangle' 0' triangle.Length / 3);                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,Flush,The following statement contains a magic number: while (lineVerts.Count > 0)              {                  var line = lineVerts.Pop();                  DrawManager.DrawPrimitives(PrimitiveType.LineList' line' 0' line.Length / 2);              }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (triangleVertsCount >= 3)              {                  int primitiveCount = triangleVertsCount / 3;                    var triangles = new CCV3F_C4B[triangleVertsCount];                  Array.Copy(triangleVertices' triangles' triangleVertsCount);                  // add the Triangle List to our triangles list vertices for later rendering from the Renderer                  triangleVerts.Add(triangles);                    triangleVertsCount -= primitiveCount * 3;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCPrimitiveBatch,C:\repos\mono_CocosSharp\src\Platform\CCPrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (lineVertsCount >= 2)              {                  int primitiveCount = lineVertsCount / 2;                    var lines = new CCV3F_C4B[lineVertsCount];                  Array.Copy(lineVertices' lines' triangleVertsCount);                  // add the Line Lists to our line list vertices for later rendering from the Renderer                  lineVerts.Add(lines);                    lineVertsCount -= primitiveCount * 2;                }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,CCRawList,The following statement contains a magic number: if (useArrayPool)              {                  Elements = ArrayPool<T>.Create(4);              }              else              {                  Elements = new T[4];              }
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Push,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Add,The following statement contains a magic number: if (count == Elements.Length)  			{  				Capacity = Elements.Length * 2;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,Insert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,FastInsert,The following statement contains a magic number: if (index < count)  			{  				if (count == Elements.Length)  				{  					Capacity = Elements.Length * 2;  				}    				//Array.Copy(Elements' index' Elements' index + 1' count - index);  				Elements[count] = Elements[index];  				Elements[index] = item;  				count++;  			}  			else  				Add(item);
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCRawList<T>,C:\repos\mono_CocosSharp\src\Platform\CCRawList.cs,AddRange,The following statement contains a magic number: if (neededLength > Elements.Length)  			{  				int newLength = Elements.Length * 2;  				if (newLength < neededLength)  					newLength = neededLength;  				Capacity = newLength;  			}
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,CCSAXParser,C:\repos\mono_CocosSharp\src\Platform\CCSAXParser.cs,ParseContent,The following statement contains a magic number: while (xmlReader.Read())              {                  string name = xmlReader.Name;                    switch (xmlReader.NodeType)                  {                  case XmlNodeType.Element:                        string[] attrs = null;                        if (name == "map")                      {                          Width = CCUtils.CCParseInt(xmlReader.GetAttribute("width"));                          Height = CCUtils.CCParseInt(xmlReader.GetAttribute("height"));                      }                        if (xmlReader.HasAttributes)                      {                          attrs = new string[xmlReader.AttributeCount * 2];                          xmlReader.MoveToFirstAttribute();                          int i = 0;                          attrs[0] = xmlReader.Name;                          attrs[1] = xmlReader.Value;                          i += 2;                            while (xmlReader.MoveToNextAttribute())                          {                              attrs[i] = xmlReader.Name;                              attrs[i + 1] = xmlReader.Value;                              i += 2;                          }                            // Move the reader back to the element node.                          xmlReader.MoveToElement();                      }                      StartElement(this' name' attrs);                        byte[] buffer = null;                        //read data content of tmx file                      if (name == "data")                      {                          if (attrs != null) {                              string encoding = "";                              for (int i = 0; i < attrs.Length; i++) {                                  if (attrs [i] == "encoding") {                                      encoding = attrs [i + 1];                                  }                              }                                if (encoding == "base64") {                                  var base64String = xmlReader.ReadElementContentAsString().Trim();                                  buffer = Convert.FromBase64String(base64String);                              } else {                                  string value = xmlReader.ReadElementContentAsString ();                                  buffer = Encoding.UTF8.GetBytes (value);                              }                          }                          // Pure XML TileMap                          else                           {                              int dataSize = (Width * Height * 4) + 1024;                              buffer = new byte[dataSize];                          }                            TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (name == "key" || name == "integer" || name == "real" || name == "string")                      {                          string value = xmlReader.ReadElementContentAsString();                          buffer = Encoding.UTF8.GetBytes(value);                          TextHandler(this' buffer' buffer.Length);                          EndElement(this' name);                      }                      else if (xmlReader.IsEmptyElement)                      {                          EndElement(this' name);                      }                      break;                    case XmlNodeType.EndElement:                      EndElement(this' xmlReader.Name);                      dataindex++;                      break;                    default:                      break;                  }              }
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: byte[] magicHeader = new byte[8];
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: data.Read(magicHeader' 0' 8);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,LoadFromXmlFile,The following statement contains a magic number: if (BitConverter.ToInt64 (magicHeader' 0) == 3472403351741427810) {  				using (BinaryReader reader = new BinaryReader(data))  				{  					byte[] plistData = reader.ReadBytes((int) reader.BaseStream.Length);  					Root = ReadBinary(plistData);  				}    			} else {  				//allow DTD but not try to resolve it from web  				var settings = new XmlReaderSettings () {  					DtdProcessing = DtdProcessing.Ignore'  					//ProhibitDtd = false'  #if !NETFX_CORE  					XmlResolver = null'  #endif  				};  				using (var reader = XmlReader.Create(data' settings))  					LoadFromXml (reader);  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ReadBinary,The following statement contains a magic number: offsetTableBytes = bList.GetRange((int)offsetTableOffset' bList.Count - (int)offsetTableOffset - 32);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseOffsetTable,The following statement contains a magic number: for (int i = 0; i < offsetTableBytes.Count; i += offsetByteSize)  			{  				byte[] buffer = offsetTableBytes.GetRange(i' offsetByteSize).ToArray();  				Array.Reverse(buffer);  				offsetTable.Add(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,GetCount,The following statement contains a magic number: if (headerByteTrail < 15)  			{  				count = headerByteTrail;  				newBytePosition = bytePosition + 1;  			}  			else  				count = ((PlistInteger)ParseBinaryInt(bytePosition + 1' out newBytePosition)).AsInt;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinary,The following statement contains a magic number: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDate,The following statement contains a magic number: byte[] buffer = objectTable.GetRange(headerPosition + 1' 8).ToArray();
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryInt,The following statement contains a magic number: return new PlistInteger(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryReal,The following statement contains a magic number: return new PlistReal((float)BitConverter.ToDouble(RegulateNullBytes(buffer' 8)' 0));
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: charCount = charCount * 2;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryUnicodeString,The following statement contains a magic number: for (int i = 0; i < charCount; i+=2)  			{  				one = objectTable.GetRange(charStartPosition+i'1)[0];  				two = objectTable.GetRange(charStartPosition + i+1' 1)[0];    				if (BitConverter.IsLittleEndian)  				{  					buffer[i] = two;  					buffer[i + 1] = one;  				}  				else  				{  					buffer[i] = one;  					buffer[i + 1] = two;  				}  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header as well so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinaryArray,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ConvertFromAppleTimeStamp,The following statement contains a magic number: DateTime origin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: R = (byte)CCMathHelper.Clamp(red * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: G = (byte)CCMathHelper.Clamp(green * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: B = (byte)CCMathHelper.Clamp(blue * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCColor4B,The following statement contains a magic number: A = (byte)CCMathHelper.Clamp(alpha * 255' Byte.MinValue' Byte.MaxValue);
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCColor4F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,Parse,The following statement contains a magic number: return (new CCColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,CocosSharp,CCV3F_C4B,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B_T2F,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCV3F_C4B_T2F_Quad,C:\repos\mono_CocosSharp\src\Predefine\CCTypes.cs,CCV3F_C4B_T2F_Quad,The following statement contains a magic number: var elements = new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Color' VertexElementUsage.Color' 0)'                      new VertexElement(0x10' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  };
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: currentBatchedQuads = new CCRawList<CCV3F_C4B_T2F_Quad>(256' false);
Magic Number,CocosSharp,CCRenderer,C:\repos\mono_CocosSharp\src\Renderer\CCRenderer.cs,CCRenderer,The following statement contains a magic number: quadCommands = new CCRawList<CCQuadCommand>(256' false);
Magic Number,CocosSharp,CCQuadCommand,C:\repos\mono_CocosSharp\src\Renderer\RenderCommands\CCQuadCommand.cs,GenerateMaterialId,The following statement contains a magic number: materialId = (uint)textureId << 12 | (uint)BlendType.GetHashCode();
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: time = time * 2;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BackInOut,The following statement contains a magic number: if (time < 1)              {                  return (time * time * ((overshoot + 1) * time - overshoot)) / 2;              }              else              {                  time = time - 2;                  return (time * time * ((overshoot + 1) * time + overshoot)) / 2 + 1;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceOut,The following statement contains a magic number: if (time < 1 / 2.75)              {                  return 7.5625f * time * time;              }              else if (time < 2 / 2.75)              {                  time -= 1.5f / 2.75f;                  return 7.5625f * time * time + 0.75f;              }              else if (time < 2.5 / 2.75)              {                  time -= 2.25f / 2.75f;                  return 7.5625f * time * time + 0.9375f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: if (time < 0.5f)              {                  time = time * 2;                  return (1 - BounceOut(1 - time)) * 0.5f;              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,BounceInOut,The following statement contains a magic number: return BounceOut(time * 2 - 1) * 0.5f + 0.5f;
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticIn,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;                  time = time - 1;  				return -(float)(Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2.0f / period));              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  float s = period / 4;  				return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.Pi * 2f / period) + 1);              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCEaseMath,C:\repos\mono_CocosSharp\src\Math\CCEaseMath.cs,ElasticInOut,The following statement contains a magic number: if (time == 0 || time == 1)              {                  return time;              }              else              {                  time = time * 2;                  if (period == 0)                  {                      period = 0.3f * 1.5f;                  }                    float s = period / 4;                    time = time - 1;                  if (time < 0)                  {  					return (float)(-0.5f * Math.Pow(2' 10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period));                  }                  else                  {  					return (float)(Math.Pow(2' -10 * time) * Math.Sin((time - s) * CCMathHelper.TwoPi / period) * 0.5f + 1);                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	                  return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = (x ^ (x << 11));                  x = y; y = z; z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCFastRandom,C:\repos\mono_CocosSharp\src\Math\CCFastRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)              {                  // Generate 32 more bits.                  uint t = (x ^ (x << 11));                  x = y; y = z; z = w;                  bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  bitMask = 0x80000000;                  return (bitBuffer & bitMask) == 0;              }
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToDegrees,The following statement contains a magic number: return (float)(radians * 57.295779513082320876798154814105);
Magic Number,CocosSharp,CCMathHelper,C:\repos\mono_CocosSharp\src\Math\CCMathHelper.cs,ToRadians,The following statement contains a magic number: return (float)(degrees * 0.017453292519943295769236907684886);
Magic Number,CocosSharp,CCRandom,C:\repos\mono_CocosSharp\src\Math\CCRandom.cs,Float_Minus1_1,The following statement contains a magic number: return (float)(_random.NextDouble() * 2.0 - 1.0);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCSplineMath,C:\repos\mono_CocosSharp\src\Math\CCSplineMath.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Initialise,The following statement contains a magic number: if (!isInitialized) {                  // There is a special case for Xamarin iOS monotouch on emulator where they aggresively call                   // garbage collection themselves on the simulator. This should not affect the devices though.                  // So we check if we are running on a Device and only update the counters if we are.                  #if IOS                  isGCEnabled = (Runtime.Arch == Arch.DEVICE);                  #else                  isGCEnabled = true;                  #endif                    CCTexture2D texture;                  CCTextureCache textureCache = CCTextureCache.SharedTextureCache;                    stopwatch = new Stopwatch ();                    try {                      var surfaceFormat = CCSurfaceFormat.Color;                        #if WINDOWS_PHONE81                      surfaceFormat = CCSurfaceFormat.Color;                      #endif                        texture = !textureCache.Contains ("cc_fps_images") ? textureCache.AddImage (CCFPSImage.PngData' "cc_fps_images"' surfaceFormat) : textureCache ["cc_fps_images"];                        // analysis disable CompareOfFloatsByEqualityOperator                      if (texture == null || (texture.ContentSizeInPixels.Width == 0 && texture.ContentSizeInPixels.Height == 0)) {                          CCLog.Log ("CCStats2: Failed to create stats texture");                          return;                      }                  } catch (Exception ex) {                      // MonoGame may not allow texture.fromstream'                      // so catch this exception here and disable the stats                      if (ex != null)                          CCLog.Log ("CCStats2: Failed to create stats texture: {0}"' ex);                      else                          CCLog.Log ("CCStats2: Failed to create stats texture");                      return;                  }                    // we will remove the texture cc_fps_images from our cache to fix a problem of loosing the texture                  // when the cache is purged.  If not then the statistics no longer show because it has been Disposed of.                  textureCache.RemoveTextureForKey ("cc_fps_images");                    try {                      texture.IsAntialiased = false; // disable antialiasing so the labels are always sharp                        fpsLabel = new CCLabelAtlas ("00.0"' texture' 8' 15' ' ');                      updateTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawTimeLabel = new CCLabelAtlas ("0.000"' texture' 8' 15' ' ');                      drawCallLabel = new CCLabelAtlas ("000"' texture' 8' 15' ' ');                      memoryLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                      gcLabel = new CCLabelAtlas ("0"' texture' 8' 15' ' ');                        memoryLabel.Color = new CCColor3B (255' 196' 54);                      drawCallLabel.Color = new CCColor3B (152' 217' 255);                  } catch (Exception ex) {                      if (ex != null)                          CCLog.Log ("CCStats: Failed to create stats labels: {0}"' ex);                      else                          CCLog.Log ("CCStats: Failed to create stats labels");                      return;                  }                    isInitialized = true;                  Scale = 1;              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Draw,The following statement contains a magic number: if (isEnabled) {                  totalFrames++;                  totalDrawCount++;                  totalDrawTime += (float)stopwatch.Elapsed.TotalMilliseconds - startTime;                    if (isGCEnabled && !gcWeakRef.IsAlive) {                      gcCounter++;                      gcWeakRef = new WeakReference (new object ());                  }                    if (isInitialized) {                      if (deltaAll > 1.0f) {                          var mem = GC.GetTotalMemory (false);                          var upd = totalUpdateTime / updateCount;                          var drw = totalDrawTime / totalDrawCount;                          var fps = totalDrawCount / deltaAll;                            fpsLabel.Text =        String.Format ("             {0:0} FPS"' fps);                          updateTimeLabel.Text = String.Format ("Update time: {0:0.000} ms"' upd);                          drawTimeLabel.Text =   String.Format ("Draw time:   {0:0.000} ms"' drw);                          drawCallLabel.Text =   String.Format ("Drawcalls:   {0}"' gameView.DrawManager.DrawCount);                          memoryLabel.Text =     String.Format ("Memory:      {0} B ({1} kB)"' mem' mem / 1024);                          gcLabel.Text =         String.Format ("Garbage:     #{0}"' gcCounter);                            deltaAll = totalDrawTime = totalUpdateTime = 0;                          totalDrawCount = updateCount = 0;                            drawTimeLabel.Color = drw > 16.666f ? warnColor : whiteColor;                          updateTimeLabel.Color = upd > 16.666f ? warnColor : whiteColor;                          fpsLabel.Color = fps < 30 ? warnColor : whiteColor;                      }                        var scene = gameView.Director.RunningScene;                      drawCallLabel.Scene = scene;                      fpsLabel.Scene = scene;                      updateTimeLabel.Scene = scene;                      drawTimeLabel.Scene = scene;                      memoryLabel.Scene = scene;                      gcLabel.Scene = scene;                        drawCallLabel.Visit ();                      fpsLabel.Visit ();                      updateTimeLabel.Visit ();                      drawTimeLabel.Visit ();                      memoryLabel.Visit ();                      gcLabel.Visit ();                  }              }
Magic Number,CocosSharp,CCStats,C:\repos\mono_CocosSharp\src\Support\CCStats.cs,Draw,The following statement contains a magic number: if (isEnabled) {                  totalFrames++;                  totalDrawCount++;                  totalDrawTime += (float)stopwatch.Elapsed.TotalMilliseconds - startTime;                    if (isGCEnabled && !gcWeakRef.IsAlive) {                      gcCounter++;                      gcWeakRef = new WeakReference (new object ());                  }                    if (isInitialized) {                      if (deltaAll > 1.0f) {                          var mem = GC.GetTotalMemory (false);                          var upd = totalUpdateTime / updateCount;                          var drw = totalDrawTime / totalDrawCount;                          var fps = totalDrawCount / deltaAll;                            fpsLabel.Text =        String.Format ("             {0:0} FPS"' fps);                          updateTimeLabel.Text = String.Format ("Update time: {0:0.000} ms"' upd);                          drawTimeLabel.Text =   String.Format ("Draw time:   {0:0.000} ms"' drw);                          drawCallLabel.Text =   String.Format ("Drawcalls:   {0}"' gameView.DrawManager.DrawCount);                          memoryLabel.Text =     String.Format ("Memory:      {0} B ({1} kB)"' mem' mem / 1024);                          gcLabel.Text =         String.Format ("Garbage:     #{0}"' gcCounter);                            deltaAll = totalDrawTime = totalUpdateTime = 0;                          totalDrawCount = updateCount = 0;                            drawTimeLabel.Color = drw > 16.666f ? warnColor : whiteColor;                          updateTimeLabel.Color = upd > 16.666f ? warnColor : whiteColor;                          fpsLabel.Color = fps < 30 ? warnColor : whiteColor;                      }                        var scene = gameView.Director.RunningScene;                      drawCallLabel.Scene = scene;                      fpsLabel.Scene = scene;                      updateTimeLabel.Scene = scene;                      drawTimeLabel.Scene = scene;                      memoryLabel.Scene = scene;                      gcLabel.Scene = scene;                        drawCallLabel.Visit ();                      fpsLabel.Visit ();                      updateTimeLabel.Visit ();                      drawTimeLabel.Visit ();                      memoryLabel.Visit ();                      gcLabel.Visit ();                  }              }
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,CCNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,CocosSharp,CCUtils,C:\repos\mono_CocosSharp\src\Support\ccUtils.cs,SplitWithForm,The following statement contains a magic number: do  			{  				if (pStr == null)  				{  					break;  				}  				  				// string is empty  				string content = pStr;  				if (content.Length == 0)  				{  					break;  				}  				  				int nPosLeft = content.IndexOf('{');  				int nPosRight = content.IndexOf('}');  				  				// don't have '{' and '}'  				if (nPosLeft == -1 || nPosRight == -1)  				{  					break;  				}  				// '}' is before '{'  				if (nPosLeft > nPosRight)  				{  					break;  				}  				  				string pointStr = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);  				// nothing between '{' and '}'  				if (pointStr.Length == 0)  				{  					break;  				}  				  				int nPos1 = pointStr.IndexOf('{');  				int nPos2 = pointStr.IndexOf('}');  				// contain '{' or '}'   				if (nPos1 != -1 || nPos2 != -1) break;  				  				Split(pointStr' "'"' strs);  				if (strs.Count != 2 || strs[0].Length == 0 || strs[1].Length == 0)  				{  					strs.Clear();  					break;  				}  				  				bRet = true;  			} while (false);
Magic Number,CocosSharp,CCRectConverter,C:\repos\mono_CocosSharp\src\Support\Converters\CCRectConverter.cs,CCRectFromString,The following statement contains a magic number: do              {                  if (rectSpec == null)                  {                      break;                  }                    string content = rectSpec;                    // find the first '{' and the third '}'                  int nPosLeft = content.IndexOf('{');                  int nPosRight = content.IndexOf('}');                  for (int i = 1; i < 3; ++i)                  {                      if (nPosRight == -1)                      {                          break;                      }                      nPosRight = content.IndexOf('}'' nPosRight + 1);                  }                  if (nPosLeft == -1 || nPosRight == -1)                  {                      break;                  }                  content = content.Substring(nPosLeft + 1' nPosRight - nPosLeft - 1);                  int nPointEnd = content.IndexOf('}');                  if (nPointEnd == -1)                  {                      break;                  }                  nPointEnd = content.IndexOf('''' nPointEnd);                  if (nPointEnd == -1)                  {                      break;                  }                    // get the point string and size string                  string pointStr = content.Substring(0' nPointEnd);                  string sizeStr = content.Substring(nPointEnd + 1);                  //' content.Length - nPointEnd                  // split the string with '''                  List<string> pointInfo = new List<string>();                    if (!CCUtils.SplitWithForm(pointStr' pointInfo))                  {                      break;                  }                  List<string> sizeInfo = new List<string>();                  if (!CCUtils.SplitWithForm(sizeStr' sizeInfo))                  {                      break;                  }                    float x = CCUtils.CCParseFloat(pointInfo[0]);                  float y = CCUtils.CCParseFloat(pointInfo[1]);                  float width = CCUtils.CCParseFloat(sizeInfo[0]);                  float height = CCUtils.CCParseFloat(sizeInfo[1]);                    result = new CCRect(x' y' width' height);              } while (false);
Magic Number,CocosSharp,CCImageTGA,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,CCImageTGA,The following statement contains a magic number: for (int i = 0; i < tex.Height / 2; i++)  			{  				Array.Copy(ImageData' i * tex.Width' tmp' 0' tex.Width);  				Array.Copy(ImageData' (tex.Height - i - 1) * tex.Width' ImageData' i * tex.Width' tex.Width);  				Array.Copy(tmp' 0' ImageData' (tex.Height - i - 1) * tex.Width' tex.Width);  			}
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,ReadShort,The following statement contains a magic number: return (short)(buffer[position] | buffer[position + 1] << 8);
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadHeader,The following statement contains a magic number: pos += 2;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: int headerSkip = (1 + 2) * 6;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: int headerSkip = (1 + 2) * 6;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: mode = psInfo.PixelDepth / 8;
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,CCTGAlib,C:\repos\mono_CocosSharp\src\Support\ImageSupport\CCTGAlib.cs,LoadImageData,The following statement contains a magic number: if (mode >= 3)              {                  int cx = 0;                  for (int i = headerSkip; i < buffer.Length; i += mode)                  {                      psInfo.ImageData[cx].R = buffer[i + 2];                      psInfo.ImageData[cx].G = buffer[i + 1];                      psInfo.ImageData[cx].B = buffer[i];                      if (mode == 4)                      {                          psInfo.ImageData[cx].A = buffer[i + 3];                      }                      else                      {                          psInfo.ImageData[cx].A = 255;                      }                  }              }              else              {                  return (false);              }
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: return new Matrix()              {                  M11 = m[0]' M21 = m[4]' M31 = m[8]'  M41 = m[12]'                  M12 = m[1]' M22 = m[5]' M32 = m[9]'  M42 = m[13]'                  M13 = m[2]' M23 = m[6]' M33 = m[10]' M43 = m[14]'                  M14 = m[3]' M24 = m[7]' M34 = m[11]' M44 = m[15]'              };
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: var m = new float[16];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[4] = t.C;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[12] = t.Tx;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[5] = t.D;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[13] = t.Ty;
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.C = m[4];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Tx = m[12];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.D = m[5];
Magic Number,CocosSharp,TransformUtils,C:\repos\mono_CocosSharp\src\Support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.Ty = m[13];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var data = new byte[8];
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: var dataLen = stream.Read(data' 0' 8);
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 8)              {                  if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47                      && data[4] == 0x0D && data[5] == 0x0A && data[6] == 0x1A && data[7] == 0x0A)                  {                      return CCImageFormat.Png;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 3)              {                  if (data[0] == 0x47 && data[1] == 0x49 && data[1] == 0x46)                  {                      return CCImageFormat.Gif;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if ((data[0] == 0x49 && data[1] == 0x49) || (data[0] == 0x4d && data[1] == 0x4d))                  {                      return CCImageFormat.Tiff;                  }              }
Magic Number,CocosSharp,CCTexture2D,C:\repos\mono_CocosSharp\src\Textures\CCTexture2D.cs,DetectImageFormat,The following statement contains a magic number: if (dataLen >= 2)              {                  if (data[0] == 0xff && data[1] == 0xd8)                  {                      return CCImageFormat.Jpg;                  }              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\Textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureAtlas,C:\repos\mono_CocosSharp\src\Textures\CCTextureAtlas.cs,CCTextureAtlas,The following statement contains a magic number: if (capacity < 4)              {                  capacity = 4;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: foreach (var pair in textures)              {                  var texture = pair.Value.XNATexture;                    if (texture != null)                  {                      var bytes = texture.Width * texture.Height * 4;                      CCLog.Log("{0} {1} x {2} => {3} KB."' pair.Key' texture.Width' texture.Height' bytes / 1024);                      total += bytes;                  }                    count++;              }
Magic Number,CocosSharp,CCTextureCache,C:\repos\mono_CocosSharp\src\Textures\CCTextureCache.cs,DumpCachedTextureInfo,The following statement contains a magic number: CCLog.Log("{0} textures' for {1} KB ({2:00.00} MB)"' count' total / 1024' total / (1024f * 1024f));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,NearEqual,The following statement contains a magic number: const int maxUlp = 4;
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmoothStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * (3 - (2 * amount));
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,SmootherStep,The following statement contains a magic number: return (amount <= 0) ? 0                  : (amount >= 1) ? 1                  : amount * amount * amount * (amount * ((amount * 6) - 15) + 10);
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,MathUtil,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Gauss,The following statement contains a magic number: return (amplitude * Math.E) -                  (                      Math.Pow(x - (radX / 2)' 2) / (2 * Math.Pow(sigmaX' 2)) +                      Math.Pow(y - (radY / 2)' 2) / (2 * Math.Pow(sigmaY' 2))                  );
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = ((rgba >> 24) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = ((rgba >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Green = ((rgba >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Red = (rgba & 255) / 255.0f;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Color4.");
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color4,The following statement contains a magic number: Alpha = values[3];
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = (uint)(Alpha * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  hashCode = (hashCode * 397) ^ Alpha.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = ((rgb >> 16) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Green = ((rgb >> 8) & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Red = (rgb & 255) / 255.0f;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Color3.");
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Color3,The following statement contains a magic number: Blue = values[2];
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= b << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToRgba,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint a = 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint r = (uint)(Red * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint g = (uint)(Green * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: uint b = (uint)(Blue * 255.0f) & 255;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= g << 8;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= r << 16;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,ToBgra,The following statement contains a magic number: value |= a << 24;
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Color3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = Red.GetHashCode();                  hashCode = (hashCode * 397) ^ Green.GetHashCode();                  hashCode = (hashCode * 397) ^ Blue.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: if (values.Length != 4)                  throw new ArgumentOutOfRangeException("values"' "There must be four and only four input values for Vector4.");
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector4,The following statement contains a magic number: W = values[3];
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector4,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  hashCode = (hashCode * 397) ^ W.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: if (values.Length != 3)                  throw new ArgumentOutOfRangeException("values"' "There must be three and only three input values for Vector3.");
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector3,The following statement contains a magic number: Z = values[2];
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector3,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = X.GetHashCode();                  hashCode = (hashCode * 397) ^ Y.GetHashCode();                  hashCode = (hashCode * 397) ^ Z.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,Vector2,The following statement contains a magic number: if (values.Length != 2)                  throw new ArgumentOutOfRangeException("values"' "There must be two and only two input values for Vector2.");
Magic Number,SharpDX,Vector2,C:\repos\mono_CocosSharp\src\Nodes\Labels\CCLabel-RendererUAP.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X.GetHashCode() * 397) ^ Y.GetHashCode();              }
Duplicate Code,CocosSharp,CCDrawNode,C:\repos\mono_CocosSharp\src\Nodes\Other\CCDrawNode.cs,DrawPolygon,The method contains a code clone-set at the following line numbers (starting from the method definition): ((60' 80)' (85' 105))
Duplicate Code,CocosSharp,CCParticleSystemCache,C:\repos\mono_CocosSharp\src\Nodes\Particles\CCParticleSystemCache.cs,OnConfigLoad,The method contains a code clone-set at the following line numbers (starting from the method definition): ((40' 65)' (83' 108))
Missing Default,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\Platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case VirtualKey.Escape:                      e.Handled = true;                      DetachWithIME();                      break;              }
Missing Default,CocosSharp,IMEKeyboardImpl,C:\repos\mono_CocosSharp\src\Platform\Keyboard\Windows\WinRT\IMEKeyboardImpl.cs,ConvertKey,The following switch statement is missing a default case: switch (key)              {                    case CCKeys.A: return ConvertToChar('a'' shift' capsLock);                  case CCKeys.B: return ConvertToChar('b'' shift' capsLock);                  case CCKeys.C: return ConvertToChar('c'' shift' capsLock);                  case CCKeys.D: return ConvertToChar('d'' shift' capsLock);                  case CCKeys.E: return ConvertToChar('e'' shift' capsLock);                  case CCKeys.F: return ConvertToChar('f'' shift' capsLock);                  case CCKeys.G: return ConvertToChar('g'' shift' capsLock);                  case CCKeys.H: return ConvertToChar('h'' shift' capsLock);                  case CCKeys.I: return ConvertToChar('i'' shift' capsLock);                  case CCKeys.J: return ConvertToChar('j'' shift' capsLock);                  case CCKeys.K: return ConvertToChar('k'' shift' capsLock);                  case CCKeys.L: return ConvertToChar('l'' shift' capsLock);                  case CCKeys.M: return ConvertToChar('m'' shift' capsLock);                  case CCKeys.N: return ConvertToChar('n'' shift' capsLock);                  case CCKeys.O: return ConvertToChar('o'' shift' capsLock);                  case CCKeys.P: return ConvertToChar('p'' shift' capsLock);                  case CCKeys.Q: return ConvertToChar('q'' shift' capsLock);                  case CCKeys.R: return ConvertToChar('r'' shift' capsLock);                  case CCKeys.S: return ConvertToChar('s'' shift' capsLock);                  case CCKeys.T: return ConvertToChar('t'' shift' capsLock);                  case CCKeys.U: return ConvertToChar('u'' shift' capsLock);                  case CCKeys.V: return ConvertToChar('v'' shift' capsLock);                  case CCKeys.W: return ConvertToChar('w'' shift' capsLock);                  case CCKeys.X: return ConvertToChar('x'' shift' capsLock);                  case CCKeys.Y: return ConvertToChar('y'' shift' capsLock);                  case CCKeys.Z: return ConvertToChar('z'' shift' capsLock);                    case CCKeys.D0: return (shift) ? ')' : '0';                  case CCKeys.D1: return (shift) ? '!' : '1';                  case CCKeys.D2: return (shift) ? '@' : '2';                  case CCKeys.D3: return (shift) ? '#' : '3';                  case CCKeys.D4: return (shift) ? '$' : '4';                  case CCKeys.D5: return (shift) ? '%' : '5';                  case CCKeys.D6: return (shift) ? '^' : '6';                  case CCKeys.D7: return (shift) ? '&' : '7';                  case CCKeys.D8: return (shift) ? '*' : '8';                  case CCKeys.D9: return (shift) ? '(' : '9';                    case CCKeys.Add: return '+';                  case CCKeys.Divide: return '/';                  case CCKeys.Multiply: return '*';                  case CCKeys.Subtract: return '-';                    case CCKeys.Space: return ' ';                  case CCKeys.Enter: return '\n';                    case CCKeys.Decimal: if (numLock && !shift) return '.'; break;                  case CCKeys.NumPad0: if (numLock && !shift) return '0'; break;                  case CCKeys.NumPad1: if (numLock && !shift) return '1'; break;                  case CCKeys.NumPad2: if (numLock && !shift) return '2'; break;                  case CCKeys.NumPad3: if (numLock && !shift) return '3'; break;                  case CCKeys.NumPad4: if (numLock && !shift) return '4'; break;                  case CCKeys.NumPad5: if (numLock && !shift) return '5'; break;                  case CCKeys.NumPad6: if (numLock && !shift) return '6'; break;                  case CCKeys.NumPad7: if (numLock && !shift) return '7'; break;                  case CCKeys.NumPad8: if (numLock && !shift) return '8'; break;                  case CCKeys.NumPad9: if (numLock && !shift) return '9'; break;                    case CCKeys.OemBackslash: return shift ? '|' : '\\';                  case CCKeys.OemCloseBrackets: return shift ? '}' : ']';                  case CCKeys.OemComma: return shift ? '<' : ''';                  case CCKeys.OemMinus: return shift ? '_' : '-';                  case CCKeys.OemOpenBrackets: return shift ? '{' : '[';                  case CCKeys.OemPeriod: return shift ? '>' : '.';                  case CCKeys.OemPipe: return shift ? '|' : '\\';                  case CCKeys.OemPlus: return shift ? '+' : '=';                  case CCKeys.OemQuestion: return shift ? '?' : '/';                  case CCKeys.OemQuotes: return shift ? '"' : '\'';                  case CCKeys.OemSemicolon: return shift ? ':' : ';';                  case CCKeys.OemTilde: return shift ? '~' : '`';              }
Missing Default,CocosSharp,CCMenu,C:\repos\mono_CocosSharp\src\Nodes\Menus\CCMenu.cs,AddedToScene,The following switch statement is missing a default case: switch(alignmentState.Alignment)                  {                      case Alignment.Vertical:                          AlignItemsVertically(alignmentState.Padding);                          break;                      case Alignment.Horizontal:                          AlignItemsHorizontally(alignmentState.Padding);                          break;                      case Alignment.Column:                          AlignItemsInColumns(alignmentState.NumberOfItemsPer);                          break;                      case Alignment.Row:                          AlignItemsInRows(alignmentState.NumberOfItemsPer);                          break;                  }
Missing Default,CocosSharp,CCTileMapLayer,C:\repos\mono_CocosSharp\src\Nodes\TileMaps\CCTileMapLayer.cs,LayerOffset,The following switch statement is missing a default case: switch (MapType)              {                  case CCTileMapType.Ortho:                      offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width' -tileCoords.Row * TileTexelSize.Height);                      break;                  case CCTileMapType.Iso:                      offsetInNodespace = new CCPoint((TileTexelSize.Width / 2) * (tileCoords.Column - tileCoords.Row)'                      (TileTexelSize.Height / 2) * (-tileCoords.Column - tileCoords.Row));                      break;                  case CCTileMapType.Staggered:                      float diffX = 0;                      if ((int)tileCoords.Row % 2 == 1)                          diffX = TileTexelSize.Width / 2;                        offsetInNodespace = new CCPoint(tileCoords.Column * TileTexelSize.Width + diffX'                          -tileCoords.Row * TileTexelSize.Height / 2);                      break;                  case CCTileMapType.Hex:                      break;              }
Missing Default,CocosSharp,CCOGLES,C:\repos\mono_CocosSharp\src\Platform\CCOGLES.cs,GetXNABlend,The following switch statement is missing a default case: switch (glBlend)              {                  case GL_ZERO:                      return Blend.Zero;                  case GL_ONE:                      return Blend.One;                  case GL_SRC_COLOR:                      return Blend.SourceColor;                  case GL_ONE_MINUS_SRC_COLOR:                      return Blend.InverseSourceColor;                  case GL_SRC_ALPHA:                      return Blend.SourceAlpha;                  case GL_ONE_MINUS_SRC_ALPHA:                      return Blend.InverseSourceAlpha;                  case GL_DST_ALPHA:                      return Blend.DestinationAlpha;                  case GL_ONE_MINUS_DST_ALPHA:                      return Blend.InverseDestinationAlpha;                    /* BlendingFactorSrc */                  /*      GL_ZERO */                  /*      GL_ONE */                  case GL_DST_COLOR:                      return Blend.DestinationColor;                  case GL_ONE_MINUS_DST_COLOR:                      return Blend.InverseDestinationColor;                  case GL_SRC_ALPHA_SATURATE:                      return Blend.SourceAlphaSaturation;              }
Missing Default,CocosSharp,PlistDocument,C:\repos\mono_CocosSharp\src\Platform\PList\PlistDocument.cs,ParseBinary,The following switch statement is missing a default case: switch (header & 0xF0)  			{  				case 0:  			{  				//If the byte is  				//0 return null  				//9 return true  				//8 return false  				if (objectTable [offsetTable [objRef]] == 0)  					return new PlistNull ();  				else   					if (objectTable[offsetTable[objRef]] == 9)  				    	return new PlistBoolean(true);  					else  						return new PlistBoolean(false);    			}  				case 0x10:  			{  				return ParseBinaryInt(offsetTable[objRef]);  			}  				case 0x20:  			{  				return ParseBinaryReal(offsetTable[objRef]);  			}  				case 0x30:  			{  				return ParseBinaryDate(offsetTable[objRef]);  			}  				case 0x40:  			{  				return ParseBinaryByteArray(offsetTable[objRef]);  			}  				case 0x50://String ASCII  			{  				return ParseBinaryAsciiString(offsetTable[objRef]);  			}  				case 0x60://String Unicode  			{  				return ParseBinaryUnicodeString(offsetTable[objRef]);  			}  				case 0xD0:  			{  				return ParseBinaryDictionary(objRef);  			}  				case 0xA0:  			{  				return ParseBinaryArray(objRef);  			}  			}
Missing Default,CocosSharp,CCUserDefault,C:\repos\mono_CocosSharp\src\Support\CCUserDefault.cs,ParseXMLFile,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.Element:  						key = reader.Name;  						break;  					case XmlNodeType.Text:  						values.Add(key' reader.Value);  						break;  					case XmlNodeType.XmlDeclaration:  					case XmlNodeType.ProcessingInstruction:  						break;  					case XmlNodeType.Comment:  						break;  					case XmlNodeType.EndElement:  						break;  					}
Missing Default,CocosSharp,ZipUtils,C:\repos\mono_CocosSharp\src\Support\ZipSupport\ZipUtils.cs,Inflate,The following switch statement is missing a default case: switch (format)               {              case CompressionFormat.Zlib:                    try {                      try {                          using (var deflateStream = new ZlibStream (dataStream' MonoGame.Utilities.CompressionMode.Decompress))                           {                              outputBytes = StreamToByteArray(deflateStream);                          }                      }                       catch (Exception exc)                       {                          CCLog.Log ("Error decompressing image data: " + exc.Message);                      }                    }                   catch (Exception exc)                   {                      CCLog.Log ("Error decompressing image data: " + exc.Message);                  }                  break;              case CompressionFormat.Gzip:                    try                   {                      #if !WINDOWS_PHONE                      using (var gzipInputStream = new GZipInputStream(dataStream' System.IO.Compression.CompressionMode.Decompress))                      #else                      using (var gzipInputStream = new GZipInputStream(dataStream))                      #endif                      {                          outputBytes = StreamToByteArray(gzipInputStream);                      }                  }                   catch (Exception exc)                   {                      CCLog.Log ("Error decompressing image data: " + exc.Message);                  }                  break;              }
