Implementation smell,Namespace,Class,File,Method,Description
Long Method,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The method has 194 lines of code.
Complex Method,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,Cyclomatic complexity of the method is 36
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,WaitForProcessToExit,The length of the statement  "		Log.Warn ("The requested sleep time " + _descriptor.SleepTime.TotalMilliseconds + "is greater that the max value " + Int32.MaxValue + ". The value will be truncated"); " is 167.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,SignalShutdownPending,The length of the statement  "		Log.Warn ("The requested WaitHint value (" + _descriptor.WaitHint.TotalMilliseconds + " ms)  is greater that the max value " + Int32.MaxValue + ". The value will be truncated"); " is 177.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,SignalShutdownPending,The length of the statement  "	//            WriteEvent("SignalShutdownPending " + wrapperServiceStatus.checkPoint + ":" + wrapperServiceStatus.waitHint); " is 123.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,SignalShutdownComplete,The length of the statement  "	//            WriteEvent("SignalShutdownComplete " + wrapperServiceStatus.checkPoint + ":" + wrapperServiceStatus.waitHint); " is 124.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,StartProcess,The length of the statement  "	ProcessHelper.StartProcessAndCallbackForExit (processToStart: processToStart' executable: executable' arguments: arguments' envVars: _envs' workingDirectory: _descriptor.WorkingDirectory' priority: _descriptor.Priority' callback: processCompletionCallback); " is 257.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The length of the statement  "			svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies); " is 183.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The length of the statement  "			Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description); " is 165.
Long Statement,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The length of the statement  "			bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi); " is 178.
Complex Conditional,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The conditional expression  "args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?""  is complex.
Empty Catch Block,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,StopIt,The method has an empty catch block.
Empty Catch Block,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,WaitForProcessToExit,The method has an empty catch block.
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,HandleFileCopies,The following statement contains a magic number: try {  	using (var tr = new StreamReader (file' Encoding.UTF8)) {  		string line;  		while ((line = tr.ReadLine ()) != null) {  			LogEvent ("Handling copy: " + line);  			string[] tokens = line.Split ('>');  			if (tokens.Length > 2) {  				LogEvent ("Too many delimiters in " + line);  				continue;  			}  			CopyFile (tokens [0]' tokens [1]);  		}  	}  } finally {  	File.Delete (file);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,HandleFileCopies,The following statement contains a magic number: using (var tr = new StreamReader (file' Encoding.UTF8)) {  	string line;  	while ((line = tr.ReadLine ()) != null) {  		LogEvent ("Handling copy: " + line);  		string[] tokens = line.Split ('>');  		if (tokens.Length > 2) {  			LogEvent ("Too many delimiters in " + line);  			continue;  		}  		CopyFile (tokens [0]' tokens [1]);  	}  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,HandleFileCopies,The following statement contains a magic number: while ((line = tr.ReadLine ()) != null) {  	LogEvent ("Handling copy: " + line);  	string[] tokens = line.Split ('>');  	if (tokens.Length > 2) {  		LogEvent ("Too many delimiters in " + line);  		continue;  	}  	CopyFile (tokens [0]' tokens [1]);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,HandleFileCopies,The following statement contains a magic number: if (tokens.Length > 2) {  	LogEvent ("Too many delimiters in " + line);  	continue;  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (isCLIMode)// CLI mode' in-service mode otherwise   {  	Log.Debug ("Starting ServiceWrapper in the CLI mode");  	// Get service info for the future use  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f) {  			AutoFlush = true  		};  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.SafeFileHandle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		Log.Info ("Installing the service with id '" + d.Id + "'");  		// Check if the service exists  		if (s != null) {  			Console.WriteLine ("Service with id '" + d.Id + "' already exists");  			Console.WriteLine ("To install the service' delete the existing one or change service Id in the configuration file");  			throw new Exception ("Installation failure: Service with id '" + d.Id + "' already exists");  		}  		string username = null' password = null;  		bool setallowlogonasaserviceright = false;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  			Console.WriteLine ();  			Console.Write ("Set Account rights to allow log on as a service (y/n)?: ");  			var keypressed = Console.ReadKey ();  			Console.WriteLine ();  			if (keypressed.Key == ConsoleKey.Y) {  				setallowlogonasaserviceright = true;  			}  		} else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  				setallowlogonasaserviceright = d.AllowServiceAcountLogonRight;  			}  		}  		if (setallowlogonasaserviceright) {  			LogonAsAService.AddLogonAsAServiceRight (username);  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' ServiceType.OwnProcess' ErrorControl.UserNotified' d.StartMode' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		var isDelayedAutoStart = d.StartMode == StartMode.Automatic && d.DelayedAutoStart;  		if (actions.Count > 0 || isDelayedAutoStart) {  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					// Delayed auto start  					if (isDelayedAutoStart) {  						sc.SetDelayedAutoStart (true);  					}  					// Set the failure actions  					if (actions.Count > 0) {  						sc.ChangeConfig (d.ResetFailureAfter' actions);  					}  				}  			}  		}  		return;  	}  	if (args [0] == "uninstall") {  		Log.Info ("Uninstalling the service with id '" + d.Id + "'");  		if (s == null) {  			Log.Warn ("The service with id '" + d.Id + "' does not exist. Nothing to uninstall");  			return;  			// there's no such service' so consider it already uninstalled  		}  		if (s.Started) {  			// We could fail the opeartion here' but it would be an incompatible change.  			// So it is just a warning  			Log.Warn ("The service with id '" + d.Id + "' is running. It may be impossible to uninstall it");  		}  		try {  			s.Delete ();  		} catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion) {  				Log.Error ("Failed to uninstall the service with id '" + d.Id + "'" + ". It has been marked for deletion.");  				// TODO: change the default behavior to Error?  				return;  				// it's already uninstalled' so consider it a success  			} else {  				Log.Fatal ("Failed to uninstall the service with id '" + d.Id + "'. WMI Error code is '" + e.ErrorCode + "'");  			}  			throw e;  		}  		return;  	}  	if (args [0] == "start") {  		Log.Info ("Starting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  		return;  	}  	if (args [0] == "stop") {  		Log.Info ("Stopping the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  		return;  	}  	if (args [0] == "restart") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  		return;  	}  	if (args [0] == "restart!") {  		Log.Info ("Restarting the service with id '" + d.Id + "'");  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  		return;  	}  	if (args [0] == "status") {  		Log.Debug ("User requested the status of the process with id '" + d.Id + "'");  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  		return;  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  		return;  	}  	if (args [0] == "help" || args [0] == "--help" || args [0] == "-h" || args [0] == "-?" || args [0] == "/?") {  		printHelp ();  		return;  	}  	if (args [0] == "version") {  		printVersion ();  		return;  	}  	Console.WriteLine ("Unknown command: " + args [0]);  	printAvailableCommandsInfo ();  	throw new Exception ("Unknown command: " + args [0]);  } else {  	Log.Info ("Starting ServiceWrapper in the service mode");  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f) {  		AutoFlush = true  	};  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.SafeFileHandle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f) {  		AutoFlush = true  	};  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.SafeFileHandle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f) {  		AutoFlush = true  	};  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.SafeFileHandle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f) {  		AutoFlush = true  	};  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.SafeFileHandle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: Kernel32.SetStdHandle (-11' handle);  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: Kernel32.SetStdHandle (-12' handle);  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: args = args.GetRange (2' args.Count - 2);  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: args = args.GetRange (2' args.Count - 2);  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "restart") {  	Log.Info ("Restarting the service with id '" + d.Id + "'");  	if (s == null)  		ThrowNoSuchService ();  	if (s.Started)  		s.StopService ();  	while (s.Started) {  		Thread.Sleep (1000);  		s = svc.Select (d.Id);  	}  	s.StartService ();  	return;  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: while (s.Started) {  	Thread.Sleep (1000);  	s = svc.Select (d.Id);  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: if (args [0] == "test") {  	WrapperService wsvc = new WrapperService ();  	wsvc.OnStart (args.ToArray ());  	Thread.Sleep (1000);  	wsvc.OnStop ();  	return;  }  
Magic Number,winsw,WrapperService,F:\newReposMay17\kohsuke_winsw\src\Core\ServiceWrapper\Main.cs,Run,The following statement contains a magic number: Thread.Sleep (1000);  
