Implementation smell,Namespace,Class,File,Method,Description
Complex Method,winsw,Download,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Download.cs,Perform,Cyclomatic complexity of the method is 13
Complex Method,winsw,TimeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithDateRotation,Cyclomatic complexity of the method is 8
Complex Method,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,Cyclomatic complexity of the method is 11
Complex Method,winsw,PeriodicRollingCalendar,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\PeriodicRollingCalendar.cs,nextTriggeringTime,Cyclomatic complexity of the method is 17
Complex Method,DynamicProxy,ProxyFactory,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\DynamicProxy.cs,GenerateMethod,Cyclomatic complexity of the method is 10
Long Parameter List,winsw,Download,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Download.cs,Download,The method has 7 parameters.
Long Parameter List,winsw.Native,Advapi32,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,LookupAccountName,The method has 7 parameters.
Long Parameter List,winsw.Native,Kernel32,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Kernel32.cs,CreateProcess,The method has 10 parameters.
Long Parameter List,winsw.Util,ProcessHelper,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Util\ProcessHelper.cs,StartProcessAndCallbackForExit,The method has 7 parameters.
Long Parameter List,WMI,Win32Services,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\WmiSchema.cs,Create,The method has 10 parameters.
Long Parameter List,WMI,Win32Services,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\WmiSchema.cs,Create,The method has 8 parameters.
Long Statement,DynamicProxy,ProxyFactory,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\DynamicProxy.cs,CreateType,The length of the statement  "		ConstructorBuilder delegateConstructor = typeBuilder.DefineConstructor (MethodAttributes.Public' CallingConventions.Standard' new Type[] { " is 138.
Long Statement,DynamicProxy,ProxyFactory,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\DynamicProxy.cs,GenerateMethod,The length of the statement  "		MethodBuilder methodBuilder = typeBuilder.DefineMethod (methodInfo.Name' /*MethodAttributes.Public | MethodAttributes.Virtual | */methodInfo.Attributes & ~MethodAttributes.Abstract' CallingConventions.Standard' methodInfo.ReturnType' methodParameters); " is 252.
Long Statement,DynamicProxy,ProxyFactory,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\DynamicProxy.cs,GenerateMethod,The length of the statement  "	//    PropertyBuilder pb = typeBuilder.DefineProperty(p.Name' p.Attributes' p.PropertyType' new Type[] { p.PropertyType }); " is 123.
Long Statement,winsw.Extensions,WinSWExtensionManager,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Extensions\WinSWExtensionManager.cs,LoadExtension,The length of the statement  "	XmlElement configNode = (extensionsConfig != null) ? extensionsConfig.SelectSingleNode ("extension[@id='" + id + "'][1]") as XmlElement : null; " is 143.
Long Statement,winsw.Extensions,WinSWExtensionManager,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Extensions\WinSWExtensionManager.cs,CreateExtensionInstance,The length of the statement  "		throw new ExtensionException (id' "The loaded class is not a WinSW extension: " + className + ". Type is " + created.GetType ()); " is 129.
Long Statement,winsw.Native,ServiceManager,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,Open,The length of the statement  "		throw new Exception (String.Format ("Error opening service for modifying. Error returned was: 0x{0:X}"' Marshal.GetLastWin32Error ())); " is 135.
Long Statement,winsw.Native,Service,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,SetDelayedAutoStart,The length of the statement  "	if (!Advapi32.ChangeServiceConfig2 (Handle' SERVICE_CONFIG_INFOLEVEL.SERVICE_CONFIG_DELAYED_AUTO_START_INFO' ref settings)) { " is 125.
Long Statement,winsw.Native,LogonAsAService,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,SetRight,The length of the statement  "	bool result = Advapi32.LookupAccountName (String.Empty' accountName' sid' ref sidSize' domainName' ref nameSize' ref accountType); " is 130.
Long Statement,winsw.Native,LogonAsAService,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,SetRight,The length of the statement  "		const int access = (int)(LSA_AccessPolicy.POLICY_AUDIT_LOG_ADMIN | LSA_AccessPolicy.POLICY_CREATE_ACCOUNT | LSA_AccessPolicy.POLICY_CREATE_PRIVILEGE | LSA_AccessPolicy.POLICY_CREATE_SECRET | LSA_AccessPolicy.POLICY_GET_PRIVATE_INFORMATION | LSA_AccessPolicy.POLICY_LOOKUP_NAMES | LSA_AccessPolicy.POLICY_NOTIFICATION | LSA_AccessPolicy.POLICY_SERVER_ADMIN | LSA_AccessPolicy.POLICY_SET_AUDIT_REQUIREMENTS | LSA_AccessPolicy.POLICY_SET_DEFAULT_QUOTA_LIMITS | LSA_AccessPolicy.POLICY_TRUST_ADMIN | LSA_AccessPolicy.POLICY_VIEW_AUDIT_INFORMATION | LSA_AccessPolicy.POLICY_VIEW_LOCAL_INFORMATION); " is 593.
Long Statement,winsw.Util,ProcessHelper,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Util\ProcessHelper.cs,StartProcessAndCallbackForExit,The length of the statement  "			// bugged (lower cases all variable names due to StringDictionary being used' see http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=326163) " is 169.
Long Statement,winsw.Util,XmlHelper,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Util\XmlHelper.cs,EnumAttribute,The length of the statement  "		throw new InvalidDataException ("Cannot parse <" + attributeName + "> Enum value from string '" + substitutedValue + "'. Enum type: " + typeof(TAttributeType)' ex); " is 164.
Magic Number,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: while (true) {  	int len = data.Read (buf' 0' buf.Length);  	if (len == 0)  		break;  	// EOF  	if (sz + len < SizeTheshold) {  		// typical case. write the whole thing into the current file  		w.Write (buf' 0' len);  		sz += len;  	} else {  		// rotate at the line boundary  		int s = 0;  		for (int i = 0; i < len; i++) {  			if (buf [i] != 0x0A)  				continue;  			if (sz + i < SizeTheshold)  				continue;  			// at the line boundary and exceeded the rotation unit.  			// time to rotate.  			w.Write (buf' s' i + 1);  			w.Close ();  			s = i + 1;  			try {  				for (int j = FilesToKeep; j >= 1; j--) {  					string dst = BaseLogFileName + "." + (j - 1) + ext;  					string src = BaseLogFileName + "." + (j - 2) + ext;  					if (File.Exists (dst))  						File.Delete (dst);  					if (File.Exists (src))  						File.Move (src' dst);  				}  				File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  			} catch (IOException e) {  				EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  			}  			// even if the log rotation fails' create a new one' or else  			// we'll infinitely try to rotate.  			w = new FileStream (BaseLogFileName + ext' FileMode.Create);  			sz = new FileInfo (BaseLogFileName + ext).Length;  		}  	}  	w.Flush ();  }  
Magic Number,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: if (sz + len < SizeTheshold) {  	// typical case. write the whole thing into the current file  	w.Write (buf' 0' len);  	sz += len;  } else {  	// rotate at the line boundary  	int s = 0;  	for (int i = 0; i < len; i++) {  		if (buf [i] != 0x0A)  			continue;  		if (sz + i < SizeTheshold)  			continue;  		// at the line boundary and exceeded the rotation unit.  		// time to rotate.  		w.Write (buf' s' i + 1);  		w.Close ();  		s = i + 1;  		try {  			for (int j = FilesToKeep; j >= 1; j--) {  				string dst = BaseLogFileName + "." + (j - 1) + ext;  				string src = BaseLogFileName + "." + (j - 2) + ext;  				if (File.Exists (dst))  					File.Delete (dst);  				if (File.Exists (src))  					File.Move (src' dst);  			}  			File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  		} catch (IOException e) {  			EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  		}  		// even if the log rotation fails' create a new one' or else  		// we'll infinitely try to rotate.  		w = new FileStream (BaseLogFileName + ext' FileMode.Create);  		sz = new FileInfo (BaseLogFileName + ext).Length;  	}  }  
Magic Number,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	if (buf [i] != 0x0A)  		continue;  	if (sz + i < SizeTheshold)  		continue;  	// at the line boundary and exceeded the rotation unit.  	// time to rotate.  	w.Write (buf' s' i + 1);  	w.Close ();  	s = i + 1;  	try {  		for (int j = FilesToKeep; j >= 1; j--) {  			string dst = BaseLogFileName + "." + (j - 1) + ext;  			string src = BaseLogFileName + "." + (j - 2) + ext;  			if (File.Exists (dst))  				File.Delete (dst);  			if (File.Exists (src))  				File.Move (src' dst);  		}  		File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  	} catch (IOException e) {  		EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  	}  	// even if the log rotation fails' create a new one' or else  	// we'll infinitely try to rotate.  	w = new FileStream (BaseLogFileName + ext' FileMode.Create);  	sz = new FileInfo (BaseLogFileName + ext).Length;  }  
Magic Number,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: try {  	for (int j = FilesToKeep; j >= 1; j--) {  		string dst = BaseLogFileName + "." + (j - 1) + ext;  		string src = BaseLogFileName + "." + (j - 2) + ext;  		if (File.Exists (dst))  			File.Delete (dst);  		if (File.Exists (src))  			File.Move (src' dst);  	}  	File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  } catch (IOException e) {  	EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  }  
Magic Number,winsw,SizeBasedRollingLogAppender,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: for (int j = FilesToKeep; j >= 1; j--) {  	string dst = BaseLogFileName + "." + (j - 1) + ext;  	string src = BaseLogFileName + "." + (j - 2) + ext;  	if (File.Exists (dst))  		File.Delete (dst);  	if (File.Exists (src))  		File.Move (src' dst);  }  
Magic Number,winsw,ServiceDescriptor,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\ServiceDescriptor.cs,ServiceDescriptor,The following statement contains a magic number: if (baseName.EndsWith (".vshost"))  	baseName = baseName.Substring (0' baseName.Length - 7);  
Magic Number,winsw,ServiceDescriptor,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\ServiceDescriptor.cs,ServiceDescriptor,The following statement contains a magic number: baseName = baseName.Substring (0' baseName.Length - 7);  
Magic Number,winsw.Native,LogonAsAService,F:\newReposMay17\kohsuke_winsw\src\Core\WinSWCore\Native\Advapi32.cs,AddLogonAsAServiceRight,The following statement contains a magic number: if (osInfo.Version.Major >= 5 && osInfo.Version.Minor >= 1) {  	var newuser = GetLocalAccountIfLocalAccount (username);  	//Trace.WriteLine("Username for Logon as A Service: " + newuser);  	long rightexitcode = SetRight (newuser' PrivlegeRights.SeServiceLogonRight.ToString ());  	if (rightexitcode != 0) {  		Console.WriteLine ("Failed to set logon as a service right");  		Environment.Exit (1);  	}  } else {  	Console.WriteLine ("Cannot set Logon as a Service right.  Unsupported operating system detected");  }  
