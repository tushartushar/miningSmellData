Implementation smell,Namespace,Class,File,Method,Description
Long Method,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The method has 166 lines of code.
Long Method,VDS.RDF,ComparisonHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\EqualityHelper.cs,CompareLiterals,The method has 327 lines of code.
Long Method,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Flush,The method has 103 lines of code.
Long Method,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Discard,The method has 107 lines of code.
Long Method,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,IsSubGraph,The method has 129 lines of code.
Long Method,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The method has 281 lines of code.
Long Method,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,Equals,The method has 123 lines of code.
Long Method,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The method has 281 lines of code.
Long Method,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The method has 137 lines of code.
Long Method,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The method has 109 lines of code.
Long Method,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The method has 284 lines of code.
Long Method,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The method has 100 lines of code.
Long Method,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The method has 164 lines of code.
Long Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The method has 113 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The method has 181 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The method has 237 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGraphPattern,The method has 148 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The method has 148 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The method has 285 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The method has 130 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseOrderByClause,The method has 163 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGroupByClause,The method has 149 lines of code.
Long Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The method has 114 lines of code.
Long Method,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The method has 206 lines of code.
Long Method,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The method has 100 lines of code.
Long Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The method has 140 lines of code.
Long Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The method has 137 lines of code.
Long Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The method has 168 lines of code.
Long Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The method has 129 lines of code.
Long Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The method has 162 lines of code.
Long Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,The method has 114 lines of code.
Long Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,Parse,The method has 100 lines of code.
Long Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The method has 451 lines of code.
Long Method,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Parse,The method has 130 lines of code.
Long Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The method has 116 lines of code.
Long Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The method has 154 lines of code.
Long Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The method has 209 lines of code.
Long Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The method has 212 lines of code.
Long Method,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The method has 157 lines of code.
Long Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,EffectiveBooleanValue,The method has 116 lines of code.
Long Method,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The method has 101 lines of code.
Long Method,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The method has 132 lines of code.
Long Method,VDS.RDF.Query,SparqlOrderingComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,The method has 108 lines of code.
Long Method,VDS.RDF.Query,SparqlOrderingComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,The method has 108 lines of code.
Long Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The method has 146 lines of code.
Long Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The method has 146 lines of code.
Long Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has 250 lines of code.
Long Method,VDS.RDF.Writing,SparqlHtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlHtmlWriter.cs,GenerateOutput,The method has 142 lines of code.
Long Method,VDS.RDF.Writing,SparqlJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlJsonWriter.cs,GenerateOutput,The method has 100 lines of code.
Long Method,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The method has 100 lines of code.
Long Method,VDS.RDF.Writing,WriterHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\WriterUtilities.cs,FindCollections,The method has 183 lines of code.
Long Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateOutput,The method has 101 lines of code.
Long Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The method has 114 lines of code.
Long Method,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The method has 514 lines of code.
Long Method,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The method has 203 lines of code.
Long Method,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateOutput,The method has 158 lines of code.
Long Method,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,The method has 145 lines of code.
Long Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateOutput,The method has 203 lines of code.
Long Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateCollectionOutput,The method has 103 lines of code.
Long Method,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,The method has 106 lines of code.
Long Method,VDS.RDF.Writing,RdfJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfJsonWriter.cs,GenerateOutput,The method has 139 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,GetNextToken,The method has 101 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The method has 156 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The method has 110 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,GetNextToken,The method has 176 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,The method has 272 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrologueOrQueryKeyword,The method has 158 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The method has 539 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetLiteral,The method has 100 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,GetNextToken,The method has 178 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetPlainLiteralOrQName,The method has 120 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetKeywordOrLangSpec,The method has 103 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The method has 574 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The method has 117 lines of code.
Long Method,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,GetNextToken,The method has 105 lines of code.
Long Method,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The method has 107 lines of code.
Long Method,VDS.RDF.Query.Optimisation,VirtualAlgebraOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VirtualAlgebraOptimiser.cs,Optimise,The method has 104 lines of code.
Long Method,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The method has 143 lines of code.
Long Method,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The method has 111 lines of code.
Long Method,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetTriples,The method has 225 lines of code.
Long Method,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The method has 112 lines of code.
Long Method,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The method has 313 lines of code.
Long Method,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The method has 461 lines of code.
Long Method,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The method has 323 lines of code.
Long Method,VDS.RDF.Nodes,ValuedNodeExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Nodes\ValuedNodeExtensions.cs,AsValuedNode,The method has 157 lines of code.
Long Method,VDS.RDF.Query.Aggregates.Leviathan,NumericMaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMaxAggregate.cs,Apply,The method has 117 lines of code.
Long Method,VDS.RDF.Query.Aggregates.Leviathan,NumericMinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMinAggregate.cs,Apply,The method has 117 lines of code.
Long Method,VDS.RDF.Query.Algebra,AskBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AskBgp.cs,StreamingEvaluate,The method has 146 lines of code.
Long Method,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,StreamingEvaluate,The method has 284 lines of code.
Long Method,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The method has 142 lines of code.
Long Method,VDS.RDF.Query.Algebra,OneOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\OneOrMorePath.cs,Evaluate,The method has 135 lines of code.
Long Method,VDS.RDF.Query.Algebra,ZeroLengthPath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroLengthPath.cs,Evaluate,The method has 138 lines of code.
Long Method,VDS.RDF.Query.Algebra,ZeroOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroOrMorePath.cs,Evaluate,The method has 164 lines of code.
Long Method,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,LeftJoin,The method has 145 lines of code.
Long Method,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,ExistsJoin,The method has 133 lines of code.
Long Method,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The method has 117 lines of code.
Long Method,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The method has 127 lines of code.
Long Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,BooleanCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\BooleanCast.cs,Evaluate,The method has 105 lines of code.
Long Method,VDS.RDF.Query.Inference,SimpleN3RulesReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\SimpleN3RulesReasoner.cs,TryCreateRule,The method has 104 lines of code.
Long Method,VDS.RDF.Query.Paths,Property,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\Property.cs,Evaluate,The method has 178 lines of code.
Long Method,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,The method has 142 lines of code.
Long Method,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The method has 163 lines of code.
Long Method,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has 234 lines of code.
Long Method,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The method has 177 lines of code.
Long Method,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The method has 138 lines of code.
Long Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessQueryRequest,The method has 154 lines of code.
Long Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,The method has 118 lines of code.
Long Method,VDS.RDF.Web,SparqlServiceDescriber,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServiceDescriber.cs,GetServiceDescription,The method has 122 lines of code.
Long Method,VDS.RDF.Web.Configuration.Server,BaseSparqlServerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\Server\BaseSparqlServerConfiguration.cs,BaseSparqlServerConfiguration,The method has 130 lines of code.
Long Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The method has 161 lines of code.
Long Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The method has 101 lines of code.
Long Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatExpression,The method has 123 lines of code.
Long Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The method has 124 lines of code.
Long Method,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEvents,The method has 173 lines of code.
Long Method,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The method has 154 lines of code.
Complex Method,VDS.RDF,BaseGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BaseGraph.cs,Merge,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF,BaseGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BaseGraph.cs,ReadXml,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,IsFullyEscaped,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,Escape,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,BaseLiteralNode,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,ReadXml,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF,QNameOutputMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NamespaceMapper.cs,ReduceToQName,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,ResolveUri,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,CopyNode,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF,LazyIndexedTripleCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\AdvancedTripleCollections.cs,Index,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,TripleTrie,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\AdvancedTripleCollections.cs,GetKeyMapper,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,EqualityHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\EqualityHelper.cs,AreLiteralsEqual,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF,ComparisonHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\EqualityHelper.cs,CompareUris,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,ComparisonHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\EqualityHelper.cs,CompareLiterals,Cyclomatic complexity of the method is 93
Complex Method,VDS.RDF,GraphDiff,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphDiff.cs,Difference,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF,GraphPersistenceWrapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphPersistenceWrapper.cs,Merge,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF,GraphPersistenceWrapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphPersistenceWrapper.cs,Flush,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,DecrementNesting,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Flush,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Discard,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,IsSubGraph,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,Cyclomatic complexity of the method is 77
Complex Method,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,GenerateMappings,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,Equals,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,Cyclomatic complexity of the method is 77
Complex Method,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,GenerateMappings,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF,IndexHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Indexing.cs,SearchIndex,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,CanLoadObject,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Configuration,OptimiserFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\OptimiserFactory.cs,TryLoadObject,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Configuration,PermissionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 35
Complex Method,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationValue,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetDefaultType,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,Cyclomatic complexity of the method is 118
Complex Method,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,CanLoadObject,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Ontology,OntologyClass,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyClass.cs,OntologyClass,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Ontology,OntologyProperty,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyProperty.cs,OntologyProperty,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing,FolderStoreReader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FolderStoreReader.cs,Load,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,FolderStoreReader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FolderStoreReader.cs,LoadGraphs,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBinding,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,Cyclomatic complexity of the method is 44
Complex Method,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Parse,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseGraph,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParsePredicateObjectList,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,Cyclomatic complexity of the method is 47
Complex Method,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseCollection,Cyclomatic complexity of the method is 33
Complex Method,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsValidQName,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,Cyclomatic complexity of the method is 74
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseQueryVerb,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,Cyclomatic complexity of the method is 155
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseDescribeVariables,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFrom,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGraphPattern,Cyclomatic complexity of the method is 71
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,Cyclomatic complexity of the method is 83
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,Cyclomatic complexity of the method is 135
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,Cyclomatic complexity of the method is 36
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFilterClause,Cyclomatic complexity of the method is 67
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseExpression,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseOrderByClause,Cyclomatic complexity of the method is 99
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGroupByClause,Cyclomatic complexity of the method is 87
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseHavingClause,Cyclomatic complexity of the method is 70
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,Cyclomatic complexity of the method is 73
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSubquery,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseSubject,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParsePredicate,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,Cyclomatic complexity of the method is 30
Complex Method,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionPropertyElement,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionLiteralPropertyElement,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing,XmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\XmlSpecsHelper.cs,GetSupportedDataType,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,XmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\XmlSpecsHelper.cs,GetCompatibleSupportedDataType,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseHeaderRow,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseResultRow,Cyclomatic complexity of the method is 48
Complex Method,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,TryParseHeaderRow,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,TryParseResultRow,Cyclomatic complexity of the method is 56
Complex Method,VDS.RDF.Parsing,BlockingTextReader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\BlockingTextReader.cs,ReadBlock,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,DataUriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\DataUriLoader.cs,Load,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadGraphInternal,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadDatasetInternal,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsGenDelims,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsSubDelims,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsHexDigit,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Parse,Cyclomatic complexity of the method is 38
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseForAll,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseForSome,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseTriples,Cyclomatic complexity of the method is 40
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,Cyclomatic complexity of the method is 59
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,Cyclomatic complexity of the method is 72
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseGraphLiteral,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePath,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,Parse,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,Cyclomatic complexity of the method is 147
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurie,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParsePrefixAttribute,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,GrabText,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessXmlLiteral,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Parse,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,ParseInternal,Cyclomatic complexity of the method is 58
Complex Method,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteCommand,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteDataCommand,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertDataCommand,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseTriples,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,Cyclomatic complexity of the method is 52
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseCollection,Cyclomatic complexity of the method is 42
Complex Method,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseObject,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,Cyclomatic complexity of the method is 30
Complex Method,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,Load,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraphset,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraph,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,Initialise,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,Cyclomatic complexity of the method is 70
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathSequence,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathPrimary,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParseNegatedPropertySet,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathOneInPropertySet,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRelationalExpression,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAdditiveExpression,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParsePrimaryExpression,Cyclomatic complexity of the method is 78
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBrackettedExpression,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,Cyclomatic complexity of the method is 103
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseIriRefOrFunction,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,Cyclomatic complexity of the method is 25
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,Cyclomatic complexity of the method is 69
Complex Method,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseScalarArguments,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,Cyclomatic complexity of the method is 70
Complex Method,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToAlgebra,Cyclomatic complexity of the method is 42
Complex Method,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryInternal,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,ExecuteQuery,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,WriteXml,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,ReadXml,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNLocal,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,Cyclomatic complexity of the method is 27
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsHex,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,Cyclomatic complexity of the method is 31
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,EffectiveBooleanValue,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,Equality,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,Inequality,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,NumericEquality,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query,ExplainQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\ExplainQueryProcessor.cs,PrintBgpAnalysis,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,Cyclomatic complexity of the method is 36
Complex Method,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessAlgebra,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Query,QueryExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryExtensions.cs,UsesDefaultDataset,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query,QueryExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryExtensions.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,NumericCompare,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,NumericCompare,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query,SparqlOrderingComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Query,SparqlOrderingComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,QueryInternal,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,SaveGraph,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,ListGraphs,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,CreateRequest,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,SaveGraph,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,DeleteGraph,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,BeginTransaction,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,ToString,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,Query,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,Query,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,LoadGraph,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,SaveGraph,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Query,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Query,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,SaveGraph,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,UpdateGraph,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Storage,SesameHttpProtocolVersion6Connector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCopyCommand,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCommand,Cyclomatic complexity of the method is 39
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,Cyclomatic complexity of the method is 35
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,Cyclomatic complexity of the method is 25
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,Cyclomatic complexity of the method is 35
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,Cyclomatic complexity of the method is 63
Complex Method,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessMoveCommand,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Update,LeviathanUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\LeviathanUpdateProcessor.cs,ProcessCommandInternal,Cyclomatic complexity of the method is 42
Complex Method,VDS.RDF.Update,SparqlRemoteUpdateEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlRemoteUpdateEndpoint.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,ProcessPut,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,FolderStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FolderStoreWriter.cs,Save,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing,FolderStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FolderStoreWriter.cs,SaveGraphs,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Writing,InternalXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\InternalXmlWriter.cs,WriteNode,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Writing,SparqlHtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlHtmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Writing,SparqlJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlJsonWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 32
Complex Method,VDS.RDF.Writing,SparqlXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlXmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateTripleOutput,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,NTriplesWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NTriplesWriter.cs,NodeToNTriples,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,WriterHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\WriterUtilities.cs,FindCollections,Cyclomatic complexity of the method is 38
Complex Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GeneratePredicateOutput,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateObjectOutput,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateCollectionOutput,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GeneratePredicateNode,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Writing,RdfXmlTripleComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Writing,CsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CsvWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing,CsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CsvWriter.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,CsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CsvWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 52
Complex Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateCollectionOutput,Cyclomatic complexity of the method is 35
Complex Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GeneratePredicateNode,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,FindTypeReferences,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,NQuadsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NQuadsWriter.cs,Save,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Writing,NQuadsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NQuadsWriter.cs,NodeToNTriples,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Writing,RdfJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfJsonWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 56
Complex Method,VDS.RDF.Writing,SparqlCsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlCsvWriter.cs,Save,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Writing,SparqlRdfWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlRdfWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Writing,SparqlTsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlTsvWriter.cs,Save,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Writing,TriXWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriXWriter.cs,NodeToTriX,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Writing,TsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TsvWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Writing,TsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TsvWriter.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Writing,TsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TsvWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Writing,TurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TurtleWriter.cs,GenerateOutput,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Writing,TurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TurtleWriter.cs,GenerateNodeOutput,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing.Handlers,HandlerExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\HandlerExtensions.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Handlers,HandlerExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\HandlerExtensions.cs,Apply,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing.Handlers,WriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartRdfInternal,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartResultsInternal,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 23
Complex Method,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,TryGetLiteral,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,ConsumeNewLine,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,DiscardWhiteSpace,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,Cyclomatic complexity of the method is 47
Complex Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,Cyclomatic complexity of the method is 45
Complex Method,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,IsHexDigit,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 57
Complex Method,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetLiteral,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetNumericLiteral,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetPlainLiteralOrQName,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 90
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrologueOrQueryKeyword,Cyclomatic complexity of the method is 53
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQName,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,Cyclomatic complexity of the method is 233
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrNumericLiteral,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetLiteral,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 56
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetPlainLiteralOrQName,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetKeywordOrLangSpec,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetQName,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetLiteral,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetFormula,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,IsRDFTermToken,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 156
Complex Method,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Parsing.Tokens,CsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\CsvTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing.Tokens,CsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\CsvTokeniser.cs,TryGetQuotedField,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,GetNextToken,Cyclomatic complexity of the method is 30
Complex Method,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetLiteral,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Query.Datasets,BaseTransactionalQuadDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseQuadDataset.cs,Flush,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Datasets,BaseTransactionalQuadDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseQuadDataset.cs,Discard,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Query.Datasets,BaseTransactionalDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseDataset.cs,Flush,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Datasets,BaseTransactionalDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseDataset.cs,Discard,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Query.Optimisation,ImplicitJoinOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\ImplicitJoinOptimiser.cs,Optimise,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Optimisation,VariableSubstitutionTransformer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VariableSubstitutionTransformer.cs,Optimise,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Optimisation,AskBgpOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BgpOptimisers.cs,OptimiseInternal,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Optimisation,IdentityFilterOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\IdentityFilterOptimiser.cs,IsIdentityExpression,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Optimisation,StrictAlgebraOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\StrictAlgebraOptimiser.cs,Optimise,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query.Optimisation,VirtualAlgebraOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VirtualAlgebraOptimiser.cs,Optimise,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Query.Optimisation,WeightingComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\WeightedOptimiser.cs,GetSelectivities,Cyclomatic complexity of the method is 45
Complex Method,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,Cyclomatic complexity of the method is 49
Complex Method,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,TriplePattern,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetTriples,Cyclomatic complexity of the method is 49
Complex Method,VDS.RDF.Query.Patterns,LetPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\LetPattern.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Patterns,SubQueryPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\SubQueryPattern.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions,SparqlExpressionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlExpressionFactory.cs,CreateExpression,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,Cyclomatic complexity of the method is 49
Complex Method,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,Cyclomatic complexity of the method is 146
Complex Method,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,Cyclomatic complexity of the method is 216
Complex Method,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,Cyclomatic complexity of the method is 150
Complex Method,VDS.RDF.Nodes,ValuedNodeExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Nodes\ValuedNodeExtensions.cs,AsValuedNode,Cyclomatic complexity of the method is 73
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Aggregates.Leviathan,MedianAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\MedianAggregate.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Aggregates.Leviathan,ModeAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\ModeAggregate.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Aggregates.Leviathan,NumericMaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMaxAggregate.cs,Apply,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Query.Aggregates.Leviathan,NumericMinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMinAggregate.cs,Apply,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Query.Aggregates.Sparql,AverageAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\AverageAggregate.cs,Apply,Cyclomatic complexity of the method is 33
Complex Method,VDS.RDF.Query.Aggregates.Sparql,CountAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountAggregate.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Aggregates.Sparql,CountDistinctAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountDistinctAggregate.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Aggregates.Sparql,SumAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\SumAggregate.cs,Apply,Cyclomatic complexity of the method is 33
Complex Method,VDS.RDF.Query.Algebra,AskBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AskBgp.cs,StreamingEvaluate,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Query.Algebra,Bgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Bgp.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,StreamingEvaluate,Cyclomatic complexity of the method is 51
Complex Method,VDS.RDF.Query.Algebra,Distinct,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Algebra,Reduced,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Query.Algebra,NegatedPropertySet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\NegatedPropertySet.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Algebra,OneOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\OneOrMorePath.cs,Evaluate,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Algebra,BaseArbitraryLengthPathOperator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\PropertyPathOperators.cs,GetPathStarts,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Algebra,BaseArbitraryLengthPathOperator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\PropertyPathOperators.cs,EvaluateStep,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Query.Algebra,SingleValueRestrictionFilter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\RestrictionFilters.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Algebra,SubQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\SubQuery.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Algebra,ZeroLengthPath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroLengthPath.cs,Evaluate,Cyclomatic complexity of the method is 25
Complex Method,VDS.RDF.Query.Algebra,ZeroOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroOrMorePath.cs,Evaluate,Cyclomatic complexity of the method is 37
Complex Method,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,LeftJoin,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,ExistsJoin,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,MinusJoin,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Query.Algebra,Select,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Query.Algebra,Slice,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Slice.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetNode,Cyclomatic complexity of the method is 24
Complex Method,VDS.RDF.Query.Describe,BaseDescribeAlgorithm,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\BaseDescribeAlgorithm.cs,Describe,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Describe,BaseDescribeAlgorithm,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\BaseDescribeAlgorithm.cs,GetNodes,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Query.Describe,ConciseBoundedDescription,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\ConciseBoundedDescription.cs,DescribeInternal,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Describe,LabelledDescription,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\LabelledDescription.cs,DescribeInternal,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Describe,MinimalSpanningGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\MinimalSpanningGraph.cs,DescribeInternal,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Query.Describe,SymmetricConciseBoundedDescription,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\SymmetricConciseBoundedDescription.cs,DescribeInternal,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Query.Expressions.Functions.Arq,StringJoinFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\StringJoinFunction.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CubeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CubeFunction.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,EFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\EFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,LeviathanNaturalLogFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\NaturalLogFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RandomFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RandomFunction.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareFunction.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareRootFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareRootFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,TenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\TenFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,RegexFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\RegexFunction.cs,RegexFunction,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,RegexFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\RegexFunction.cs,ConfigureOptions,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,RegexFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\RegexFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,EvaluateInternal,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,BNodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\BNodeFunction.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,IriFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\IriFunction.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,StrLangFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\StrLangFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Hash,BaseHashFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Hash\BaseHashFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.Hash,BaseHashLibFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Hash\BaseHashFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\BaseBinaryStringFunction.cs,IsValidArgumentPair,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,ConcatFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ConcatFunction.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,ReplaceFunction,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,ConfigureOptions,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,DataTypeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\DataTypeFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,DataType11Function,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\DataTypeFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrAfterFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrAfterFunction.cs,IsValidArgumentPair,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrBeforeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrBeforeFunction.cs,IsValidArgumentPair,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,Evaluate,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,BooleanCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\BooleanCast.cs,Evaluate,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,DateTimeCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\DateTimeCast.cs,Evaluate,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,DecimalCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\DecimalCast.cs,Evaluate,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,DoubleCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\DoubleCast.cs,Evaluate,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,FloatCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\FloatCast.cs,Evaluate,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Cast,IntegerCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\IntegerCast.cs,Evaluate,Cyclomatic complexity of the method is 17
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundHalfToEvenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundHalfToEvenFunction.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,AbsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\AbsFunction.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,CeilingFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\CeilingFunction.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,FloorFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\FloorFunction.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundFunction.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\BaseBinaryStringFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.String,NormalizeUnicodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\NormalizeUnicodeFunction.cs,ValueInternal,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,ReplaceFunction,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,ConfigureOptions,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Grouping,GroupByVariable,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Grouping\SparqlGroupByClasses.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Grouping,GroupByVariable,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Grouping\SparqlGroupByClasses.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Query.Grouping,GroupByExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Grouping\SparqlGroupByClasses.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Grouping,GroupByExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Grouping\SparqlGroupByClasses.cs,Apply,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Query.Inference,SimpleN3RulesReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\SimpleN3RulesReasoner.cs,TryCreateRule,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,Apply,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,Initialise,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Query.Inference.Pellet,PelletServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\PelletServer.cs,Discover,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Inference.Pellet,PelletService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\PelletService.cs,CreateService,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Query.Inference.Pellet.Services,NamespaceService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\NamespaceService.cs,GetNamespaces,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Query.Inference.Pellet.Services,QueryService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\QueryService.cs,Query,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Query.Inference.Pellet.Services,SearchService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SearchService.cs,Search,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Query.Paths,Property,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\Property.cs,Evaluate,Cyclomatic complexity of the method is 31
Complex Method,VDS.RDF.Query.Paths,Property,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\Property.cs,ToString,Cyclomatic complexity of the method is 21
Complex Method,VDS.RDF.Update.Commands,BaseTransferCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseTransferCommand.cs,ToString,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Update.Commands,ClearCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ClearCommand.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Update.Commands,DropCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DropCommand.cs,Evaluate,Cyclomatic complexity of the method is 18
Complex Method,VDS.RDF.Update.Commands,DropCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DropCommand.cs,ToString,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,Evaluate,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,AffectsGraph,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,Cyclomatic complexity of the method is 49
Complex Method,VDS.RDF.Update.Commands,MoveCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\MoveCommand.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,VDS.RDF.Web,BaseGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseGraphHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Web,BaseSparqlHttpProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlHttpProtocolHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 34
Complex Method,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 40
Complex Method,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,GetPermissionAction,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 27
Complex Method,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,GetPermissionAction,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessRequest,Cyclomatic complexity of the method is 14
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessQueryRequest,Cyclomatic complexity of the method is 38
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,Cyclomatic complexity of the method is 25
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessProtocolRequest,Cyclomatic complexity of the method is 35
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,GetQueryPermissionAction,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,GetUpdatePermissionAction,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Web,NegotiateByFileExtension,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\NegotiateByFileExtension.cs,context_BeginRequest,Cyclomatic complexity of the method is 10
Complex Method,VDS.RDF.Web,SparqlServiceDescriber,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServiceDescriber.cs,GetServiceDescription,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Web,SparqlServiceDescriber,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServiceDescriber.cs,GetServiceDescription,Cyclomatic complexity of the method is 26
Complex Method,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,SendToClient,Cyclomatic complexity of the method is 16
Complex Method,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,ApplyWriterOptions,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Web.Configuration,BaseHandlerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\BaseHandlerConfiguration.cs,BaseHandlerConfiguration,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Web.Configuration.Query,BaseQueryHandlerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\Query\BaseQueryHandlerConfiguration.cs,BaseQueryHandlerConfiguration,Cyclomatic complexity of the method is 20
Complex Method,VDS.RDF.Web.Configuration.Server,BaseSparqlServerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\Server\BaseSparqlServerConfiguration.cs,BaseSparqlServerConfiguration,Cyclomatic complexity of the method is 29
Complex Method,VDS.RDF.Web.Configuration.Server,BaseSparqlServerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\Server\BaseSparqlServerConfiguration.cs,AddFeatureDescription,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Web.Configuration.Update,BaseUpdateHandlerConfiguration,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\Update\BaseUpdateHandlerConfiguration.cs,BaseUpdateHandlerConfiguration,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Writing.Formatting,RdfXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\RdfXmlFormatter.cs,Format,Cyclomatic complexity of the method is 48
Complex Method,VDS.RDF.Writing.Formatting,SparqlXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlXmlFormatter.cs,Format,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Writing.Formatting,DeliminatedLineFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\DeliminatedLineFormatter.cs,FormatLiteralNode,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,Cyclomatic complexity of the method is 65
Complex Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,Cyclomatic complexity of the method is 32
Complex Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,Cyclomatic complexity of the method is 19
Complex Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatExpression,Cyclomatic complexity of the method is 58
Complex Method,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,Cyclomatic complexity of the method is 33
Complex Method,VDS.RDF.Writing.Formatting,TurtleFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\TurtleFormatter.cs,FormatLiteralNode,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Writing.Serialization,ResultSetDeserializationInfo,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Serialization\ResultSetDeserializationInfo.cs,ResultSetDeserializationInfo,Cyclomatic complexity of the method is 9
Complex Method,VDS.RDF.Writing.Serialization,ResultSetDeserializationInfo,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Serialization\ResultSetDeserializationInfo.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEventTree,Cyclomatic complexity of the method is 13
Complex Method,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEvents,Cyclomatic complexity of the method is 30
Complex Method,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,FlattenEventTree,Cyclomatic complexity of the method is 15
Complex Method,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetNextEvent,Cyclomatic complexity of the method is 28
Complex Method,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetNextAttribute,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetElement,Cyclomatic complexity of the method is 12
Complex Method,VDS.RDF.Query.Expressions.Arithmetic,DivisionExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\DivisionExpression.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,VDS.RDF.Query.Expressions.Arithmetic,MinusExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\MinusExpression.cs,Evaluate,Cyclomatic complexity of the method is 20
Complex Method,HashLib,Hash,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Hash.cs,TransformObject,Cyclomatic complexity of the method is 22
Complex Method,VDS.RDF.Storage.Virtualisation,BaseVirtualNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\Virtualisation\VirtualNode.cs,CompareTo,Cyclomatic complexity of the method is 19
Long Parameter List,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,AssertList,The method has 5 parameters.
Long Parameter List,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,RemoveFromList,The method has 5 parameters.
Long Parameter List,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Remove,The method has 7 parameters.
Long Parameter List,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetFilenameFilter,The method has 6 parameters.
Long Parameter List,VDS.RDF,Triple,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Triple.cs,Triple,The method has 5 parameters.
Long Parameter List,VDS.RDF,GraphDiff,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphDiff.cs,Difference,The method has 9 parameters.
Long Parameter List,VDS.RDF,MimeTypeDefinition,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypeDefinition.cs,MimeTypeDefinition,The method has 9 parameters.
Long Parameter List,VDS.RDF,MimeTypeDefinition,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypeDefinition.cs,MimeTypeDefinition,The method has 10 parameters.
Long Parameter List,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,AddNamespace,The method has 5 parameters.
Long Parameter List,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The method has 20 parameters.
Long Parameter List,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryBruteForceMapping,The method has 8 parameters.
Long Parameter List,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,GenerateMappings,The method has 8 parameters.
Long Parameter List,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The method has 20 parameters.
Long Parameter List,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryBruteForceMapping,The method has 8 parameters.
Long Parameter List,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,GenerateMappings,The method has 8 parameters.
Long Parameter List,VDS.RDF,UnionGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\UnionGraph.cs,UnionGraph,The method has 7 parameters.
Long Parameter List,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The method has 6 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The method has 7 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationArray,The method has 6 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationBoolean,The method has 5 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationInt64,The method has 5 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationInt32,The method has 5 parameters.
Long Parameter List,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetUsernameAndPassword,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,RdfParseException,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Exceptions.cs,RdfParseException,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,RdfParseException,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Exceptions.cs,RdfParseException,The method has 6 parameters.
Long Parameter List,VDS.RDF.Parsing,RdfParseException,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Exceptions.cs,RdfParseException,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,IsProjectableExpression,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Reify,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadGraphInternal,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadDatasetInternal,The method has 6 parameters.
Long Parameter List,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParsePrefixAttribute,The method has 6 parameters.
Long Parameter List,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteCommand,The method has 6 parameters.
Long Parameter List,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SparqlRemoteEndpoint,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SparqlRemoteEndpoint,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SparqlRemoteEndpoint,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultSet,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultSet,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultGraph,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultGraph,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,Equals,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,PelletQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\PelletQueryProcessor.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,ISparqlQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\ISparqlQueryProcessor.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,SimpleQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,SimpleQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,GenericQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query,GenericQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,GenerateChangeSet,The method has 6 parameters.
Long Parameter List,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,StardogConnector,The method has 6 parameters.
Long Parameter List,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,StardogConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,StardogConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,AllegroGraphConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,AllegroGraphConnector,The method has 6 parameters.
Long Parameter List,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,AllegroGraphConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,BaseSesameHttpProtocolConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,SesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,SesameHttpProtocolConnector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,SesameHttpProtocolVersion5Connector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,SesameHttpProtocolVersion5Connector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Storage,SesameHttpProtocolVersion6Connector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,SesameHttpProtocolVersion6Connector,The method has 5 parameters.
Long Parameter List,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,IsValidDataPattern,The method has 5 parameters.
Long Parameter List,VDS.RDF.Update,SparqlRemoteUpdateEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlRemoteUpdateEndpoint.cs,Update,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing,WriterHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\WriterUtilities.cs,FindCollections,The method has 8 parameters.
Long Parameter List,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The method has 11 parameters.
Long Parameter List,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateCaptionedInformation,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateCaptionedInformation,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateCollectionOutput,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GeneratePredicateNode,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateUriOutput,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateUriRef,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateTemporaryNamespace,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Tokens,BaseToken,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseToken.cs,BaseToken,The method has 6 parameters.
Long Parameter List,VDS.RDF.Parsing.Tokens,LiteralToken,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Tokens.cs,LiteralToken,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Tokens,LongLiteralToken,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Tokens.cs,LongLiteralToken,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Tokens,GraphLiteralToken,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Tokens.cs,GraphLiteralToken,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Tokens,BlankNodeCollectionToken,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Tokens.cs,BlankNodeCollectionToken,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The method has 8 parameters.
Long Parameter List,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,TryReorderPatterns,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetTriples,The method has 7 parameters.
Long Parameter List,VDS.RDF.Query.Ordering,OrderByVariable,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Ordering\SparqlOrderByClasses.cs,GetComparer,The method has 7 parameters.
Long Parameter List,VDS.RDF.Query.Ordering,OrderByExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Ordering\SparqlOrderByClasses.cs,GetComparer,The method has 7 parameters.
Long Parameter List,VDS.RDF.Configuration.Permissions,UserGroup,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\Permissions\UserGroup.cs,IsActionPermitted,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseParserContext.cs,TokenisingParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingResultParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseResultsParserContext.cs,TokenisingResultParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TokenisingStoreParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\BaseStoreParserContext.cs,TokenisingStoreParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,Notation3ParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\Notation3ParserContext.cs,Notation3ParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,Notation3ParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\Notation3ParserContext.cs,Notation3ParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TriGParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\TriGParserContext.cs,TriGParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Contexts,TriGParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\TriGParserContext.cs,TriGParserContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Validation,SyntaxValidationResults,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Validation\SyntaxValidationResults.cs,SyntaxValidationResults,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Algebra,NegatedPropertySet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\NegatedPropertySet.cs,NegatedPropertySet,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,EvalJoin,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianFunction,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,Cluster,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,Cluster,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,SimilarityRaw,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,Predict,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,PredictRaw,The method has 6 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,ExplainPropertyService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ExplainServices.cs,ExplainProperty,The method has 5 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,QueryService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\QueryService.cs,Query,The method has 7 parameters.
Long Parameter List,VDS.RDF.Query.Inference.Pellet.Services,QueryService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\QueryService.cs,Query,The method has 9 parameters.
Long Parameter List,VDS.RDF.Update.Commands,BaseModificationCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseModifyCommand.cs,IsValidDeletePattern,The method has 5 parameters.
Long Parameter List,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,IsValidDataPattern,The method has 5 parameters.
Long Parameter List,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,IsValidDataPattern,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,HandleErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,HandleErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,HandleQueryErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,HandleUpdateErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,IsAuthenticated,The method has 6 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,SendToClient,The method has 6 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,HandleQueryErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,HandleQueryErrors,The method has 6 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,HandleUpdateErrors,The method has 5 parameters.
Long Parameter List,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,HandleUpdateErrors,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,BaseWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\BaseWriterContexts.cs,BaseWriterContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,TriGWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TriGWriterContext.cs,TriGWriterContext,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,TurtleWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TurtleWriterContext.cs,TurtleWriterContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,TurtleWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TurtleWriterContext.cs,TurtleWriterContext,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,CompressingTurtleWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TurtleWriterContext.cs,CompressingTurtleWriterContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,CompressingTurtleWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TurtleWriterContext.cs,CompressingTurtleWriterContext,The method has 5 parameters.
Long Parameter List,VDS.RDF.Writing.Contexts,CompressingTurtleWriterContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Contexts\TurtleWriterContext.cs,CompressingTurtleWriterContext,The method has 6 parameters.
Long Parameter List,VDS.RDF.Writing.Formatting,DeliminatedLineFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\DeliminatedLineFormatter.cs,DeliminatedLineFormatter,The method has 9 parameters.
Long Parameter List,VDS.RDF.Parsing.Events.RdfXml,ElementEvent,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\XmlEvents.cs,ElementEvent,The method has 5 parameters.
Long Parameter List,VDS.RDF.Parsing.Events.RdfXml,AttributeEvent,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\XmlEvents.cs,AttributeEvent,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,Check,The method has 5 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,Check,The method has 6 parameters.
Long Parameter List,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,Check,The method has 7 parameters.
Long Parameter List,VDS.RDF.Storage.Virtualisation,BaseVirtualNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\Virtualisation\VirtualNode.cs,BaseVirtualNode,The method has 5 parameters.
Long Statement,VDS.RDF,BaseGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BaseGraph.cs,Merge,The length of the statement  "			this.Assert (new Triple (Tools.CopyNode (t.Subject' this' keepOriginalGraphUri)' Tools.CopyNode (t.Predicate' this' keepOriginalGraphUri)' Tools.CopyNode (t.Object' this' keepOriginalGraphUri)' t.Context)); " is 206.
Long Statement,VDS.RDF,BaseGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BaseGraph.cs,ReadXml,The length of the statement  "		throw new RdfParseException ("Expected a <triples> element inside a <graph> element but got a <" + reader.Name + "> element instead"); " is 134.
Long Statement,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,GetListAsTriples,The length of the statement  "			throw new RdfException ("Unable to get list as there was no rdf:first associated with the list item " + listCurrent.ToString ()); " is 129.
Long Statement,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,GetListAsTriples,The length of the statement  "			throw new RdfException ("Unable to get list as there was more than one rdf:first associated with the list item " + listCurrent.ToString ()); " is 140.
Long Statement,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,GetListAsTriples,The length of the statement  "			throw new RdfException ("Unable to get list as there was no rdf:rest associated with the list item " + listCurrent.ToString ()); " is 128.
Long Statement,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,GetListAsTriples,The length of the statement  "			throw new RdfException ("Unable to get list as there was more than one rdf:rest associated with the list item " + listCurrent.ToString ()); " is 139.
Long Statement,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,IsListRoot,The length of the statement  "	return !g.GetTriplesWithPredicateObject (rdfRest' n).Any () && (g.GetTriplesWithSubjectPredicate (n' rdfFirst).Count () == 1); " is 126.
Long Statement,VDS.RDF,GraphExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,SaveToFile,The length of the statement  "	IRdfWriter writer = MimeTypesHelper.GetWriter (MimeTypesHelper.GetMimeTypes (MimeTypesHelper.GetTrueFileExtension (file))); " is 123.
Long Statement,VDS.RDF,TripleStoreExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,SaveToFile,The length of the statement  "	IStoreWriter writer = MimeTypesHelper.GetStoreWriter (MimeTypesHelper.GetMimeType (MimeTypesHelper.GetTrueFileExtension (file))); " is 129.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteral,The length of the statement  "	return factory.CreateLiteralNode (b.ToString ().ToLower ()' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean)); " is 121.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteral,The length of the statement  "		return factory.CreateLiteralNode (XmlConvert.ToString (b)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeUnsignedByte)); " is 125.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteral,The length of the statement  "	return factory.CreateLiteralNode (dt.ToString (XmlSpecsHelper.XmlSchemaDateTimeFormat)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDateTime)); " is 150.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteralDate,The length of the statement  "	return factory.CreateLiteralNode (dt.ToString (XmlSpecsHelper.XmlSchemaDateFormat)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDate)); " is 142.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteralTime,The length of the statement  "	return factory.CreateLiteralNode (dt.ToString (XmlSpecsHelper.XmlSchemaTimeFormat)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeTime)); " is 142.
Long Statement,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteral,The length of the statement  "	return factory.CreateLiteralNode (XmlConvert.ToString (t)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration)); " is 128.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Contains,The length of the statement  "		if (this._graphs [id].BaseUri != null && this._graphs [id].BaseUri.ToString ().Equals (graphUri.ToSafeString ()' StringComparison.Ordinal)) { " is 141.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Contains,The length of the statement  "			return this._collisionGraphs.Any (g => (g.BaseUri == null && graphUri == null) || g.BaseUri.ToString ().Equals (graphUri.ToSafeString ()' StringComparison.Ordinal)); " is 165.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,The length of the statement  "		if (this._graphs [id].BaseUri != null && this._graphs [id].BaseUri.ToString ().Equals (g.BaseUri.ToString ()' StringComparison.Ordinal)) { " is 138.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,The length of the statement  "				throw new RdfException ("The Graph you tried to add already exists in the Graph Collection and the mergeIfExists parameter was set to false"); " is 142.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,The length of the statement  "				throw new RdfException ("The Graph you tried to add already exists in the Graph Collection and the mergeIfExists parameter was set to false"); " is 142.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,The length of the statement  "			IGraph temp = this._collisionGraphs.FirstOrDefault (graph => (graph.BaseUri == null && g.BaseUri == null) || graph.BaseUri.ToString ().Equals (g.BaseUri.ToString ()' StringComparison.Ordinal)); " is 193.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Add,The length of the statement  "					throw new RdfException ("The Graph you tried to add already exists in the Graph Collection and the mergeIfExists parameter was set to false"); " is 142.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Remove,The length of the statement  "		if (this._graphs [id].BaseUri != null && this._graphs [id].BaseUri.ToString ().Equals (graphUri.ToString ()' StringComparison.Ordinal)) { " is 137.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Remove,The length of the statement  "			IGraph temp = this._collisionGraphs.First (g => (g.BaseUri == null && graphUri == null) || g.BaseUri.ToString ().Equals (graphUri.ToString ()' StringComparison.Ordinal)); " is 170.
Long Statement,VDS.RDF,GraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphCollection.cs,Remove,The length of the statement  "			this._collisionGraphs.RemoveAll (g => (g.BaseUri == null && graphUri == null) || g.BaseUri.ToString ().Equals (graphUri.ToString ()' StringComparison.Ordinal)); " is 160.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The length of the statement  "		MimeTypeDefinition ntriples = new MimeTypeDefinition ("NTriples"' W3CFormatsNamespace + "N-Triples"' NTriples' new String[] { " is 125.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The length of the statement  "		_mimeTypes.Add (new MimeTypeDefinition ("SPARQL Results XML"' W3CFormatsNamespace + "SPARQL_Results_XML"' SparqlResultsXml' new String[] { " is 138.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The length of the statement  "		_mimeTypes.Add (new MimeTypeDefinition ("SPARQL Results JSON"' W3CFormatsNamespace + "SPARQL_Results_JSON"' SparqlResultsJson' new String[] { " is 141.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The length of the statement  "		_mimeTypes.Add (new MimeTypeDefinition ("SPARQL Boolean Result"' SparqlResultsBoolean' Enumerable.Empty<String> ()' null' null' typeof(SparqlBooleanParser)' null' null' null)); " is 176.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,Init,The length of the statement  "		//Define RDF/JSON - include SPARQL Parsers to support servers that send back incorrect MIME Type for SPARQL JSON Results " is 120.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetFilenameFilter,The length of the statement  "		if ((rdf && (def.CanParseRdf || def.CanWriteRdf)) || (rdfDatasets && (def.CanParseRdfDatasets || def.CanWriteRdfDatasets)) || (sparqlResults && (def.CanParseSparqlResults || def.CanWriteSparqlResults)) || (sparqlQuery && def.CanParseObject<SparqlQuery> ()) || (sparqlUpdate && def.CanParseObject<SparqlUpdateCommandSet> ())) { " is 326.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetParser,The length of the statement  "	throw new RdfParserSelectionException ("The Library does not contain any Parsers which understand RDF Graphs in any of the following MIME Types: " + types); " is 156.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetParser,The length of the statement  "	throw new RdfParserSelectionException ("The Library does not contain a Parser which understands RDF Graphs in the format '" + contentType + "'"); " is 145.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetSparqlParser,The length of the statement  "	throw new RdfParserSelectionException ("The Library does not contain a Parser which understands SPARQL Results in the format '" + contentType + "'"); " is 149.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetStoreParser,The length of the statement  "	throw new RdfParserSelectionException ("The Library does not contain a Parser which understands RDF datasets in the format '" + contentType + "'"); " is 147.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetStoreWriter,The length of the statement  "	throw new RdfWriterSelectionException ("The Library does not contain a writer which can output RDF datasets in a format supported by the Client"); " is 146.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetMimeType,The length of the statement  "	throw new RdfParserSelectionException ("Unable to determine the appropriate MIME Type for the File Extension '" + fileExt + "' as this is not a standard extension for an RDF format"); " is 183.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetMimeTypes,The length of the statement  "	throw new RdfParserSelectionException ("Unable to determine the appropriate MIME Type for the File Extension '" + fileExt + "' as this is not a standard extension for an RDF format"); " is 183.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetFileExtension,The length of the statement  "	throw new RdfException ("Unable to determine the appropriate File Extension for the RDF Writer '" + writer.GetType ().ToString () + "'"); " is 137.
Long Statement,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetFileExtension,The length of the statement  "	throw new RdfException ("Unable to determine the appropriate File Extension for the Store Writer '" + writer.GetType ().ToString () + "'"); " is 139.
Long Statement,VDS.RDF,NamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NamespaceMapper.cs,GetPrefix,The length of the statement  "		throw new RdfException ("The Prefix for the given URI '" + uri.ToString () + "' is not known by the in-scope NamespaceMapper"); " is 127.
Long Statement,VDS.RDF,NamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NamespaceMapper.cs,GetNamespaceUri,The length of the statement  "		throw new RdfException ("The Namespace URI for the given Prefix '" + prefix + "' is not known by the in-scope NamespaceMapper"); " is 128.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The length of the statement  "		//HACK: This is something of a Hack as a workaround to the issue that some systems may generate RDF which have technically malformed file:// scheme URIs in it " is 158.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The length of the statement  "		//This is because *nix style filesystems use paths of the form /path/to/somewhere and some serializers will serialize such " is 122.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,ResolveUri,The length of the statement  "					throw new RdfParseException ("Cannot resolve a URI since the Base URI is not a valid for resolving Relative URIs against"); " is 123.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,ResolveUri,The length of the statement  "			throw new RdfParseException ("Cannot use an Empty URI to refer to the document Base URI since there is no in-scope Base URI!"); " is 127.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,ResolveQName,The length of the statement  "				throw new RdfParseException ("Cannot resolve a QName in the Default Namespace when there is no in-scope Base URI and no Default Namespace defined"); " is 148.
Long Statement,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,HttpDebugResponse,The length of the statement  "	Console.Error.WriteLine ("HTTP/" + httpResponse.ProtocolVersion + " " + (int)httpResponse.StatusCode + " " + httpResponse.StatusDescription); " is 141.
Long Statement,VDS.RDF,Triple,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Triple.cs,Equals,The length of the statement  "		return (this._subject.Equals (temp.Subject) || (this._subject.NodeType == NodeType.Blank && temp.Subject.NodeType == NodeType.Blank && this._subject.ToString ().Equals (temp.Subject.ToString ()))) && (this._predicate.Equals (temp.Predicate) || (this._predicate.NodeType == NodeType.Blank && temp.Predicate.NodeType == NodeType.Blank && this._predicate.ToString ().Equals (temp.Predicate.ToString ()))) && (this._object.Equals (temp.Object) || (this._object.NodeType == NodeType.Blank && temp.Object.NodeType == NodeType.Blank && this._object.ToString ().Equals (temp.Object.ToString ()))); " is 589.
Long Statement,VDS.RDF,Triple,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Triple.cs,ReadXml,The length of the statement  "	this._hashcode = (this._subject.GetHashCode ().ToString () + this._predicate.GetHashCode ().ToString () + this._object.GetHashCode ().ToString ()).GetHashCode (); " is 162.
Long Statement,VDS.RDF,ListIndexedTripleCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\AdvancedTripleCollections.cs,WithPredicate,The length of the statement  "	return this._predIndex.SearchIndex<Triple> (this._p' new Triple (this._varSubj.CopyNode (pred.Graph)' pred' this._varObj.CopyNode (pred.Graph))); " is 145.
Long Statement,VDS.RDF,ListIndexedTripleCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\AdvancedTripleCollections.cs,WithObject,The length of the statement  "	return this._objIndex.SearchIndex<Triple> (this._o' new Triple (this._varSubj.CopyNode (obj.Graph)' this._varPred.CopyNode (obj.Graph)' obj)); " is 142.
Long Statement,VDS.RDF,ListIndexedTripleCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\AdvancedTripleCollections.cs,WithSubject,The length of the statement  "	return this._subjIndex.SearchIndex<Triple> (this._s' new Triple (subj' this._varPred.CopyNode (subj.Graph)' this._varObj.CopyNode (subj.Graph))); " is 145.
Long Statement,VDS.RDF,BaseEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BaseEndpoint.cs,SerializeConfiguration,The length of the statement  "				INode useCreds = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyUseCredentialsForProxy); " is 129.
Long Statement,VDS.RDF,EqualityHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\EqualityHelper.cs,AreUrisEqual,The length of the statement  "	return a.Scheme.Equals (b.Scheme' StringComparison.OrdinalIgnoreCase) && a.Host.Equals (b.Host' StringComparison.OrdinalIgnoreCase) && a.Port.Equals (b.Port) && a.UserInfo.Equals (b.UserInfo' StringComparison.Ordinal)  " is 217.
Long Statement,VDS.RDF,GraphDiff,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphDiff.cs,MergeMapping,The length of the statement  "				throw new RdfException ("Error in GraphDiff - " + kvp.Key.ToString () + " is already mapped to " + report.Mapping [kvp.Key].ToString () + " so cannot be remapped to " + kvp.Value.ToString ()); " is 192.
Long Statement,VDS.RDF,MimeTypeDefinition,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypeDefinition.cs,EnsureInterface,The length of the statement  "		throw new RdfException ("Cannot use Type " + t.FullName + " for the " + property + " Type as it does not implement the required interface " + interfaceType.FullName); " is 166.
Long Statement,VDS.RDF,MimeTypeDefinition,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypeDefinition.cs,EnsureObjectParserInterface,The length of the statement  "		throw new RdfException ("Cannot use Type " + t.FullName + " as an Object Parser for the Type " + obj.FullName + " as it does not implement the required interface IObjectParser<" + obj.Name + ">"); " is 196.
Long Statement,VDS.RDF,GraphPersistenceWrapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphPersistenceWrapper.cs,Merge,The length of the statement  "			this.Assert (new Triple (Tools.CopyNode (t.Subject' this._g' keepOriginalGraphUri)' Tools.CopyNode (t.Predicate' this._g' keepOriginalGraphUri)' Tools.CopyNode (t.Object' this._g' keepOriginalGraphUri))); " is 204.
Long Statement,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,GetNamespaceUri,The length of the statement  "		throw new RdfException ("The Namespace URI for the given Prefix '" + prefix + "' is not known by the in-scope NamespaceMapper"); " is 128.
Long Statement,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,GetPrefix,The length of the statement  "		throw new RdfException ("The Prefix for the given URI '" + uri.ToString () + "' is not known by the in-scope NamespaceMapper"); " is 127.
Long Statement,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,GetNestingLevel,The length of the statement  "		throw new RdfException ("The Nesting Level for the given Prefix '" + prefix + "' is not known by the in-scope NamespaceMapper"); " is 128.
Long Statement,VDS.RDF,NestedNamespaceMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NestedNamespaceMapper.cs,Import,The length of the statement  "			if (!this.GetNamespaceUri (prefix).ToString ().Equals (nsmap.GetNamespaceUri (prefix).ToString ()' StringComparison.Ordinal)) { " is 127.
Long Statement,VDS.RDF,PersistentTripleStore,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,ExecuteQuery,The length of the statement  "			throw new RdfQueryException ("Unable to execute a SPARQL Query as the in-memory view of the store is not synced with the underlying store' please invoked Flush() or Discard() and try again.  Alternatively if you do not want to see in-memory changes reflected in query results you can invoke the Query() method directly on the underlying store by accessing it through the UnderlyingStore property."); " is 399.
Long Statement,VDS.RDF,PersistentTripleStore,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,ExecuteUpdate,The length of the statement  "			throw new SparqlUpdateException ("Unable to execute a SPARQL Update as the in-memory view of the store is not synced with the underlying store' please invoked Flush() or Discard() and try again.  Alternatively if you do not want to see in-memory changes reflected in update results you can invoke the Update() method directly on the underlying store by accessing it through the UnderlyingStore property."); " is 406.
Long Statement,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,RaiseGraphAdded,The length of the statement  "				this._actions.Add (new TripleStorePersistenceAction (new GraphPersistenceAction (g' GraphPersistenceActionType.Added))); " is 120.
Long Statement,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,RaiseGraphAdded,The length of the statement  "			this._actions.Add (new TripleStorePersistenceAction (new GraphPersistenceAction (g' GraphPersistenceActionType.Added))); " is 120.
Long Statement,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,RaiseGraphRemoved,The length of the statement  "			this._actions.Add (new TripleStorePersistenceAction (new GraphPersistenceAction (g' GraphPersistenceActionType.Deleted))); " is 122.
Long Statement,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,RaiseGraphRemoved,The length of the statement  "			this._actions.Add (new TripleStorePersistenceAction (new GraphPersistenceAction (g' GraphPersistenceActionType.Deleted))); " is 122.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,IsSubGraph,The length of the statement  "	//If there are no Triples left in the parent Graph' all our Triples were Ground Triples and there are no Blank Nodes to map then we're a sub-graph " is 146.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "		if (t.Subject.NodeType == NodeType.Blank && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank) { " is 124.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "		if (t.Subject.NodeType == NodeType.Blank && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank) { " is 124.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "				where t.Subject.NodeType == NodeType.Blank && t.Predicate.Equals (xs [0].Predicate) && t.Object.NodeType == NodeType.Blank " is 122.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "				where t.Subject.Equals (xs [0].Subject) && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank " is 120.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryBruteForceMapping,The length of the statement  "			foreach (KeyValuePair<INode' int> hPair in parentNodes.Where (p => p.Value == gPair.Value && !this._bound.Contains (p.Key))) { " is 126.
Long Statement,VDS.RDF,SubGraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\SubGraphMatcher.cs,TryBruteForceMapping,The length of the statement  "	List<Dictionary<INode' INode>> possibles = this.GenerateMappings (possibleMappings' subDependencies' parentDependencies' parent); " is 129.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,Equals,The length of the statement  "	//If there are no Triples left in the other Graph' all our Triples were Ground Triples and there are no Blank Nodes to map the Graphs are equal " is 143.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "		if (t.Subject.NodeType == NodeType.Blank && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank) { " is 124.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "		if (t.Subject.NodeType == NodeType.Blank && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank) { " is 124.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "				where t.Subject.NodeType == NodeType.Blank && t.Predicate.Equals (xs [0].Predicate) && t.Object.NodeType == NodeType.Blank " is 122.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryRulesBasedMapping,The length of the statement  "				where t.Subject.Equals (xs [0].Subject) && t.Predicate.NodeType == NodeType.Blank && t.Object.NodeType == NodeType.Blank " is 120.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryBruteForceMapping,The length of the statement  "			foreach (KeyValuePair<INode' int> hPair in hNodes.Where (p => p.Value == gPair.Value && !this._bound.Contains (p.Key))) { " is 121.
Long Statement,VDS.RDF,GraphMatcher,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\GraphMatcher.cs,TryBruteForceMapping,The length of the statement  "	List<Dictionary<INode' INode>> possibles = this.GenerateMappings (possibleMappings' sourceDependencies' targetDependencies' h); " is 127.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromGraph)); " is 152.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from another Graph for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromGraph property points to an Object that cannot be loaded as an object which implements the IGraph interface"); " is 297.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromEmbedded)); " is 155.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from an Embedded Resource for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromEmbedded property is not a Literal Node as required"); " is 248.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromFile)); " is 151.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from a file for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromFile property is not a Literal Node as required"); " is 230.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromString)); " is 153.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from a string for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromString property is not a Literal Node as required"); " is 234.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	IEnumerable<INode> stores = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromStore)); " is 170.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyWithUri)); " is 150.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "					throw new DotNetRdfConfigurationException ("Unable to load data from a Generic Store for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:withUri property is not a URI/Literal Node as required"); " is 242.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "					throw new DotNetRdfConfigurationException ("Unable to load data from a Store for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:withUri property is not a URI/Literal Node as required"); " is 234.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from a Store for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values of the dnr:fromStore property points to an Object which cannot be loaded as an object which implements either the IGenericIOManager/ITripleStore interface"); " is 322.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromUri)); " is 150.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			                    throw new PlatformNotSupportedException("Loading Data into a Graph from a remote URI is not currently supported under Silverlight/Windows Phone 7");" is 148.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			                    throw new PlatformNotSupportedException("Loading Data into a Graph from a remote URI is not currently supported under Silverlight/Windows Phone 7");" is 148.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load data from a URI for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromUri property is not a URI/Literal Node as required"); " is 232.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	INode baseUri = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAssignUri)); " is 158.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to assign a new Base URI for the Graph identified by the Node '" + objNode.ToString () + "' as the value for the dnr:assignUri property is not a URI/Literal Node as required"); " is 227.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	IEnumerable<INode> reasoners = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyReasoner)); " is 172.
Long Statement,VDS.RDF.Configuration,GraphFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to apply a reasoner for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:reasoner property points to an Object which cannot be loaded as an object which implements the IInferenceEngine interface"); " is 295.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "	INode propSqlManager = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertySqlManager)' propGenericManager = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)' propAsync = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAsync); " is 321.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "		throw new DotNetRdfConfigurationException ("The NativeTripleStore class is obsolete' please use a PersistentTripleStore instead which supercedes this class and provides more useful behaviour"); " is 193.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load a Persistent Triple Store identified by the Node '" + objNode.ToString () + "' as the value given the for dnr:genericManager property points to an Object which could not be loaded as an object which implements the IGenericIOManager interface"); " is 303.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<INode> sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' "dnr:usingGraph")); " is 150.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load data from a Graph for the Triple Store identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:usingGraph property points to an Object that cannot be loaded as an object which implements the IGraph interface"); " is 299.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "		sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromEmbedded)); " is 155.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load data from an Embedded Resource for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromEmbedded property is not a Literal Node as required"); " is 248.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "		sources = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromFile)); " is 151.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load data from a file for the Triple Store identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:fromFile property is not a Literal Node as required"); " is 237.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "			IEnumerable<INode> reasoners = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyReasoner)); " is 172.
Long Statement,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The length of the statement  "					throw new DotNetRdfConfigurationException ("Unable to apply a reasoner for the Graph identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:reasoner property points to an Object which cannot be loaded as an object which implements the IInferenceEngine interface"); " is 295.
Long Statement,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,The length of the statement  "		storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 155.
Long Statement,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Dataset identified by the Node '" + objNode.ToString () + "' since the Object pointed to by the dnr:usingStore property could not be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 283.
Long Statement,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,The length of the statement  "		storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 155.
Long Statement,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Dataset identified by the Node '" + objNode.ToString () + "' since the Object pointed to by the dnr:usingStore property could not be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 283.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "		String endpointUri = ConfigurationLoader.GetConfigurationValue (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpointUri)); " is 166.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<String> defaultGraphs = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDefaultGraphUri)) " is 193.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<String> namedGraphs = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyNamedGraphUri)) " is 189.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<INode> endpoints = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint)); " is 172.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the SPARQL Endpoint identified by the Node '" + e.ToString () + "' as one of the values for the dnr:endpoint property points to an Object which cannot be loaded as an object which is a SparqlRemoteEndpoint"); " is 267.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "		INode proxyNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyProxy)); " is 156.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "				bool useCredentialsForProxy = ConfigurationLoader.GetConfigurationBoolean (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUseCredentialsForProxy)' false); " is 195.
Long Statement,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load SPARQL Endpoint identified by the Node '" + objNode.ToString () + "' as the value for the dnr:proxy property points to an Object which cannot be loaded as an object of type WebProxy"); " is 243.
Long Statement,VDS.RDF.Configuration,OptimiserFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\OptimiserFactory.cs,TryLoadObject,The length of the statement  "		INode statsObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingGraph)); " is 160.
Long Statement,VDS.RDF.Configuration,OptimiserFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\OptimiserFactory.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to create the Weighted Query Optimiser identified by the Node '" + objNode.ToString () + "' since the dnr:usingGraph property points to an object that cannot be loaded as an Object that imlements the required IGraph interface"); " is 279.
Long Statement,VDS.RDF.Configuration,PermissionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		String action = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAction)); " is 157.
Long Statement,VDS.RDF.Configuration,PermissionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<String> actions = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAction)) " is 178.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<INode> members = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyMember)); " is 168.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the User identified by the Node '" + member.ToString () + "' as there does not appear to be a valid username and password specified for this User either via the dnr:user and dnr:password properties or via a dnr:credentials property"); " is 293.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<INode> allowed = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAllow)); " is 167.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Permission identified by the Node '" + allow.ToString () + "' as the Object specified could not be loaded as an object which implements the IPermission interface"); " is 227.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		IEnumerable<INode> denied = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDeny)); " is 165.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Permission identified by the Node '" + deny.ToString () + "' as the Object specified could not be loaded as an object which implements the IPermission interface"); " is 226.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		result.AllowGuests = !ConfigurationLoader.GetConfigurationBoolean (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyRequiresAuthentication)' true); " is 186.
Long Statement,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The length of the statement  "		String mode = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyPermissionModel)); " is 164.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset)); " is 164.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface"); " is 298.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 154.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 305.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 154.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Simple Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the INativelyQueryableStore interface"); " is 302.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)); " is 166.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Generic Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IQueryableGenericIOManager interface"); " is 310.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode endpointObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint)); " is 161.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Remote Query Processor identified by the Node '" + objNode.ToSafeString () + "' as the value given for the dnr:endpoint property points to an Object that cannot be loaded as an object which is a SparqlRemoteEndpoint"); " is 281.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		String server = ConfigurationLoader.GetConfigurationValue (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyServer)); " is 156.
Long Statement,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		String kb = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyStore)); " is 152.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset)); " is 164.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface"); " is 299.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 154.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 306.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 154.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Simple Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IUpdateableTripleStore interface"); " is 302.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)); " is 166.
Long Statement,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Generic Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IGenericIOManager interface"); " is 302.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode qNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyQueryProcessor)); " is 161.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode uNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUpdateProcessor)); " is 162.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:updateProcessor property points to an Object that cannot be loaded as an object which implements the ISparqlUpdateProcessor interface"); " is 314.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:queryProcessor property points to an Object that cannot be loaded as an object which implements the ISparqlQueryProcessor interface"); " is 312.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode datasetNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset)); " is 165.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface"); " is 301.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			INode storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 161.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 310.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "		INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)); " is 166.
Long Statement,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Generic Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IGenericIOManager interface"); " is 304.
Long Statement,VDS.RDF.Configuration,ProxyFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProxyFactory.cs,TryLoadObject,The length of the statement  "	String server = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyServer)); " is 157.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "		String server = ConfigurationLoader.GetConfigurationValue (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyServer)); " is 156.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "		String kb = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyStore)); " is 152.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "		INode reasonerNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyOwlReasoner)); " is 165.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load configuration for the OWL Reasoner Wrapper identified by the Node '" + objNode.ToString () + "' as the value for the dnr:owlReasoner property points to an Object which cannot be loaded as an object which implements the IOwlReasoner interface"); " is 303.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "			IEnumerable<INode> rulesGraphs = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingGraph)); " is 176.
Long Statement,VDS.RDF.Configuration,ReasonerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ReasonerFactory.cs,TryLoadObject,The length of the statement  "					throw new DotNetRdfConfigurationException ("Unable to load Configuration for the Forward Chaining Reasoner identified by the Node '" + objNode.ToString () + "' as one of the values for the dnr:usingGraph property points to an Object which cannot be loaded as an object which implements the IGraph interface"); " is 309.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectObjectFactories,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Object Loaders failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:ObjectFactory but failed to load as an object which implements the IObjectFactory interface"); " is 253.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Parser specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:RdfParser but failed to load as an object which implements the required IRdfReader interface"); " is 259.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Parser specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:DatasetParser but failed to load as an object which implements the required IStoreReader interface"); " is 265.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Parser specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:SparqlResultsParser but failed to load as an object which implements the required ISparqlResultsReader interface"); " is 279.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Writer specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:RdfWriter but failed to load as an object which implements the required IRdfWriter interface"); " is 259.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Writer specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:DatasetWriter but failed to load as an object which implements the required IStoreWriter interface"); " is 265.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "				throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Writer specified by the Node '" + objNode.ToString () + "' is not associated with any MIME types"); " is 195.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,AutoDetectReadersAndWriters,The length of the statement  "			throw new DotNetRdfConfigurationException ("Auto-detection of Readers and Writers failed as the Node '" + objNode.ToString () + "' was stated to be rdf:type of dnr:SparqlResultsWriter but failed to load as an object which implements the required ISparqlResultsWriter interface"); " is 279.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,CheckCircularReference,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + a.ToString () + "' as one of the values for the " + property + " property is a circular reference to the Object we are attempting to load"); " is 238.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetConfigurationArray,The length of the statement  "	return g.GetTriplesWithSubjectPredicate (objNode' property).Select (t => t.Object).Where (n => n.NodeType == NodeType.Literal).Select (n => ((ILiteralNode)n).Value).ToArray (); " is 176.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetUsernameAndPassword,The length of the statement  "	INode propUser = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUser)' propPwd = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyPassword); " is 196.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,GetUsernameAndPassword,The length of the statement  "			NetworkCredential credentials = (NetworkCredential)ConfigurationLoader.LoadObject (g' credObj' typeof(NetworkCredential)); " is 122.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' as a null target type was provided - this may be due to a failure to specify a fully qualified type name with the dnr:type property for this object"); " is 273.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load an Object as the Object Node was not a URI/Blank Node as required"); " is 127.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' as we have already started trying to load this Object which indicates that your Configuration Graph contains a circular reference"); " is 255.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' as previous attempt(s) to load the Object failed.  Call ClearCache() before attempting loading if you wish to retry loading"); " is 249.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' as an error occurred in the Object Loader which attempted to load it"' ex); " is 198.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' as an instance of type '" + targetType.ToString () + "' since no Object Loaders are able to load this type"); " is 232.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "	String typeName = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' "dnr:type")); " is 135.
Long Statement,VDS.RDF.Configuration,ConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ConfigurationLoader.cs,LoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Object identified by the Node '" + objNode.ToString () + "' since there is no dnr:type property associated with it"); " is 180.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "	INode propServer = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyServer)' propDb = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDatabase)' propStore = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyStore)' propAsync = ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAsync); " is 391.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String catalog = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyCatalog)); " is 159.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String file = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromFile)); " is 157.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String account = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyCatalog)); " is 159.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		bool enableUpdates = ConfigurationLoader.GetConfigurationBoolean (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEnableUpdates)' true); " is 176.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset)); " is 164.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Manager identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface"); " is 290.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore)); " is 154.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "					throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Manager identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface"); " is 297.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String queryService = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyQueryPath)); " is 166.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String updateService = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUpdatePath)); " is 168.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)); " is 158.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Read-Only Connector identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object which cannot be loaded as an object which implements the required IGenericIOManager interface"); " is 307.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager)); " is 158.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			throw new DotNetRdfConfigurationException ("Unable to load the Queryable Read-Only Connector identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object which cannot be loaded as an object which implements the required IQueryableGenericIOManager interface"); " is 326.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		server = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpointUri)); " is 155.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String loadModeRaw = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyLoadMode)); " is 164.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the SparqlConnector identified by the Node '" + objNode.ToString () + "' as the value given for the property dnr:loadMode is not valid"); " is 196.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			INode endpointObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint)); " is 161.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load the SparqlConnector identified by the Node '" + objNode.ToString () + "' as the value given for the property dnr:endpoint points to an Object which cannot be loaded as an object which is of the type SparqlRemoteEndpoint"); " is 281.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			IEnumerable<Uri> defGraphs = from def in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDefaultGraphUri)) " is 188.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "			IEnumerable<Uri> namedGraphs = from named in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyNamedGraphUri)) " is 190.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "				manager = new SparqlConnector (new SparqlRemoteEndpoint (UriFactory.Create (server)' defGraphs' namedGraphs)' loadMode); " is 120.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		String mode = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyLoadMode)); " is 157.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "		INode proxyNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyProxy)); " is 156.
Long Statement,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The length of the statement  "				throw new DotNetRdfConfigurationException ("Unable to load Generic Manager identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:proxy property pointed to an Object which could not be loaded as an object of the required type WebProxy"); " is 266.
Long Statement,VDS.RDF.Ontology,Ontology,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\Ontology.cs,RemoveBackwardsCompatibleWith,The length of the statement  "	return this.RemoveResourceProperty (OntologyHelper.PropertyBackwardCompatibleWith' resource.CopyNode (this._graph)' true); " is 122.
Long Statement,VDS.RDF.Ontology,OntologyClass,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyClass.cs,ClearSubClasses,The length of the statement  "	this._graph.Retract (this._graph.GetTriplesWithPredicateObject (this._graph.CreateUriNode (UriFactory.Create (OntologyHelper.PropertySubClassOf))' this._resource)); " is 164.
Long Statement,VDS.RDF.Ontology,OntologyClass,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyClass.cs,ClearSuperClasses,The length of the statement  "	this._graph.Retract (this._graph.GetTriplesWithSubjectPredicate (this._resource' this._graph.CreateUriNode (UriFactory.Create (OntologyHelper.PropertySubClassOf)))); " is 165.
Long Statement,VDS.RDF.Ontology,OntologyProperty,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyProperty.cs,ClearSubProperties,The length of the statement  "	this._graph.Retract (this._graph.GetTriplesWithPredicateObject (this._graph.CreateUriNode (UriFactory.Create (OntologyHelper.PropertySubPropertyOf))' this._resource)); " is 167.
Long Statement,VDS.RDF.Ontology,OntologyProperty,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyProperty.cs,ClearSuperProperties,The length of the statement  "	this._graph.Retract (this._graph.GetTriplesWithSubjectPredicate (this._resource' this._graph.CreateUriNode (UriFactory.Create (OntologyHelper.PropertySubPropertyOf)))); " is 168.
Long Statement,VDS.RDF.Ontology,OntologyResource,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyResource.cs,ClearLiteralProperty,The length of the statement  "			this._graph.Retract (this._graph.GetTriplesWithSubjectPredicate (this._resource' this._graph.CreateUriNode (UriFactory.Create (propertyUri)))); " is 143.
Long Statement,VDS.RDF.Ontology,OntologyResource,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyResource.cs,ClearResourceProperty,The length of the statement  "			this._graph.Retract (this._graph.GetTriplesWithSubjectPredicate (this._resource' this._graph.CreateUriNode (UriFactory.Create (propertyUri)))); " is 143.
Long Statement,VDS.RDF.Ontology,OntologyResource,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Ontology\OntologyResource.cs,RemoveVersionInfo,The length of the statement  "	return this.RemoveLiteralProperty (OntologyHelper.PropertyVersionInfo' (ILiteralNode)info.CopyNode (this._graph)' true); " is 120.
Long Statement,VDS.RDF.Parsing,BaseGZipParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\BaseGZipParser.cs,Load,The length of the statement  "	this.Load (handler' new StreamReader (new GZipStream (new FileStream (filename' FileMode.Open' FileAccess.Read)' CompressionMode.Decompress))); " is 143.
Long Statement,VDS.RDF.Parsing,BaseGZipResultsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\BaseGZipResultsParser.cs,Load,The length of the statement  "	this.Load (handler' new StreamReader (new GZipStream (new FileStream (filename' FileMode.Open' FileAccess.Read)' CompressionMode.Decompress))); " is 143.
Long Statement,VDS.RDF.Parsing,FolderStoreReader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FolderStoreReader.cs,Load,The length of the statement  "		RdfThreadedParsingException parsingEx = new RdfThreadedParsingException ("One/more errors occurred while parsing RDF from a Folder Store using a multi-threaded parsing process"); " is 178.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseGraphObject,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' end of the JSON Graph Object was expected"' startPos); " is 153.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseGraphObject,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' start of the JSON Graph Object was expected"' startPos); " is 155.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseTriples,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a JSON Property Name to represent the Subject of a Triple"' startPos); " is 178.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParsePredicateObjectList,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Name which represents a Predicate"' startPos); " is 165.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParsePredicateObjectList,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a JSON Object to represent a Predicate Object List"' startPos); " is 184.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObjectList,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a JSON Array to represent an Object List"' startPos); " is 174.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "						throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Object Node"' startPos); " is 188.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "							throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified"' startPos); " is 149.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "							throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified"' startPos); " is 149.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "						throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties"' startPos); " is 166.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Name describing one of the properties of an Object Node"' startPos); " is 187.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "				throw Error (context' "Cannot parse an Object Node from the JSON where no 'type' property was specified in the JSON Object representing the Node"' startPos); " is 157.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "				throw Error (context' "Cannot parse an Object Node from the JSON where no 'value' property was specified in the JSON Object representing the Node"' startPos); " is 158.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,ParseObject,The length of the statement  "				throw Error (context' "Cannot parse an Object Node from the JSON where the 'type' property is not set to one of the permitted values 'uri'' 'bnode' or 'literal' in the JSON Object representing the Node"' startPos); " is 214.
Long Statement,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,Error,The length of the statement  "	error.Append ("[Line " + info.StartLine + " Column " + info.StartPosition + " to Line " + info.EndLine + " Column " + info.EndPosition + "] "); " is 143.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResultSetObject,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' end of the JSON Result Set Object was expected"); " is 148.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResultSetObject,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' start of the JSON Result Set Object was expected"); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeader,The length of the statement  "				throw Error (context' "Unexpected Property Name '" + propName + "' encountered' expected the 'head' property of the JSON Result Set Object"); " is 141.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeader,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' the 'head' property of the JSON Result Set Object was expected"); " is 164.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeader,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the Head property of the JSON Result Set Object"); " is 126.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeaderObject,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' end of the Header Object of the JSON Result Set was expected"); " is 162.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeaderProperties,The length of the statement  "						throw Error (context' "Unexpected Property Name 'vars' encountered' a 'vars' property has already been seen in the Header Object of the JSON Result Set"); " is 154.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeaderProperties,The length of the statement  "					throw Error (context' "Unexpected Property Name '" + propName + "' encountered' expected a 'link' or 'vars' property of the Header Object of the JSON Result Set"); " is 163.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeaderProperties,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Name for a property of the Header Object of the JSON Result Set"); " is 185.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseHeaderProperties,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the properties of the Header Object of the JSON Result Set"); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseVariables,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a String giving the name of a Variable for the Result Set"); " is 168.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseVariables,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the Start of an Array giving the list of Variables for the 'vars' property of the Header Object of the JSON Result Set"); " is 229.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseVariables,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the 'vars' property of the Header Object of the JSON Result Set"); " is 142.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseLink,The length of the statement  "				throw new RdfParseException ("Unexpected End of Input while trying to parse the 'link' property of the Header Object of the JSON Result Set"); " is 142.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseLink,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the 'link' property of the Header Object of the JSON Result Set"); " is 142.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBody,The length of the statement  "				throw Error (context' "Unexpected Property Name '" + propName + "' encountered' expected the 'results' or 'boolean' property of the JSON Result Set Object"); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBody,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' the 'results' or 'boolean' property of the JSON Result Set Object was expected"); " is 180.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "							throw Error (context' "Deprecated Property '" + propName + "' used incorrectly' only a Boolean may be given for this property and this property should no longer be used according to the W3C Specification"); " is 206.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "							throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the 'bindings' property for the Results Object"); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "						throw Error (context' "Unexpected Property Name '" + propName + "' encountered' expected the 'bindings' property of the Results Object"); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of an Array for the 'bindings' property of the Results Object"); " is 182.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the 'bindings' property for the Results Object"); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the end of the Results Object"); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of the Results Object"); " is 142.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseResults,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the 'results' property of the JSON Result Set Object"); " is 131.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBindings,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Binding Object"); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBinding,The length of the statement  "				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Name giving the Binding for a Variable for this Result"); " is 176.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "					throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Variable Binding"); " is 183.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "						throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified"); " is 139.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "						throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified"); " is 139.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "					throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties"); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "				throw new RdfParseException ("Cannot parse a Node from the JSON where no 'type' property was specified in the JSON Object representing the Node"); " is 146.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "				throw new RdfParseException ("Cannot parse a Node from the JSON where no 'value' property was specified in the JSON Object representing the Node"); " is 147.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "				throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node"); " is 253.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a Binding Object attempts to bind a value to the variable '" + var + "' which is not defined in the Header Object in the value for the 'vars' property!"); " is 226.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Bound Variable Object"); " is 147.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoolean,The length of the statement  "			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Boolean value for the 'boolean' property of the JSON Result Set"); " is 176.
Long Statement,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoolean,The length of the statement  "		throw new RdfParseException ("Unexpected End of Input while trying to parse the 'boolean' property of the JSON Result Set Object"); " is 131.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set as it was not possible to read a document element from the input"); " is 133.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set as it was not possible to read a document element from the input"); " is 133.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set from the provided XML since the Document Element is not a <sparql> element!"); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "						throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <sparql> element has an incorrect Namespace!"); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <sparql> element fails to specify the SPARQL Namespace!"); " is 134.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the first Child Node of the <sparql> element is not the required <head> element!"); " is 155.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "						throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <variable> element has too few/many attributes' only a 'name' attribute should be present!"); " is 167.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "					throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <head> contains an unexpected element <" + context.Input.Name + ">!"); " is 146.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set as reached the end of the input before the closing </head> element was found"); " is 145.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set as could not read a <results> element from the input"); " is 121.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "						throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <results> element contains an unexpected element <" + context.Input.Name + ">!"); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "							throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <result> element contains an unexpected element <" + context.Input.Name + ">!"); " is 154.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "							throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element has too few/many attributes' only a 'name' attribute should be present!"); " is 166.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "							throw new RdfParseException ("Unable to Parse a SPARQL Result Set as reached the end of input when the contents of a <binding> element was expected"); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "							throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element attempts to bind a value to the variable '" + var + "' which is not defined in the <head> by a <variable> element!"); " is 209.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "						throw new RdfParseException ("Unable to Parse a SPARQL Result Set as reached the end of the input before a closing </result> element was found"); " is 145.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set as reached the end of the input before the closing </results> element was found"); " is 148.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <boolean> element is specified but the <head> contained one/more <variable> elements which is not permitted!"); " is 187.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the <boolean> element contained a value that could not be understood as a Boolean value!"); " is 163.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Parse,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since the second Child Node of the <sparql> element is not the required <results> or <boolean> element!"); " is 172.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The length of the statement  "				throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has an unknown attribute '" + context.Input.Name + "'!"); " is 149.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The length of the statement  "			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has too many Attributes' only 1 of 'xml:lang' or 'datatype' may be specified!"); " is 172.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The length of the statement  "		//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones) " is 214.
Long Statement,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The length of the statement  "		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!"); " is 155.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,Parse,The length of the statement  "		else if (data.Contains ("\"value\"") && data.Contains ("\"type\"") && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")) { " is 161.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,Parse,The length of the statement  "		throw new RdfParseException ("StringParser failed to parse the RDF string correctly' StringParser auto-detection guessed '" + format + "' but this failed to parse.  RDF string may be malformed or StringParser may have guessed incorrectly"' parseEx); " is 249.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,ParseDataset,The length of the statement  "		throw new RdfParseException ("StringParser failed to parse the RDF Dataset string correctly' StringParser auto-detection guessed '" + format + "' but this failed to parse.  RDF Dataset string may be malformed or StringParser may have guessed incorrectly"' parseEx); " is 265.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,ParseResultSet,The length of the statement  "		else if (data.Contains ("\"head\"") && (data.Contains ("\"results\"") || data.Contains ("\"boolean\"")) && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")) { " is 198.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,ParseResultSet,The length of the statement  "			throw new RdfParserSelectionException ("StringParser is unable to detect the SPARQL Results Format as the given String does not appear to be SPARQL Results in either XML or JSON format"); " is 187.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,ParseResultSet,The length of the statement  "		throw new RdfParserSelectionException ("StringParser failed to parse the SPARQL Results string correctly' StringParser auto-detection guessed '" + format + "' but this failed to parse.  SPARQL Results string may be malformed or StringParser may have guessed incorrectly"' parseEx); " is 281.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,GetParser,The length of the statement  "	else if (data.Contains ("\"value\"") && data.Contains ("\"type\"") && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")) { " is 161.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,GetResultSetParser,The length of the statement  "	else if (data.Contains ("\"head\"") && (data.Contains ("\"results\"") || data.Contains ("\"boolean\"")) && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")) { " is 198.
Long Statement,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,GetResultSetParser,The length of the statement  "		throw new RdfParserSelectionException ("StringParser is unable to detect the SPARQL Results Format as the given String does not appear to be SPARQL Results in either XML or JSON format"); " is 187.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Load,The length of the statement  "			this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + ((StreamReader)input).CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 214.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Load,The length of the statement  "			                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + ((StreamReader)input).CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 215.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Load,The length of the statement  "			TriGParserContext context = new TriGParserContext (handler' new TriGTokeniser (input)' TokenQueueMode.SynchronousBufferDuringParsing' false' this._tracetokeniser); " is 163.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Parse,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + first.GetType ().ToString () + "' encountered' expected a BOF Token"' first); " is 126.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,The length of the statement  "						throw ParserHelper.Error ("Unexpected Token '" + dot.GetType ().ToString () + "' encountered' expected a Dot (Line Terminator) Token to terminate a Prefix Directive"' dot); " is 172.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,The length of the statement  "					throw ParserHelper.Error ("The URI '" + uri.Value + "' given for the prefix '" + prefix.Value + "' is not a valid Absolute URI"' uri); " is 134.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + prefix.GetType ().ToString () + "' encountered' expected a URI Token after a Prefix Token"' uri); " is 146.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + prefix.GetType ().ToString () + "' encountered' expected a Prefix Token after a Prefix Directive Token"' prefix); " is 162.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseDirective,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + directive.GetType ().ToString () + "' encountered' expected a Base/Prefix Directive Token"' directive); " is 152.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseGraph,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Curly Bracket to start a Graph"' next); " is 150.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + subj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Subject of a Triple"' subj); " is 162.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + dot.GetType ().ToString () + "' encountered' expected a Dot (Line Terminator) Token to terminate Triples"' dot); " is 161.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + pred.GetType ().ToString () + "' encountered before a Predicate Object list was parsed"' pred); " is 144.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + pred.GetType ().ToString () + "' encountered before a Predicate Object list of a Blank Node Collection was parsed"' pred); " is 171.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParsePredicateObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + pred.GetType ().ToString () + "' encountered' expected a URI/QName as the Predicate of a Triple"' pred); " is 153.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParsePredicateObjectList,The length of the statement  "		if (context.Tokens.LastTokenType == Token.DOT || context.Tokens.LastTokenType == Token.RIGHTCURLYBRACKET || context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) { " is 163.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName Token to specify a Data Type after a ^^ Token"' next); " is 170.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list of a Blank Node Collection was parsed"' obj); " is 160.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list was parsed"' obj); " is 133.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Object of a Triple"' obj); " is 159.
Long Statement,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseCollection,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName/Literal/Blank Node as an item in a Collection"' next); " is 170.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsValidPlainLiteral,The length of the statement  "	StringComparison comparison = (syntax == TurtleSyntax.Original ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase); " is 128.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsValidPlainLiteral,The length of the statement  "	StringComparison comparison = (syntax == TurtleSyntax.Original ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase); " is 128.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsValidPlainLiteral,The length of the statement  "	if ((value.Equals ("true"' comparison) || value.Equals ("false"' comparison)) && dt.ToSafeString ().Equals (XmlSpecsHelper.XmlSchemaDataTypeBoolean)) { " is 151.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,InferPlainLiteralType,The length of the statement  "	StringComparison comparison = (syntax == TurtleSyntax.Original ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase); " is 128.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,InferPlainLiteralType,The length of the statement  "		throw new RdfParseException ("Unable to automatically Infer a Type for this PlainLiteralToken.  Plain Literals may only be Booleans' Integers' Decimals or Doubles"); " is 165.
Long Statement,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsPNCharsBase,The length of the statement  "	else if ((c >= 0x00c0 && c <= 0x00d6) || (c >= 0x00d8 && c <= 0x00f6) || (c >= 0x00f8 && c <= 0x02ff) || (c >= 0x0370 && c <= 0x037d) || (c >= 0x200c && c <= 0x200d) || (c >= 0x2070 && c <= 0x218f) || (c >= 0x2c00 && c <= 0x2fef) || (c >= 0x3001 && c <= 0xd7ff) || (c >= 0xf900 && c <= 0xfdcf) || (c >= 0xfdf0 && c <= 0xfffd)/*||" is 329.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,Parse,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,Parse,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "		SparqlQueryParserContext context = new SparqlQueryParserContext (new SparqlTokeniser (input' this._syntax)' this._queuemode' false' this._tracetokeniser); " is 154.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "			if (context.Query.QueryType != SparqlQueryType.Construct || (context.Query.QueryType == SparqlQueryType.Construct && context.Query.RootGraphPattern == null)) { " is 159.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "			if (SparqlSpecsHelper.IsSelectQuery (context.Query.QueryType) && (context.Query.IsAggregate && context.Query.GroupBy == null && context.Query.Variables.Any (v => v.IsResultVariable && !v.IsAggregate))) { " is 203.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "				throw new RdfParseException ("The Select Query is invalid since it contains both Aggregates and Variables in the SELECT Clause but it does not contain a GROUP BY clause"); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token encountered' a valid ASK query has been parsed but additional invalid tokens are present after the Graph pattern"' temp); " is 165.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token encountered - expected a BASE/PREFIX directive or a Query Keyword to start a Query"' temp); " is 135.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "					throw new RdfParseException ("Cannot assign the results of an Aggregate/Project Expression to the variable " + var.ToString () + " as this Variable is already Projected to earlier in the SELECT"); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "						//if (!var.Projection.Variables.All(v => context.Query.GroupBy.ProjectableVariables.Contains(v) || projectedSoFar.Contains(v))) " is 127.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "							throw new RdfParseException ("Your SELECT uses the Project Expression " + var.Projection.ToString () + " which uses one/more Variables which are either not projectable from the GROUP BY or not projected earlier in the SELECT.  All Variables used must be projectable from the GROUP BY' projected earlier in the SELECT or within an aggregate"); " is 342.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The length of the statement  "							throw new RdfParseException ("Your SELECT/DESCRIBE query tries to project the variable " + var.ToString () + " but this Variable is not Grouped By"); " is 149.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause"' next); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause"' next); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Select All and specify an Aggregate in the SELECT Clause"' next); " is 126.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an AS Keyword after a Projection Expression"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable as an alias after an AS Keyword"' next); " is 155.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Expected a Left Bracket after a URI/QName in Select Variables for the arguments of a function call"' context.Tokens.Peek ()); " is 152.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an AS Keyword after a Projection Expression"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable as an alias after an AS Keyword"' next); " is 155.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Select All and specify a Projection Expression in the SELECT Clause"' next); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an AS Keyword after a Projection Expression"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable as an alias after an AS Keyword"' next); " is 155.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Right Bracket to terminate the Projection Expression after the alias"' next); " is 183.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The length of the statement  "				throw ParserHelper.Error ("The SELECT Keyword must be followed by a list of one/more variables or a * to specify all variables"' next); " is 135.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,The length of the statement  "		throw ParserHelper.Error ("Cannot parse an Aggregate since '" + agg.GetType ().ToString () + "' is not an Aggregate Keyword Token"' agg); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,The length of the statement  "		throw new RdfParseException ("Unexpected expression was parsed when an Aggregate was expected: " + aggExpr.ToString ()); " is 120.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "'' expected a Variable Token after an AS Keyword to act as an aliased name for the Aggregate"' next); " is 181.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an AS keyword after an Aggregate"' next); " is 145.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseAggregate,The length of the statement  "		this.RaiseWarning ("No AS ?variable given for the Aggregate " + aggregate.ToString () + " so assigning alias '" + alias + "'"); " is 127.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseDescribeVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause"' next); " is 139.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseDescribeVariables,The length of the statement  "				throw ParserHelper.Error ("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause"' next); " is 139.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseDescribeVariables,The length of the statement  "				throw ParserHelper.Error ("The DESCRIBE keyword must be followed by a list of one/more variables/IRI References or a * to specify all variables"' next); " is 152.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + temp.GetType ().Name + " encountered' expected the WHERE of a Short Form Construct to come after the FROM/FROM NAMED clauses of a Short Form Construct"' temp); " is 208.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Curly Bracket to start a CONSTRUCT Template"' next); " is 163.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,The length of the statement  "	else if (constructTemplate.IsOptional || constructTemplate.IsMinus || constructTemplate.IsExists || constructTemplate.IsNotExists || constructTemplate.IsService || constructTemplate.IsSubQuery) { " is 195.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,The length of the statement  "		throw new RdfParseException ("A Construct Template may only be composed of Triple Patterns - Assignments' Property Paths' Sub-queries etc. are not permitted"); " is 159.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFrom,The length of the statement  "				throw ParserHelper.Error ("Expected a QName/URI Token to occur after a FROM NAMED Keyword to specify a Named Graph URI"' next); " is 127.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFrom,The length of the statement  "			throw ParserHelper.Error ("Expected a QName/URI Token to occur after a FROM Keyword to specify a Default Graph URI"' next); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGraphPattern,The length of the statement  "						throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended"); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The length of the statement  "				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next); " is 151.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The length of the statement  "			throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended"); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The length of the statement  "			throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next); " is 120.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "			else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) { " is 127.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "					throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next); " is 151.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "					throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit); " is 130.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next); " is 202.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next); " is 200.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next); " is 154.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next); " is 152.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next); " is 158.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "			if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) { " is 194.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next); " is 152.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "			if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) { " is 250.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) { " is 253.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "					throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next); " is 152.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next); " is 150.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next); " is 128.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "			context.LocalTokens.Push (new UriToken ("<" + NamespaceMapper.RDF + "nil>"' next.StartLine' next.StartPosition' next.EndPosition)); " is 131.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "			blank = new BlankNodeWithIDToken ("_:sparql-autos" + context.BlankNodeID' next.StartLine' next.StartPosition' next.EndPosition); " is 128.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' next))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfRest)' this.TryCreatePatternItem (context' blank2))); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' next))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					BlankNodeWithIDToken anon = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 138.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' anon))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfRest)' this.TryCreatePatternItem (context' blank2))); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' anon))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					BlankNodeWithIDToken anon = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 138.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' anon))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfRest)' this.TryCreatePatternItem (context' blank2))); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "						p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' anon))); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "				BlankNodeWithIDToken innerCollection = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 149.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' innerCollection))); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' next.StartLine' next.StartPosition' next.EndPosition); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfRest)' this.TryCreatePatternItem (context' blank2))); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "					p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfFirst)' this.TryCreatePatternItem (context' innerCollection))); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "				p.AddTriplePattern (new TriplePattern (this.TryCreatePatternItem (context' blank)' new NodeMatchPattern (rdfRest)' new NodeMatchPattern (rdfNil))); " is 147.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseCollection,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFilterClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a FILTER Clause"' next); " is 140.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseFilterBuiltInCall,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Built-in Function call"' next); " is 149.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGraphClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + graphspec.GetType ().ToString () + "' encountered' expected a URI/QName/Variable Token to specify the active Graph for a GRAPH Clause"' graphspec); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseExpression,The length of the statement  "				throw ParserHelper.Error ("Unexpected DISTINCT Keyword Token encountered' DISTINCT modifier keyword may only occur as the first argument to an aggregate function"' next); " is 170.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseOrderByClause,The length of the statement  "				throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Bracket Token to start a Bracketted Expression after an ASC/DESC Token"); " is 187.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseOrderByClause,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToSafeString () + "' encountered' aggregates are not permitted in an ORDER BY in SPARQL 1.0"' next); " is 165.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseOrderByClause,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a valid ORDER BY clause term"' next); " is 141.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGroupByClause,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a valid GROUP BY clause term"' next); " is 141.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGroupByClause,The length of the statement  "						throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a ) to terminate the AS clause in a bracketted expression"' next); " is 170.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseGroupByClause,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable Token after an AS token in a GROUP BY clause to specify the value to assign the GROUPed value to"' next); " is 220.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseHavingClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Bracket to start a bracketted expression in a HAVING Clause"' next); " is 179.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "							throw ParserHelper.Error ("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause"' next); " is 146.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "						throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Plain Literal containing an Integer value as part of the OFFSET Clause"' next); " is 185.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "				throw ParserHelper.Error ("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause"' next); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Plain Literal containing an Integer value as part of the LIMIT Clause"' next); " is 184.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "							throw ParserHelper.Error ("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause"' next); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "						throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Plain Literal containing an Integer value as part of the LIMIT Clause"' next); " is 184.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "				throw ParserHelper.Error ("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause"' next); " is 146.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Plain Literal containing an Integer value as part of the OFFSET Clause"' next); " is 185.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLimitOffsetClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Limit/Offset Token to start a Limit Offset Clause"' next); " is 164.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Token which was valid as the start of an expression for the right hand side of a LET assignment"' next); " is 210.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Right Bracket to terminate the LET assignment"' next); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an Assignment operator as part of a LET assignment"' next); " is 163.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable as the first item in a LET assignment"' next); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseLetAssignment,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Bracket to start a LET assignment after a LET Keyword"' next); " is 173.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a ( to start a BIND assignment after a BIND keyword"' next); " is 164.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "		throw ParserHelper.Error ("A BIND assignment did not end with an AS ?var as expected' BIND assignment must be of the general form BIND(expr AS ?var)"' next); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "			throw ParserHelper.Error ("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use in the query"' next); " is 167.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "			throw ParserHelper.Error ("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use earlier in the Graph pattern"' next); " is 183.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a ) to terminate a BIND assignment"' next); " is 147.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindAssignment,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Variable after the AS in a BIND assignment"' next); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSubquery,The length of the statement  "			throw ParserHelper.Error ("Unexpected End of File encountered while trying to gather Tokens to parse a Sub-Query from"' next); " is 126.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseServiceClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + specifier.GetType ().ToString () + "' encountered' expected a URI/Variable after a SERVICE keyword"' specifier); " is 161.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected either one/more Variable Tokens or the empty set { } after a BINDINGS keyword"' next); " is 190.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "							throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to specify the datatype for a Literal"' next); " is 167.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "					throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Token for a URI/Literal or an UNDEF keyword as part of a tuple in a BINDINGS clause"' next); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "				throw new RdfParseException ("Invalid tuple in the BINDINGS clause' each Binding should contain " + vars.Count + " values but got a tuple containing " + values.Count + " values"); " is 179.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Right Curly Bracket to terminate the BINDINGS clause"' next); " is 167.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseBindingsClause,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Curly Bracket after the list of variables as part of a BINDINGS clause"' next); " is 190.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "		//We know it must be one of the inferrable types or the Parser would have failed at the Tokenisation stage for the Literal " is 122.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "			return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble))); " is 122.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "			return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger))); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "			return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal))); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "			return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean))); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "			return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' this.ResolveQName (context' litdt.DataType))); " is 124.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The length of the statement  "		throw ParserHelper.Error ("Unable to Convert a '" + t.GetType ().ToString () + "' to a Pattern Item in a Triple Pattern"' t); " is 125.
Long Statement,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,IsProjectableExpression,The length of the statement  "		return expr.Variables.All (v => context.Query.GroupBy.ProjectableVariables.Contains (v) || projectedSoFar.Contains (v)); " is 120.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Load,The length of the statement  "            this.RaiseWarning("NTriples files are ASCII format but Silverlight does not support ASCII - will open as UTF-8 instead which may cause issues");" is 144.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as ASCII but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Load,The length of the statement  "		TokenisingParserContext context = new TokenisingParserContext (handler' new NTriplesTokeniser (input)' this._queuemode' this._traceparsing' this._tracetokeniser); " is 162.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Parse,The length of the statement  "			throw Error ("Unexpected Token '" + start.GetType ().ToString () + "' encountered' expected a Beginning of File Token"' start); " is 127.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseSubject,The length of the statement  "		throw Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' expected a Blank Node or URI for the Subject of a Triple"' subjToken); " is 157.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParsePredicate,The length of the statement  "		throw Error ("Unexpected Token '" + predToken.GetType ().ToString () + "' encountered' expected a URI for the Predicate of a Triple"' predToken); " is 145.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The length of the statement  "			return context.Handler.CreateLiteralNode (objToken.Value' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Namespaces' context.BaseUri))); " is 147.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The length of the statement  "		throw Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered' expected a Blank Node' Literal or URI for the Object of a Triple"' objToken); " is 163.
Long Statement,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseLineTerminator,The length of the statement  "		throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Dot Line Terminator to terminate a Triple"' next); " is 143.
Long Statement,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The length of the statement  "			IRdfHandler cacheHandler = _cache.ToCache (u' Tools.StripUriFragment (httpResponse.ResponseUri)' httpResponse.Headers ["ETag"]); " is 128.
Long Statement,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid"' uriEx); " is 127.
Long Statement,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The length of the statement  "					RaiseStoreWarning ("Unable to select a RDF Dataset parser based on Content-Type: " + httpResponse.ContentType + " - seeing if the content is an RDF Graph instead"); " is 164.
Long Statement,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The length of the statement  "		throw new RdfException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid' see inner exception for details"' uriEx); " is 155.
Long Statement,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The length of the statement  "		throw new WebException ("A HTTP Error occurred resolving the URI '" + u.ToString () + "'' see innner exception for details"' webEx); " is 132.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to Parse this RDF/XML since System.Xml was unable to parse the document' see Inner Exception for details"' new PositionInfo (xmlEx.LineNumber' xmlEx.LinePosition)' xmlEx); " is 208.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to Parse this RDF/XML due to an IO Exception' see Inner Exception for details"' ioEx); " is 123.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to Parse this RDF/XML since System.Xml was unable to parse the document into a DOM Tree"' xmlEx); " is 134.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionDoc,The length of the statement  "	if (localName.Equals ("RDF") && ((context.Namespaces.HasNamespace (prefix) && context.Namespaces.GetNamespaceUri (prefix).ToString ().Equals (NamespaceMapper.RDF)) || root.DocumentElement.NamespaceAttributes.Any (ns => ns.Prefix.Equals (prefix) && ns.Uri.Equals (NamespaceMapper.RDF)))) { " is 288.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionRDF,The length of the statement  "	if (localName.Equals ("RDF") || ((context.Namespaces.HasNamespace (prefix) && context.Namespaces.GetNamespaceUri (prefix).ToString ().Equals (NamespaceMapper.RDF)) || element.NamespaceAttributes.Any (ns => ns.Prefix.Equals (prefix) && ns.Uri.Equals (NamespaceMapper.RDF)))) { " is 275.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionRDF,The length of the statement  "		throw ParserHelper.Error ("Root Node should not contain any attributes other than XML Namespace Declarations"' "RDF"' element); " is 127.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionRDF,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' an EndElementEvent was expected"' "RDF"' element); " is 133.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "		throw ParserHelper.Error ("Expected an ElementEvent but encountered a '" + first.GetType ().ToString () + "'"' "Node Element"' first); " is 134.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "		throw ParserHelper.Error ("A Node Element was encountered with an invalid URI '" + element.QName + "' \nCore Syntax Terms' Old Syntax Terms and rdf:li cannot be used as Node Element URIs"' "Node Element"' element); " is 214.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "				throw ParserHelper.Error ("The value '" + attr.Value + "' for rdf:nodeID is not valid' RDF Node IDs can only be valid Names as defined by the W3C XML Specification"' "Node Element"' attr); " is 188.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "			throw ParserHelper.Error ("A Node Element can only have 1 of the following attributes: rdf:id' rdf:nodeID' rdf:about"' "Node Element"' element); " is 144.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "				pred = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (attr.QName' context.Namespaces' context.BaseUri))); " is 128.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionNodeElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + last.GetType ().ToString () + "'' expected an EndElement Event"' "NodeElement"' last); " is 135.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionPropertyElement,The length of the statement  "		throw ParserHelper.Error ("Expected an ElementEvent but encountered a '" + first.GetType ().ToString () + "'"' "PropertyElement"' first); " is 137.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionPropertyElement,The length of the statement  "		throw ParserHelper.Error ("A Property Element was encountered with an invalid URI '" + element.QName + "'\nCore Syntax Terms' Old Syntax Terms and rdf:Description cannot be used as Property Element URIs"' "PropertyElement"' element); " is 233.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionPropertyElement,The length of the statement  "			throw ParserHelper.Error ("An Element which should be Parsed with the Default Parsing Rules was encountered without a valid subsequent Event - Parser cannot proceed!"' "Property Element"' element); " is 197.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionPropertyElement,The length of the statement  "		throw ParserHelper.Error ("An Element without a known Parse Type was encountered Or the Parser was unable to determine what to do based on the subsequent event - Parser cannot proceed!"' "Node Element"' element); " is 212.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("A Resource Property Element contains too many Attributes' only rdf:ID is permitted"' element); " is 121.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,The length of the statement  "			throw ParserHelper.Error ("A Resource Property Element was encountered with a single attribute which was not rdf:ID' only rdf:ID is permitted"' element); " is 153.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' expected an ElementEvent as the first Event in a Resource Property Elements Event list"' next); " is 178.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + last.GetType ().ToString () + "'' expected an EndElement Event"' last); " is 120.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Parent Event '" + parent.GetType ().ToString () + "'' expected an ElementEvent"' parent); " is 127.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionLiteralPropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected event '" + middle.GetType ().ToString () + "'' expected a TextEvent in a Literal Property Element"' middle); " is 146.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionLiteralPropertyElement,The length of the statement  "		throw ParserHelper.Error ("A Literal Property Element contains too many attributes' only rdf:ID and rdf:datatype are permitted"' element); " is 138.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionLiteralPropertyElement,The length of the statement  "				throw ParserHelper.Error ("A Literal Property Element contains an unexpected attribute' only rdf:ID and rdf:datatype are permitted"' element); " is 142.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,The length of the statement  "		throw ParserHelper.Error ("An Property Element with Parse Type 'Literal' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'"' "Parse Type Literal Property Element"' element); " is 255.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,The length of the statement  "				throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Literal'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'"' "Parse Type Literal Property Element"' element); " is 271.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + lit.GetType ().ToString () + "'' expected a TypedLiteralEvent after a Property Element with Parse Type 'Literal'"' "Parse Type Literal Property Element"' lit); " is 208.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' expected an EndElementEvent to terminate a Parse Type Literal Property Element!"' "Parse Type Literal Property Element"' next); " is 210.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("An Property Element with Parse Type 'Resource' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'"' "Parse Type Resource Property Element"' element); " is 258.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,The length of the statement  "				throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Resource'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'"' "Parse Type Resource Property Element"' element); " is 274.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' expected an ElementEvent or EndElementEvent after a Parse Type Resource Property Element!"' "Parse Type Resource Property Element"' next); " is 221.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' expected an EndElementEvent to terminate a Parse Type Resource Property Element!"' "Parse Type Resource Property Element"' next); " is 212.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The length of the statement  "		throw ParserHelper.Error ("An Property Element with Parse Type 'Collection' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'"' "Parse Type Collection Property Element"' element); " is 264.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The length of the statement  "				throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Collection'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'"' "Parse Type Collection Property Element"' element); " is 280.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The length of the statement  "		if (!context.Handler.HandleTriple (new Triple (b1' restPred' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil))))) " is 141.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The length of the statement  "		throw ParserHelper.Error ("Unexpected Event '" + next.GetType ().ToString () + "'' expected an EndElementEvent to terminate a Parse Type Collection Property Element!"' "Parse Type Collection Property Element"' next); " is 216.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "	if (element.Attributes.Count == 0 || (element.Attributes.Count == 1 && RdfXmlSpecsHelper.IsIDAttribute (element.Attributes [0]))) { " is 131.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "	else if (element.Attributes.Count > 0 && element.Attributes.Where (a => RdfXmlSpecsHelper.IsDataTypeAttribute (a)).Count () == 1) { " is 131.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "					throw ParserHelper.Error ("The value '" + a.Value + "' for rdf:nodeID is not valid' RDF Node IDs can only be valid Names as defined by the W3C XML Specification"' "Empty Property Element"' a); " is 192.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "				throw ParserHelper.Error ("A Property Element can only have 1 of the following attributes: rdf:nodeID or rdf:resource"' "Empty Property Element"' element); " is 155.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "					throw ParserHelper.Error ("Encountered a Property Attribute '" + a.QName + "' whose value was not correctly normalized in Unicode Normal Form C"' "Empty Property Element"' a); " is 175.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "					pred = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (a.QName' context.Namespaces' context.BaseUri))); " is 125.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "			else if (RdfXmlSpecsHelper.IsIDAttribute (a) || RdfXmlSpecsHelper.IsNodeIDAttribute (a) || RdfXmlSpecsHelper.IsResourceAttribute (a)) { " is 135.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionEmptyPropertyElement,The length of the statement  "				throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' encountered on a Property Element!  Only rdf:ID' rdf:resource' rdf:nodeID and Property Attributes are permitted on Property Elements"' "Empty Property Element"' element); " is 236.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,ApplyNamespaces,The length of the statement  "		if (!context.Namespaces.HasNamespace (ns.Prefix) || !context.Namespaces.GetNamespaceUri (ns.Prefix).ToString ().Equals (ns.Uri)) { " is 130.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Resolve,The length of the statement  "		IUriNode u = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (el.QName' context.Namespaces' context.BaseUri))); " is 132.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Reify,The length of the statement  "	if (!context.Handler.HandleTriple (new Triple (uriref' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfSubject))' subj))) " is 141.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Reify,The length of the statement  "	if (!context.Handler.HandleTriple (new Triple (uriref' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfPredicate))' pred))) " is 143.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Reify,The length of the statement  "	if (!context.Handler.HandleTriple (new Triple (uriref' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfObject))' obj))) " is 139.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Reify,The length of the statement  "	if (!context.Handler.HandleTriple (new Triple (uriref' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfType))' context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfStatement))))) " is 213.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,ValidateID,The length of the statement  "		throw new RdfParseException ("The value '" + id + "' for rdf:ID is not valid' RDF IDs can only be valid Names as defined by the W3C XML Specification"); " is 152.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,ValidateID,The length of the statement  "			throw new RdfParseException ("An rdf:ID must be unique to a Node within a File' the rdf:ID '" + id + "' has already been used for a Node in this RDF/XML File!"); " is 161.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,ProductionTracePartial,The length of the statement  "	Console.WriteLine (" on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty)); " is 175.
Long Statement,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,ProductionTrace,The length of the statement  "	Console.WriteLine ("Production '" + production + "' called on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty)); " is 213.
Long Statement,VDS.RDF.Parsing,XmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\XmlSpecsHelper.cs,IsNameStartChar,The length of the statement  "	else if ((c >= 0xC0 && c <= 0xD6) || (c >= 0xD8 && c <= 0xF6) || (c >= 0xF8 && c <= 0x2FF) || (c >= 0x370 && c <= 0x37D) || (c >= 0x37F && c <= 0x1FFF) || (c >= 0x200C && c <= 0x200D) || (c >= 0x2070 && c <= 0x218F) || (c >= 0x2C00 && c <= 0x2FEF) || (c >= 0x3001 && c <= 0xD7FF) || (c >= 0xF900 && c <= 0xFDCF) || (c >= 0xFDF0 && c <= 0xFFFD)) { " is 346.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The length of the statement  "		TokenisingResultParserContext context = new TokenisingResultParserContext (handler' new CsvTokeniser (BlockingTextReader.Create (input))); " is 138.
Long Statement,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseResultRow,The length of the statement  "			if (lexicalForm.StartsWith ("http://") || lexicalForm.StartsWith ("https://") || lexicalForm.StartsWith ("mailto:") || lexicalForm.StartsWith ("ftp://")) { " is 155.
Long Statement,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The length of the statement  "		TokenisingResultParserContext context = new TokenisingResultParserContext (handler' new TsvTokeniser (BlockingTextReader.Create (input))); " is 138.
Long Statement,VDS.RDF.Parsing,DataUriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\DataUriLoader.cs,Load,The length of the statement  "				throw new UriFormatException ("This data: URI appears to be malformed as encountered the parameter value '" + meta [i] + "' in the metadata section of the URI"); " is 161.
Long Statement,VDS.RDF.Parsing,DataUriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\DataUriLoader.cs,Load,The length of the statement  "			throw new UriFormatException ("This data: URI appears to be malformed as encountered the parameter value '" + metadata + "' in the metadata section of the URI"); " is 161.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,Load,The length of the statement  "				throw new RdfParseException ("The Embedded Resource '" + resourceName + "' cannot be loaded as the required assembly '" + assemblyName + "' could not be loaded"); " is 162.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to load the Embedded Resource '" + resource + "' as an unexpected error occurred"' ex); " is 124.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadGraphInternal,The length of the statement  "			throw new RdfParseException ("The Embedded Resource '" + resource + "' does not exist inside of " + asm.GetName ().Name); " is 121.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadGraphInternal,The length of the statement  "				MimeTypeDefinition def = MimeTypesHelper.GetDefinitions (MimeTypesHelper.GetMimeTypes (ext)).FirstOrDefault (d => d.CanParseRdf); " is 129.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,Load,The length of the statement  "			Assembly asm = (assemblyName.Equals (_currAsmName) ? Assembly.GetExecutingAssembly () : Assembly.Load (assemblyName)) as Assembly; " is 130.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,Load,The length of the statement  "				throw new RdfParseException ("The Embedded Resource '" + resourceName + "' cannot be loaded as the required assembly '" + assemblyName + "' could not be loaded.  Please ensure that the assembly name is correct and that is is referenced/accessible in your application."); " is 270.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,Load,The length of the statement  "		throw new RdfParseException ("Unable to load the Embedded Resource '" + resource + "' as an unexpected error occurred"' ex); " is 124.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadDatasetInternal,The length of the statement  "			throw new RdfParseException ("The Embedded Resource '" + resource + "' does not exist inside of " + asm.GetName ().Name); " is 121.
Long Statement,VDS.RDF.Parsing,EmbeddedResourceLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\EmbeddedResourceLoader.cs,LoadDatasetInternal,The length of the statement  "				MimeTypeDefinition def = MimeTypesHelper.GetDefinitions (MimeTypesHelper.GetMimeTypes (ext)).FirstOrDefault (d => d.CanParseRdfDatasets); " is 137.
Long Statement,VDS.RDF.Parsing,TermMappings,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IRdfAVocabulary.cs,ResolveTerm,The length of the statement  "		throw new RdfParseException ("The Term '" + term + "' cannot be resolved to a valid URI as it is not a term in this vocabularly nor is there a vocabulary URI defined"); " is 168.
Long Statement,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPath,The length of the statement  "	return IsIPathAbEmpty (value) || IsIPathAbsolute (value) || IsIPathNoScheme (value) || IsIPathRootless (value) || IsIPathEmpty (value); " is 135.
Long Statement,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsDecOctet,The length of the statement  "		return (value [0] == '1' || value [0] == '2') && (value [1] == '0' || value [1] == '1' || value [1] == '2' || value [1] == '3' || value [1] == '4' || value [1] == '5') && Char.IsDigit (value [2]); " is 196.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Load,The length of the statement  "		Notation3ParserContext context = new Notation3ParserContext (handler' new Notation3Tokeniser (input)' this._queueMode' this._traceParsing' this._traceTokeniser); " is 161.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Parse,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a BOF Token"' next); " is 124.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Parse,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' the 'a' Keyword is only valid as a Predicate in Notation 3"' next); " is 162.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + u.GetType ().ToString () + "' encountered' expected a URI after a Base Directive"' u); " is 135.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + ns.GetType ().ToString () + "' encountered' expected a URI after a Prefix Directive"' pre); " is 140.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + pre.GetType ().ToString () + "' encountered' expected a Prefix after a Prefix Directive"' pre); " is 144.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when a CustomKeywordDefinitionToken was expected"' next); " is 151.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + directive.GetType ().ToString () + "' encountered' expected a Base/Prefix/Keywords Directive after an @ symbol"' directive); " is 173.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseDirective,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + terminator.GetType ().ToString () + "' encountered' expected a Dot Line Terminator to terminate a Prefix/Base Directive"' terminator); " is 183.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseForAll,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName for a Universal Variable as part of a @forAll directive"' next); " is 180.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseForSome,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName for an Existential Variable as part of a @forSome directive"' next); " is 184.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseTriples,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' this Token is not valid as the subject of a Triple"' subjToken); " is 164.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "			Console.WriteLine ("Attempting to parse Predicate Object List from the Predicate Token '" + predToken.GetType ().ToString () + "'"); " is 132.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Left Curly Bracket encountered' Graph Literals are not valid as Predicates in Notation 3"' predToken); " is 140.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' predToken); " is 128.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "					//If Predicate is not null then we've seen at least one valid Triple and this is just the end of the Blank Node Predicate Object list " is 133.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "						throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Blank Node Predicate Object list' expected a valid Predicate"' predToken); " is 169.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Predicate Object list"' predToken); " is 130.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + predToken.GetType ().ToString () + "' encountered while trying to parse a Predicate Object list"' predToken); " is 158.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "			Console.WriteLine ("Attempting to parse an Object List from the Object Token '" + objToken.GetType ().ToString () + "'"); " is 121.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 134.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 132.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' objToken); " is 127.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "					throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken); " is 158.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken); " is 147.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 138.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken); " is 147.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "			if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.DOT && next.TokenType != Token.RIGHTCURLYBRACKET) { " is 149.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple or a } to terminate the Graph Literal"' next); " is 245.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Blank Node Object List' expected a comma' semicolon or ] to terminate the current Triple/list"' next); " is 220.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple"' next); " is 207.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next); " is 137.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseGraphLiteral,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Right Curly Bracket to terminate a Graph Literal"' next); " is 163.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePath,The length of the statement  "			secondItem = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri))); " is 134.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePath,The length of the statement  "			secondItem = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (next.Value' context.BaseUri.ToSafeString ()))); " is 128.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePath,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' only Literals' QNames and URIs are valid as Path Items"' next); " is 158.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "						return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ()))); " is 132.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "					throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx); " is 143.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next); " is 159.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "				return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ()))); " is 134.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "			throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx); " is 148.
Long Statement,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit); " is 153.
Long Statement,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The length of the statement  "			RaiseWarning ("Selected Parser " + parser.ToString () + " based on file extension' if this is incorrect consider specifying the parser explicitly"); " is 148.
Long Statement,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The length of the statement  "		RaiseWarning ("Attempting to select parser based on analysis of the data file' this requires loading the file into memory"); " is 124.
Long Statement,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The length of the statement  "		throw new FileNotFoundException ("Cannot read a RDF Dataset from the File '" + filename + "' since it doesn't exist"' filename); " is 128.
Long Statement,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The length of the statement  "			parser = MimeTypesHelper.GetStoreParser (MimeTypesHelper.GetMimeType (MimeTypesHelper.GetTrueFileExtension (filename))); " is 120.
Long Statement,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The length of the statement  "				IRdfReader rdfParser = MimeTypesHelper.GetParser (MimeTypesHelper.GetMimeType (MimeTypesHelper.GetTrueFileExtension (filename))); " is 129.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (t.Value' context.Namespaces' context.BaseUri))); " is 125.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 140.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 134.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (t.Value' context.Namespaces' context.BaseUri))); " is 125.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 140.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 134.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw new RdfException ("Unable to resolve the QName since an RDF Handler does not have a Namespace Map that can be used to resolve QNames"); " is 141.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw new RdfException ("Unable to resolve the QName since a Results Handler does not have a Namespace Map that can be used to resolve QNames"); " is 144.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 140.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the QName '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 134.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + formatEx.Message' t' formatEx); " is 138.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "			throw new RdfParseException ("Unable to resolve the URI '" + t.Value + "' due to the following error:\n" + rdfEx.Message' t' rdfEx); " is 132.
Long Statement,VDS.RDF.Parsing,ParserHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\ParserHelper.cs,TryResolveUri,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + t.GetType ().ToString () + "' encountered' expected a URI/QName Token to resolve into a URI"' t); " is 146.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "	bool rel = false' rev = false' about = false' src = false' href = false' property = false' type = false' resource = false' content = false' datatype = false; " is 157.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "						this.OnWarning ("Unable to resolve a Profile document specified by the @profile attribute on the element <" + currElement.Name + "> - ignoring the DOM subtree of this element"); " is 177.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "			newSubj = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (currElement.Attributes ["src"].Value' baseUri))); " is 127.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "			newSubj = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (currElement.Attributes ["href"].Value' baseUri))); " is 128.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "					this.OnWarning ("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI"); " is 135.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "			newSubj = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (currElement.Attributes ["src"].Value' baseUri))); " is 127.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "					this.OnWarning ("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI"); " is 135.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "			currObj = context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (currElement.Attributes ["href"].Value' baseUri))); " is 128.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "				this.OnWarning ("Unable to resolve a valid Datatype for the Literal since the value '" + currElement.Attributes ["datatype"].Value + "' is not a valid CURIE or it cannot be resolved into a URI given the in-scope namespace prefixes and Base URI - assuming a Plain Literal instead"); " is 281.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The length of the statement  "				currLiteral = context.Handler.CreateLiteralNode (currElement.InnerHtml' UriFactory.Create (RdfSpecsHelper.RdfXmlLiteral)); " is 122.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveCurie,The length of the statement  "				return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (curie' evalContext.NamespaceMap' evalContext.BaseUri))); " is 133.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveCurie,The length of the statement  "			return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (curie' evalContext.NamespaceMap' evalContext.BaseUri))); " is 133.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveUriOrCurie,The length of the statement  "			return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (uriref' evalContext.BaseUri.ToSafeString ()))); " is 122.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveUriOrCurie,The length of the statement  "		this.OnWarning ("Unable to resolve a URI or CURIE since the value '" + uriref + "' does not contain a valid URI/CURIE or it cannot be resolved to a URI given the in-scope namespace prefixes and Base URI"); " is 205.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurie,The length of the statement  "				if (evalContext.LocalVocabulary.HasTerm (curie.Substring (1)) || !evalContext.LocalVocabulary.VocabularyUri.Equals (String.Empty)) { " is 132.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurie,The length of the statement  "					return context.Handler.CreateUriNode (UriFactory.Create (evalContext.LocalVocabulary.ResolveTerm (curie.Substring (1)))); " is 121.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurie,The length of the statement  "					throw new RdfParseException ("Unable to resolve a Term since there is no appropriate Local/Default Vocabulary in scope"); " is 121.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurie,The length of the statement  "				throw new RdfParseException ("Unable to resolve a Term since there is no appropriate Local/Default Vocabularly in scope"); " is 122.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveTermOrCurieOrUri,The length of the statement  "		return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (value' evalContext.BaseUri.ToSafeString ()))); " is 121.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseComplexAttribute,The length of the statement  "			this.OnWarning ("Ignoring the value '" + val + "' since this is not a valid Term/CURIE/URI or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI"); " is 180.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseAttribute,The length of the statement  "			this.OnWarning ("Ignoring the value '" + val + "' since this is not a valid CURIE or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI"); " is 171.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParsePrefixAttribute,The length of the statement  "				this.OnWarning ("Aborted parsing a prefix attribute since failed to find a prefix of the form prefix: from the following content: " + prefixData.ToString ()); " is 158.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParsePrefixAttribute,The length of the statement  "				this.OnWarning ("Aborted parsing a prefix attribute since reached the end of the attribute without finding a URI to go with the prefix '" + prefixData.ToString () + ":'"); " is 171.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,The length of the statement  "	String prefixQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?prefix) AS ?NamespacePrefix SAMPLE(?uri) AS ?NamespaceURI WHERE { ?s rdfa:prefix ?prefix ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?prefix) = 1 && COUNT(?uri) = 1)"; " is 241.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,The length of the statement  "	String termQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?term) AS ?Term SAMPLE(?uri) AS ?URI WHERE {?s rdfa:term ?term ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?term) = 1 && COUNT(?uri) = 1)"; " is 210.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,The length of the statement  "			if (profile.Equals (XHtmlVocabNamespace) || profile.Equals (XHtmlVocabNamespace.Substring (0' XHtmlVocabNamespace.Length - 1))) { " is 129.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,The length of the statement  "					                            throw new PlatformNotSupportedException("The @profile attribute is not currently supported under Silverlight/Windows Phone 7");" is 127.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ParseProfileAttribute,The length of the statement  "			this.OnWarning ("Ignoring the value '" + profile + "' since this is not a valid URI or a profile document was not successfully retrieved and parsed from this URI"); " is 164.
Long Statement,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,IsCurie,The length of the statement  "		return (XmlSpecsHelper.IsNCName (prefix) || prefix.Equals ("_")) && evalContext.NamespaceMap.HasNamespace (prefix) && IriSpecsHelper.IsIrelativeRef (reference); " is 160.
Long Statement,VDS.RDF.Parsing,RdfXmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlSpecsHelper.cs,IsIDAttribute,The length of the statement  "			throw ParserHelper.Error ("The value '" + attr.Value + "' for rdf:ID is not valid' RDF IDs can only be valid NCNames as defined by the W3C XML Namespaces specification"' attr); " is 176.
Long Statement,VDS.RDF.Parsing,RdfXmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlSpecsHelper.cs,IsNodeIDAttribute,The length of the statement  "			throw ParserHelper.Error ("The value '" + attr.Value + "' for rdf:id is not valid' RDF IDs can only be valid NCNames as defined by the W3C XML Namespaces specification"' attr); " is 176.
Long Statement,VDS.RDF.Parsing,RdfXmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlSpecsHelper.cs,IsRdfUriReference,The length of the statement  "			throw new RdfParseException ("An Invalid RDF URI Reference was encountered' the URI Reference '" + value + "' is not valid since it contains Unicode Control Characters!"); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Parse,The length of the statement  "								throw new RdfParseException ("Result Set has a boolean result which is a Literal typed as boolean but which does not contain a valid boolean value"); " is 149.
Long Statement,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Parse,The length of the statement  "									throw new RdfParseException ("Result Set contains a Binding which refers to a Variable but not by a Literal Node as required"); " is 127.
Long Statement,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Parse,The length of the statement  "							throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element attempts to bind a value to the variable '" + var + "' which is not defined in the <head> by a <variable> element!"); " is 209.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,Parse,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,Parse,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,Parse,The length of the statement  "		SparqlUpdateParserContext context = new SparqlUpdateParserContext (new SparqlTokeniser (input' SparqlQuerySyntax.Sparql_1_1)); " is 126.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,ParseInternal,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a semicolon separator or EOF after a command"' next); " is 157.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseClearCommand,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a GRAPH <URI> to specify the Graph to CLEAR or one of the DEFAULT/NAMED/ALL keywords"' next); " is 197.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseCreateCommand,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a GRAPH Keyword as part of the CREATE command"' next); " is 158.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteCommand,The length of the statement  "			throw ParserHelper.Error ("The DATA keyword is not permitted here as this INSERT command forms part of a modification command"' next); " is 134.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteCommand,The length of the statement  "			GraphPattern where = context.QueryParser.TryParseGraphPattern (subContext' context.Tokens.LastTokenType != Token.LEFTCURLYBRACKET); " is 131.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteCommand,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a WHERE keyword as part of a DELETE command"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteDataCommand,The length of the statement  "	GraphPattern gp = context.QueryParser.TryParseGraphPattern (subContext' context.Tokens.LastTokenType != Token.LEFTCURLYBRACKET); " is 128.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteDataCommand,The length of the statement  "		if (!gp.ChildGraphPatterns.All (p => p.IsGraph || (!p.IsExists && !p.IsMinus && !p.IsNotExists && !p.IsOptional && !p.IsOptional && !p.IsService && !p.IsSubQuery && !p.IsUnion))) { " is 180.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteDataCommand,The length of the statement  "			throw new RdfParseException ("A DELETE DATA Command may only contain a combination of Triple Patterns and GRAPH clauses"); " is 122.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDropCommand,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a GRAPH <URI> to specify the Graph to DROP or one of the DEFAULT/NAMED/ALL keywords"' next); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertCommand,The length of the statement  "			throw ParserHelper.Error ("The DATA keyword is not permitted here as this INSERT command forms part of a modification command"' next); " is 134.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertCommand,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a WHERE keyword as part of a INSERT command"' next); " is 156.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertCommand,The length of the statement  "	GraphPattern where = context.QueryParser.TryParseGraphPattern (subContext' context.Tokens.LastTokenType != Token.LEFTCURLYBRACKET); " is 131.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertDataCommand,The length of the statement  "	GraphPattern gp = context.QueryParser.TryParseGraphPattern (subContext' context.Tokens.LastTokenType != Token.LEFTCURLYBRACKET); " is 128.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertDataCommand,The length of the statement  "		if (!gp.ChildGraphPatterns.All (p => p.IsGraph || (!p.IsExists && !p.IsMinus && !p.IsNotExists && !p.IsOptional && !p.IsOptional && !p.IsService && !p.IsSubQuery && !p.IsUnion))) { " is 180.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertDataCommand,The length of the statement  "			throw new RdfParseException ("An INSERT DATA Command may only contain a combination of Triple Patterns and GRAPH clauses"); " is 123.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseLoadCommand,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a GRAPH keyword after the INTO keyword for a LOAD command"' next); " is 170.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseModifyCommand,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an INSERT/DELETE keyword"' next); " is 137.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseModifyTemplate,The length of the statement  "	GraphPattern gp = context.QueryParser.TryParseGraphPattern (subContext' context.Tokens.LastTokenType != Token.LEFTCURLYBRACKET); " is 128.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseModifyTemplate,The length of the statement  "		if (gp.ChildGraphPatterns.All (p => p.IsGraph && !p.IsFiltered && !p.IsOptional && !p.IsUnion && !p.HasChildGraphPatterns)) { " is 125.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseUsingStatements,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI as part of a USING statement"' next); " is 147.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,The length of the statement  "			ParserHelper.Error ("Unexpected Token '" + next.GetType ().Name + "' encountered' expected a URI/QName after a GRAPH keyword to specify the URI of the Source Graph for a Transfer (ADD/COPY/MOVE) Command"' next); " is 211.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().Name + "' encountered' expected a GRAPH/DEFAULT keyword to indicate the Source Graph for a Transfer (ADD/COPY/MOVE) Command"' next); " is 197.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().Name + "' encountered' expected a TO Keyword after the Source Graph specifier"' next); " is 151.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,The length of the statement  "			ParserHelper.Error ("Unexpected Token '" + next.GetType ().Name + "' encountered' expected a URI/QName after a GRAPH keyword to specify the URI of the Destination Graph for a Transfer (ADD/COPY/MOVE) Command"' next); " is 216.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseTransferUris,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().Name + "' encountered' expected a GRAPH/DEFAULT keyword to indicate the Destination Graph for a Transfer (ADD/COPY/MOVE) Command"' next); " is 202.
Long Statement,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseIriRef,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName Token " + expected' next); " is 142.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Load,The length of the statement  "		this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 198.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Load,The length of the statement  "		                this.RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.GetType().Name + " - Please be aware that parsing errors may occur as a result");" is 199.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Load,The length of the statement  "		TokenisingParserContext context = new TokenisingParserContext (handler' new TurtleTokeniser (input' this._syntax)' this._queueMode' this._traceParsing' this._traceTokeniser); " is 174.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a BOF Token"' next); " is 124.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' Literals are not valid as Subjects in Turtle"' next); " is 148.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' the 'a' Keyword is only valid as a Predicate in Turtle"' next); " is 158.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "				throw new RdfParseException ("Unable to set the Base URI to '" + u.Value + "' due to the following error:\n" + rdfEx.Message' u' rdfEx); " is 136.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + u.GetType ().ToString () + "' encountered' expected a URI after a Base Directive"' u); " is 135.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "					throw new RdfParseException ("Unable to resolve the Namespace URI '" + ns.Value + "' due to the following error:\n" + rdfEx.Message' ns' rdfEx); " is 144.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + ns.GetType ().ToString () + "' encountered' expected a URI after a Prefix Directive"' pre); " is 140.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + pre.GetType ().ToString () + "' encountered' expected a Prefix after a Prefix Directive"' pre); " is 144.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + directive.GetType ().ToString () + "' encountered' expected a Base/Prefix Directive after an @ symbol"' directive); " is 164.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseDirective,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + terminator.GetType ().ToString () + "' encountered' expected a Dot Line Terminator to terminate a Prefix/Base Directive"' terminator); " is 183.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseTriples,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' this Token is not valid as the subject of a Triple"' subjToken); " is 164.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,The length of the statement  "			Console.WriteLine ("Attempting to parse Predicate Object List from the Predicate Token '" + predToken.GetType ().ToString () + "'"); " is 132.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,The length of the statement  "					//If Predicate is not null then we've seen at least one valid Triple and this is just the end of the Blank Node Predicate Object list " is 133.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,The length of the statement  "						throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Blank Node Predicate Object list' expected a valid Predicate"' predToken); " is 169.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Predicate Object list"' predToken); " is 130.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParsePredicateObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + predToken.GetType ().ToString () + "' encountered while trying to parse a Predicate Object list"' predToken); " is 158.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "			Console.WriteLine ("Attempting to parse an Object List from the Object Token '" + objToken.GetType ().ToString () + "'"); " is 121.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 134.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 132.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "					throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken); " is 158.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken); " is 147.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken); " is 138.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken); " is 147.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Blank Node Object List' expected a comma' semicolon or ] to terminate the current Triple/list"' next); " is 220.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple"' next); " is 207.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseCollection,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next); " is 137.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "					return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ()))); " is 132.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "				throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx); " is 143.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "				return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ()))); " is 134.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "			throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx); " is 148.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "				return context.Handler.CreateLiteralNode (lit.Value.ToLower ()' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean)); " is 125.
Long Statement,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit); " is 153.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,Load,The length of the statement  "			this.RaiseWarning ("Expected Input Stream to be encoded as ASCII but got a Stream encoded as " + ((StreamReader)input).CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 214.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,Parse,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a BOF token at the start of the input"' next); " is 150.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseSubject,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/URI as the Subject of a Triple"' next); " is 156.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParsePredicate,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI as the Predicate of a Triple"' next); " is 147.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseObject,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Object of a Triple"' next); " is 163.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Context of the Triple"' next); " is 166.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The length of the statement  "			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Dot Token (Line Terminator) to terminate a Triple"' next); " is 164.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The length of the statement  "			throw ParserHelper.Error ("Cannot turn a Node of type '" + context.GetType ().ToString () + "' into a Context URI for a Triple"' next); " is 135.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + s.GetType ().ToString () + "' encountered' expected a Blank Node/URI as the Subject of a Triple"' s); " is 150.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + p.GetType ().ToString () + "' encountered' expected a URI as the Predicate of a Triple"' p); " is 141.
Long Statement,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The length of the statement  "		throw ParserHelper.Error ("Unexpected Token '" + o.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Object of a Triple"' o); " is 157.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,Load,The length of the statement  "			this.RaiseWarning ("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + ((StreamReader)input).CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result"); " is 214.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,Load,The length of the statement  "			throw new RdfParseException ("Unable to Parse this TriX since System.Xml was unable to parse the document into a DOM Tree' see the inner exception for details"' xmlEx); " is 168.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraphset,The length of the statement  "			throw new RdfParseException ("Unexpected Document Element '" + graphsetEl.Name + "' encountered' expected the Document Element of a TriX Document to be the <TriX> element"); " is 173.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraphset,The length of the statement  "			throw new RdfParseException ("<TriX> fails to define any attributes' the element must define the xmlns attribute to be the TriX namespace"); " is 140.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraphset,The length of the statement  "						throw new RdfParseException ("The xmlns attribute of the <TriX> element must have it's value set to the TriX Namespace URI which is '" + TriXNamespaceURI + "'"); " is 161.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraphset,The length of the statement  "				throw new RdfParseException ("The <TriX> element fails to define the required xmlns attribute defining the TriX Namespace"); " is 124.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraph,The length of the statement  "		throw new RdfParseException ("Unexpected Element <" + graphEl.Name + "> encountered' only <graph> elements are permitted within a <TriX> element"); " is 147.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseGraph,The length of the statement  "				this.RaiseWarning ("A Graph is marked as not asserted in the TriX input.  This Graph will not be parsed' if you reserialize the input the information contained in it will not be preserved"); " is 190.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw new RdfParseException ("Unexpected Element <" + tripleEl.Name + "> encountered' only an optional <uri> element followed by zero/more <triple> elements are permitted within a <graph> element"); " is 198.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw new RdfParseException ("<triple> element has too few child nodes (" + tripleEl.ChildNodes.Count + ") - 3 child nodes are expected"); " is 138.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw new RdfParseException ("<triple> element has too many child nodes (" + tripleEl.ChildNodes.Count + ") - 3 child nodes are expected"); " is 139.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw Error ("Unexpected element <" + subjEl.Name + "> encountered' expected a <id>/<uri> element as the Subject of a Triple"' subjEl); " is 135.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw Error ("Unexpected element <" + predEl.Name + "> encountered' expected a <uri> element as the Predicate of a Triple"' subjEl); " is 132.
Long Statement,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The length of the statement  "		throw Error ("Unexpected element <" + objEl.Name + "> encountered' expected a <id>/<uri>/<plainLiteral>/<typedLiteral> element as the Object of a Triple"' subjEl); " is 163.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The length of the statement  "		throw new RdfParseException ("Unexpected Token '" + first.GetType ().ToString () + "' encountered' this is not valid as the start of a property path"); " is 151.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The length of the statement  "					if (lastItem == LastPathItemType.Sequencer && next.TokenType == Token.HAT && (lastSequencer == Token.DIVIDE || lastSequencer == Token.BITWISEOR)) { " is 147.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The length of the statement  "				if (lastItem != LastPathItemType.None && lastItem != LastPathItemType.Sequencer && lastItem != LastPathItemType.Negation) { " is 123.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The length of the statement  "					throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encounted' this is not a valid token for a Path"' next); " is 141.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathAlternative,The length of the statement  "			throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a valid path sequence/alternative token"' next); " is 155.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathPrimary,The length of the statement  "		path = new Property (new UriNode (null' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Query.NamespaceMap' context.Query.BaseUri)))); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathPrimary,The length of the statement  "		throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName' the 'a' keyword or the start of a group path expression"' next); " is 184.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "								throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a } to terminate a Path Cardinality modifier"' next); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "							throw new RdfParseException ("The value '" + next.Value + "' is not valid for use as a Path Cardinality modifier"' next); " is 121.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "						throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an Integer Plain Literal as part of a Path Cardinality modifier"' next); " is 179.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "					throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a valid token to continue the Path Cardinality modifier"' next); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "				throw new RdfParseException ("The value '" + next.Value + "' is not valid for use as a Path Cardinality modifier"' next); " is 121.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "						throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a } to terminate a Path Cardinality modifier"' next); " is 160.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "					throw new RdfParseException ("The value '" + next.Value + "' is not valid for use as a Path Cardinality modifier"' next); " is 121.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "				throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an Integer Plain Literal as part of a Path Cardinality modifier"' next); " is 179.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "			throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected an Integer Plain Literal/Comma as part of a Path Cardinality modifier"' next); " is 185.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathMod,The length of the statement  "		throw new RdfParseException ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a token which is valid as a Path Cardinality modifier"' next); " is 169.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParseNegatedPropertySet,The length of the statement  "					throw new RdfParseException ("Unexpected ) to end a negated property set encountered immediately after a | which should indicate that further items are in the set"' next); " is 171.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParseNegatedPropertySet,The length of the statement  "		throw new RdfParseException ("Unexpected Token Type '" + next.GetType ().Name + "' encountered' expected the first path in a negated property set"' next); " is 154.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathOneInPropertySet,The length of the statement  "		return new Property (new UriNode (null' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Query.NamespaceMap' context.Query.BaseUri)))); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathOneInPropertySet,The length of the statement  "			return new Property (new UriNode (null' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Query.NamespaceMap' context.Query.BaseUri)))); " is 144.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathOneInPropertySet,The length of the statement  "			throw new RdfParseException ("Unexpected Token Type '" + next.GetType ().Name + "' encountered' expected a QName/URI or the 'a' Keyword after an inverse operator in a negated property set"' next); " is 196.
Long Statement,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathOneInPropertySet,The length of the statement  "		throw new RdfParseException ("Unexpected Token Type '" + next.GetType ().Name + "' encountered' expected a QName/URI or the 'a' Keyword or the inverse operator '^' to define a path in a negated property set"' next); " is 215.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseConditionalOrExpression,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Conditional Or expression"' next); " is 139.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseConditionalAndExpression,The length of the statement  "			//throw new RdfParseException("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Conditional And expression"); " is 149.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParsePrimaryExpression,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' Aggregates are not permitted in this Expression"' next); " is 138.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParsePrimaryExpression,The length of the statement  "		throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Primary Expression"' next); " is 132.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBrackettedExpression,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Left Bracket to start a Bracketted Expression"' next); " is 147.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBrackettedExpression,The length of the statement  "				throw Error ("Unexpected DISTINCT Keyword Token encountered' DISTINCT modifier keyword may only occur as the first argument to an aggregate function"' next); " is 157.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "					throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' a Right Bracket to end a BOUND function call was expected"' next); " is 148.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "				throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' a Variable Token for a BOUND function call was expected"' next); " is 146.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' a Left Bracket to start a BOUND function call was expected"' next); " is 149.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new ContainsFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 124.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new IfElseFunction (this.TryParseBrackettedExpression (tokens' true' out comma)' this.TryParseBrackettedExpression (tokens' false' out comma)' this.TryParseBrackettedExpression (tokens' false' out comma)); " is 212.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new LangMatchesFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 127.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new SameTermFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 124.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrAfterFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 124.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrBeforeFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 125.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrDtFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 121.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrEndsFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 123.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrLangFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 123.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		return new StrStartsFunction (this.TryParseBrackettedExpression (tokens)' this.TryParseBrackettedExpression (tokens' false)); " is 125.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseBuiltInCall,The length of the statement  "		throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Built-in Function call"' next); " is 136.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseIriRefOrFunction,The length of the statement  "					throw new RdfParseException ("Arguments List terminated by a Semicolon - Arbitrary Scalar Arguments for Extension Functions/Aggregates are not permitted in SPARQL 1.1"); " is 169.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseIriRefOrFunction,The length of the statement  "					throw new RdfParseException ("Aggregate Expression '" + expr.ToString () + "' encountered but aggregates are not permitted in this Expression"); " is 144.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,The length of the statement  "			throw Error ("The Literal '" + literal.Value + "' with Datatype URI '" + dtUri + "' is not a valid Integer' Decimal or Double"' literal); " is 137.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,The length of the statement  "		throw Error ("Unexpected Token '" + literal.GetType ().ToString () + "' encountered while trying to parse a Numeric Literal"' literal); " is 135.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "		throw Error ("Unexpected Token '" + next.GetType ().ToString () + "'' expected a Left Bracket after an Aggregate Keyword"' next); " is 129.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "		throw Error ("Unexpected Token '" + next.GetType ().ToString () + "'' expected a Right Bracket after the * specifier in an aggregate to terminate the aggregate"' next); " is 168.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "				throw new RdfParseException ("The GROUP_CONCAT aggregate has Scalar Arguments but does not have the expected SEPARATOR argument"); " is 130.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "			return new AggregateTerm (new GroupConcatAggregate (aggExpr' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]' distinct)); " is 132.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "			throw new RdfParseException ("The NMAX (Numeric Maximum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type"); " is 275.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "			throw new RdfParseException ("The NMIN (Numeric Minimum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type"); " is 275.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseAggregateExpression,The length of the statement  "		throw Error ("Cannot parse an Aggregate since '" + agg.GetType ().ToString () + "' is not an Aggregate Keyword Token"' agg); " is 124.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseScalarArguments,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Keyword/QName/URI for the Scalar Argument Name"' next); " is 148.
Long Statement,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseScalarArguments,The length of the statement  "			throw Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a = after a Scalar Argument name in an aggregate"' next); " is 148.
Long Statement,VDS.RDF.Query,SparqlResultBinder,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultBinder.cs,Group,The length of the statement  "		throw new RdfQueryException ("Cannot lookup a Group when the Query has not been executed or does not contain Groups as part of it's Results"); " is 142.
Long Statement,VDS.RDF.Query,LeviathanResultBinder,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultBinder.cs,SetGroupContext,The length of the statement  "			throw new RdfQueryException ("Cannot set Group Context to access Contents data when the Input is not a Group Multiset"); " is 120.
Long Statement,VDS.RDF.Query,NonBlankSelector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\BlankNodeSelectors.cs,Accepts,The length of the statement  "	if (obj.Subject.NodeType != NodeType.Blank && obj.Predicate.NodeType != NodeType.Blank && obj.Object.NodeType != NodeType.Blank) { " is 130.
Long Statement,VDS.RDF.Query,HasBlankSelector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\BlankNodeSelectors.cs,Accepts,The length of the statement  "	return (obj.Subject.NodeType == NodeType.Blank || obj.Predicate.NodeType == NodeType.Blank || obj.Object.NodeType == NodeType.Blank); " is 133.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultSet,The length of the statement  "			throw new RdfParseException ("The SPARQL Endpoint returned unexpected Content Type '" + ctype + "'' this error may be due to the given URI not returning a SPARQL Result Set"); " is 175.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultSet,The length of the statement  "		throw new RdfQueryException ("A HTTP Error occurred while trying to make the SPARQL Query' see inner exception for details"' webEx); " is 132.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryWithResultGraph,The length of the statement  "		throw new RdfQueryException ("A HTTP Error occurred when trying to make the SPARQL Query' see inner exception for details"' webEx); " is 131.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SerializeConfiguration,The length of the statement  "	INode endpointClass = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassSparqlEndpoint); " is 123.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SerializeConfiguration,The length of the statement  "	INode endpointUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyEndpointUri); " is 121.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SerializeConfiguration,The length of the statement  "	INode defGraphUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyDefaultGraphUri); " is 125.
Long Statement,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,SerializeConfiguration,The length of the statement  "	INode namedGraphUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyNamedGraphUri); " is 125.
Long Statement,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,SetResult,The length of the statement  "		throw new RdfException ("Cannot set the Boolean Result value for this Result Set as its Result Type has already been set"); " is 123.
Long Statement,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,ReadXml,The length of the statement  "			throw new RdfParseException ("Unable to deserialize a SparqlResultSet as did not get the expected <results> element after the <variables> element"); " is 148.
Long Statement,VDS.RDF.Query,SparqlResultSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResultSet.cs,ReadXml,The length of the statement  "		throw new RdfParseException ("Unable to deserialize a SparqlResultSet' expected a <boolean> or <results> element after the <resultSet> element"); " is 145.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsQueryKeyword,The length of the statement  "	if (keyword.Equals (SparqlKeywordAsk) || keyword.Equals (SparqlKeywordConstruct) || keyword.Equals (SparqlKeywordDescribe) || keyword.Equals (SparqlKeywordSelect)) { " is 165.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNCharsBase,The length of the statement  "	else if ((c >= 0x00c0 && c <= 0x00d6) || (c >= 0x00d8 && c <= 0x00f6) || (c >= 0x00f8 && c <= 0x02ff) || (c >= 0x0370 && c <= 0x037d) || (c >= 0x037f && c <= 0x1fff) || (c >= 0x200c && c <= 0x200d) || (c >= 0x2070 && c <= 0x218f) || (c >= 0x2c00 && c <= 0x2fef) || (c >= 0x3001 && c <= 0xd7ff) || (c >= 0xf900 && c <= 0xfdcf) || (c >= 0xfdf0 && c <= 0xfffd)/*||" is 361.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNLocal,The length of the statement  "	if (Char.IsDigit (first) || IsPNCharsU (first) || (syntax != SparqlQuerySyntax.Sparql_1_0 && IsPLX (cs' 0' out start))) { " is 121.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The length of the statement  "					throw new RdfParseException ("Invalid backslash to start an escape at the end of the Local Name' expecting a single character after the backslash"); " is 148.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The length of the statement  "					throw new RdfParseException ("Invalid character after a backslash' a backslash can only be used to escape a limited set (_-.|$&\\()*+';=:/?#@%) of characters in a Local Name"); " is 176.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The length of the statement  "					throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly"); " is 182.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,Equality,The length of the statement  "			SparqlNumericType numtype = (SparqlNumericType)Math.Max ((int)GetNumericTypeFromDataTypeUri (xtype)' (int)GetNumericTypeFromDataTypeUri (ytype)); " is 145.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,NumericEquality,The length of the statement  "		// new RdfQueryException("Cannot evaluate numeric equality since one of the arguments does not have a valid lexical value for the given type"); " is 143.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,DateTimeEquality,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate date time equality since one of the arguments does not have a valid lexical value for a Date Time"); " is 146.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,DateEquality,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate date equality since one of the arguments does not have a valid lexical value for a Date"); " is 136.
Long Statement,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,TimeSpanEquality,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate time span equality since one of the arguments does not have a valid lexical value for a Time Span"); " is 146.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryRaw,The length of the statement  "	//If we have any other number of endpoints we either have no responses or no way of logically/sensibly combining responses " is 122.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryRaw,The length of the statement  "	//If we have any other number of endpoints we either have no responses or no way of logically/sensibly combining responses " is 122.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The length of the statement  "		throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds"); " is 203.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The length of the statement  "				throw new RdfQueryException ("Federated Querying failed due to the query against the endpoint '" + this._endpoints [i] + "' failing"' ex); " is 138.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The length of the statement  "		throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds"); " is 203.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The length of the statement  "				throw new RdfQueryException ("Federated Querying failed due to the query against the endpoint '" + this._endpoints [i].Uri.ToString () + "' failing"' ex); " is 154.
Long Statement,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,SerializeConfiguration,The length of the statement  "	INode endpointClass = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassSparqlEndpoint); " is 123.
Long Statement,VDS.RDF.Query,PelletQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\PelletQueryProcessor.cs,ProcessQuery,The length of the statement  "	            throw new NotSupportedException("Synchronous remote query is not supported under Silverlight/WP7 - please use one of the alternative overload of this methods which takes a callback");" is 183.
Long Statement,VDS.RDF.Query,PelletQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\PelletQueryProcessor.cs,ProcessQuery,The length of the statement  "	            throw new NotSupportedException("Synchronous remote query is not supported under Silverlight/WP7 - please use one of the alternative overload of this methods which takes a callback");" is 183.
Long Statement,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The length of the statement  "	if (rdfHandler == null && (query.QueryType == SparqlQueryType.Construct || query.QueryType == SparqlQueryType.Describe || query.QueryType == SparqlQueryType.DescribeAll)) " is 170.
Long Statement,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The length of the statement  "	if (resultsHandler == null && (query.QueryType == SparqlQueryType.Ask || SparqlSpecsHelper.IsSelectQuery (query.QueryType))) " is 124.
Long Statement,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The length of the statement  "	ReaderWriterLockSlim currLock = (this._dataset is IThreadSafeDataset) ? ((IThreadSafeDataset)this._dataset).Lock : this._lock; " is 126.
Long Statement,VDS.RDF.Query,QueryExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryExtensions.cs,Apply,The length of the statement  "			type = (context.OutputMultiset.Variables.Any () || context.OutputMultiset.Sets.Any () ? SparqlQueryType.Select : SparqlQueryType.Ask); " is 134.
Long Statement,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The length of the statement  "	            throw new NotSupportedException("Synchronous remote query is not supported under Silverlight/WP7 - please use one of the alternative overload of this methods which takes a callback");" is 183.
Long Statement,VDS.RDF.Query,RemoteQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\QueryProcessors.cs,ProcessQuery,The length of the statement  "	            throw new NotSupportedException("Synchronous remote query is not supported under Silverlight/WP7 - please use one of the alternative overload of this methods which takes a callback");" is 183.
Long Statement,VDS.RDF.Query,SparqlEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlEvaluationContext.cs,CalculateTimeout,The length of the statement  "			if (Options.QueryExecutionTimeout == 0 || (this._query.Timeout <= Options.QueryExecutionTimeout && Options.QueryExecutionTimeout > 0)) { " is 136.
Long Statement,VDS.RDF.Query,SparqlEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlEvaluationContext.cs,CheckTimeout,The length of the statement  "			throw new RdfQueryTimeoutException ("Query Execution Time exceeded the Timeout of " + this._timeout + "ms' query aborted after " + this._timer.ElapsedMilliseconds + "ms"); " is 171.
Long Statement,VDS.RDF.Query,SparqlEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlEvaluationContext.cs,CheckTimeout,The length of the statement  "                    throw new RdfQueryTimeoutException("Query Execution Time exceeded the Timeout of " + this._timeout + "ms' query aborted after " + elapsed.Milliseconds + "ms");" is 159.
Long Statement,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,The length of the statement  "					throw new RdfQueryException ("Unable to determine ordering since one/both arguments does not contain a valid value for it's type"); " is 131.
Long Statement,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,Compare,The length of the statement  "					throw new RdfQueryException ("Unable to determine ordering since one/both arguments does not contain a valid value for it's type"); " is 131.
Long Statement,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,DateTimeCompare,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate date time equality since one of the arguments does not have a valid lexical value for a Date Time"); " is 146.
Long Statement,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,DateTimeCompare,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate date time equality since one of the arguments does not have a valid lexical value for a Date Time"); " is 146.
Long Statement,VDS.RDF.Query,SparqlNodeComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlNodeComparer.cs,DateCompare,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate date equality since one of the arguments does not have a valid lexical value for a Date"); " is 136.
Long Statement,VDS.RDF.Query,SparqlParameterizedString,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlParameterizedString.cs,SetParameter,The length of the statement  "		throw new FormatException ("The parameter name '" + name + "' is not a valid parameter name' parameter names must consist only of alphanumeric characters and hypens/underscores"); " is 179.
Long Statement,VDS.RDF.Query,SparqlParameterizedString,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlParameterizedString.cs,SetVariable,The length of the statement  "		throw new FormatException ("The variable name '" + name + "' is not a valid variable name' variable names must consist only of alphanumeric characters and hyphens/underscores"); " is 177.
Long Statement,VDS.RDF.Query,SparqlParameterizedString,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlParameterizedString.cs,ToString,The length of the statement  "			output = Regex.Replace (output' "(@" + param + ")([^\\w]|$)"' this._formatter.Format (this._parameters [param]) + "$2"); " is 120.
Long Statement,VDS.RDF.Query,SparqlView,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlView.cs,UpdateViewInternal,The length of the statement  "		this.LastError = new RdfQueryException ("Unable to Update a SPARQL View as an error occurred in processing the Query - see Inner Exception for details"' queryEx); " is 162.
Long Statement,VDS.RDF.Query,NativeSparqlView,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlView.cs,UpdateViewInternal,The length of the statement  "		this.LastError = new RdfQueryException ("Unable to Update a SPARQL View as an error occurred in processing the Query - see Inner Exception for details"' queryEx); " is 162.
Long Statement,VDS.RDF.Query,BindingGroup,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\BindingClasses.cs,AddAssignment,The length of the statement  "		throw new RdfQueryException ("Cannot assign the value of a GROUP BY expression to a Variable assigned to by an earlier GROUP BY"); " is 130.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,GenerateChangeSet,The length of the statement  "	ILiteralNode dotNetRDFUpdate = g.CreateLiteralNode ("Updates to the store were requested by a dotNetRDF powered application"); " is 126.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,GenerateChangeSet,The length of the statement  "		IUriNode report = g.CreateUriNode (UriFactory.Create (Tools.ResolveUri (subj.GetHashCode () + "/changes/" + DateTime.Now.ToString (TalisChangeSetIDFormat)' g.BaseUri.ToString ()))); " is 181.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,QueryInternal,The length of the statement  "			throw new RdfQueryException ("Unknown Query Type was used' unable to determine how to process the response from Talis"); " is 120.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,DeleteGraph,The length of the statement  "	throw new RdfStorageException ("The TalisConnector does not support deletion of Graphs since the Talis platform is not a named graph store"); " is 141.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,DeleteGraph,The length of the statement  "	throw new RdfStorageException ("The TalisConnector does not support deletion of Graphs since the Talis platform is not a named graph store"); " is 141.
Long Statement,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,ListGraphs,The length of the statement  "		HttpWebRequest request = this.CreateRequest ("/contexts"' MimeTypesHelper.CustomHttpAcceptHeader (MimeTypesHelper.SparqlResultsJson)' "GET"' new Dictionary<string' string> ()); " is 176.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,ListGraphs,The length of the statement  "		throw new RdfStorageException ("An error occurred while attempting to retrieve the Graph List from the Store' see inner exception for details"' ex); " is 148.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,The length of the statement  "			throw new RdfStorageException ("An unexpected error occurred while trying to parse the SPARQL Query prior to sending it to the Store' see inner exception for details"' ex); " is 172.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,The length of the statement  "		String accept = (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask) ? MimeTypesHelper.HttpSparqlAcceptHeader : MimeTypesHelper.HttpAcceptHeader; " is 178.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,The length of the statement  "					throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx); " is 147.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The length of the statement  "			return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7); " is 153.
Long Statement,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The length of the statement  "		String accept = MimeTypesHelper.CustomHttpAcceptHeader (MimeTypesHelper.SparqlResultsXml.Concat (MimeTypesHelper.Definitions.Where (d => d.CanParseRdf).SelectMany (d => d.MimeTypes))); " is 184.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The length of the statement  "				ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' Regex.IsMatch (sparqlQuery' "ASK"' RegexOptions.IgnoreCase)); " is 134.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The length of the statement  "					throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx); " is 147.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,SaveGraph,The length of the statement  "				throw new RdfStorageException ("Unable to save a Named Graph to the Store as this requires deleting any existing Named Graph with this name which failed' see inner exception for more detail"' ex); " is 196.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,SaveGraph,The length of the statement  "		HttpWebRequest request = this.CreateRequest (this._kb + "/" + tID + "/add"' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 140.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,UpdateGraph,The length of the statement  "				HttpWebRequest request = this.CreateRequest (this._kb + "/" + tID + "/remove"' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 143.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,UpdateGraph,The length of the statement  "				HttpWebRequest request = this.CreateRequest (this._kb + "/" + tID + "/add"' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 140.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,DeleteGraph,The length of the statement  "			request = this.CreateRequest (this._kb + "/" + tID + "/clear/?graph-uri=" + Uri.EscapeDataString (graphUri)' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 173.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,DeleteGraph,The length of the statement  "			request = this.CreateRequest (this._kb + "/" + tID + "/clear/?graph-uri=DEFAULT"' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 146.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,ListGraphs,The length of the statement  "		throw new RdfStorageException ("Stardog returned an error while trying to List Graphs' see inner exception for details"' ex); " is 125.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,BeginTransaction,The length of the statement  "	HttpWebRequest request = this.CreateRequest (this._kb + "/transaction/begin"' "text/plain"/*MimeTypesHelper.Any*/' "POST"' new Dictionary<string' string> ()); " is 158.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,CommitTransaction,The length of the statement  "	HttpWebRequest request = this.CreateRequest (this._kb + "/transaction/commit/" + tID' "text/plain"/* MimeTypesHelper.Any*/' "POST"' new Dictionary<string' string> ()); " is 167.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,RollbackTransaction,The length of the statement  "	HttpWebRequest request = this.CreateRequest (this._kb + "/transaction/rollback/" + tID' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 152.
Long Statement,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,DatasetFileManager,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DatasetFileManager.cs,Initialise,The length of the statement  "		IStoreReader reader = MimeTypesHelper.GetStoreParser (MimeTypesHelper.GetMimeType (MimeTypesHelper.GetTrueFileExtension (filename))); " is 133.
Long Statement,VDS.RDF.Storage,DatasetFileManager,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DatasetFileManager.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,UpdateGraph,The length of the statement  "		String graph = (graphUri != null && !graphUri.Equals (String.Empty)) ? "GRAPH <" + this._formatter.FormatUri (graphUri) + "> {" : String.Empty; " is 143.
Long Statement,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,InMemoryManager,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\InMemoryManager.cs,SerializeConfiguration,The length of the statement  "	context.Graph.Assert (manager' rdfType' ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager)); " is 142.
Long Statement,VDS.RDF.Storage,ReadOnlyConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\ReadOnlyConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyGenericManager); " is 127.
Long Statement,VDS.RDF.Storage,ReadOnlyConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\ReadOnlyConnector.cs,SerializeConfiguration,The length of the statement  "	context.Graph.Assert (manager' rdfType' ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager)); " is 142.
Long Statement,VDS.RDF.Storage,ReadOnlyConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\ReadOnlyConnector.cs,SerializeConfiguration,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to serialize configuration as the underlying IGenericIOManager is not serializable"); " is 136.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,Query,The length of the statement  "			throw new RdfQueryException ("Unknown Query Type was used' unable to determine how to process the response from Talis"); " is 120.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,SerializeConfiguration,The length of the statement  "		INode endpointUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyEndpointUri); " is 121.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,SerializeConfiguration,The length of the statement  "		INode defGraphUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyDefaultGraphUri); " is 125.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,SerializeConfiguration,The length of the statement  "		INode namedGraphUri = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyNamedGraphUri); " is 125.
Long Statement,VDS.RDF.Storage,SparqlConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlConnector.cs,SerializeConfiguration,The length of the statement  "		context.Graph.Assert (new Triple (manager' endpointUri' context.Graph.CreateLiteralNode (this._endpoint.Uri.ToString ()))); " is 123.
Long Statement,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,GraphExists,The length of the statement  "		throw new RdfStorageException ("A HTTP Error occurred while trying to check whether a Graph exists in the Store"' webEx); " is 121.
Long Statement,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,UpdateGraph,The length of the statement  "		throw new RdfStorageException ("Unable to Update a Graph since this update requests that Triples be removed from the Graph which the SPARQL Graph Store HTTP Protocol for Graph Management does not support"); " is 206.
Long Statement,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,DeleteGraph,The length of the statement  "		if (webEx.Response == null || (webEx.Response != null && ((HttpWebResponse)webEx.Response).StatusCode != HttpStatusCode.NotFound)) { " is 132.
Long Statement,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,IndexStore,The length of the statement  "		HttpWebRequest request = this.CreateRequest ("repositories/" + this._store + "/indexing"' "*/*"' "POST"' requestParams); " is 120.
Long Statement,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,DeleteStore,The length of the statement  "		HttpWebRequest request = this.CreateRequest ("repositories/" + this._store' "*/*"' "DELETE"' new Dictionary<string' string> ()); " is 128.
Long Statement,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,ToString,The length of the statement  "		return "[AllegroGraph] Store '" + this._store + "' in Catalog '" + this._catalog + "' on Server '" + this._baseUri.Substring (0' this._baseUri.IndexOf ("catalogs/")) + "'"; " is 172.
Long Statement,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,SerializeConfiguration,The length of the statement  "		context.Graph.Assert (new Triple (manager' server' context.Graph.CreateLiteralNode (this._baseUri.Substring (0' this._baseUri.IndexOf ("catalogs/"))))); " is 152.
Long Statement,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,LoadGraph,The length of the statement  "			this._endpoint.QueryWithResultGraph (handler' "CONSTRUCT { ?s ?p ?o } FROM <" + graphUri.Replace (">"' "\\>") + "> WHERE { ?s ?p ?o }"); " is 136.
Long Statement,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,SerializeConfiguration,The length of the statement  "	INode enableUpdates = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyEnableUpdates); " is 125.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,SaveGraph,The length of the statement  "		throw new RdfStorageException ("Unable to save a Graph to the Joseki store - the connector was created in read-only mode"); " is 123.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,SaveGraph,The length of the statement  "		HttpWebRequest request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 130.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,UpdateGraph,The length of the statement  "		throw new RdfStorageException ("Unable to update a Graph in the Joseki store - the connector was created in read-only mode"); " is 125.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,UpdateGraph,The length of the statement  "		HttpWebRequest request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "POST"' new Dictionary<string' string> ()); " is 130.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Update,The length of the statement  "		throw new RdfStorageException ("Unable to perform SPARQL Updates on the Joseki store - the connector was created in read-only mode"); " is 133.
Long Statement,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Query,The length of the statement  "			accept = (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask ? MimeTypesHelper.HttpSparqlAcceptHeader : MimeTypesHelper.HttpAcceptHeader); " is 171.
Long Statement,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Query,The length of the statement  "					throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx); " is 147.
Long Statement,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,SerializeConfiguration,The length of the statement  "	INode genericManager = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassGenericManager); " is 124.
Long Statement,VDS.RDF.Storage,SesameHttpProtocolVersion6Connector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Update,The length of the statement  "		request = this.CreateRequest (this._repositoriesPrefix + this._store + this._updatePath' MimeTypesHelper.Any' "POST"' new Dictionary<String' String> ()); " is 153.
Long Statement,VDS.RDF.Storage,SesameHttpProtocolVersion6Connector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Update,The length of the statement  "					throw new RdfQueryException ("A HTTP error occured while updating the Store.  Store returned the following error message: " + responseText' webEx); " is 147.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessAddCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not provide support for an explicit unnamed Default Graph required to process this command"); " is 153.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessAddCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not provide the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to clear the default graph as the underlying store does not support an explicit default graph"); " is 137.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to clear a named graph as the underlying store does not support named graphs"); " is 120.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "				if ((cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) { " is 189.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to evaluate a CLEAR command as the underlying store does not provide appropriate IO Behaviour to approximate this command"); " is 165.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "						if ((u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) { " is 165.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The length of the statement  "							throw new SparqlUpdateException ("Unable to evaluate a CLEAR command as the underlying store does not provide appropriate IO Behaviour to approximate this command"); " is 165.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCopyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not provide support for an explicit unnamed Default Graph required to process this command"); " is 153.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCopyCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not provide the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCopyCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to process a COPY command as unable to ensure that the Destination Graph was deleted prior to moving the data from the Source Graph"' ex); " is 179.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessCreateCommand,The length of the statement  "			//As Khalil Ahmed pointed out the behaviour when the store doesn't support empty graphs the behaviour should be to act as if the operation succeeded " is 148.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 141.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 139.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "				throw new SparqlUpdateException ("Cannot evaluate an DELETE Command as the underlying Store failed to answer the query for the WHERE portion of the command as expected"); " is 170.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The length of the statement  "			throw new NotSupportedException ("DELETE commands are not supported by this Update Processor as the manager for the underlying Store does not provide Query capabilities which are necessary to process this command"); " is 215.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "			if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 141.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "			if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 139.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "				throw new SparqlUpdateException ("Cannot evaluate a DELETE DATA command where any of the Triple Patterns are not concrete triples - variables are not permitted"); " is 162.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteDataCommand,The length of the statement  "					throw new NotSupportedException ("Graph Specifiers as QNames for DELETE DATA Commands are not supported - please specify an absolute URI instead"); " is 147.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The length of the statement  "				else if ((cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) { " is 194.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to evaluate a DROP command as the underlying store does not provide appropriate IO Behaviour to approximate this command"); " is 164.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The length of the statement  "						else if ((u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) { " is 170.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The length of the statement  "							throw new SparqlUpdateException ("Unable to evaluate a DROP command as the underlying store does not provide appropriate IO Behaviour to approximate this command"); " is 164.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 138.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 136.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "				throw new SparqlUpdateException ("Cannot evaluate an INSERT Command as the underlying Store failed to answer the query for the WHERE portion of the command as expected"); " is 170.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The length of the statement  "			throw new NotSupportedException ("INSERT commands are not supported by this Update Processor as the manager for the underlying Store does not provide Query capabilities which are necessary to process this command"); " is 215.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "			if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 138.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "			if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 136.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "				throw new SparqlUpdateException ("Cannot evaluate an INSERT DATA command where any of the Triple Patterns are not concrete triples - variables are not permitted"); " is 163.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertDataCommand,The length of the statement  "					throw new NotSupportedException ("Graph Specifiers as QNames for INSERT DATA Commands are not supported - please specify an absolute URI instead"); " is 147.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 138.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 136.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessLoadCommand,The length of the statement  "			                    throw new SparqlUpdateException("Executing the LOAD command requires synchronous HTTP requests which are not supported on your platform currently");" is 148.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 141.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 139.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of an explicit unnamed Default Graph required to process this command"); " is 155.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) == 0) " is 138.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the notion of named graphs required to process this command"); " is 134.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "				if ((this._manager.IOBehaviour & IOBehaviour.CanUpdateAddTriples) == 0 && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) == 0) " is 136.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not support the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "				throw new SparqlUpdateException ("Cannot evaluate an INSERT/DELETE Command as the underlying Store failed to answer the query for the WHERE portion of the command as expected"); " is 177.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The length of the statement  "			throw new NotSupportedException ("INSERT/DELETE commands are not supported by this Update Processor as the manager for the underlying Store does not provide Query capabilities which are necessary to process this command"); " is 222.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessMoveCommand,The length of the statement  "					throw new SparqlUpdateException ("The underlying store does not provide support for an explicit unnamed Default Graph required to process this command"); " is 153.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessMoveCommand,The length of the statement  "				throw new SparqlUpdateException ("The underlying store does not provide the required IO Behaviour to implement this command"); " is 126.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessMoveCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to process a MOVE command as unable to ensure that the Destination Graph was deleted prior to moving the data from the Source Graph"' ex); " is 179.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessMoveCommand,The length of the statement  "					throw new SparqlUpdateException ("Unable to process a MOVE command as unable to ensure that the Source Graph was deleted after the movement of data to the Destination Graph"' ex); " is 179.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,IsValidDataPattern,The length of the statement  "		return !p.HasChildGraphPatterns && p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoExplicitVariables); " is 150.
Long Statement,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,IsValidDataPattern,The length of the statement  "		return p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoExplicitVariables) && ((top && p.ChildGraphPatterns.All (gp => IsValidDataPattern (gp' false))) || !p.HasChildGraphPatterns); " is 228.
Long Statement,VDS.RDF.Update,LeviathanUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\LeviathanUpdateProcessor.cs,Flush,The length of the statement  "		throw new SparqlUpdateException ("Unable to commit since one/more Commands executed in the current Transaction failed"); " is 120.
Long Statement,VDS.RDF.Update,LeviathanUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\LeviathanUpdateProcessor.cs,ProcessCommandInternal,The length of the statement  "	ReaderWriterLockSlim currLock = (this._dataset is IThreadSafeDataset) ? ((IThreadSafeDataset)this._dataset).Lock : this._lock; " is 126.
Long Statement,VDS.RDF.Update,LeviathanUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\LeviathanUpdateProcessor.cs,ProcessCommandSet,The length of the statement  "	ReaderWriterLockSlim currLock = (this._dataset is IThreadSafeDataset) ? ((IThreadSafeDataset)this._dataset).Lock : this._lock; " is 126.
Long Statement,VDS.RDF.Update,SparqlUpdateEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlUpdateEvaluationContext.cs,CalculateTimeout,The length of the statement  "			if (Options.UpdateExecutionTimeout == 0 || (this._commands.Timeout <= Options.UpdateExecutionTimeout && Options.UpdateExecutionTimeout > 0)) { " is 142.
Long Statement,VDS.RDF.Update,SparqlUpdateEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlUpdateEvaluationContext.cs,CheckTimeout,The length of the statement  "			throw new SparqlUpdateTimeoutException ("Update Execution Time exceeded the Timeout of " + this._timeout + "ms' updates aborted after " + this._timer.ElapsedMilliseconds + "ms"); " is 178.
Long Statement,VDS.RDF.Update,SparqlUpdateEvaluationContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlUpdateEvaluationContext.cs,CheckTimeout,The length of the statement  "                    throw new SparqlUpdateTimeoutException("Update Execution Time exceeded the Timeout of " + this._timeout + "ms' updates aborted after " + elapsed.Milliseconds + "ms");" is 166.
Long Statement,VDS.RDF.Update.Protocol,BaseProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\BaseProtocolProcessor.cs,ResolveGraphUri,The length of the statement  "				throw new SparqlHttpProtocolUriResolutionException ("Graph URIs specified using the ?graph parameter must be absolute URIs"); " is 125.
Long Statement,VDS.RDF.Update.Protocol,BaseProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\BaseProtocolProcessor.cs,ResolveGraphUri,The length of the statement  "		else if (context.Request.QueryString.AllKeys.Contains ("default") || Regex.IsMatch (context.Request.QueryString.ToString ()' DefaultParameterPattern)) { " is 152.
Long Statement,VDS.RDF.Update.Protocol,BaseProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\BaseProtocolProcessor.cs,ResolveGraphUri,The length of the statement  "				throw new SparqlHttpProtocolUriResolutionException ("Graph URIs specified using the ?graph parameter must be absolute URIs"); " is 125.
Long Statement,VDS.RDF.Update.Protocol,BaseProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\BaseProtocolProcessor.cs,ResolveGraphUri,The length of the statement  "		else if (context.Request.QueryString.AllKeys.Contains ("default") || Regex.IsMatch (context.Request.QueryString.ToString ()' DefaultParameterPattern)) { " is 152.
Long Statement,VDS.RDF.Update.Protocol,BaseProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\BaseProtocolProcessor.cs,SendResultsToClient,The length of the statement  "	MimeTypeDefinition definition = MimeTypesHelper.GetDefinitions (HandlerHelper.GetAcceptTypes (context)).FirstOrDefault (d => d.CanWriteRdf); " is 140.
Long Statement,VDS.RDF.Update.Protocol,GenericProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\GenericProtocolProcessor.cs,HasGraph,The length of the statement  "			throw new SparqlHttpProtocolException ("Failed to retrieve a Boolean Result since the query processor did not return a valid SPARQL Result Set as expected"); " is 157.
Long Statement,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,GetGraph,The length of the statement  "		throw new SparqlHttpProtocolException ("Failed to retrieve a Graph since the query processor did not return a valid Graph as expected"); " is 136.
Long Statement,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,HasGraph,The length of the statement  "		throw new SparqlHttpProtocolException ("Failed to retrieve a Boolean Result since the query processor did not return a valid SPARQL Result Set as expected"); " is 157.
Long Statement,VDS.RDF.Writing,BaseGZipWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\BaseGZipWriter.cs,Save,The length of the statement  "	this.Save (g' new StreamWriter (new GZipStream (new FileStream (filename' FileMode.OpenOrCreate' FileAccess.Write)' CompressionMode.Compress))); " is 144.
Long Statement,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,Save,The length of the statement  "		CompressingTurtleWriterContext context = new CompressingTurtleWriterContext (g' output' this._compressionLevel' this._prettyprint' this._allowHiSpeed' this._syntax); " is 165.
Long Statement,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateOutput,The length of the statement  "				context.Output.WriteLine ("@prefix " + prefix + ": <" + context.UriFormatter.FormatUri (context.Graph.NamespaceMap.GetNamespaceUri (prefix)) + ">."); " is 149.
Long Statement,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateOutput,The length of the statement  "				context.Output.WriteLine ("@prefix : <" + context.UriFormatter.FormatUri (context.Graph.NamespaceMap.GetNamespaceUri (String.Empty)) + ">."); " is 141.
Long Statement,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,The length of the statement  "				output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent)); " is 123.
Long Statement,VDS.RDF.Writing,BaseGZipResultsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\BaseGZipResultsWriter.cs,Save,The length of the statement  "	this.Save (results' new StreamWriter (new GZipStream (new FileStream (filename' FileMode.OpenOrCreate' FileAccess.Write)' CompressionMode.Compress))); " is 150.
Long Statement,VDS.RDF.Writing,FolderStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FolderStoreWriter.cs,Save,The length of the statement  "		RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("Folder Store")); " is 130.
Long Statement,VDS.RDF.Writing,SparqlHtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlHtmlWriter.cs,GenerateOutput,The length of the statement  "	QNameOutputMapper qnameMapper = new QNameOutputMapper (this._namespaces != null ? this._namespaces : new NamespaceMapper (true)); " is 129.
Long Statement,VDS.RDF.Writing,SparqlHtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlHtmlWriter.cs,GenerateOutput,The length of the statement  "	writer.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"); " is 143.
Long Statement,VDS.RDF.Writing,SparqlJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlJsonWriter.cs,GenerateOutput,The length of the statement  "					throw new RdfOutputException ("Result Sets which contain Graph Literal Nodes cannot be serialized in the SPARQL Query Results JSON Format"); " is 140.
Long Statement,VDS.RDF.Writing,SparqlJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlJsonWriter.cs,GenerateOutput,The length of the statement  "					throw new RdfOutputException ("Result Sets which contain Nodes of unknown Type cannot be serialized in the SPARQL Query Results JSON Format"); " is 142.
Long Statement,VDS.RDF.Writing,SparqlXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlXmlWriter.cs,GenerateOutput,The length of the statement  "						throw new RdfOutputException ("Result Sets which contain Graph Literal Nodes cannot be serialized in the SPARQL Query Results XML Format"); " is 139.
Long Statement,VDS.RDF.Writing,SparqlXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlXmlWriter.cs,GenerateOutput,The length of the statement  "						throw new RdfOutputException ("Result Sets which contain Nodes of unknown Type cannot be serialized in the SPARQL Query Results XML Format"); " is 141.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The length of the statement  "		context = new TriGWriterContext (store' ((StreamParams)parameters).StreamWriter' this._prettyprint' this._allowHiSpeed' this._compressionLevel' this._n3compat); " is 160.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The length of the statement  "		context = new TriGWriterContext (store' ((TextWriterParams)parameters).TextWriter' this._prettyprint' this._allowHiSpeed' this._compressionLevel' this._n3compat); " is 162.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The length of the statement  "					context.Output.WriteLine ("@prefix " + prefix + ": <" + context.FormatUri (context.NamespaceMap.GetNamespaceUri (prefix)) + ">."); " is 130.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The length of the statement  "			RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("TriG")); " is 122.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The length of the statement  "					TurtleWriterContext graphContext = new TurtleWriterContext (g' new System.IO.StringWriter ()' context.PrettyPrint' context.HighSpeedModePermitted); " is 147.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateGraphOutput,The length of the statement  "		if (globalContext.CompressionLevel > WriterCompressionLevel.None && globalContext.QNameMapper.ReduceToQName (context.Graph.BaseUri.ToString ()' out gname)) { " is 157.
Long Statement,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,SaveGraphs,The length of the statement  "			TurtleWriterContext context = new TurtleWriterContext (g' new System.IO.StringWriter ()' globalContext.PrettyPrint' globalContext.HighSpeedModePermitted); " is 154.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateOutput,The length of the statement  "				context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)kvp.Key).InternalID)); " is 147.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The length of the statement  "					context.Writer.WriteStartElement (uriref.Substring (0' uriref.IndexOf (':'))' uriref.Substring (uriref.IndexOf (':') + 1)' tempUri); " is 132.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The length of the statement  "				context.Writer.WriteStartElement (uriref.Substring (0' uriref.IndexOf (':'))' uriref.Substring (uriref.IndexOf (':') + 1)' ns); " is 127.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The length of the statement  "			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)subj).InternalID)); " is 144.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSimpleLiteralAttributes,The length of the statement  "			context.Writer.WriteAttributeString (uriref.Substring (0' uriref.IndexOf (':'))' uriref.Substring (uriref.IndexOf (':') + 1)' ns' t.Object.ToString ()); " is 152.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GeneratePredicateOutput,The length of the statement  "		context.Writer.WriteStartElement (uriref.Substring (0' uriref.IndexOf (':'))' uriref.Substring (uriref.IndexOf (':') + 1)' ns); " is 127.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateObjectOutput,The length of the statement  "			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)t.Object).InternalID)); " is 148.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateObjectOutput,The length of the statement  "				context.Writer.WriteAttributeString ("rdf"' "datatype"' NamespaceMapper.RDF' Uri.EscapeUriString (lit.DataType.ToString ())); " is 125.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateObjectOutput,The length of the statement  "		context.Writer.WriteAttributeString ("rdf"' "resource"' NamespaceMapper.RDF' Uri.EscapeUriString (t.Object.ToString ())); " is 121.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateCollectionOutput,The length of the statement  "			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID)); " is 143.
Long Statement,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateTemporaryNamespace,The length of the statement  "	while (context.NamespaceMap.HasNamespace ("ns" + context.NextNamespaceID) && (context.NamespaceMap.GetNestingLevel ("ns" + context.NextNamespaceID) == 0 || context.NamespaceMap.GetNestingLevel ("ns" + context.NextNamespaceID) == context.NamespaceMap.NestingLevel)) { " is 266.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	INode ontoNode = context.Graph.GetTriplesWithPredicateObject (rdfType' ontology).Select (t => t.Subject).FirstOrDefault (); " is 123.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	INode ontoLabel = (ontoNode != null) ? context.Graph.GetTriplesWithSubjectPredicate (ontoNode' rdfsLabel).Select (t => t.Object).FirstOrDefault () : null; " is 154.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	context.HtmlWriter.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\" \"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd\">"); " is 137.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "		getOntoDescrip.CommandText = "SELECT * WHERE { @onto a owl:Ontology . OPTIONAL { @onto rdfs:comment ?description } . OPTIONAL { @onto vann:preferredNamespacePrefix ?nsPrefix ; vann:preferredNamespaceUri ?nsUri } . OPTIONAL { @onto dc:creator ?creator . ?creator (foaf:name | rdfs:label) ?creatorName } }"; " is 305.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "							context.HtmlWriter.AddAttribute (HtmlTextWriterAttribute.Href' context.QNameMapper.GetNamespaceUri (prefix).ToString ()); " is 121.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "							context.HtmlWriter.WriteEncodedText ("<rdf:RDF xmlns:rdf=\"" + NamespaceMapper.RDF + "\" xmlns:" + prefix + "=\"" + context.UriFormatter.FormatUri (context.QNameMapper.GetNamespaceUri (prefix)) + "\">"); " is 203.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "							context.HtmlWriter.WriteEncodedText ("@prefix " + prefix + ": <" + context.UriFormatter.FormatUri (context.QNameMapper.GetNamespaceUri (prefix)) + "> ."); " is 154.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "							context.HtmlWriter.WriteEncodedText ("PREFIX " + prefix + ": <" + context.UriFormatter.FormatUri (context.QNameMapper.GetNamespaceUri (prefix)) + ">"); " is 151.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				throw new RdfOutputException ("Tried to make a SPARQL Query to determine Schema Information but an unexpected Query Result was returned"); " is 138.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "			throw new RdfOutputException ("Tried to make a SPARQL Query to determine Schema Information but a Query Error occurred"' queryEx); " is 130.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getPropertyRanges.CommandText = "SELECT ?range WHERE { { @property rdfs:range ?range . FILTER(ISURI(?range)) } UNION { @property rdfs:range ?union . ?union owl:unionOf ?ranges . { ?ranges rdf:first ?range } UNION { ?ranges rdf:rest+/rdf:first ?range } } }"; " is 257.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getPropertyDomains.CommandText = "SELECT ?domain WHERE { { @property rdfs:domain ?domain . FILTER(ISURI(?domain)) } UNION { @property rdfs:domain ?union . ?union owl:unionOf ?domains . { ?domains rdf:first ?domain } UNION { ?domains rdf:rest+/rdf:first ?domain } } }"; " is 268.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getClasses.CommandText = "SELECT DISTINCT ?class WHERE { { ?class a rdfs:Class } UNION { ?class a owl:Class } FILTER(ISURI(?class)) } ORDER BY ?class"; " is 151.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "			throw new RdfOutputException ("Tried to make a SPARQL Query to find Classes in the Schema but an unexpected Query Result was returned"); " is 136.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "		throw new RdfOutputException ("Tried to make a SPARQL Query to find Classes in the Schema but a Query Error occurred"' queryEx); " is 128.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getProperties.CommandText = "SELECT DISTINCT ?property WHERE { { ?property a rdf:Property } UNION { ?property a owl:DatatypeProperty } UNION { ?property a owl:ObjectProperty } FILTER(ISURI(?property)) } ORDER BY ?property"; " is 223.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "			throw new RdfOutputException ("Tried to make a SPARQL Query to find Properties in the Schema but an unexpected Query Result was returned"); " is 139.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "		throw new RdfOutputException ("Tried to make a SPARQL Query to find Properties in the Schema but a Query Error occurred"' queryEx); " is 131.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	IUriNode owlEquivalentClass = context.Graph.CreateUriNode (UriFactory.Create (NamespaceMapper.OWL + "equivalentClass")); " is 120.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	IUriNode owlEquivalentProperty = context.Graph.CreateUriNode (UriFactory.Create (NamespaceMapper.OWL + "equivalentProperty")); " is 126.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getClasses.CommandText = "SELECT ?class (SAMPLE(?label) AS ?classLabel) (SAMPLE(?description) AS ?classDescription) WHERE { { ?class a rdfs:Class } UNION { ?class a owl:Class } FILTER(ISURI(?class)) OPTIONAL { ?class rdfs:label ?label } OPTIONAL { ?class rdfs:comment ?description } } GROUP BY ?class ORDER BY ?class"; " is 318.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				ts = context.Graph.GetTriplesWithSubjectPredicate (r ["class"]' owlEquivalentClass).Concat (context.Graph.GetTriplesWithPredicateObject (owlEquivalentClass' r ["class"])); " is 171.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Equivalent Classes"' ts' t => t.Subject.Equals (r ["class"]) ? t.Object : t.Subject); " is 130.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				ts = context.Graph.GetTriplesWithSubjectPredicate (r ["class"]' owlDisjointClass).Concat (context.Graph.GetTriplesWithPredicateObject (owlDisjointClass' r ["class"])); " is 167.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Disjoint Classes"' ts' t => t.Subject.Equals (r ["class"]) ? t.Object : t.Subject); " is 128.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "			throw new RdfOutputException ("Tried to make a SPARQL Query to get Class Information from the Schema but an unexpected Query Result was returned"); " is 147.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "		throw new RdfOutputException ("Tried to make a SPARQL Query to get Class Information from the Schema but a Query Error occurred"' queryEx); " is 139.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "	getProperties.CommandText = "SELECT ?property (SAMPLE(?label) AS ?propertyLabel) (SAMPLE(?description) AS ?propertyDescription) WHERE { { ?property a rdf:Property } UNION { ?property a owl:ObjectProperty } UNION { ?property a owl:DatatypeProperty } FILTER(ISURI(?property)) OPTIONAL { ?property rdfs:label ?label } OPTIONAL { ?property rdfs:comment ?description } } GROUP BY ?property ORDER BY ?property"; " is 405.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Has Domain"' context.Graph.ExecuteQuery (getPropertyDomains) as SparqlResultSet' "domain"); " is 136.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Has Range"' context.Graph.ExecuteQuery (getPropertyRanges) as SparqlResultSet' "range"); " is 133.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				ts = context.Graph.GetTriplesWithSubjectPredicate (r ["property"]' owlEquivalentProperty).Concat (context.Graph.GetTriplesWithPredicateObject (owlEquivalentProperty' r ["property"])); " is 183.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Equivalent Properties"' ts' t => t.Subject.Equals (r ["property"]) ? t.Object : t.Subject); " is 136.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				ts = context.Graph.GetTriplesWithSubjectPredicate (r ["property"]' owlInverseProperty).Concat (context.Graph.GetTriplesWithPredicateObject (owlInverseProperty' r ["property"])); " is 177.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "				this.GenerateCaptionedInformation (context' "Inverse Property"' ts' t => t.Subject.Equals (r ["property"]) ? t.Object : t.Subject); " is 131.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "			throw new RdfOutputException ("Tried to make a SPARQL Query to get Property Information from the Schema but an unexpected Query Result was returned"); " is 150.
Long Statement,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The length of the statement  "		throw new RdfOutputException ("Tried to make a SPARQL Query to get Property Information from the Schema but a Query Error occurred"' queryEx); " is 142.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "			context.Writer.WriteRaw (Uri.EscapeUriString (WriterHelper.EncodeForXml (context.NamespaceMap.GetNamespaceUri (prefix).ToString ()))); " is 134.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "			context.Writer.WriteRaw (Uri.EscapeUriString (WriterHelper.EncodeForXml (context.NamespaceMap.GetNamespaceUri (prefix).ToString ()))); " is 134.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "					context.Writer.WriteStartElement (tref.Substring (0' tref.IndexOf (':'))' tref.Substring (tref.IndexOf (':') + 1)' null); " is 121.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "					context.Writer.WriteAttributeString ("rdf"' "nodeID"' null' context.BlankNodeMapper.GetOutputID (((IBlankNode)t.Subject).InternalID)); " is 134.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "				context.Writer.WriteAttributeString ("rdf"' "nodeID"' null' context.BlankNodeMapper.GetOutputID (((IBlankNode)t.Object).InternalID)); " is 133.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "					context.Writer.WriteStartElement (tref.Substring (0' tref.IndexOf (':'))' tref.Substring (tref.IndexOf (':') + 1)' null); " is 121.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateOutput,The length of the statement  "				context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)pair.Key).InternalID)); " is 148.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The length of the statement  "				context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)next).InternalID)); " is 144.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The length of the statement  "			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID)); " is 143.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The length of the statement  "						context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID)); " is 143.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateUriOutput,The length of the statement  "		context.Writer.WriteStartAttribute (attribute.Substring (0' attribute.IndexOf (':'))' attribute.Substring (attribute.IndexOf (':') + 1)' NamespaceMapper.RDF); " is 158.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateTemporaryNamespace,The length of the statement  "	while (context.NamespaceMap.HasNamespace ("ns" + context.NextNamespaceID) && (context.NamespaceMap.GetNestingLevel ("ns" + context.NextNamespaceID) == 0 || context.NamespaceMap.GetNestingLevel ("ns" + context.NextNamespaceID) == context.NamespaceMap.NestingLevel)) { " is 266.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateElement,The length of the statement  "			String ns = (context.NamespaceMap.GetNestingLevel (prefix) > 1) ? context.NamespaceMap.GetNamespaceUri (prefix).ToString () : null; " is 131.
Long Statement,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,FindTypeReferences,The length of the statement  "	where (t.Subject.NodeType == NodeType.Blank || t.Subject.NodeType == NodeType.Uri) && t.Predicate.Equals (rdfType) && t.Object.NodeType == NodeType.Uri && !context.TriplesDone.Contains (t) " is 188.
Long Statement,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateOutput,The length of the statement  "	context.HtmlWriter.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML+RDFa 1.0//EN\" \"http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd\">"); " is 137.
Long Statement,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,The length of the statement  "					context.HtmlWriter.AddAttribute ("xmlns:" + ns' context.UriFormatter.FormatUri (context.QNameMapper.GetNamespaceUri (ns))); " is 123.
Long Statement,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,The length of the statement  "					this.RaiseWarning ("Cannot serialize a Triple since the Predicate cannot be reduced to a QName: " + t.Predicate.ToString ()); " is 125.
Long Statement,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,The length of the statement  "						this.RaiseWarning ("Cannot serialize a Triple since the Object is not a URI/Blank/Literal Node: " + t.Object.ToString ()); " is 122.
Long Statement,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,GenerateNodeOutput,The length of the statement  "					context.HtmlWriter.AddAttribute ("xmlns:" + ns' context.UriFormatter.FormatUri (context.QNameMapper.GetNamespaceUri (ns))); " is 123.
Long Statement,VDS.RDF.Writing,CsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CsvWriter.cs,Save,The length of the statement  "		RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("CSV")); " is 121.
Long Statement,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateUriRef,The length of the statement  "	if (context.Graph.NamespaceMap.ReduceToQName (u.Uri.ToString ()' out qname) && RdfXmlSpecsHelper.IsValidQName (qname)) { " is 120.
Long Statement,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateElement,The length of the statement  "			return doc.CreateElement (qname' context.Graph.NamespaceMap.GetNamespaceUri (qname.Substring (0' qname.IndexOf (':'))).ToString ()); " is 132.
Long Statement,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,GenerateAttribute,The length of the statement  "			return doc.CreateAttribute (qname' context.Graph.NamespaceMap.GetNamespaceUri (qname.Substring (0' qname.IndexOf (':'))).ToString ()); " is 134.
Long Statement,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,FindTypeReferences,The length of the statement  "	where (t.Subject.NodeType == NodeType.Blank || t.Subject.NodeType == NodeType.Uri) && t.Predicate.Equals (rdfType) && t.Object.NodeType == NodeType.Uri && !context.TriplesDone.Contains (t) " is 188.
Long Statement,VDS.RDF.Writing,GenericStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\GenericStoreWriter.cs,Save,The length of the statement  "		RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("TSV")); " is 121.
Long Statement,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,Save,The length of the statement  "		CompressingTurtleWriterContext context = new CompressingTurtleWriterContext (g' output' this._compressionLevel' this._prettyprint' this._allowHiSpeed); " is 151.
Long Statement,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,The length of the statement  "				context.Output.WriteLine ("@prefix " + prefix + ": <" + context.UriFormatter.FormatUri (context.Graph.NamespaceMap.GetNamespaceUri (prefix)) + ">."); " is 149.
Long Statement,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,The length of the statement  "				context.Output.WriteLine ("@prefix : <" + context.UriFormatter.FormatUri (context.Graph.NamespaceMap.GetNamespaceUri (String.Empty)) + ">."); " is 141.
Long Statement,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateNodeOutput,The length of the statement  "		CompressingTurtleWriterContext subcontext = new CompressingTurtleWriterContext (glit.SubGraph' new System.IO.StringWriter (temp)); " is 130.
Long Statement,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,The length of the statement  "				output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent)); " is 123.
Long Statement,VDS.RDF.Writing,NQuadsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NQuadsWriter.cs,Save,The length of the statement  "				RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("TSV")); " is 121.
Long Statement,VDS.RDF.Writing,NQuadsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NQuadsWriter.cs,SaveGraphs,The length of the statement  "			NTriplesWriterContext context = new NTriplesWriterContext (g' new System.IO.StringWriter ()' globalContext.PrettyPrint' globalContext.HighSpeedModePermitted); " is 158.
Long Statement,VDS.RDF.Writing,RdfJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfJsonWriter.cs,Save,The length of the statement  "		this.RaiseWarning ("RDF/JSON does not contain any Namespace information.  If you read this serialized data back in at a later date you may not be able to reserialize it to Namespace reliant formats (like RDF/XML)"); " is 215.
Long Statement,VDS.RDF.Writing,SparqlRdfWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlRdfWriter.cs,GenerateOutput,The length of the statement  "		g.Assert (new Triple (rset' boolean' g.CreateLiteralNode (results.Result.ToString ()' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean)))); " is 149.
Long Statement,VDS.RDF.Writing,TsvStoreWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TsvWriter.cs,Save,The length of the statement  "		RdfThreadedOutputException outputEx = new RdfThreadedOutputException (WriterErrorMessages.ThreadedOutputFailure ("TSV")); " is 121.
Long Statement,VDS.RDF.Parsing.Handlers,WriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartRdfInternal,The length of the statement  "		throw new RdfParseException ("Cannot use this WriteThroughHandler as an RDF Handler for parsing as you set closeOnEnd to true and you have already used this Handler and so the provided TextWriter was closed"); " is 209.
Long Statement,VDS.RDF.Parsing.Handlers,WriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartRdfInternal,The length of the statement  "			throw new RdfParseException ("Unable to instantiate a ITripleFormatter from the given Formatter Type " + this._formatterType.FullName); " is 135.
Long Statement,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartResultsInternal,The length of the statement  "		throw new RdfParseException ("Cannot use this ResultWriteThroughHandler as an Results Handler for parsing as you set closeOnEnd to true and you have already used this Handler and so the provided TextWriter was closed"); " is 219.
Long Statement,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartResultsInternal,The length of the statement  "			throw new RdfParseException ("Unable to instantiate a IResultFormatter from the given Formatter Type " + this._formatterType.FullName); " is 135.
Long Statement,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,HandleBooleanResultInternal,The length of the statement  "		throw new RdfParseException ("Cannot handle a Boolean Result when the handler has already handled other types of results"); " is 123.
Long Statement,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,HandleResultInternal,The length of the statement  "		this._writer.WriteLine (((IResultSetFormatter)this._formatter).FormatResultSetHeader (this._currVariables.Distinct ())); " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,ConsumeCharacter,The length of the statement  "		throw Error ("Unexpected End of Stream while trying to tokenise from the following input:\n" + this._output.ToString ()); " is 121.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,SkipCharacter,The length of the statement  "		throw Error ("Unexpected End of Stream while trying to tokenise from the following input:\n" + this._output.ToString ()); " is 121.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The length of the statement  "			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits"); " is 225.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The length of the statement  "			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits"); " is 226.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The length of the statement  "			throw Error ("Unexpected Backslash Character encountered in a QName' the Backslash Character can only be used for Unicode escapes (\\u and \\U) in QNames"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits"); " is 225.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits"); " is 226.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The length of the statement  "			throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names"); " is 227.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The length of the statement  "			throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character"); " is 179.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,Error,The length of the statement  "		return new RdfParseException ("[Line " + this._currline + " Column " + this._currpos + "] " + String.Format (detail' this._format)' this._currline' this._currpos); " is 163.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,Error,The length of the statement  "		return new RdfParseException ("[Line " + this._currline + " Column " + this._currpos + "] " + detail' this._currline' this._currpos); " is 133.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,UnexpectedEndOfInput,The length of the statement  "	error.Append ("[Line " + this._startline + " Column " + this._startpos + " to Line " + this._currline + " Column " + this._currpos + "] Unexpected end of input while trying to parse " + expected); " is 196.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,UnexpectedNewLine,The length of the statement  "	error.AppendLine ("[Line " + this._startline + " Column " + this._startpos + " to Line " + this._currline + " Column " + this._currpos + "] Unexpected new line while trying to parse " + expected + " from content:"); " is 215.
Long Statement,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,UnexpectedToken,The length of the statement  "	error.Append ("[Line " + t.StartLine + " Column " + t.StartPosition + " to Line " + t.EndLine + " Column " + t.EndPosition + "] Unexpected Token parsed " + expected); " is 166.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,GetNextToken,The length of the statement  "							throw Error ("Unexpected Character (Code " + (int)next + ") " + (char)next + " was encountered' expected the second ^ as part of a ^^ Data Type Specifier"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetPrefix,The length of the statement  "		throw new RdfParseException ("The value '" + this.Value + "' is not a valid Prefix in TriG"' new PositionInfo (this.StartLine' this.CurrentLine' this.StartPosition' this.EndPosition)); " is 184.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetKeywordOrLangSpec,The length of the statement  "		throw Error ("Unexpected Content '" + output + "' encountered' expected an @prefix/@base keyword or a Language Specifier"); " is 123.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetNumericLiteral,The length of the statement  "	while (Char.IsDigit (next) || next == '-' || next == '+' || (next == '.' && !dotoccurred) || next == 'e' || next == 'E') { " is 122.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character " + next + " encountered while parsing a Numeric Literal from input '" + this.Value + "'' a +/- to specify sign has already occurred in this Numeric Literal"); " is 194.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character " + next + " encountered while parsing a Numeric Literal from input '" + this.Value + "'' a e/E to specify exponent has already occurred in this Numeric Literal"); " is 198.
Long Statement,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetDataType,The length of the statement  "			throw Error ("Unexpected Token '" + qname.GetType ().ToString () + "' parsed when a QName Token to specify a Data Type was expected"); " is 134.
Long Statement,VDS.RDF.Parsing.Tokens,TokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,PrintTrace,The length of the statement  "	Console.WriteLine ("[Lines " + t.StartLine + "-" + t.EndLine + " Columns " + t.StartPosition + "-" + t.EndPosition + "] " + t.GetType ().Name + " " + t.Value); " is 159.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,The length of the statement  "						if (this.LastTokenType == Token.SELECT || this.LastTokenType == Token.DISTINCT || this.LastTokenType == Token.REDUCED) { " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,The length of the statement  "							//throw Error("Unexpected Character (Code " + (int)next + ") " + (char)next + " was encountered after a ^ character' expected a ^^ for a Data Type specifier"); " is 159.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,The length of the statement  "							throw Error ("Unexpected Character (Code " + (int)next + ") " + (char)next + " was encountered while trying to parse a Logical And operator"); " is 142.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,GetNextToken,The length of the statement  "							//throw Error("Unexpected Character (Code " + (int)next + ") " + (char)next + " was encountered while trying to parse a Logical Or operator"); " is 142.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrologueOrQueryKeyword,The length of the statement  "				throw Error ("Unexpected Update Keyword '" + value + "' encountered while trying to parse the Query Prologue' expected an Update Keyword which can start an Update Command"); " is 173.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrologueOrQueryKeyword,The length of the statement  "			throw Error ("Unexpected String '" + value + "' encountered while trying to parse the Query Prologue' expected a Base Declaration' Prefix Declaration or a Query/Update Keyword"); " is 178.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrologueOrQueryKeyword,The length of the statement  "		throw Error ("Unexpected String '" + value + "' encountered while trying to parse the Query Prologue' expected a Base Declaration' Prefix Declaration or a Query/Update Keyword"); " is 178.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrefix,The length of the statement  "		throw new RdfParseException ("Didn't find expected : Character while attempting to parse Prefix at content:\n" + this.Value + "\nPrefixes must end in a Colon Character"' this.StartLine' this.CurrentLine' this.StartPosition' this.CurrentPosition); " is 246.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetPrefix,The length of the statement  "		throw new RdfParseException ("The value '" + this.Value + "' is not a valid Prefix in SPARQL"' new PositionInfo (this.StartLine' this.CurrentLine' this.StartPosition' this.EndPosition)); " is 186.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetUri,The length of the statement  "			throw Error ("Ambigious syntax in string '" + this.Value + "'' the Tokeniser is unable to determine whether a Less Than or a URI was intended"); " is 144.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQName,The length of the statement  "	while (UnicodeSpecsHelper.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterModifier (next) || next == '_' || next == '-' || next == ':' || next == '.' || next == '\\' || next == '%') { " is 188.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQName,The length of the statement  "		return new QNameToken (SparqlSpecsHelper.UnescapeQName (value)' this.CurrentLine' this.StartPosition' this.EndPosition); " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "	while (UnicodeSpecsHelper.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterModifier (next) || next == '_' || next == '-' || next == ':' || next == '.' || next == '\\' || next == '%') { " is 188.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "	if (!colonoccurred && (SparqlSpecsHelper.IsNonQueryKeyword (value) || SparqlSpecsHelper.IsFunctionKeyword (value) || SparqlSpecsHelper.IsAggregateKeyword (value) || SparqlSpecsHelper.IsUpdateKeyword (value))) { " is 210.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "			throw Error ("Unexpected String '" + value + "' encountered while trying to parse a SPARQL Keyword.  This appears to be an attempt to use a sub-query but sub-queries are not supported in SPARQL 1.0"); " is 200.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "			throw Error ("Unexpected String '" + value + "' encountered while trying to parse a SPARQL Keyword.  This appears to be an attempt to use an ASK/CONSTRUCT/DESCRIBE as a sub-query which is not supported"); " is 204.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "	//else if (!colonoccurred && (this.LastTokenType == Token.ORDERBY || (/*this._orderByKeywordSeen && */this.LastTokenType == Token.RIGHTBRACKET))) " is 145.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "		//    throw Error("Unexpected String '" + value + "' encountered after an Order By which is not a valid QName/Keyword"); " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The length of the statement  "		return new QNameToken (SparqlSpecsHelper.UnescapeQName (value)' this.CurrentLine' this.StartPosition' this.EndPosition); " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrNumericLiteral,The length of the statement  "	while (UnicodeSpecsHelper.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterModifier (next) || next == '_' || next == '-' || next == ':' || next == '\\' || (next == '.' && !dotoccurred && !colonoccurred) || next == '+' || next == '-' || next == '%') { " is 254.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrNumericLiteral,The length of the statement  "			return new QNameToken (SparqlSpecsHelper.UnescapeQName (value)' this.CurrentLine' this.StartPosition' this.EndPosition); " is 120.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetLiteral,The length of the statement  "				throw Error ("Unexpected New Line while trying to Parse a Quoted Literal from content:\n" + this.Value + "\nTo use New Lines you must use the Triple Quote Long Literal syntax"); " is 177.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + ") +\nThe plus sign can only occur once at the Start of a Numeric Literal and once immediately after the 'e' exponent specifier' if this was intended as an additive operator please insert space to disambiguate this"); " is 274.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + ") -\nThe minus sign can only occur once at the Start of a Numeric Literal' if this was intended as a subtractive operator please insert space to disambiguate this"); " is 223.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw Error ("Unexpected Character (Code " + (int)next + ") -\nThe minus sign can only occur at the Start of a Numeric Literal and once immediately after the 'e' exponent specifier' if this was intended as a subtractive operator please insert space to disambiguate this"); " is 272.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier can only occur once in a Numeric Literal"); " is 128.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier cannot occur at the start of a Numeric Literal"); " is 134.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetDataType,The length of the statement  "			throw Error ("Unexpected Token '" + temp.GetType ().ToString () + "' was produced when a QName for a Data Type was expected!"); " is 127.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetDataType,The length of the statement  "		throw Error ("Unexpected Character (Code " + (int)next + " " + next + "\nExpected a < to start a URI or a valid start character for a QName to specify Data Type"); " is 163.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetLangSpec,The length of the statement  "		throw Error ("Unexpected Character (Code " + (int)'@' + ") @ encountered' the @ character can only be used as part of a Language Specifier after a Literal/Long Literal"); " is 170.
Long Statement,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetVariable,The length of the statement  "	while (Char.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterOrDigit (next) || next == '-' || next == '_' || next == '\\') { " is 128.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The length of the statement  "	while (Char.IsDigit (next) || next == '-' || next == '+' || next == 'e' || next == 'E' || (next == '.' && !dotoccurred)) { " is 122.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The length of the statement  "						throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent"); " is 130.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent"); " is 130.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent"); " is 130.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier can only occur once in a Numeric Literal"); " is 128.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetKeywordOrLangSpec,The length of the statement  "					throw Error ("Unexpected Character (Code " + (int)next + " -\nThe hyphen character can only be used once in a Language Specifier"); " is 131.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetKeywordOrLangSpec,The length of the statement  "		throw Error ("Unexpected Character (Code " + (int)'@' + " @\nThe @ sign cannot be used to specify a Language on a Plain Literal"); " is 130.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetKeywordDefinition,The length of the statement  "			throw Error ("Unexpected New Line encountered in a Keywords Directive.  A Keywords Directive must be terminated by a . Line Terminator character"); " is 147.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetPrefix,The length of the statement  "		throw new RdfParseException ("Didn't find expected : Character while attempting to parse Prefix at content:\n" + this.Value + "\nPrefixes must end in a Colon Character"' this.StartLine' this.CurrentLine' this.StartPosition' this.CurrentPosition); " is 246.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetUri,The length of the statement  "			throw Error ("Ambigious syntax in string '" + this.Value + "'' the Tokeniser is unable to determine whether an Implied By or a URI was intended"); " is 146.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetQName,The length of the statement  "		throw Error ("The value '" + value + "' is not valid as a QName since it doesn't contain a Colon Character and the Namespace is thus not determinable"); " is 152.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetLiteral,The length of the statement  "								throw Error ("Too many \" characters encountered at the end of a long literal - ensure that you have escaped quotes in a long literal to avoid this error"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetLiteral,The length of the statement  "				throw Error ("Unexpected New Line while trying to Parse a Quoted Literal from content:\n" + this.Value + "\nTo use New Lines you must use the Triple Quote Long Literal syntax"); " is 177.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetDataTypeOrPath,The length of the statement  "			throw Error ("Unexpected ^^ sequence for specifying a DataType was encountered' the DataType cannot be specified for Plain Literals"); " is 134.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetDataTypeOrPath,The length of the statement  "			throw Error ("Unexpected ^^ sequence for specifying a DataType was encountered' the DataType specifier can only be used after a Quoted Literal"); " is 145.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetDataType,The length of the statement  "			throw Error ("Unexpected Token '" + temp.GetType ().ToString () + "' was produced when a QName for a Data Type was expected!"); " is 127.
Long Statement,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetDataType,The length of the statement  "		throw Error ("Unexpected Character (Code " + (int)next + " " + next + "\nExpected a < to start a URI or a valid start character for a QName to specify Data Type"); " is 163.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The length of the statement  "				if (Char.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterModifier (next)) { " is 125.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The length of the statement  "										throw Error ("Too many \" characters encountered at the end of a long literal - ensure that you have escaped quotes in a long literal to avoid this error"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The length of the statement  "											throw Error ("Too many \' characters encountered at the end of a long literal - ensure that you have escaped quotes in a long literal to avoid this error"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The length of the statement  "							throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be an attempt to use a Graph Literal which is not valid in Turtle"); " is 159.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle"); " is 159.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle"); " is 173.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive"); " is 123.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetPrefixToken,The length of the statement  "		throw new RdfParseException ("Didn't find expected : Character while attempting to parse Prefix at content:\n" + this.Value + "\nPrefixes must end in a Colon Character"' this.StartLine' this.CurrentLine' this.StartPosition' this.CurrentPosition); " is 246.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetPrefixToken,The length of the statement  "		throw new RdfParseException ("The value '" + this.Value + "' is not a valid Prefix in Turtle"' new PositionInfo (this.StartLine' this.CurrentLine' this.StartPosition' this.EndPosition)); " is 186.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The length of the statement  "	StringComparison comparison = (this._syntax == TurtleSyntax.Original ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase); " is 134.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The length of the statement  "	while (next == ':' || Char.IsLetterOrDigit (next) || next == '_' || next == '-' || next == '+' || (next == '.' && !colonoccurred) || (next == '\\' && this._syntax == TurtleSyntax.W3C)) { " is 186.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The length of the statement  "			throw Error ("Unexpected additional Colon Character while trying to parse a QName from content:\n" + this.Value + "\nQNames can only contain 1 Colon character"); " is 161.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The length of the statement  "			throw Error ("Unexpected additional Dot Character while trying to parse a Plain Literal from content:\n" + this.Value + "\nPlain Literals can only contain 1 Dot Character' ensure you use White Space after a Plain Literal which contains a dot to avoid ambiguity"); " is 263.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The length of the statement  "				throw Error ("The value of the Plain Literal '" + value + "' is not valid in Turtle.  Turtle supports Boolean' Integer' Decimal and Double Plain Literals"); " is 156.
Long Statement,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDataTypeToken,The length of the statement  "			throw Error ("Parsed a '" + temp.GetType ().ToString () + "' Token while attempting to get a QNameToken for a DataType"); " is 121.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetVariable,The length of the statement  "	while (Char.IsLetterOrDigit (next) || UnicodeSpecsHelper.IsLetterOrDigit (next) || next == '-' || next == '_' || next == '\\') { " is 128.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + ") +\nThe plus sign can only occur once at the Start of a Numeric Literal and once immediately after the 'e' exponent specifier' if this was intended as an additive operator please insert space to disambiguate this"); " is 274.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + ") -\nThe minus sign can only occur once at the Start of a Numeric Literal' if this was intended as a subtractive operator please insert space to disambiguate this"); " is 223.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw Error ("Unexpected Character (Code " + (int)next + ") -\nThe minus sign can only occur at the Start of a Numeric Literal and once immediately after the 'e' exponent specifier' if this was intended as a subtractive operator please insert space to disambiguate this"); " is 272.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,The length of the statement  "				throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier can only occur once in a Numeric Literal"); " is 128.
Long Statement,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetNumericLiteral,The length of the statement  "					throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier cannot occur at the start of a Numeric Literal"); " is 134.
Long Statement,VDS.RDF.Query.Datasets,WrapperDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\WrapperDataset.cs,SerializeConfiguration,The length of the statement  "		INode datasetClass = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.ClassSparqlDataset); " is 121.
Long Statement,VDS.RDF.Query.Datasets,WrapperDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\WrapperDataset.cs,SerializeConfiguration,The length of the statement  "		INode usingDataset = ConfigurationLoader.CreateConfigurationNode (context.Graph' ConfigurationLoader.PropertyUsingDataset); " is 123.
Long Statement,VDS.RDF.Query.Datasets,WrapperDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\WrapperDataset.cs,SerializeConfiguration,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to serialize configuration as the inner dataset is now serializable"); " is 121.
Long Statement,VDS.RDF.Query.Datasets,BaseDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseDataset.cs,SetActiveGraph,The length of the statement  "		this._activeGraphUris.Value.Push (this._defaultGraphUris.Value.Count > 0 ? this._defaultGraphUris.Value.Peek () : Enumerable.Empty<Uri> ()); " is 140.
Long Statement,VDS.RDF.Query.Datasets,DatasetGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\DatasetGraphCollection.cs,Add,The length of the statement  "			throw new RdfException ("Cannot add this Graph as a Graph with the URI '" + g.BaseUri.ToSafeString () + "' already exists in the Collection and mergeIfExists was set to false"); " is 177.
Long Statement,VDS.RDF.Query.Optimisation,VariableSubstitutionTransformer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VariableSubstitutionTransformer.cs,Optimise,The length of the statement  "				PatternItem subj = tp.Subject.VariableName != null && tp.Subject.VariableName.Equals (this._findVar) ? this._replaceItem : tp.Subject; " is 134.
Long Statement,VDS.RDF.Query.Optimisation,VariableSubstitutionTransformer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VariableSubstitutionTransformer.cs,Optimise,The length of the statement  "				PatternItem pred = tp.Predicate.VariableName != null && tp.Predicate.VariableName.Equals (this._findVar) ? this._replaceItem : tp.Predicate; " is 140.
Long Statement,VDS.RDF.Query.Optimisation,VariableSubstitutionTransformer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VariableSubstitutionTransformer.cs,Optimise,The length of the statement  "				PatternItem obj = tp.Object.VariableName != null && tp.Object.VariableName.Equals (this._findVar) ? this._replaceItem : tp.Object; " is 130.
Long Statement,VDS.RDF.Query.Optimisation,VariableSubstitutionTransformer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\VariableSubstitutionTransformer.cs,Optimise,The length of the statement  "				throw new RdfQueryException ("Cannot do a variable substitution when the variable is used for a GRAPH specifier and the replacement term is not a URI"); " is 152.
Long Statement,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The length of the statement  "				if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) { " is 149.
Long Statement,VDS.RDF.Query.Optimisation,LazyBgpOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BgpOptimisers.cs,OptimiseInternal,The length of the statement  "				//If the sides of the Join are disjoint then can fully transform the join since we only need to find the requisite number of " is 124.
Long Statement,VDS.RDF.Query.Optimisation,LazyBgpOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BgpOptimisers.cs,IsApplicable,The length of the statement  "	return q.Limit > 0 && !q.HasDistinctModifier && (q.OrderBy == null || q.IsOptimisableOrderBy) && q.GroupBy == null && q.Having == null && !q.IsAggregate && q.Bindings == null; " is 175.
Long Statement,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,InsertAssignment,The length of the statement  "		throw new RdfQueryException ("Cannot Insert an Assignment that is not currently an unplaced Assignment in this Graph Pattern"); " is 127.
Long Statement,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The length of the statement  "	bool linebreaks = ((this._triplePatterns.Count + this._graphPatterns.Count + this._unplacedAssignments.Count) > 1) || this._isFiltered; " is 135.
Long Statement,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Accepts,The length of the statement  "		return (this._subj.Accepts (context' obj.Subject) && this._pred.Accepts (context' obj.Predicate) && this._obj.Accepts (context' obj.Object)); " is 141.
Long Statement,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Accepts,The length of the statement  "		return (this._subj.Accepts (context' obj.Subject) && obj.Subject.Equals (obj.Predicate) && this._obj.Accepts (context' obj.Object)); " is 132.
Long Statement,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Accepts,The length of the statement  "		return (this._subj.Accepts (context' obj.Subject) && this._pred.Accepts (context' obj.Predicate) && obj.Subject.Equals (obj.Object)); " is 133.
Long Statement,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Accepts,The length of the statement  "		return (this._subj.Accepts (context' obj.Subject) && obj.Subject.Equals (obj.Predicate) && obj.Subject.Equals (obj.Object)); " is 124.
Long Statement,VDS.RDF.Query.Patterns,TriplePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Construct,The length of the statement  "	return new Triple (Tools.CopyNode (this._subj.Construct (context)' context.Graph)' Tools.CopyNode (this._pred.Construct (context)' context.Graph)' Tools.CopyNode (this._obj.Construct (context)' context.Graph)); " is 210.
Long Statement,VDS.RDF.Query.Patterns,SetDistinctnessComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,Equals,The length of the statement  "		return this._vars.All (v => (x [v] == null && y [v] == null) || (x [v] != null && y [v] == null) && x [v].Equals (y [v])); " is 122.
Long Statement,VDS.RDF.Query.Patterns,BindPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\BindPattern.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("Cannot use a BIND assigment to BIND to a variable that has previously been used in the Query"); " is 125.
Long Statement,VDS.RDF.Query.Patterns,VariablePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\VariablePattern.cs,Construct,The length of the statement  "		throw new RdfQueryException ("Unable to construct a Value for this Variable for this solution as it is bound to a null"); " is 121.
Long Statement,VDS.RDF.Query.Expressions,SparqlExpressionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlExpressionFactory.cs,CreateExpression,The length of the statement  "			throw new RdfParseException ("Too few/many arguments for a XPath Cast function' expected a single Expression as an argument"); " is 126.
Long Statement,VDS.RDF.Query.Expressions,SparqlExpressionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlExpressionFactory.cs,CreateExpression,The length of the statement  "			throw new RdfParseException ("Unable to parse a supported XPath Cast Function with IRI <" + u.ToString () + ">' it appears to be a valid Cast function URI but it couldn't be parsed"); " is 183.
Long Statement,VDS.RDF.Query.Expressions,SparqlExpressionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlExpressionFactory.cs,CreateExpression,The length of the statement  "		throw new RdfParseException ("Unable to parse a SPARQL Extension Function with IRI <" + u.ToString () + ">' it is not a supported Casting function and no Custom Expression Factories are able to generate an Expression from this IRI"); " is 233.
Long Statement,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The length of the statement  "			if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) { " is 167.
Long Statement,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The length of the statement  "					sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator])); " is 134.
Long Statement,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The length of the statement  "				xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ()); " is 121.
Long Statement,VDS.Common,HashTable,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Common\HashTable.cs,AddEmpty,The length of the statement  "			throw new InvalidOperationException ("HashTable must be instantiated with the emptyKeys parameter set to true in order to allow empty keys"); " is 141.
Long Statement,VDS.RDF.Parsing.Contexts,JsonParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\JsonParserContext.cs,GetPositionRange,The length of the statement  "	return new PositionInfo (startPosition.StartLine' this._input.LineNumber' startPosition.StartPosition' this._input.LinePosition); " is 129.
Long Statement,VDS.RDF.Parsing.Contexts,Notation3ParserContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Contexts\Notation3ParserContext.cs,PopGraph,The length of the statement  "		throw new RdfParseException ("Cannot pop a RDF Handler from the Parser Context to become the in-scope RDF Handler since there are no RDF Handlers on the stack"); " is 161.
Long Statement,VDS.RDF.Parsing.Validation,RdfDatasetSyntaxValidator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Validation\RdfDatasetSyntaxValidator.cs,Validate,The length of the statement  "		message = "Valid RDF Dataset - " + handler.GraphCount + " Graphs with " + handler.TripleCount + " Triples - Parser: " + this._parser.GetType ().Name; " is 149.
Long Statement,VDS.RDF.Parsing.Validation,RdfStrictSyntaxValidator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Validation\RdfSyntaxValidator.cs,Validate,The length of the statement  "			message = "Valid RDF with Warnings - " + handler.Count + " Triples - Parser: " + this._parser.GetType ().Name + " - " + this._messages.Count + " Warnings"; " is 155.
Long Statement,VDS.RDF.Parsing.Validation,SparqlResultsValidator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Validation\SparqlResultsValidator.cs,Validate,The length of the statement  "		message = "Invalid SPARQL Results - Parsing Error from Parser: " + this._parser.GetType ().Name + " - " + parseEx.Message; " is 122.
Long Statement,VDS.RDF.Query.Aggregates.Leviathan,MedianAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\MedianAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a MEDIAN Aggregate since the Variable does not occur in a Graph Pattern"); " is 162.
Long Statement,VDS.RDF.Query.Aggregates.Leviathan,ModeAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\ModeAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a MODE Aggregate since the Variable does not occur in a Graph Pattern"); " is 160.
Long Statement,VDS.RDF.Query.Aggregates.Leviathan,NumericMaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMaxAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a NMAX Aggregate since the Variable does not occur in a Graph Pattern"); " is 160.
Long Statement,VDS.RDF.Query.Aggregates.Leviathan,NumericMinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMinAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a NMIN Aggregate since the Variable does not occur in a Graph Pattern"); " is 160.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,AverageAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\AverageAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a AVG Aggregate since the Variable does not occur in a Graph Pattern"); " is 159.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,CountAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a COUNT Aggregate since the Variable does not occur in a Graph Pattern"); " is 161.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,CountDistinctAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountDistinctAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a COUNT Aggregate since the Variable does not occur in a Graph Pattern"); " is 161.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,MaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\MaxAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a MAX Aggregate since the Variable does not occur in a Graph Pattern"); " is 159.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,MinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\MinAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a MIN Aggregate since the Variable does not occur in a Graph Pattern"); " is 159.
Long Statement,VDS.RDF.Query.Aggregates.Sparql,SumAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\SumAggregate.cs,Apply,The length of the statement  "			throw new RdfQueryException ("Cannot use the Variable " + this._expr.ToString () + " in a SUM Aggregate since the Variable does not occur in a Graph Pattern"); " is 159.
Long Statement,VDS.RDF.Query.Aggregates.XPath,StringJoinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\XPath\StringJoin.cs,GetSeparator,The length of the statement  "				throw new RdfQueryException ("Cannot evaluate an XPath string-join since the separator expression returns a typed Literal which is not a String"); " is 146.
Long Statement,VDS.RDF.Query.Aggregates.XPath,StringJoinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\XPath\StringJoin.cs,GetSeparator,The length of the statement  "		throw new RdfQueryException ("Cannot evaluate an XPath string-join since the separator expression does not return a Literal"); " is 126.
Long Statement,VDS.RDF.Query.Algebra,AskBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AskBgp.cs,StreamingEvaluate,The length of the statement  "						context.OutputMultiset = context.InputMultiset.ProductWithTimeout (context.OutputMultiset' context.QueryTimeout - context.QueryTime); " is 133.
Long Statement,VDS.RDF.Query.Algebra,Bgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Bgp.cs,Evaluate,The length of the statement  "				if (this._triplePatterns [i] is FilterPattern || this._triplePatterns [i] is BindPattern || this._triplePatterns [i] is LetPattern) { " is 133.
Long Statement,VDS.RDF.Query.Algebra,Extend,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Extend.cs,Transform,The length of the statement  "		return new Extend (optimiser.Optimise (this._inner)' ((IExpressionTransformer)optimiser).Transform (this._expr)' this._var); " is 124.
Long Statement,VDS.RDF.Query.Algebra,Extend,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Extend.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("Cannot use a BIND assigment to BIND to a variable that has previously been used in the Query"); " is 125.
Long Statement,VDS.RDF.Query.Algebra,BaseSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ISet.cs,Equals,The length of the statement  "	return this.Variables.All (v => other.ContainsVariable (v) && ((this [v] == null && other [v] == null) || this [v].Equals (other [v]))); " is 136.
Long Statement,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,Evaluate,The length of the statement  "			if (context.Query.HasDistinctModifier || (context.Query.OrderBy != null && !context.Query.IsOptimisableOrderBy) || context.Query.GroupBy != null || context.Query.Having != null || context.Query.Bindings != null) { " is 213.
Long Statement,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,StreamingEvaluate,The length of the statement  "			throw new RdfQueryException ("Cannot use a BIND assigment to BIND to a variable that has previously been used in the Query"); " is 125.
Long Statement,VDS.RDF.Query.Algebra,Distinct,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Distinct() to a SPARQL Query when the Inner Algebra converts to a Query that already has a DISTINCT/REDUCED modifier applied"); " is 178.
Long Statement,VDS.RDF.Query.Algebra,Distinct,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Distinct() to a SPARQL Query when the Inner Algebra converts to a Query that is not a SELECT query"); " is 152.
Long Statement,VDS.RDF.Query.Algebra,Distinct,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Distinct() to a SPARQL Query when the Inner Algebra converts to a Query with an unexpected Query Type"); " is 155.
Long Statement,VDS.RDF.Query.Algebra,Reduced,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Reduced() to a SPARQL Query when the Inner Algebra converts to a Query that already has a DISTINCT/REDUCED modifier applied"); " is 177.
Long Statement,VDS.RDF.Query.Algebra,Reduced,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Reduced() to a SPARQL Query when the Inner Algebra converts to a Query that is not a SELECT query"); " is 151.
Long Statement,VDS.RDF.Query.Algebra,Reduced,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Distinct.cs,ToQuery,The length of the statement  "		throw new NotSupportedException ("Cannot convert a Reduced() to a SPARQL Query when the Inner Algebra converts to a Query with an unexpected Query Type"); " is 154.
Long Statement,VDS.RDF.Query.Algebra,Filter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Filter.cs,Transform,The length of the statement  "		return new Filter (optimiser.Optimise (this._pattern)' new UnaryExpressionFilter (((IExpressionTransformer)optimiser).Transform (this._filter.Expression))); " is 156.
Long Statement,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The length of the statement  "					Uri activeGraphUri = UriFactory.Create (Tools.ResolveUriOrQName (this._graphSpecifier' context.Query.NamespaceMap' context.Query.BaseUri)); " is 139.
Long Statement,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The length of the statement  "						if (context.Query == null || !context.Query.NamedGraphs.Any () || context.Query.NamedGraphs.Any (u => EqualityHelper.AreUrisEqual (activeGraphUri' u))) { " is 153.
Long Statement,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot use a '" + this._graphSpecifier.GetType ().ToString () + "' Token to specify the Graph for a GRAPH clause"); " is 145.
Long Statement,VDS.RDF.Query.Algebra,Graph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Graph.cs,Evaluate,The length of the statement  "					//If there are already values bound to the Graph variable for all Input Solutions then we limit the Query to those Graphs " is 121.
Long Statement,VDS.RDF.Query.Algebra,LeftJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AlgebraJoinClasses.cs,Transform,The length of the statement  "		return new LeftJoin (optimiser.Optimise (this._lhs)' optimiser.Optimise (this._rhs)' new UnaryExpressionFilter (((IExpressionTransformer)optimiser).Transform (this._filter.Expression))); " is 186.
Long Statement,VDS.RDF.Query.Algebra,LeftJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AlgebraJoinClasses.cs,TransformLhs,The length of the statement  "		return new LeftJoin (optimiser.Optimise (this._lhs)' this._rhs' new UnaryExpressionFilter (((IExpressionTransformer)optimiser).Transform (this._filter.Expression))); " is 165.
Long Statement,VDS.RDF.Query.Algebra,LeftJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AlgebraJoinClasses.cs,TransformRhs,The length of the statement  "		return new LeftJoin (this._lhs' optimiser.Optimise (this._rhs)' new UnaryExpressionFilter (((IExpressionTransformer)optimiser).Transform (this._filter.Expression))); " is 165.
Long Statement,VDS.RDF.Query.Algebra,NegatedPropertySet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\NegatedPropertySet.cs,ToGraphPattern,The length of the statement  "		pp = new PropertyPathPattern (this.PathStart' new NegatedSet (Enumerable.Empty<Property> ()' this._properties.Select (p => new Property (p)))' this.PathEnd); " is 157.
Long Statement,VDS.RDF.Query.Algebra,NegatedPropertySet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\NegatedPropertySet.cs,ToGraphPattern,The length of the statement  "		pp = new PropertyPathPattern (this.PathStart' new NegatedSet (this._properties.Select (p => new Property (p))' Enumerable.Empty<Property> ())' this.PathEnd); " is 157.
Long Statement,VDS.RDF.Query.Algebra,OneOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\OneOrMorePath.cs,Evaluate,The length of the statement  "	if (subjVar == null || (subjVar != null && context.InputMultiset.ContainsVariable (subjVar)) || (objVar != null && !context.InputMultiset.ContainsVariable (objVar))) { " is 167.
Long Statement,VDS.RDF.Query.Algebra,OneOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\OneOrMorePath.cs,ToString,The length of the statement  "	return "OneOrMorePath(" + this.PathStart.ToString () + "' " + this.Path.ToString () + "' " + this.PathEnd.ToString () + ")"; " is 124.
Long Statement,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The length of the statement  "	IAsyncResult rhs = this._d.BeginInvoke (this._rhs' context2' activeGraphs' defaultGraphs' new AsyncCallback (this.RhsCallback)' null); " is 134.
Long Statement,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("Unknown error in parallel join evaluation' RHS is reported completed without errors but no result is available"); " is 143.
Long Statement,VDS.RDF.Query.Algebra,BaseArbitraryLengthPathOperator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\PropertyPathOperators.cs,EvaluateStep,The length of the statement  "		IEnumerable<Triple> ts = (reverse ? context.Data.GetTriplesWithPredicateObject (predicate' path [path.Count - 1]) : context.Data.GetTriplesWithSubjectPredicate (path [path.Count - 1]' predicate)); " is 196.
Long Statement,VDS.RDF.Query.Algebra,IdentityFilter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\RestrictionFilters.cs,Transform,The length of the statement  "		return new IdentityFilter (optimiser.Optimise (this.InnerAlgebra)' this.RestrictionVariable' (ConstantTerm)((IExpressionTransformer)optimiser).Transform (this.RestrictionValue)); " is 178.
Long Statement,VDS.RDF.Query.Algebra,SameTermFilter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\RestrictionFilters.cs,Transform,The length of the statement  "		return new SameTermFilter (optimiser.Optimise (this.InnerAlgebra)' this.RestrictionVariable' (ConstantTerm)((IExpressionTransformer)optimiser).Transform (this.RestrictionValue)); " is 178.
Long Statement,VDS.RDF.Query.Algebra,ZeroLengthPath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroLengthPath.cs,ToString,The length of the statement  "	return "ZeroLengthPath(" + this.PathStart.ToString () + "' " + this.Path.ToString () + "' " + this.PathEnd.ToString () + ")"; " is 125.
Long Statement,VDS.RDF.Query.Algebra,ZeroOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroOrMorePath.cs,Evaluate,The length of the statement  "	if (subjVar == null || (subjVar != null && context.InputMultiset.ContainsVariable (subjVar)) || (objVar != null && !context.InputMultiset.ContainsVariable (objVar))) { " is 167.
Long Statement,VDS.RDF.Query.Algebra,ZeroOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroOrMorePath.cs,ToString,The length of the statement  "	return "ZeroOrMorePath(" + this.PathStart.ToString () + "' " + this.Path.ToString () + "' " + this.PathEnd.ToString () + ")"; " is 125.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,Join,The length of the statement  "	//    ////if (!joinVars.All(v => x[v] == null || other.ContainsValue(v' x[v]) || other.ContainsValue(v' null))) continue; " is 121.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,Join,The length of the statement  "	//    IEnumerable<ISet> ys = other.Sets.Where(s => joinVars.All(v => x[v] == null || s[v] == null || x[v].Equals(s[v]))); " is 121.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,EvalJoin,The length of the statement  "				possMatches = (possMatches == null ? values [i].GetValues (value).Concat (nulls [i]) : possMatches.Intersect (values [i].GetValues (value).Concat (nulls [i]))); " is 160.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,LeftJoin,The length of the statement  "		//    IEnumerable<ISet> ys = other.Sets.Where(s => joinVars.All(v => x[v] == null || s[v] == null || x[v].Equals(s[v]))); " is 121.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,LeftJoin,The length of the statement  "						possMatches = (possMatches == null ? values [i].GetValues (value).Concat (nulls [i]) : possMatches.Intersect (values [i].GetValues (value).Concat (nulls [i]))); " is 160.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,ExistsJoin,The length of the statement  "					possMatches = (possMatches == null ? values [i].GetValues (value).Concat (nulls [i]) : possMatches.Intersect (values [i].GetValues (value).Concat (nulls [i]))); " is 160.
Long Statement,VDS.RDF.Query.Algebra,Multiset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Multiset.cs,MinusJoin,The length of the statement  "					possMatches = (possMatches == null ? values [i].GetValues (value).Concat (nulls [i]) : possMatches.Intersect (values [i].GetValues (value).Concat (nulls [i]))); " is 160.
Long Statement,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The length of the statement  "				if (!groupSet.ContainsVariable (v.Name) && !context.Query.GroupBy.Variables.Contains (v.Name) && !context.Query.GroupBy.ProjectableVariables.Contains (v.Name)) { " is 161.
Long Statement,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot project the variable ?" + v.Name + " since this Query contains Grouping(s) but the given Variable is not in the GROUP BY - use the SAMPLE aggregate if you need to sample this Variable"); " is 223.
Long Statement,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Cannot project the variable ?" + v.Name + " since this Query contains Aggregates and no GROUP BY"); " is 129.
Long Statement,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The length of the statement  "			else if (context.Query != null && context.Query.IsAggregate && !context.Query.GroupBy.ProjectableVariables.Contains (v.Name)) { " is 127.
Long Statement,VDS.RDF.Query.Algebra,Project,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Cannot project the variable ?" + v.Name + " since this Query contains Aggregates but the given Variable is not in the GROUP BY - use the SAMPLE aggregate if you need to access this variable"); " is 222.
Long Statement,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Cannot evaluate a SERVICE clause which uses a Variable as the Service specifier when the Variable is unbound"); " is 141.
Long Statement,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("SERVICE Specifier must be a URI/Variable Token but a " + this._endpointSpecifier.GetType ().ToString () + " Token was provided"); " is 159.
Long Statement,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The length of the statement  "				//Possible Bindings get built from current input (if there was a BINDINGS clause the variables it defines are not in this SERVICE clause) " is 137.
Long Statement,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The length of the statement  "			//If Evaluation Errors are SILENT is specified then a Multiset containing a single set with all values unbound is returned " is 122.
Long Statement,VDS.RDF.Query.Algebra,Service,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Service.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("Query execution failed because evaluating a SERVICE clause failed - this may be due to an error with the remote service"' ex); " is 156.
Long Statement,VDS.RDF.Query.Algebra,Set,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Set.cs,Equals,The length of the statement  "	return this._values.All (pair => other.ContainsVariable (pair.Key) && ((pair.Value == null && other [pair.Key] == null) || pair.Value.Equals (other [pair.Key]))); " is 162.
Long Statement,VDS.RDF.Query.Algebra,Slice,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Slice.cs,Evaluate,The length of the statement  "		vars = (context.Query != null) ? context.Query.Variables.Where (v => v.IsResultVariable).Select (v => v.Name) : context.InputMultiset.Variables; " is 144.
Long Statement,VDS.RDF.Query.Algebra,SelectDistinctGraphs,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\SpecialQueryClasses.cs,ToGraphPattern,The length of the statement  "	p.AddTriplePattern (new TriplePattern (new VariablePattern (subjVar)' new VariablePattern (predVar)' new VariablePattern (objVar))); " is 132.
Long Statement,VDS.RDF.Query.Algebra,AskAnyTriples,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\SpecialQueryClasses.cs,ToGraphPattern,The length of the statement  "	p.AddTriplePattern (new TriplePattern (new VariablePattern ("?s")' new VariablePattern ("?p")' new VariablePattern ("?o"))); " is 124.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,LocalNameFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\LocalNameFunction.cs,ToString,The length of the statement  "	return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.LocalName + ">(" + this._expr.ToString () + ")"; " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,MaxFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\MaxFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,MaxFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\MaxFunction.cs,ToString,The length of the statement  "	return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Max + ">(" + this._leftExpr.ToString () + "' " + this._rightExpr.ToString () + ")"; " is 158.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,MinFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\MinFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,MinFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\MinFunction.cs,ToString,The length of the statement  "	return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Min + ">(" + this._leftExpr.ToString () + "' " + this._rightExpr.ToString () + ")"; " is 158.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,NamespaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\NamespaceFunction.cs,ToString,The length of the statement  "	return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Namespace + ">(" + this._expr.ToString () + ")"; " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,Sha1Function,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\Sha1Function.cs,ToString,The length of the statement  "	return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Sha1Sum + ">(" + this._expr.ToString () + ")"; " is 121.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,StringJoinFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\StringJoinFunction.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot evaluate the ARQ strjoin() function when the separator expression evaluates to a Null"); " is 125.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,StringJoinFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\StringJoinFunction.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot evaluate the ARQ strjoin() function when the separator expression evaluates to a non-Literal Node"); " is 137.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,Evaluate,The length of the statement  "					return new StringNode (null' input.Value.Substring (s' e - s)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,CheckArgument,The length of the statement  "					throw new RdfQueryException ("Unable to evaluate an ARQ substring as one of the argument expressions returned a typed literal with an invalid type"); " is 149.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,CheckArgument,The length of the statement  "				throw new RdfQueryException ("Unable to evalaute an ARQ substring as one of the argument expressions returned an untyped literal"); " is 131.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,CheckArgument,The length of the statement  "			throw new RdfQueryException ("Unable to evaluate an ARQ substring as one of the argument expressions returned a non-literal"); " is 126.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,CheckArgument,The length of the statement  "		throw new RdfQueryException ("Unable to evaluate an ARQ substring as one of the argument expressions evaluated to null"); " is 121.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,ToString,The length of the statement  "		return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Substring + ">(" + this._expr.ToString () + "'" + this._start.ToString () + "'" + this._end.ToString () + ")"; " is 185.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,ToString,The length of the statement  "		return "<" + ArqFunctionFactory.ArqFunctionsNamespace + ArqFunctionFactory.Substring + ">(" + this._expr.ToString () + "'" + this._start.ToString () + ")"; " is 155.
Long Statement,VDS.RDF.Query.Expressions.Functions.Arq,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Arq\SubstringFunction.cs,Transform,The length of the statement  "		return new SubstringFunction (transformer.Transform (this._expr)' transformer.Transform (this._start)' transformer.Transform (this._end)); " is 138.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Hash,MD5HashFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Hash\MD5HashFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.MD5Hash + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Hash,Sha256HashFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Hash\Sha256HashFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Sha256Hash + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CubeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CubeFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Cube + ">(" + this._expr.ToString () + ")"; " is 136.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,EFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\EFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.E + ">(" + this._expr.ToString () + ")"; " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,FactorialFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\FactorialFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Factorial + ">(" + this._expr.ToString () + ")"; " is 141.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,LogFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\LogFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Log + ">(" + this._leftExpr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,LogFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\LogFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Log + ">(" + this._leftExpr.ToString () + "'" + this._rightExpr.ToString () + ")"; " is 175.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,LeviathanNaturalLogFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\NaturalLogFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Ln + ">(" + this._expr.ToString () + ")"; " is 134.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,PowerFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\PowerFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Power + ">(" + this._leftExpr.ToString () + "'" + this._rightExpr.ToString () + ")"; " is 177.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,PythagoreanDistanceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\PythagoreanDistanceFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Pythagoras + ">(" + this._leftExpr.ToString () + "'" + this._rightExpr.ToString () + ")"; " is 182.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,PythagoreanDistanceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\PythagoreanDistanceFunction.cs,Transform,The length of the statement  "	return new PythagoreanDistanceFunction (transformer.Transform (this._leftExpr)' transformer.Transform (this._rightExpr)); " is 121.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RandomFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RandomFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot generate a random number in the given range since the minumum is greater than the maximum"); " is 129.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,ReciprocalFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\ReciprocalFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Reciprocal + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RootFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RootFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Power + ">(" + this._leftExpr.ToString () + "'" + this._rightExpr.ToString () + ")"; " is 177.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Square + ">(" + this._expr.ToString () + ")"; " is 138.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareRootFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareRootFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.SquareRoot + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,TenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\TenFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.Ten + ">(" + this._expr.ToString () + ")"; " is 135.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,Transform,The length of the statement  "		return new CartesianFunction (transformer.Transform (this._x1)' transformer.Transform (this._y1)' transformer.Transform (this._z1)' transformer.Transform (this._x2)' transformer.Transform (this._y2)' transformer.Transform (this._z2)); " is 234.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,Transform,The length of the statement  "		return new CartesianFunction (transformer.Transform (this._x1)' transformer.Transform (this._y1)' transformer.Transform (this._x2)' transformer.Transform (this._y2)); " is 166.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CosecantFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CosecantFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCosecInv + ">(" + this._expr.ToString () + ")"; " is 144.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CosecantFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CosecantFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCosec + ">(" + this._expr.ToString () + ")"; " is 141.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CosineFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CosineFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCosInv + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CosineFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CosineFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCos + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CotangentFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CotangentFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCotanInv + ">(" + this._expr.ToString () + ")"; " is 144.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,CotangentFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\CotangentFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigCotan + ">(" + this._expr.ToString () + ")"; " is 141.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,DegreesToRadiansFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\DegreesToRadiansFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.DegreesToRadians + ">(" + this._expr.ToString () + ")"; " is 148.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,RadiansToDegreesFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\RadiansToDegressFunction.cs,ToString,The length of the statement  "	return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.RadiansToDegrees + ">(" + this._expr.ToString () + ")"; " is 148.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,SecantFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\SecantFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigSecInv + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,SecantFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\SecantFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigSec + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,SineFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\SineFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigSinInv + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,SineFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\SineFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigSin + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,TangentFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\TangentFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigTanInv + ">(" + this._expr.ToString () + ")"; " is 142.
Long Statement,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry,TangentFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\Trigonometry\TangentFunction.cs,ToString,The length of the statement  "		return "<" + LeviathanFunctionFactory.LeviathanFunctionsNamespace + LeviathanFunctionFactory.TrigTan + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql,CoalesceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\CoalesceFunction.cs,Evaluate,The length of the statement  "	throw new RdfQueryException ("None of the arguments to the COALESCE function could be evaluated to give non-null/error responses for the given Binding"); " is 153.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql,IfElseFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\IfFunction.cs,Transform,The length of the statement  "	return new IfElseFunction (transformer.Transform (this._condition)' transformer.Transform (this._ifBranch)' transformer.Transform (this._elseBranch)); " is 150.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,LangMatchesFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\LangMatchesFunction.cs,Evaluate,The length of the statement  "				return new BooleanNode (null' lang.Equals (range' StringComparison.OrdinalIgnoreCase) || lang.StartsWith (range + "-"' StringComparison.OrdinalIgnoreCase)); " is 156.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,RegexFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\RegexFunction.cs,Transform,The length of the statement  "		return new RegexFunction (transformer.Transform (this._textExpr)' transformer.Transform (this._patternExpr)' transformer.Transform (this._optionExpr)); " is 151.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,Evaluate,The length of the statement  "	if (this._result == null || this._lastInput == null || (int)this._lastInput != context.InputMultiset.GetHashCode () || this._lastCount != context.InputMultiset.Count) " is 166.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,Evaluate,The length of the statement  "		//If a NOT EXISTS then return the negation of exists i.e. if compatible solutions exist then we must return false' if none we return true " is 137.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,EvaluateInternal,The length of the statement  "					possMatches = (possMatches == null ? values [i].GetValues (value).Concat (nulls [i]) : possMatches.Intersect (values [i].GetValues (value).Concat (nulls [i]))); " is 160.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,EvaluateInternal,The length of the statement  "				possMatches = (possMatches == null ? context.InputMultiset.SetIDs : possMatches.Intersect (context.InputMultiset.SetIDs)); " is 122.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,Transform,The length of the statement  "		throw new RdfQueryException ("Unable to transform an EXISTS/NOT EXISTS function since the expression transformer in use failed to transform the inner Graph Pattern Expression to another Graph Pattern Expression"); " is 213.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,BNodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\BNodeFunction.cs,Evaluate,The length of the statement  "							this._funcContext.BlankNodes [bindingID].Add (lit.Value' new BlankNode (this._funcContext.Graph' this._funcContext.Mapper.GetNextID ())); " is 137.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,BNodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\BNodeFunction.cs,Evaluate,The length of the statement  "						throw new RdfQueryException ("Cannot create a Blank Node whne the argument Expression evaluates to a lanuage specified literal"); " is 129.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,BNodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\BNodeFunction.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot create a Blank Node when the argument Expression evaluates to a typed literal node"); " is 122.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Constructor,BNodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Constructor\BNodeFunction.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Cannot create a Blank Node when the argument Expression evaluates to a non-literal node"); " is 120.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Set,InFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Set\InFunction.cs,ToString,The length of the statement  "	if (this._expr.Type == SparqlExpressionType.BinaryOperator || this._expr.Type == SparqlExpressionType.GraphOperator || this._expr.Type == SparqlExpressionType.SetOperator) " is 171.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Set,InFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Set\InFunction.cs,ToString,The length of the statement  "	if (this._expr.Type == SparqlExpressionType.BinaryOperator || this._expr.Type == SparqlExpressionType.GraphOperator || this._expr.Type == SparqlExpressionType.SetOperator) " is 171.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.Set,NotInFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Set\NotInFunction.cs,Transform,The length of the statement  "	return new NotInFunction (transformer.Transform (this._expr)' this._expressions.Select (e => transformer.Transform (e))); " is 121.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\BaseBinaryStringFunction.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("The Literals provided as arguments to this SPARQL String function are not of valid forms (see SPARQL spec for acceptable combinations)"); " is 167.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,ConcatFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ConcatFunction.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Cannot evaluate the SPARQL CONCAT() function when an argument is a Typed Literal which is not an xsd:string"); " is 140.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,ContainsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ContainsFunction.cs,ToString,The length of the statement  "	return SparqlSpecsHelper.SparqlKeywordContains + "(" + this._leftExpr.ToString () + "' " + this._rightExpr.ToString () + ")"; " is 125.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,Transform,The length of the statement  "		return new ReplaceFunction (transformer.Transform (this._textExpr)' transformer.Transform (this._findExpr)' transformer.Transform (this._replaceExpr)' transformer.Transform (this._optionExpr)); " is 193.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,Transform,The length of the statement  "		return new ReplaceFunction (transformer.Transform (this._textExpr)' transformer.Transform (this._findExpr)' transformer.Transform (this._replaceExpr)); " is 151.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrAfterFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrAfterFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("The Literals provided as arguments to this SPARQL String function are not of valid forms (see SPARQL spec for acceptable combinations)"); " is 167.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrAfterFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrAfterFunction.cs,CheckArgument,The length of the statement  "					throw new RdfQueryException ("Unable to evaluate as one of the argument expressions returned a typed literal with an invalid type"); " is 132.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrAfterFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrAfterFunction.cs,ToString,The length of the statement  "	return SparqlSpecsHelper.SparqlKeywordStrAfter + "(" + this._stringExpr.ToString () + "' " + this._startsExpr.ToString () + ")"; " is 128.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrBeforeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrBeforeFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("The Literals provided as arguments to this SPARQL String function are not of valid forms (see SPARQL spec for acceptable combinations)"); " is 167.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrBeforeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrBeforeFunction.cs,CheckArgument,The length of the statement  "					throw new RdfQueryException ("Unable to evaluate as one of the argument expressions returned a typed literal with an invalid type"); " is 132.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrBeforeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrBeforeFunction.cs,ToString,The length of the statement  "	return SparqlSpecsHelper.SparqlKeywordStrBefore + "(" + this._stringExpr.ToString () + "' " + this._startsExpr.ToString () + ")"; " is 129.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrEndsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrEndsFunction.cs,ToString,The length of the statement  "	return SparqlSpecsHelper.SparqlKeywordStrEnds + "(" + this._leftExpr.ToString () + "' " + this._rightExpr.ToString () + ")"; " is 124.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,StrStartsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\StrStartsFunction.cs,ToString,The length of the statement  "	return SparqlSpecsHelper.SparqlKeywordStrStarts + "(" + this._leftExpr.ToString () + "' " + this._rightExpr.ToString () + ")"; " is 126.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,Evaluate,The length of the statement  "		IValuedNode length = this.CheckArgument (this._length' context' bindingID' XPathFunctionFactory.AcceptNumericArguments); " is 120.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,CheckArgument,The length of the statement  "					throw new RdfQueryException ("Unable to evaluate a substring as one of the argument expressions returned a typed literal with an invalid type"); " is 144.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,CheckArgument,The length of the statement  "				throw new RdfQueryException ("Unable to evalaute a substring as one of the argument expressions returned an untyped literal"); " is 126.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,CheckArgument,The length of the statement  "			throw new RdfQueryException ("Unable to evaluate a substring as one of the argument expressions returned a non-literal"); " is 121.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,ToString,The length of the statement  "		return SparqlSpecsHelper.SparqlKeywordSubStr + "(" + this._expr.ToString () + "'" + this._start.ToString () + "'" + this._length.ToString () + ")"; " is 147.
Long Statement,VDS.RDF.Query.Expressions.Functions.Sparql.String,SubStrFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\SubStrFunction.cs,Transform,The length of the statement  "		return new SubStrFunction (transformer.Transform (this._expr)' transformer.Transform (this._start)' transformer.Transform (this._length)); " is 138.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath,BooleanFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\BooleanFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Boolean + ">(" + this._expr.ToString () + ")"; " is 127.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Cast,BooleanCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\BooleanCast.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot cast the value '" + lit.Value + "' to a xsd:decimal as an intermediate stage in casting to a xsd:boolean"); " is 144.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Cast,BooleanCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\BooleanCast.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot cast the value '" + lit.Value + "' to a xsd:double as an intermediate stage in casting to a xsd:boolean"); " is 143.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Cast,BooleanCast,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Cast\BooleanCast.cs,Evaluate,The length of the statement  "					throw new RdfQueryException ("Cannot cast the value '" + lit.Value + "' to a xsd:integer as an intermediate stage in casting to a xsd:boolean"); " is 144.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,DayFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\DayFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.DayFromDateTime + ">(" + this._expr.ToString () + ")"; " is 135.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,HoursFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\HoursFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.HoursFromDateTime + ">(" + this._expr.ToString () + ")"; " is 137.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,MinutesFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\MinutesFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.MinutesFromDateTime + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,MonthFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\MonthFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.MonthFromDateTime + ">(" + this._expr.ToString () + ")"; " is 137.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,SecondsFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\SecondsFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.SecondsFromDateTime + ">(" + this._expr.ToString () + ")"; " is 139.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.TimezoneFromDateTime + ">(" + this._expr.ToString () + ")"; " is 140.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,YearFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\YearFromDateTimeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.YearFromDateTime + ">(" + this._expr.ToString () + ")"; " is 136.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundHalfToEvenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundHalfToEvenFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundHalfToEvenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundHalfToEvenFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.RoundHalfToEven + ">(" + this._expr.ToString () + ")"; " is 135.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,AbsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\AbsFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,AbsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\AbsFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Absolute + ">(" + this._expr.ToString () + ")"; " is 128.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,CeilingFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\CeilingFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,CeilingFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\CeilingFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Ceiling + ">(" + this._expr.ToString () + ")"; " is 127.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,FloorFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\FloorFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,FloorFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\FloorFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Floor + ">(" + this._expr.ToString () + ")"; " is 125.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundFunction.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.Numeric,RoundFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\Numeric\RoundFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Round + ">(" + this._expr.ToString () + ")"; " is 125.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,CompareFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\CompareFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Compare + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 157.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\BaseBinaryStringFunction.cs,Evaluate,The length of the statement  "						throw new RdfQueryException ("Unable to evaluate an XPath String function since the type of the argument is not supported by this function"); " is 141.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\BaseBinaryStringFunction.cs,Evaluate,The length of the statement  "				throw new RdfQueryException ("Unable to evaluate an XPath String function since the argument expression evaluated to a null and a null argument is not permitted by this function"); " is 180.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,BaseBinaryStringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\BaseBinaryStringFunction.cs,ValueInternal,The length of the statement  "		throw new RdfQueryException ("Derived classes which are functions which permit a null argument must override this method"); " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,EncodeForUriFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\EncodeForUriFunction.cs,ValueInternal,The length of the statement  "	return new StringNode (null' Uri.EscapeUriString (stringLit.Value)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 128.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,EncodeForUriFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\EncodeForUriFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.EncodeForURI + ">(" + this._expr.ToString () + ")"; " is 132.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,EndsWithFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\EndsWithFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.EndsWith + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 158.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,EscapeHtmlUriFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\EscapeHtmlUriFunction.cs,ValueInternal,The length of the statement  "	return new StringNode (null' HttpUtility.UrlEncode (stringLit.Value)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 130.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,EscapeHtmlUriFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\EscapeHtmlUriFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.EscapeHtmlURI + ">(" + this._expr.ToString () + ")"; " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,LowerCaseFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\LowerCaseFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.LowerCase + ">(" + this._expr.ToString () + ")"; " is 129.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,NormalizeSpaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\NormalizeSpaceFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.NormalizeSpace + ">(" + this._expr.ToString () + ")"; " is 134.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,NormalizeUnicodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\NormalizeUnicodeFunction.cs,ValueInternal,The length of the statement  "			throw new RdfQueryException ("'" + arg.Value + "' is not a valid Normalization Form as defined by the XPath specification"); " is 124.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,NormalizeUnicodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\NormalizeUnicodeFunction.cs,ToString,The length of the statement  "		return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.NormalizeUnicode + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 166.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,NormalizeUnicodeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\NormalizeUnicodeFunction.cs,ToString,The length of the statement  "		return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.NormalizeUnicode + ">(" + this._expr.ToString () + ")"; " is 136.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,Transform,The length of the statement  "		return new ReplaceFunction (transformer.Transform (this._textExpr)' transformer.Transform (this._findExpr)' transformer.Transform (this._replaceExpr)' transformer.Transform (this._optionExpr)); " is 193.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,Transform,The length of the statement  "		return new ReplaceFunction (transformer.Transform (this._textExpr)' transformer.Transform (this._findExpr)' transformer.Transform (this._replaceExpr)); " is 151.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,StartsWithFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\StartsWithFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.StartsWith + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 160.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,StringLengthFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\StringLengthFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.StringLength + ">(" + this._expr.ToString () + ")"; " is 132.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,ContainsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ContainsFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Contains + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 158.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringAfterFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringAfterFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.SubstringAfter + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 164.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringBeforeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringBeforeFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.SubstringBefore + ">(" + this._expr.ToString () + "'" + this._arg.ToString () + ")"; " is 165.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,Evaluate,The length of the statement  "		IValuedNode length = this.CheckArgument (this._length' context' bindingID' XPathFunctionFactory.AcceptNumericArguments); " is 120.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,Evaluate,The length of the statement  "				return new StringNode (null' input.Value.Substring (s - 1)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 120.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,Evaluate,The length of the statement  "				return new StringNode (null' input.Value.Substring (s - 1' l)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,Evaluate,The length of the statement  "		return new StringNode (null' input.Value.Substring (s - 1)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeString)); " is 120.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,CheckArgument,The length of the statement  "					throw new RdfQueryException ("Unable to evaluate an XPath substring as one of the argument expressions returned a typed literal with an invalid type"); " is 151.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,CheckArgument,The length of the statement  "				throw new RdfQueryException ("Unable to evalaute an XPath substring as one of the argument expressions returned an untyped literal"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,CheckArgument,The length of the statement  "			throw new RdfQueryException ("Unable to evaluate an XPath substring as one of the argument expressions returned a non-literal"); " is 128.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,CheckArgument,The length of the statement  "		throw new RdfQueryException ("Unable to evaluate an XPath substring as one of the argument expressions evaluated to null"); " is 123.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,ToString,The length of the statement  "		return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Substring + ">(" + this._expr.ToString () + "'" + this._start.ToString () + "'" + this._length.ToString () + ")"; " is 194.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,ToString,The length of the statement  "		return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.Substring + ">(" + this._expr.ToString () + "'" + this._start.ToString () + ")"; " is 161.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,SubstringFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\SubstringFunction.cs,Transform,The length of the statement  "		return new SubstringFunction (transformer.Transform (this._expr)' transformer.Transform (this._start)' transformer.Transform (this._length)); " is 141.
Long Statement,VDS.RDF.Query.Expressions.Functions.XPath.String,UpperCaseFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\UpperCaseFunction.cs,ToString,The length of the statement  "	return "<" + XPathFunctionFactory.XPathFunctionsNamespace + XPathFunctionFactory.UpperCase + ">(" + this._expr.ToString () + ")"; " is 129.
Long Statement,VDS.RDF.Query.Inference,PelletReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\PelletReasoner.cs,Extract,The length of the statement  "	throw new NotSupportedException ("Pellet Server does not currently support the extraction of data from a Knowledge Base"); " is 122.
Long Statement,VDS.RDF.Query.Inference,PelletReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\PelletReasoner.cs,Extract,The length of the statement  "	throw new NotSupportedException ("Pellet Server does not currently support the extraction of data from a Knowledge Base"); " is 122.
Long Statement,VDS.RDF.Query.Inference,PelletReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\PelletReasoner.cs,Extract,The length of the statement  "	throw new NotSupportedException ("Pellet Server does not currently support the extraction of data from a Knowledge Base"); " is 122.
Long Statement,VDS.RDF.Query.Inference,PelletReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\PelletReasoner.cs,IsConsistent,The length of the statement  "	throw new NotSupportedException ("Pellet Server does not currently support checking whether additional data is consistent - Use IsConsistent() to determine if the Knowledge Base itself is consistent"); " is 201.
Long Statement,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,Apply,The length of the statement  "			inferences.Add (new Triple (t.Subject.CopyNode (output)' this._rdfType.CopyNode (output)' this._rdfsClass.CopyNode (output))); " is 126.
Long Statement,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,Apply,The length of the statement  "			inferences.Add (new Triple (t.Subject.CopyNode (output)' this._rdfType.CopyNode (output)' this._rdfProperty.CopyNode (output))); " is 128.
Long Statement,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,Apply,The length of the statement  "					inferences.Add (new Triple (t.Subject.CopyNode (output)' this._propertyMappings [property].CopyNode (output)' t.Object.CopyNode (output))); " is 139.
Long Statement,VDS.RDF.Query.Inference,StaticRdfsReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\RdfsReasoner.cs,InferClasses,The length of the statement  "			inferences.Add (new Triple (t.Subject.CopyNode (output)' t.Predicate.CopyNode (output)' this._classMappings [type].CopyNode (output))); " is 135.
Long Statement,VDS.RDF.Query.Inference,StaticSkosReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\SkosReasoner.cs,Apply,The length of the statement  "			if (!(t.Predicate.Equals (this._skosBroader) || t.Predicate.Equals (this._skosNarrower)) && this._conceptMappings.ContainsKey (t.Object)) { " is 139.
Long Statement,VDS.RDF.Query.Inference,StaticSkosReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\SkosReasoner.cs,Apply,The length of the statement  "						inferences.Add (new Triple (t.Subject.CopyNode (output)' t.Predicate.CopyNode (output)' this._conceptMappings [concept].CopyNode (output))); " is 140.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (type => !type.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 155.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (type => !type.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 155.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The length of the statement  "					similarities.Add (new KeyValuePair<INode' double> (r ["ind"]' Convert.ToDouble (((ILiteralNode)r ["similarity"]).Value))); " is 122.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The length of the statement  "			throw new RdfReasoningException ("Unable to extract the Similarity Information from the Similarity Graph returned by Pellet Server"); " is 133.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The length of the statement  "		throw new RdfReasoningException ("Unable to extract the Similarity Information from the Similarity Graph returned by Pellet Server"' ex); " is 137.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,SimilarityRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The length of the statement  "					similarities.Add (new KeyValuePair<INode' double> (r ["ind"]' Convert.ToDouble (((ILiteralNode)r ["similarity"]).Value))); " is 122.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,Similarity,The length of the statement  "			throw new RdfReasoningException ("Unable to extract the Similarity Information from the Similarity Graph returned by Pellet Server"); " is 133.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,SimilarityRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,PredictRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,PredictRaw,The length of the statement  "	request.Accept = MimeTypesHelper.CustomHttpAcceptHeader (this.MimeTypes.Where (t => !t.Equals ("text/json"))' MimeTypesHelper.SupportedRdfMimeTypes); " is 149.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ExplainService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ExplainServices.cs,Explain,The length of the statement  "	HttpWebRequest request = (HttpWebRequest)WebRequest.Create (this._explainUri + "?query=" + HttpUtility.UrlEncode (sparqlQuery)); " is 128.
Long Statement,VDS.RDF.Query.Inference.Pellet.Services,ExplainService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ExplainServices.cs,Explain,The length of the statement  "	HttpWebRequest request = (HttpWebRequest)WebRequest.Create (this._explainUri + "?query=" + HttpUtility.UrlEncode (sparqlQuery)); " is 128.
Long Statement,VDS.RDF.Query.Paths,NegatedSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\NegatedSet.cs,ToAlgebra,The length of the statement  "		lhsContext.AddTriplePattern (new PropertyPathPattern (lhsContext.Subject' new NegatedSet (this._properties' Enumerable.Empty<Property> ())' lhsContext.Object)); " is 160.
Long Statement,VDS.RDF.Query.Paths,NegatedSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\NegatedSet.cs,ToAlgebra,The length of the statement  "		rhsContext.AddTriplePattern (new PropertyPathPattern (rhsContext.Subject' new NegatedSet (Enumerable.Empty<Property> ()' this._inverseProperties)' rhsContext.Object)); " is 167.
Long Statement,VDS.RDF.Query.Paths,NOrMore,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\CardinalityPathClasses.cs,ToAlgebra,The length of the statement  "	context.AddTriplePattern (new PropertyPathPattern (context.Subject' new FixedCardinality (this._path' this._n)' tempVar)); " is 122.
Long Statement,VDS.RDF.Query.Paths,ZeroToN,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\CardinalityPathClasses.cs,ToAlgebra,The length of the statement  "	context.AddTriplePattern (new PropertyPathPattern (context.Subject' new NToM (this._path' 0' this._n)' context.Object)); " is 120.
Long Statement,VDS.RDF.Query.Paths,NToM,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\CardinalityPathClasses.cs,ToAlgebra,The length of the statement  "		tempContext.AddTriplePattern (new PropertyPathPattern (context.Subject' new FixedCardinality (this._path' i)' context.Object)); " is 127.
Long Statement,VDS.RDF.Query.Paths,Property,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Paths\Property.cs,Evaluate,The length of the statement  "			if (context.CompletePaths.Any (p => context.PathStart.Accepts (context.SparqlContext' p.Start) && context.PathEnd.Accepts (context.SparqlContext' p.Current))) { " is 160.
Long Statement,VDS.RDF.Update.Commands,BaseModificationCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseModifyCommand.cs,IsValidDeletePattern,The length of the statement  "		return !p.HasChildGraphPatterns && p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoBlankVariables); " is 147.
Long Statement,VDS.RDF.Update.Commands,BaseModificationCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseModifyCommand.cs,IsValidDeletePattern,The length of the statement  "		return p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoBlankVariables) && ((top && p.ChildGraphPatterns.All (gp => IsValidDeletePattern (gp' false))) || !p.HasChildGraphPatterns); " is 227.
Long Statement,VDS.RDF.Update.Commands,BaseTransferCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseTransferCommand.cs,AffectsGraph,The length of the statement  "		return (this._destUri == null || this._sourceUri == null) || this._sourceUri.ToSafeString ().Equals (GraphCollection.DefaultGraphUri) || this._destUri.ToSafeString ().Equals (GraphCollection.DefaultGraphUri); " is 208.
Long Statement,VDS.RDF.Update.Commands,BaseTransferCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseTransferCommand.cs,AffectsGraph,The length of the statement  "		return graphUri.ToString ().Equals (this._sourceUri.ToSafeString ()) || graphUri.ToString ().Equals (this._destUri.ToSafeString ()); " is 132.
Long Statement,VDS.RDF.Update.Commands,BaseTransferCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseTransferCommand.cs,ToString,The length of the statement  "		throw new RdfException ("Cannot display the String for this Transfer command as it is not one of the valid transfer commands (ADD/COPY/MOVE)"); " is 143.
Long Statement,VDS.RDF.Update.Commands,CreateCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\CreateCommand.cs,Evaluate,The length of the statement  "			throw new SparqlUpdateException ("Cannot create a Named Graph with URI '" + this._graphUri.ToString () + "' since a Graph with this URI already exists in the Store"); " is 166.
Long Statement,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,IsValidDataPattern,The length of the statement  "		return !p.HasChildGraphPatterns && p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoVariables); " is 142.
Long Statement,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,IsValidDataPattern,The length of the statement  "		return p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoVariables) && ((top && p.ChildGraphPatterns.All (gp => IsValidDataPattern (gp' false))) || !p.HasChildGraphPatterns); " is 220.
Long Statement,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,Evaluate,The length of the statement  "			throw new SparqlUpdateException ("Cannot evaluate a DELETE DATA command where any of the Triple Patterns are not concrete triples (variables are not permitted) or any of the GRAPH clauses have nested Graph Patterns"); " is 217.
Long Statement,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,Evaluate,The length of the statement  "				throw new NotSupportedException ("Graph Specifiers as QNames for DELETE DATA Commands are not supported - please specify an absolute URI instead"); " is 147.
Long Statement,VDS.RDF.Update.Commands,DropCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DropCommand.cs,Evaluate,The length of the statement  "					throw new SparqlUpdateException ("Cannot remove a Named Graph with URI '" + this._graphUri.ToString () + "' since a Graph with this URI does not exist in the Store"); " is 166.
Long Statement,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The length of the statement  "		//TODO: Need to detect when we create a Graph for Insertion but then fail to insert anything since in this case the Inserted Graph should be removed " is 148.
Long Statement,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,IsValidDataPattern,The length of the statement  "		return !p.HasChildGraphPatterns && p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoExplicitVariables); " is 150.
Long Statement,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,IsValidDataPattern,The length of the statement  "		return p.TriplePatterns.All (tp => tp is IConstructTriplePattern && ((IConstructTriplePattern)tp).HasNoExplicitVariables) && ((top && p.ChildGraphPatterns.All (gp => IsValidDataPattern (gp' false))) || !p.HasChildGraphPatterns); " is 228.
Long Statement,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,Evaluate,The length of the statement  "			throw new SparqlUpdateException ("Cannot evaluate a INSERT DATA command where any of the Triple Patterns are not concrete triples (variables are not permitted) or any of the GRAPH clauses have nested Graph Patterns"); " is 217.
Long Statement,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,Evaluate,The length of the statement  "				throw new NotSupportedException ("Graph Specifiers as QNames for INSERT DATA Commands are not supported - please specify an absolute URI instead"); " is 147.
Long Statement,VDS.RDF.Update.Commands,LoadCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\LoadCommand.cs,Evaluate,The length of the statement  "		                throw new PlatformNotSupportedException("The SPARQL LOAD command is not currently supported under Silverlight/Windows Phone 7");" is 128.
Long Statement,VDS.RDF.Update.Commands,LoadCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\LoadCommand.cs,ToString,The length of the statement  "		return "LOAD " + silent + "<" + this._sourceUri.ToString ().Replace (">"' "\\>") + "> INTO <" + this._graphUri.ToString ().Replace (">"' "\\>") + ">"; " is 150.
Long Statement,VDS.RDF.Web,BaseDatasetHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseDatasetHandler.cs,ProcessRequest,The length of the statement  "	//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseGraphHandler.cs,ProcessRequest,The length of the statement  "	//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseGraphHandler.cs,ProcessRequest,The length of the statement  "			throw new RdfWriterSelectionException ("No MIME Type Definitions have a registered RDF Writer for the MIME Types specified in the HTTP Accept Header"); " is 151.
Long Statement,VDS.RDF.Web,BaseSparqlHttpProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlHttpProtocolHandler.cs,ProcessRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' new Uri (UriFactory.Create (context.Request.Url.AbsoluteUri)' this._basePath)); " is 168.
Long Statement,VDS.RDF.Web,BaseSparqlHttpProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlHttpProtocolHandler.cs,ProcessRequest,The length of the statement  "				else if (context.Request.QueryString.AllKeys.Contains ("default") || Regex.IsMatch (context.Request.QueryString.ToString ()' BaseProtocolProcessor.DefaultParameterPattern)) { " is 174.
Long Statement,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)); " is 142.
Long Statement,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The length of the statement  "			MimeTypeDefinition definition = MimeTypesHelper.GetDefinitions (HandlerHelper.GetAcceptTypes (context)).FirstOrDefault (d => d.CanWriteRdf); " is 140.
Long Statement,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The length of the statement  "					IGraph serviceDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)); " is 146.
Long Statement,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The length of the statement  "		//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ShowQueryForm,The length of the statement  "	output.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"); " is 143.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)); " is 142.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "			MimeTypeDefinition definition = MimeTypesHelper.GetDefinitions (HandlerHelper.GetAcceptTypes (context)).FirstOrDefault (d => d.CanWriteRdf); " is 140.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "					IGraph serviceDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)); " is 146.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "		//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "				throw new SparqlUpdatePermissionException ("You are not authorised to perform the " + this.GetPermissionAction (cmd) + " action"); " is 130.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The length of the statement  "						throw new SparqlUpdateMalformedException ("A command in your update request contains a WITH/USING/USING NAMED clause but you have also specified one/both of the using-graph-uri or using-named-graph-uri parameters which is not permitted by the SPARQL Protocol"); " is 261.
Long Statement,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ShowUpdateForm,The length of the statement  "	output.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"); " is 143.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' new Uri (UriFactory.Create (context.Request.Url.AbsoluteUri)' this._basePath + "description")' ServiceDescriptionType.All); " is 212.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessQueryRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)' ServiceDescriptionType.Query); " is 172.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessQueryRequest,The length of the statement  "		//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)' ServiceDescriptionType.Update); " is 173.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,The length of the statement  "		//If there are no user groups then no authentication is in use so we default to authenticated with no per-action authentication needed " is 134.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,The length of the statement  "				throw new SparqlUpdatePermissionException ("You are not authorised to perform the " + this.GetUpdatePermissionAction (cmd) + " action"); " is 136.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessUpdateRequest,The length of the statement  "						throw new SparqlUpdateMalformedException ("A command in your update request contains a WITH/USING/USING NAMED clause but you have also specified one/both of the using-graph-uri or using-named-graph-uri parameters which is not permitted by the SPARQL Protocol"); " is 261.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessProtocolRequest,The length of the statement  "		IGraph svcDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' new Uri (UriFactory.Create (context.Request.Url.AbsoluteUri)' this._basePath)' ServiceDescriptionType.Protocol); " is 201.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessProtocolRequest,The length of the statement  "				else if (context.Request.QueryString.AllKeys.Contains ("default") || Regex.IsMatch (context.Request.QueryString.ToString ()' BaseProtocolProcessor.DefaultParameterPattern)) { " is 174.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ProcessDescriptionRequest,The length of the statement  "		IGraph serviceDescrip = SparqlServiceDescriber.GetServiceDescription (context' this._config' UriFactory.Create (context.Request.Url.AbsoluteUri)' ServiceDescriptionType.All); " is 174.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ShowQueryForm,The length of the statement  "	output.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"); " is 143.
Long Statement,VDS.RDF.Web,BaseSparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlServer.cs,ShowUpdateForm,The length of the statement  "	output.Write ("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"); " is 143.
Long Statement,VDS.RDF.Web,DatasetHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\DatasetHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Dataset Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 207.
Long Statement,VDS.RDF.Web,DatasetHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\DatasetHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Dataset Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 230.
Long Statement,VDS.RDF.Web,DatasetHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\DatasetHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 243.
Long Statement,VDS.RDF.Web,DatasetHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\DatasetHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 247.
Long Statement,VDS.RDF.Web,SparqlServiceDescriber,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServiceDescriber.cs,GetServiceDescription,The length of the statement  "	if (config.ProtocolProcessor != null && (type == ServiceDescriptionType.Protocol || type == ServiceDescriptionType.All)) { " is 122.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Wildcard Protocol Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 217.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Wildcard Protocol Handler Configuration as the RDF configuration file does not have any configuration associated with an appropriate wildcard URI"); " is 207.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (this._basePath' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 237.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (this._basePath' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 241.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,UpdateConfig,The length of the statement  "			System.Web.Caching.CacheDependency dependency = (configFile != null) ? new System.Web.Caching.CacheDependency (configFile) : null; " is 130.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (this._basePath' this._config' null' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' this._config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 202.
Long Statement,VDS.RDF.Web,WildcardProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardProtocolHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (this._basePath' this._config' null' DateTime.Now.AddMinutes (this._config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 206.
Long Statement,VDS.RDF.Web,GraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\GraphHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 205.
Long Statement,VDS.RDF.Web,GraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\GraphHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 228.
Long Statement,VDS.RDF.Web,GraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\GraphHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 243.
Long Statement,VDS.RDF.Web,GraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\GraphHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 247.
Long Statement,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,SendToClient,The length of the statement  "			definition = new MimeTypeDefinition ("SPARQL Results XML"' MimeTypesHelper.SparqlResultsXml' Enumerable.Empty<String> ()); " is 122.
Long Statement,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,SendToClient,The length of the statement  "			storeWriter.Save ((ITripleStore)result' new VDS.RDF.Storage.Params.StreamParams (context.Response.OutputStream' definition.Encoding)); " is 134.
Long Statement,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,SendToClient,The length of the statement  "		throw new RdfOutputException ("Unexpected Result Object of Type '" + result.GetType ().ToString () + "' returned - unable to write Objects of this Type to the HTTP Response"); " is 175.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Protocol Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 208.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Protocol Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 231.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 243.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 247.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,UpdateConfig,The length of the statement  "			System.Web.Caching.CacheDependency dependency = (configFile != null) ? new System.Web.Caching.CacheDependency (configFile) : null; " is 130.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' this._config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 214.
Long Statement,VDS.RDF.Web,ProtocolHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\ProtocolHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' DateTime.Now.AddMinutes (this._config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 218.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Query Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 205.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Query Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 228.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 243.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 247.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,UpdateConfig,The length of the statement  "			System.Web.Caching.CacheDependency dependency = (configFile != null) ? new System.Web.Caching.CacheDependency (configFile) : null; " is 130.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' this._config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 214.
Long Statement,VDS.RDF.Web,QueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\QueryHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' DateTime.Now.AddMinutes (this._config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 218.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 205.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 228.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,LoadConfig,The length of the statement  "		context.Cache.Add (basePath' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 231.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,LoadConfig,The length of the statement  "		context.Cache.Add (basePath' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 235.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,UpdateConfig,The length of the statement  "			System.Web.Caching.CacheDependency dependency = (configFile != null) ? new System.Web.Caching.CacheDependency (configFile) : null; " is 130.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (this._cachePath' this._config' dependency' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' this._config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 209.
Long Statement,VDS.RDF.Web,SparqlServer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\SparqlServer.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (this._cachePath' this._config' dependency' DateTime.Now.AddMinutes (this._config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 213.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Update Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 206.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Update Handler Configuration as the RDF configuration file does not have any configuration associated with the URI <dotnetrdf:" + context.Request.Path + "> as required"); " is 229.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 243.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (context.Request.Path' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 247.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,UpdateConfig,The length of the statement  "			System.Web.Caching.CacheDependency dependency = (configFile != null) ? new System.Web.Caching.CacheDependency (configFile) : null; " is 130.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' this._config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 214.
Long Statement,VDS.RDF.Web,UpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\UpdateHandler.cs,UpdateConfig,The length of the statement  "				context.Cache.Add (context.Request.Path' this._config' dependency' DateTime.Now.AddMinutes (this._config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 218.
Long Statement,VDS.RDF.Web,WildcardGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardGraphHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the Web.Config file does not specify a 'dotNetRDFConfig' AppSetting to specify the RDF configuration file to use"); " is 205.
Long Statement,VDS.RDF.Web,WildcardGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardGraphHandler.cs,LoadConfig,The length of the statement  "		throw new DotNetRdfConfigurationException ("Unable to load Graph Handler Configuration as the RDF configuration file does not have any configuration associated with an appropriate wildcard URI"); " is 195.
Long Statement,VDS.RDF.Web,WildcardGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardGraphHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (this._cachePath' config' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' config.CacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 238.
Long Statement,VDS.RDF.Web,WildcardGraphHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\WildcardGraphHandler.cs,LoadConfig,The length of the statement  "		context.Cache.Add (this._cachePath' config' new System.Web.Caching.CacheDependency (configFile)' DateTime.Now.AddMinutes (config.CacheDuration)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.Normal' null); " is 242.
Long Statement,VDS.RDF.Web.Configuration,WebConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\WebConfigurationLoader.cs,LoadConfigurationGraph,The length of the statement  "		context.Cache.Add (WebConfigGraphCacheKey + Path.GetFileName (configFile)' g' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' WebConfigGraphCacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 279.
Long Statement,VDS.RDF.Web.Configuration,WebConfigurationLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Configuration\WebConfigurationLoader.cs,LoadConfigurationGraph,The length of the statement  "			context.Cache.Add (WebConfigGraphCacheKey + Path.GetFileName (configFile)' g' new System.Web.Caching.CacheDependency (configFile)' System.Web.Caching.Cache.NoAbsoluteExpiration' new TimeSpan (0' WebConfigGraphCacheDuration' 0)' System.Web.Caching.CacheItemPriority.Normal' null); " is 279.
Long Statement,VDS.RDF.Writing.Formatting,RdfXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\RdfXmlFormatter.cs,FormatGraphHeader,The length of the statement  "				output.Append (" xmlns:" + prefix + "=\"" + WriterHelper.EncodeForXml (g.NamespaceMap.GetNamespaceUri (prefix).ToString ()) + "\""); " is 132.
Long Statement,VDS.RDF.Writing.Formatting,RdfXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\RdfXmlFormatter.cs,FormatGraphHeader,The length of the statement  "				output.Append (" xmlns:" + prefix + "=\"" + WriterHelper.EncodeForXml (namespaces.GetNamespaceUri (prefix).ToString ()) + "\""); " is 128.
Long Statement,VDS.RDF.Writing.Formatting,RdfXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\RdfXmlFormatter.cs,GetQName,The length of the statement  "	if (this._mapper != null && this._mapper.ReduceToQName (u.ToString ()' out qname) && RdfXmlSpecsHelper.IsValidQName (qname)) { " is 126.
Long Statement,VDS.RDF.Writing.Formatting,RdfXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\RdfXmlFormatter.cs,Format,The length of the statement  "				output.AppendLine (" rdf:datatype=\"" + WriterHelper.EncodeForXml (lit.DataType.ToString ()) + "\">" + WriterHelper.EncodeForXml (lit.Value) + "</" + qname + ">"); " is 163.
Long Statement,VDS.RDF.Writing.Formatting,SparqlXmlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlXmlFormatter.cs,Format,The length of the statement  "						output.Append (" datatype=\"" + WriterHelper.EncodeForXml (lit.DataType.ToString ()) + "\">" + WriterHelper.EncodeForXml (lit.Value) + "</literal>"); " is 149.
Long Statement,VDS.RDF.Writing.Formatting,BaseFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\BaseFormatter.cs,Format,The length of the statement  "	return this.Format (t.Subject' TripleSegment.Subject) + " " + this.Format (t.Predicate' TripleSegment.Predicate) + " " + this.Format (t.Object' TripleSegment.Object) + " ."; " is 173.
Long Statement,VDS.RDF.Writing.Formatting,NQuadsFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\NQuadsFormatter.cs,Format,The length of the statement  "		return this.Format (t.Subject' TripleSegment.Subject) + " " + this.Format (t.Predicate' TripleSegment.Predicate) + " " + this.Format (t.Object' TripleSegment.Object) + " <" + this.FormatUri (t.GraphUri) + "> ."; " is 211.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The length of the statement  "				output.AppendLine ("PREFIX " + prefix + ": <" + this.FormatUri (this._qnameMapper.GetNamespaceUri (prefix).ToString ()) + ">"); " is 127.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The length of the statement  "				throw new RdfOutputException ("Cannot Format a SPARQL Query as it has no Graph Pattern for the WHERE clause and is not a DESCRIBE query"); " is 138.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The length of the statement  "				throw new RdfOutputException ("Cannot format the Graph/Service Specifier QName " + gp.GraphSpecifier.Value + " as the Namespace Mapper in use for this Formatter cannot resolve the QName"); " is 188.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The length of the statement  "	if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) { " is 191.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The length of the statement  "				throw new RdfOutputException ("Cannot format a Fixed Blank Node Pattern Item as the Predicate of a Triple Pattern as Blank Nodes are not permitted as Predicates"); " is 163.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The length of the statement  "			if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) { " is 165.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The length of the statement  "				throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query"); " is 198.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatExpression,The length of the statement  "				throw new RdfOutputException ("Error Formatting SPARQL Expression - Expressions of type GraphOperator are only allowed a single argument"); " is 139.
Long Statement,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatExpression,The length of the statement  "		throw new RdfOutputException ("Error formatting a SPARQL Expression - the Expression may have the wrong number of arguments for the reported expression type"' ex); " is 163.
Long Statement,VDS.RDF.Writing.Formatting,TurtleFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\TurtleFormatter.cs,FormatLiteralNode,The length of the statement  "		bool fullyEscaped = (longlit) ? value.IsFullyEscaped (this._validEscapes' this._longLitMustEscape) : value.IsFullyEscaped (this._validEscapes' this._litMustEscape); " is 164.
Long Statement,VDS.RDF.Writing.Formatting,TurtleFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\TurtleFormatter.cs,FormatLiteralNode,The length of the statement  "			//Don't need all the other escapes for long literals as the characters that would be escaped are permitted in long literals " is 123.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,ElementEvent,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\XmlEvents.cs,SetUri,The length of the statement  "		throw new RdfParseException ("It is forbidden to change the URI of an Element Event unless it is a rdf:li Element and thus needs expanding to the form rdf:_X according to List Expansion rules"); " is 194.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEvents,The length of the statement  "				throw ParserHelper.Error ("An Attribute with an ambigious name '" + a.LocalName + "' was encountered.  The following attribute names MUST have the rdf: prefix - about' aboutEach' ID' bagID' type' resource' parseType"' element); " is 227.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEvents,The length of the statement  "			throw ParserHelper.Error ("An Attribute with an incorrectly encoded URIRef was encountered' URIRef's must be encoded in Unicode Normal Form C"' a); " is 147.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,DomBasedEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\DomBasedEventGenerator.cs,GenerateEvents,The length of the statement  "		TypedLiteralEvent lit = new TypedLiteralEvent (node.InnerXml.Normalize ()' RdfSpecsHelper.RdfXmlLiteral' node.InnerXml); " is 120.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetNextAttribute,The length of the statement  "			return new NamespaceAttributeEvent (this._reader.LocalName' this._reader.Value' this._reader.Value' this.GetPosition ()); " is 121.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetNextAttribute,The length of the statement  "	else if (this.IsInNamespace (XmlSpecsHelper.NamespaceXml) || (this._reader.NamespaceURI.Equals (String.Empty) && this._reader.Name.StartsWith ("xml"))) { " is 153.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetElement,The length of the statement  "				el.Attributes.Add (new AttributeEvent (this._reader.Name' this._reader.Value' this._reader.Value' this.GetPosition ())); " is 120.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetElement,The length of the statement  "				throw new RdfParseException ("An Attribute with an ambigious name '" + a.LocalName + "' was encountered.  The following attribute names MUST have the rdf: prefix - about' aboutEach' ID' bagID' type' resource' parseType"); " is 221.
Long Statement,VDS.RDF.Parsing.Events.RdfXml,StreamingEventGenerator,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Events\RdfXml\StreamingEventGenerator.cs,GetElement,The length of the statement  "			throw new RdfParseException ("An Attribute with an incorrectly encoded URIRef was encountered' URIRef's must be encoded in Unicode Normal Form C"); " is 147.
Long Statement,VDS.RDF.Query.Expressions.Arithmetic,AdditionExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\AdditionExpression.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Arithmetic,DivisionExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\DivisionExpression.cs,Evaluate,The length of the statement  "			throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Arithmetic,MinusExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\MinusExpression.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Arithmetic,MultiplicationExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\MultiplicationExpression.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Arithmetic,SubtractionExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Arithmetic\SubtractionExpression.cs,Evaluate,The length of the statement  "		throw new RdfQueryException ("Cannot evalute an Arithmetic Expression when the Numeric Type of the expression cannot be determined"); " is 133.
Long Statement,VDS.RDF.Query.Expressions.Comparison,GreaterThanOrEqualToExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Comparison\GreaterThanOrEqualToExpression.cs,Transform,The length of the statement  "	return new GreaterThanOrEqualToExpression (transformer.Transform (this._leftExpr)' transformer.Transform (this._rightExpr)); " is 124.
Long Statement,VDS.RDF.Query.Expressions.Comparison,LessThanOrEqualToExpression,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Comparison\LessThanOrEqualToExpression.cs,Transform,The length of the statement  "	return new LessThanOrEqualToExpression (transformer.Transform (this._leftExpr)' transformer.Transform (this._rightExpr)); " is 121.
Long Statement,VDS.RDF.Query.Expressions.Primary,AllModifier,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Primary\AllModifier.cs,Evaluate,The length of the statement  "	throw new NotImplementedException ("This class is a placeholder only - aggregates taking this as an argument should apply over all rows"); " is 138.
Long Statement,VDS.RDF.Query.Expressions.Primary,DistinctModifier,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Primary\DistinctModifier.cs,Evaluate,The length of the statement  "	throw new NotImplementedException ("This class is a placeholder only - aggregates taking this as an argument should apply a DISTINCT modifer"); " is 143.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The length of the statement  "		a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++]; " is 132.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The length of the statement  "		a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++]; " is 129.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The length of the statement  "	return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index]; " is 259.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntSwapOrder,The length of the statement  "	return ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index]; " is 120.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInt,The length of the statement  "	return (uint)a_in [a_index++] | ((uint)a_in [a_index++] << 8) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index] << 24); " is 126.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The length of the statement  "		a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++])); " is 306.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The length of the statement  "		a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++])); " is 298.
Long Statement,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The length of the statement  "	return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56); " is 285.
Long Statement,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The length of the statement  "		data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16]; " is 175.
Long Statement,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The length of the statement  "		uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G)); " is 133.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16]; " is 177.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a)); " is 129.
Long Statement,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The length of the statement  "		a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h)); " is 129.
Long Statement,VDS.RDF.Storage.Virtualisation,BaseVirtualNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\Virtualisation\VirtualNode.cs,MaterialiseValue,The length of the statement  "			throw new RdfException ("The Virtual RDF Provider materialised a Node of the wrong type! Expected " + this._type.ToString () + " but got " + this._value.NodeType.ToString ()); " is 175.
Complex Conditional,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetFilenameFilter,The conditional expression  "(rdf && (def.CanParseRdf || def.CanWriteRdf)) || (rdfDatasets && (def.CanParseRdfDatasets || def.CanWriteRdfDatasets)) || (sparqlResults && (def.CanParseSparqlResults || def.CanWriteSparqlResults)) || (sparqlQuery && def.CanParseObject<SparqlQuery> ()) || (sparqlUpdate && def.CanParseObject<SparqlUpdateCommandSet> ())"  is complex.
Complex Conditional,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,Parse,The conditional expression  "data.Contains ("\"value\"") && data.Contains ("\"type\"") && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")"  is complex.
Complex Conditional,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,ParseResultSet,The conditional expression  "data.Contains ("\"head\"") && (data.Contains ("\"results\"") || data.Contains ("\"boolean\"")) && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")"  is complex.
Complex Conditional,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,GetParser,The conditional expression  "data.Contains ("\"value\"") && data.Contains ("\"type\"") && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")"  is complex.
Complex Conditional,VDS.RDF.Parsing,StringParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\StringParser.cs,GetResultSetParser,The conditional expression  "data.Contains ("\"head\"") && (data.Contains ("\"results\"") || data.Contains ("\"boolean\"")) && data.Contains ("{") && data.Contains ("}") && data.Contains ("[") && data.Contains ("]")"  is complex.
Complex Conditional,VDS.RDF.Parsing,TurtleSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleSpecsHelper.cs,IsPNCharsBase,The conditional expression  "(c >= 0x00c0 && c <= 0x00d6) || (c >= 0x00d8 && c <= 0x00f6) || (c >= 0x00f8 && c <= 0x02ff) || (c >= 0x0370 && c <= 0x037d) || (c >= 0x200c && c <= 0x200d) || (c >= 0x2070 && c <= 0x218f) || (c >= 0x2c00 && c <= 0x2fef) || (c >= 0x3001 && c <= 0xd7ff) || (c >= 0xf900 && c <= 0xfdcf) || (c >= 0xfdf0 && c <= 0xfffd)"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The conditional expression  "SparqlSpecsHelper.IsSelectQuery (context.Query.QueryType) && (context.Query.IsAggregate && context.Query.GroupBy == null && context.Query.Variables.Any (v => v.IsResultVariable && !v.IsAggregate))"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseConstructTemplate,The conditional expression  "constructTemplate.IsOptional || constructTemplate.IsMinus || constructTemplate.IsExists || constructTemplate.IsNotExists || constructTemplate.IsService || constructTemplate.IsSubQuery"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The conditional expression  "context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The conditional expression  "context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The conditional expression  "next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)"  is complex.
Complex Conditional,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionDoc,The conditional expression  "localName.Equals ("RDF") && ((context.Namespaces.HasNamespace (prefix) && context.Namespaces.GetNamespaceUri (prefix).ToString ().Equals (NamespaceMapper.RDF)) || root.DocumentElement.NamespaceAttributes.Any (ns => ns.Prefix.Equals (prefix) && ns.Uri.Equals (NamespaceMapper.RDF)))"  is complex.
Complex Conditional,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionRDF,The conditional expression  "localName.Equals ("RDF") || ((context.Namespaces.HasNamespace (prefix) && context.Namespaces.GetNamespaceUri (prefix).ToString ().Equals (NamespaceMapper.RDF)) || element.NamespaceAttributes.Any (ns => ns.Prefix.Equals (prefix) && ns.Uri.Equals (NamespaceMapper.RDF)))"  is complex.
Complex Conditional,VDS.RDF.Parsing,XmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\XmlSpecsHelper.cs,IsNameStartChar,The conditional expression  "(c >= 0xC0 && c <= 0xD6) || (c >= 0xD8 && c <= 0xF6) || (c >= 0xF8 && c <= 0x2FF) || (c >= 0x370 && c <= 0x37D) || (c >= 0x37F && c <= 0x1FFF) || (c >= 0x200C && c <= 0x200D) || (c >= 0x2070 && c <= 0x218F) || (c >= 0x2C00 && c <= 0x2FEF) || (c >= 0x3001 && c <= 0xD7FF) || (c >= 0xF900 && c <= 0xFDCF) || (c >= 0xFDF0 && c <= 0xFFFD)"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseResultRow,The conditional expression  "lexicalForm.StartsWith ("http://") || lexicalForm.StartsWith ("https://") || lexicalForm.StartsWith ("mailto:") || lexicalForm.StartsWith ("ftp://")"  is complex.
Complex Conditional,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUnreserved,The conditional expression  "c == '-' || c == '.' || c == '_' || c == '~'"  is complex.
Complex Conditional,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsScheme,The conditional expression  "!Char.IsLetterOrDigit (cs [i]) && cs [i] != '+' && cs [i] != '-' && cs [i] != '.'"  is complex.
Complex Conditional,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The conditional expression  "next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.DOT && next.TokenType != Token.RIGHTCURLYBRACKET"  is complex.
Complex Conditional,VDS.RDF.Parsing,RdfXmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlSpecsHelper.cs,IsPropertyAttributeURI,The conditional expression  "IsCoreSyntaxTerm (qname) || qname.Equals ("rdf:li") || qname.Equals ("rdf:Description") || IsOldTerm (qname)"  is complex.
Complex Conditional,VDS.RDF.Parsing,RdfXmlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlSpecsHelper.cs,IsRdfUriReference,The conditional expression  "(c >= 0x00 && c <= 0x1f) || (c >= 0x7f && c <= 0x9f)"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseDeleteDataCommand,The conditional expression  "!gp.ChildGraphPatterns.All (p => p.IsGraph || (!p.IsExists && !p.IsMinus && !p.IsNotExists && !p.IsOptional && !p.IsOptional && !p.IsService && !p.IsSubQuery && !p.IsUnion))"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseInsertDataCommand,The conditional expression  "!gp.ChildGraphPatterns.All (p => p.IsGraph || (!p.IsExists && !p.IsMinus && !p.IsNotExists && !p.IsOptional && !p.IsOptional && !p.IsService && !p.IsSubQuery && !p.IsUnion))"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,TryParseModifyTemplate,The conditional expression  "gp.ChildGraphPatterns.All (p => p.IsGraph && !p.IsFiltered && !p.IsOptional && !p.IsUnion && !p.HasChildGraphPatterns)"  is complex.
Complex Conditional,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,Parse,The conditional expression  "lastItem == LastPathItemType.Sequencer && next.TokenType == Token.HAT && (lastSequencer == Token.DIVIDE || lastSequencer == Token.BITWISEOR)"  is complex.
Complex Conditional,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsQueryKeyword,The conditional expression  "keyword.Equals (SparqlKeywordAsk) || keyword.Equals (SparqlKeywordConstruct) || keyword.Equals (SparqlKeywordDescribe) || keyword.Equals (SparqlKeywordSelect)"  is complex.
Complex Conditional,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNCharsBase,The conditional expression  "(c >= 0x00c0 && c <= 0x00d6) || (c >= 0x00d8 && c <= 0x00f6) || (c >= 0x00f8 && c <= 0x02ff) || (c >= 0x0370 && c <= 0x037d) || (c >= 0x037f && c <= 0x1fff) || (c >= 0x200c && c <= 0x200d) || (c >= 0x2070 && c <= 0x218f) || (c >= 0x2c00 && c <= 0x2fef) || (c >= 0x3001 && c <= 0xd7ff) || (c >= 0xf900 && c <= 0xfdcf) || (c >= 0xfdf0 && c <= 0xfffd)"  is complex.
Complex Conditional,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNChars,The conditional expression  "(c >= 0x0300 && c <= 0x036f) || (c >= 0x204f && c <= 0x2040)"  is complex.
Complex Conditional,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNLocal,The conditional expression  "Char.IsDigit (first) || IsPNCharsU (first) || (syntax != SparqlQuerySyntax.Sparql_1_0 && IsPLX (cs' 0' out start))"  is complex.
Complex Conditional,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPNLocal,The conditional expression  "!(cs [i] == '.' || IsPNChars (cs [i]) || (syntax != SparqlQuerySyntax.Sparql_1_0 && IsPLX (cs' i' out j)))"  is complex.
Complex Conditional,VDS.RDF.Query,ExplainQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\ExplainQueryProcessor.cs,PrintBgpAnalysis,The conditional expression  "i > 0 && (ps [i] is TriplePattern || ps [i] is SubQueryPattern || ps [i] is PropertyPathPattern)"  is complex.
Complex Conditional,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The conditional expression  "rdfHandler == null && (query.QueryType == SparqlQueryType.Construct || query.QueryType == SparqlQueryType.Describe || query.QueryType == SparqlQueryType.DescribeAll)"  is complex.
Complex Conditional,VDS.RDF.Storage,InMemoryManager,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\InMemoryManager.cs,UpdateGraph,The conditional expression  "(additions != null && additions.Any ()) || (removals != null && removals.Any ())"  is complex.
Complex Conditional,VDS.RDF.Storage,SparqlHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SparqlHttpProtocolConnector.cs,LoadGraph,The conditional expression  "origUri == null && g.IsEmpty && graphUri != null && !graphUri.Equals (String.Empty)"  is complex.
Complex Conditional,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The conditional expression  "(cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)"  is complex.
Complex Conditional,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The conditional expression  "(u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)"  is complex.
Complex Conditional,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The conditional expression  "(cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)"  is complex.
Complex Conditional,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The conditional expression  "(u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)"  is complex.
Complex Conditional,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,IsValidDataPattern,The conditional expression  "p.IsExists || p.IsMinus || p.IsNotExists || p.IsOptional || p.IsService || p.IsSubQuery || p.IsUnion"  is complex.
Complex Conditional,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,The conditional expression  "lastSubj == null || !t.Subject.Equals (lastSubj) || (t.Context != null && t.Context is VariableContext)"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,TriGTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TriGTokeniser.cs,TryGetNumericLiteral,The conditional expression  "(signoccurred || expoccurred) && !(this.Value.EndsWith ("e") || this.Value.EndsWith ("E"))"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetQNameOrKeyword,The conditional expression  "!colonoccurred && (SparqlSpecsHelper.IsNonQueryKeyword (value) || SparqlSpecsHelper.IsFunctionKeyword (value) || SparqlSpecsHelper.IsAggregateKeyword (value) || SparqlSpecsHelper.IsUpdateKeyword (value))"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,SparqlTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\SparqlTokeniser.cs,TryGetDataType,The conditional expression  "Char.IsLetter (next) || UnicodeSpecsHelper.IsLetter (next) || next == '_' || next == ':'"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,IsValidQName,The conditional expression  "first == '_' || first == ':' || Char.IsLetter (first) || UnicodeSpecsHelper.IsLetter (first)"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,IsValidQName,The conditional expression  "c == '_' || c == ':' || c == '-' || Char.IsLetterOrDigit (c) || UnicodeSpecsHelper.IsLetterOrDigit (c)"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,IsValidVarName,The conditional expression  "c == '_' || c == '-' || Char.IsLetterOrDigit (c) || UnicodeSpecsHelper.IsLetterOrDigit (c)"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The conditional expression  "Char.IsWhiteSpace (next) || next == '.' || next == ';' || next == ''' || next == '^' || next == '@'"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,GetNextToken,The conditional expression  "Char.IsWhiteSpace (next) || next == '.' || next == ';' || next == ''' || next == '^' || next == '@'"  is complex.
Complex Conditional,VDS.RDF.Parsing.Tokens,CsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\CsvTokeniser.cs,TryGetQuotedField,The conditional expression  "next == ''' || next == '\n' || next == '\r' || this._in.EndOfStream"  is complex.
Complex Conditional,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,Evaluate,The conditional expression  "context.Query.HasDistinctModifier || (context.Query.OrderBy != null && !context.Query.IsOptimisableOrderBy) || context.Query.GroupBy != null || context.Query.Having != null || context.Query.Bindings != null"  is complex.
Complex Conditional,VDS.RDF.Query.Algebra,OneOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\OneOrMorePath.cs,Evaluate,The conditional expression  "subjVar == null || (subjVar != null && context.InputMultiset.ContainsVariable (subjVar)) || (objVar != null && !context.InputMultiset.ContainsVariable (objVar))"  is complex.
Complex Conditional,VDS.RDF.Query.Algebra,ZeroOrMorePath,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ZeroOrMorePath.cs,Evaluate,The conditional expression  "subjVar == null || (subjVar != null && context.InputMultiset.ContainsVariable (subjVar)) || (objVar != null && !context.InputMultiset.ContainsVariable (objVar))"  is complex.
Complex Conditional,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,ExistsFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs,Evaluate,The conditional expression  "this._result == null || this._lastInput == null || (int)this._lastInput != context.InputMultiset.GetHashCode () || this._lastCount != context.InputMultiset.Count"  is complex.
Complex Conditional,VDS.RDF.Update.Commands,BaseModificationCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\BaseModifyCommand.cs,IsValidDeletePattern,The conditional expression  "p.IsExists || p.IsMinus || p.IsNotExists || p.IsOptional || p.IsService || p.IsSubQuery || p.IsUnion"  is complex.
Complex Conditional,VDS.RDF.Update.Commands,DeleteDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteDataCommand.cs,IsValidDataPattern,The conditional expression  "p.IsExists || p.IsMinus || p.IsNotExists || p.IsOptional || p.IsService || p.IsSubQuery || p.IsUnion"  is complex.
Complex Conditional,VDS.RDF.Update.Commands,InsertDataCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertDataCommand.cs,IsValidDataPattern,The conditional expression  "p.IsExists || p.IsMinus || p.IsNotExists || p.IsOptional || p.IsService || p.IsSubQuery || p.IsUnion"  is complex.
Complex Conditional,VDS.RDF.Writing.Formatting,CsvFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\CsvFormatter.cs,FormatLiteralNode,The conditional expression  "value.Contains ('"') || value.Contains (''') || value.Contains ('\n') || value.Contains ('\r')"  is complex.
Complex Conditional,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The conditional expression  "gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0"  is complex.
Empty Catch Block,VDS.RDF,MimeTypesHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\MimeTypesHelper.cs,GetParser,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,RdfJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfJsonParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,FileLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\FileLoader.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlRdfParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlRdfParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlUpdateParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlUpdateParser.cs,Parse,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,SparqlBooleanParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlBooleanParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,Load,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,Initialise,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,Initialise,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,Initialise,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,Initialise,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,RemoveETag,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing,UriLoaderCache,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoaderCache.cs,ToCache,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ApplyAlgebraOptimisations,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ApplyAlgebraOptimisations,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,LeviathanQueryProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\LeviathanQueryProcessor.cs,ProcessQuery,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query,BaseSparqlView,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlView.cs,InvalidateViewCompleted,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDeleteCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessInsertCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,SparqlUpdateCommandSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlUpdateCommandSet.cs,ApplyAlgebraOptimisers,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update,SparqlUpdateCommandSet,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\SparqlUpdateCommandSet.cs,ApplyAlgebraOptimisers,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlHtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlHtmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlJsonWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlXmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,NTriplesWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NTriplesWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,HtmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,CsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CsvWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,FastRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\FastRdfXmlWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,NQuadsWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\NQuadsWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,RdfJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfJsonWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlCsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlCsvWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlTsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlTsvWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,SparqlXsltWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\SparqlXsltWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,TriXWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriXWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,TsvWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TsvWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Writing,TurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TurtleWriter.cs,Save,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing.Handlers,WriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartRdfInternal,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Parsing.Handlers,ResultWriteThroughHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Handlers\WriteThroughHandler.cs,StartResultsInternal,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Patterns,BindPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\BindPattern.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Patterns,LetPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\LetPattern.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Patterns,LetPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\LetPattern.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Leviathan,AnyAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\AnyAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Leviathan,MedianAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\MedianAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Leviathan,NoneAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NoneAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Sparql,CountAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Sparql,CountDistinctAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\CountDistinctAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Sparql,MaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\MaxAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Sparql,MinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\MinAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Aggregates.Sparql,SampleAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\SampleAggregate.cs,Apply,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,AskBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AskBgp.cs,StreamingEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,Extend,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Extend.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,StreamingEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,LazyBgp,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\LazyBgp.cs,StreamingEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,ParallelUnion,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,ParallelUnion,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,ParallelEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,ParallelUnion,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,ParallelEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,ParallelEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,ParallelEvaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Expressions.Functions.Sparql,CoalesceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\CoalesceFunction.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Expressions.Functions.Sparql.Boolean,RegexFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\Boolean\RegexFunction.cs,RegexFunction,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Expressions.Functions.Sparql.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\String\ReplaceFunction.cs,ReplaceFunction,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Query.Expressions.Functions.XPath.String,ReplaceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\String\ReplaceFunction.cs,ReplaceFunction,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,DeleteCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DeleteCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,InsertCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\InsertCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Web,BaseSparqlQueryHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlQueryHandler.cs,ProcessRequest,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Web,BaseSparqlUpdateHandler,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\BaseSparqlUpdateHandler.cs,ProcessRequest,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Web,NegotiateByFileExtension,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\NegotiateByFileExtension.cs,context_BeginRequest,The method has an empty catch block.
Empty Catch Block,VDS.RDF.Web,HandlerHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\HandlerHelper.cs,AddCachingHeaders,The method has an empty catch block.
Magic Number,VDS.RDF,BackgroundPersistedGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BackgroundPersistedGraph.cs,PersistData,The following statement contains a magic number: while (true) {  	try {  		if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0) {  			this.Flush ();  		}  		//If we've been asked to End Persistence we'll do so unless we've not finished flushing the buffers  		if (this._endPersistence) {  			if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0)  				continue;  			this._finished = true;  			return;  		}  		//Only sleep if there aren't anything in the queue  		if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0)  			continue;  		Thread.Sleep (5000);  	}  	catch (ThreadAbortException) {  		//Asked to stop  		this.Flush ();  		#if !SILVERLIGHT  		Thread.ResetAbort ();  		#endif  		this._finished = true;  		return;  	}  }  
Magic Number,VDS.RDF,BackgroundPersistedGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BackgroundPersistedGraph.cs,PersistData,The following statement contains a magic number: try {  	if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0) {  		this.Flush ();  	}  	//If we've been asked to End Persistence we'll do so unless we've not finished flushing the buffers  	if (this._endPersistence) {  		if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0)  			continue;  		this._finished = true;  		return;  	}  	//Only sleep if there aren't anything in the queue  	if (this._addedTriplesBuffer.Count > 0 || this._removedTriplesBuffer.Count > 0)  		continue;  	Thread.Sleep (5000);  }  catch (ThreadAbortException) {  	//Asked to stop  	this.Flush ();  	#if !SILVERLIGHT  	Thread.ResetAbort ();  	#endif  	this._finished = true;  	return;  }  
Magic Number,VDS.RDF,BackgroundPersistedGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BackgroundPersistedGraph.cs,PersistData,The following statement contains a magic number: Thread.Sleep (5000);  
Magic Number,VDS.RDF,BackgroundPersistedGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BackgroundPersistedGraph.cs,Dispose,The following statement contains a magic number: if (this._persister != null && !this._finished) {  	//Use a signal to terminate the Thread rather than Thread.Abort() which may block indefinitely in some circumstances  	this._endPersistence = true;  	this._suspendPersistence = true;  	Thread.Sleep (100);  }  
Magic Number,VDS.RDF,BackgroundPersistedGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\BackgroundPersistedGraph.cs,Dispose,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,IsFullyEscaped,The following statement contains a magic number: if (value.Length == 1) {  	if (value [0] == '\\')  		return false;  	if (cs.Contains (value [0]))  		return false;  }  else {  	//Work through the characters in pairs  	for (int i = 0; i < value.Length; i += 2) {  		char c = value [i];  		if (i < value.Length - 1) {  			char d = value [i + 1];  			if (c == '\\') {  				//Only fully escaped if followed by an escape character  				if (!cs.Contains (d))  					return false;  			}  			else if (ds.Contains (c)) {  				//If c is a character that must be escaped then not fully escaped  				return false;  			}  			else if (d == '\\') {  				//If d is a backslash shift the index back by 1 so that this will be the first  				//character of the next character pair we assess  				i--;  			}  			else if (ds.Contains (d)) {  				//If d is a character that must be escaped we know that the preceding character  				//was not a backslash so the string is not fully escaped  				return false;  			}  		}  		else {  			//If trailing character is a backslash or a character that must be escaped then not fully escaped  			if (c == '\\' || ds.Contains (c))  				return false;  		}  	}  }  
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,IsFullyEscaped,The following statement contains a magic number: for (int i = 0; i < value.Length; i += 2) {  	char c = value [i];  	if (i < value.Length - 1) {  		char d = value [i + 1];  		if (c == '\\') {  			//Only fully escaped if followed by an escape character  			if (!cs.Contains (d))  				return false;  		}  		else if (ds.Contains (c)) {  			//If c is a character that must be escaped then not fully escaped  			return false;  		}  		else if (d == '\\') {  			//If d is a backslash shift the index back by 1 so that this will be the first  			//character of the next character pair we assess  			i--;  		}  		else if (ds.Contains (d)) {  			//If d is a character that must be escaped we know that the preceding character  			//was not a backslash so the string is not fully escaped  			return false;  		}  	}  	else {  		//If trailing character is a backslash or a character that must be escaped then not fully escaped  		if (c == '\\' || ds.Contains (c))  			return false;  	}  }  
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,IsFullyEscaped,The following statement contains a magic number: i += 2
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,Escape,The following statement contains a magic number: if (value.Length == 1) {  	if (value [0] == toEscape)  		return new String (new char[] {  			'\\''  			toEscape  		});  	return value;  }  else {  	//Work through the characters in pairs  	StringBuilder output = new StringBuilder ();  	for (int i = 0; i < value.Length; i += 2) {  		char c = value [i];  		if (i < value.Length - 1) {  			char d = value [i + 1];  			if (c == toEscape) {  				//Must escape this  				output.Append ('\\');  				output.Append (escapeAs);  				//Reduce index by 1 as next character is now start of next pair  				i--;  			}  			else if (c == '\\') {  				//Regardless of the next character we append this to the output since it is an escape  				//of some kind - whether it relates to the character we want to escape or not is  				//irrelevant in this case  				output.Append (c);  				output.Append (d);  			}  			else if (d == toEscape) {  				//If d is the character to be escaped and we get to this case then it isn't escaped  				//currently so we must escape it  				output.Append (c);  				output.Append ('\\');  				output.Append (escapeAs);  			}  			else if (d == '\\') {  				//If d is a backslash shift the index back by 1 so that this will be the first  				//character of the next character pair we assess  				output.Append (c);  				i--;  			}  			else {  				output.Append (c);  				output.Append (d);  			}  		}  		else {  			//If trailing character is character to escape then do so  			if (c == toEscape) {  				output.Append ('\\');  			}  			output.Append (c);  		}  	}  	return output.ToString ();  }  
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,Escape,The following statement contains a magic number: for (int i = 0; i < value.Length; i += 2) {  	char c = value [i];  	if (i < value.Length - 1) {  		char d = value [i + 1];  		if (c == toEscape) {  			//Must escape this  			output.Append ('\\');  			output.Append (escapeAs);  			//Reduce index by 1 as next character is now start of next pair  			i--;  		}  		else if (c == '\\') {  			//Regardless of the next character we append this to the output since it is an escape  			//of some kind - whether it relates to the character we want to escape or not is  			//irrelevant in this case  			output.Append (c);  			output.Append (d);  		}  		else if (d == toEscape) {  			//If d is the character to be escaped and we get to this case then it isn't escaped  			//currently so we must escape it  			output.Append (c);  			output.Append ('\\');  			output.Append (escapeAs);  		}  		else if (d == '\\') {  			//If d is a backslash shift the index back by 1 so that this will be the first  			//character of the next character pair we assess  			output.Append (c);  			i--;  		}  		else {  			output.Append (c);  			output.Append (d);  		}  	}  	else {  		//If trailing character is character to escape then do so  		if (c == toEscape) {  			output.Append ('\\');  		}  		output.Append (c);  	}  }  
Magic Number,VDS.RDF,Extensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,Escape,The following statement contains a magic number: i += 2
Magic Number,VDS.RDF,LiteralExtensions,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Extensions.cs,ToLiteral,The following statement contains a magic number: if (b > 128) {  	//If value is > 128 must use unsigned byte as the type as xsd:byte has range -127 to 128   	//while .Net byte has range 0-255  	return factory.CreateLiteralNode (XmlConvert.ToString (b)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeUnsignedByte));  }  else {  	return factory.CreateLiteralNode (XmlConvert.ToString (b)' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeByte));  }  
Magic Number,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,BaseLiteralNode,The following statement contains a magic number: switch (mode) {  case 0:  	//Nothing more to do - plain literal  	this._hashcode = (this._nodetype + this.ToString () + PlainLiteralHashCodeSalt).GetHashCode ();  	break;  case 1:  	//Get the Language  	this._language = info.GetString ("lang");  	this._hashcode = (this._nodetype + this.ToString () + LangSpecLiteralHashCodeSalt).GetHashCode ();  	break;  case 2:  	//Get the Datatype  	this._datatype = UriFactory.Create (info.GetString ("datatype"));  	this._hashcode = (this._nodetype + this.ToString () + DataTypedLiteralHashCodeSalt).GetHashCode ();  	break;  default:  	throw new RdfParseException ("Unable to deserialize a Literal Node");  }  
Magic Number,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,GetObjectData,The following statement contains a magic number: if (this._datatype != null) {  	info.AddValue ("mode"' (byte)2);  	info.AddValue ("datatype"' this._datatype.ToString ());  }  else if (!this._language.Equals (String.Empty)) {  	info.AddValue ("mode"' (byte)1);  	info.AddValue ("lang"' this._language);  }  else {  	info.AddValue ("mode"' (byte)0);  }  
Magic Number,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,GetObjectData,The following statement contains a magic number: info.AddValue ("mode"' (byte)2);  
Magic Number,VDS.RDF,QNameOutputMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NamespaceMapper.cs,ReduceToQName,The following statement contains a magic number: if (uri.Contains ('#')) {  	nsUri = uri.Substring (0' uri.LastIndexOf ('#') + 1);  	nsPrefix = this.GetNextTemporaryNamespacePrefix ();  }  else if (uri.LastIndexOf ('/') > 8) {  	nsUri = uri.Substring (0' uri.LastIndexOf ('/') + 1);  	nsPrefix = this.GetNextTemporaryNamespacePrefix ();  }  else {  	//Failed to find a Reduction and unable to issue a Temporary Namespace  	qname = String.Empty;  	return false;  }  
Magic Number,VDS.RDF,QNameOutputMapper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\NamespaceMapper.cs,ReduceToQName,The following statement contains a magic number: if (uri.LastIndexOf ('/') > 8) {  	nsUri = uri.Substring (0' uri.LastIndexOf ('/') + 1);  	nsPrefix = this.GetNextTemporaryNamespacePrefix ();  }  else {  	//Failed to find a Reduction and unable to issue a Temporary Namespace  	qname = String.Empty;  	return false;  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.StartsWith ("file:/")) {  	//HACK: This is something of a Hack as a workaround to the issue that some systems may generate RDF which have technically malformed file:// scheme URIs in it  	//This is because *nix style filesystems use paths of the form /path/to/somewhere and some serializers will serialize such  	//a file path by just prepending file: when they should be prepending file://  	if (uriref.Length > 6) {  		if (uriref [6] != '/') {  			return "file://" + uriref.Substring (5);  		}  	}  	return uriref;  }  else {  	return uriref;  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.StartsWith ("file:/")) {  	//HACK: This is something of a Hack as a workaround to the issue that some systems may generate RDF which have technically malformed file:// scheme URIs in it  	//This is because *nix style filesystems use paths of the form /path/to/somewhere and some serializers will serialize such  	//a file path by just prepending file: when they should be prepending file://  	if (uriref.Length > 6) {  		if (uriref [6] != '/') {  			return "file://" + uriref.Substring (5);  		}  	}  	return uriref;  }  else {  	return uriref;  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.StartsWith ("file:/")) {  	//HACK: This is something of a Hack as a workaround to the issue that some systems may generate RDF which have technically malformed file:// scheme URIs in it  	//This is because *nix style filesystems use paths of the form /path/to/somewhere and some serializers will serialize such  	//a file path by just prepending file: when they should be prepending file://  	if (uriref.Length > 6) {  		if (uriref [6] != '/') {  			return "file://" + uriref.Substring (5);  		}  	}  	return uriref;  }  else {  	return uriref;  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.Length > 6) {  	if (uriref [6] != '/') {  		return "file://" + uriref.Substring (5);  	}  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.Length > 6) {  	if (uriref [6] != '/') {  		return "file://" + uriref.Substring (5);  	}  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref.Length > 6) {  	if (uriref [6] != '/') {  		return "file://" + uriref.Substring (5);  	}  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref [6] != '/') {  	return "file://" + uriref.Substring (5);  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: if (uriref [6] != '/') {  	return "file://" + uriref.Substring (5);  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,FixMalformedUriStrings,The following statement contains a magic number: return "file://" + uriref.Substring (5);  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,ResolveQName,The following statement contains a magic number: if (qname.StartsWith (":")) {  	//QName in Default Namespace  	if (nsmap.HasNamespace (String.Empty)) {  		//Default Namespace Defined  		output = nsmap.GetNamespaceUri (String.Empty).ToString () + qname.Substring (1);  	}  	else {  		//No Default Namespace so use Base Uri  		//These type of QNames are scoped to the local Uri regardless of the type of the Base Uri  		//i.e. these always result in Hash URIs  		if (baseUri != null) {  			output = baseUri.ToString ();  			if (output.EndsWith ("#")) {  				output += qname.Substring (1);  			}  			else {  				output += "#" + qname.Substring (1);  			}  		}  		else {  			throw new RdfParseException ("Cannot resolve a QName in the Default Namespace when there is no in-scope Base URI and no Default Namespace defined");  		}  	}  }  else {  	//QName in some other Namespace  	String[] parts = qname.Split (new char[] {  		':'  	}' 2);  	if (parts.Length == 1) {  		output = nsmap.GetNamespaceUri (String.Empty).ToString () + parts [0];  	}  	else {  		output = nsmap.GetNamespaceUri (parts [0]).ToString () + parts [1];  	}  }  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,CombineHashCodes,The following statement contains a magic number: hash = hash * 31 + x.GetHashCode ();  
Magic Number,VDS.RDF,Tools,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\Tools.cs,CombineHashCodes,The following statement contains a magic number: hash = hash * 31 + y.GetHashCode ();  
Magic Number,VDS.RDF,DiskDemandGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\DiskDemandTripleStore.cs,Contains,The following statement contains a magic number: if (graphUri.IsFile)  #endif   {  	try {  		Graph g = new Graph ();  		FileLoader.Load (g' graphUri.ToString ().Substring (8));  		this.Add (g' false);  		return true;  	}  	catch {  		return false;  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF,DiskDemandGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\DiskDemandTripleStore.cs,Contains,The following statement contains a magic number: try {  	Graph g = new Graph ();  	FileLoader.Load (g' graphUri.ToString ().Substring (8));  	this.Add (g' false);  	return true;  }  catch {  	return false;  }  
Magic Number,VDS.RDF,DiskDemandGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\DiskDemandTripleStore.cs,Contains,The following statement contains a magic number: FileLoader.Load (g' graphUri.ToString ().Substring (8));  
Magic Number,VDS.RDF,IndexHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Indexing.cs,SearchIndex,The following statement contains a magic number: do {  	if (lower > upper)  		return Enumerable.Empty<T> ();  	middle = (lower + upper) / 2;  	c = comparer.Compare (index [middle]' search);  	if (c < 0) {  		//Increment lower bound  		lower = middle + 1;  	}  	else {  		//If equal record possible start point  		if (c == 0)  			start = middle;  		//Decrement upper bound and end  		upper = middle - 1;  		if (c != 0)  			end = middle;  	}  }  while (lower < start);  
Magic Number,VDS.RDF,IndexHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Indexing.cs,SearchIndex,The following statement contains a magic number: middle = (lower + upper) / 2;  
Magic Number,VDS.RDF,IndexHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Indexing.cs,SearchIndex,The following statement contains a magic number: do {  	if (lower > upper)  		break;  	middle = (lower + upper) / 2;  	c = comparer.Compare (index [middle]' search);  	if (c > 0) {  		//Decrement upper bound  		upper = middle - 1;  	}  	else {  		//If equal record possible end point  		if (c == 0)  			end = middle;  		//Increment lower bound  		lower = middle + 1;  	}  }  while (true);  
Magic Number,VDS.RDF,IndexHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Indexing.cs,SearchIndex,The following statement contains a magic number: middle = (lower + upper) / 2;  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (context.Input.Read ()) {  	if (context.Input.TokenType == JsonToken.StartObject) {  		context.Input.Read ();  		while (context.Input.TokenType != JsonToken.EndObject) {  			token = context.Input.Value.ToString ().ToLower ();  			//Check that we get a Property Value as a String  			context.Input.Read ();  			if (context.Input.TokenType != JsonToken.String) {  				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Variable Binding");  			}  			//Extract the Information from the Object  			if (token.Equals ("value")) {  				nodeValue = context.Input.Value.ToString ();  			}  			else if (token.Equals ("type")) {  				nodeType = context.Input.Value.ToString ().ToLower ();  			}  			else if (token.Equals ("lang") || token.Equals ("xml:lang")) {  				if (nodeLang == null && nodeDatatype == null) {  					nodeLang = context.Input.Value.ToString ();  				}  				else {  					throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified");  				}  			}  			else if (token.Equals ("datatype")) {  				if (nodeDatatype == null && nodeLang == null) {  					nodeDatatype = context.Input.Value.ToString ();  				}  				else {  					throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified");  				}  			}  			else {  				throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties");  			}  			//Get Next Token  			if (!context.Input.Read ()) {  				throw new RdfParseException ("Unexpected End of Input while trying to parse a Bound Variable Object");  			}  		}  		//Validate the Information  		if (nodeType == null) {  			throw new RdfParseException ("Cannot parse a Node from the JSON where no 'type' property was specified in the JSON Object representing the Node");  		}  		if (nodeValue == null) {  			throw new RdfParseException ("Cannot parse a Node from the JSON where no 'value' property was specified in the JSON Object representing the Node");  		}  		//Turn this information into a Node  		INode n;  		if (nodeType.Equals ("uri")) {  			n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  		}  		else if (nodeType.Equals ("bnode")) {  			if (nodeValue.StartsWith ("_:")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  			}  			else if (nodeValue.Contains ("://")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  			}  			else if (nodeValue.Contains (":")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  			}  			else {  				n = context.Handler.CreateBlankNode (nodeValue);  			}  		}  		else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  			if (nodeLang != null) {  				n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  			}  			else if (nodeDatatype != null) {  				n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  			}  			else {  				n = context.Handler.CreateLiteralNode (nodeValue);  			}  		}  		else {  			throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  		}  		//Check that the Variable was defined in the Header  		if (!context.Variables.Contains (var)) {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a Binding Object attempts to bind a value to the variable '" + var + "' which is not defined in the Header Object in the value for the 'vars' property!");  		}  		//Add to the result  		r.SetValue (var' n);  	}  	else {  		throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Bound Variable Object");  	}  }  else {  	throw Error (context' "Unexpected End of Input while trying to parse a Bound Variable Object");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (context.Input.Read ()) {  	if (context.Input.TokenType == JsonToken.StartObject) {  		context.Input.Read ();  		while (context.Input.TokenType != JsonToken.EndObject) {  			token = context.Input.Value.ToString ().ToLower ();  			//Check that we get a Property Value as a String  			context.Input.Read ();  			if (context.Input.TokenType != JsonToken.String) {  				throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Variable Binding");  			}  			//Extract the Information from the Object  			if (token.Equals ("value")) {  				nodeValue = context.Input.Value.ToString ();  			}  			else if (token.Equals ("type")) {  				nodeType = context.Input.Value.ToString ().ToLower ();  			}  			else if (token.Equals ("lang") || token.Equals ("xml:lang")) {  				if (nodeLang == null && nodeDatatype == null) {  					nodeLang = context.Input.Value.ToString ();  				}  				else {  					throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified");  				}  			}  			else if (token.Equals ("datatype")) {  				if (nodeDatatype == null && nodeLang == null) {  					nodeDatatype = context.Input.Value.ToString ();  				}  				else {  					throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified");  				}  			}  			else {  				throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties");  			}  			//Get Next Token  			if (!context.Input.Read ()) {  				throw new RdfParseException ("Unexpected End of Input while trying to parse a Bound Variable Object");  			}  		}  		//Validate the Information  		if (nodeType == null) {  			throw new RdfParseException ("Cannot parse a Node from the JSON where no 'type' property was specified in the JSON Object representing the Node");  		}  		if (nodeValue == null) {  			throw new RdfParseException ("Cannot parse a Node from the JSON where no 'value' property was specified in the JSON Object representing the Node");  		}  		//Turn this information into a Node  		INode n;  		if (nodeType.Equals ("uri")) {  			n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  		}  		else if (nodeType.Equals ("bnode")) {  			if (nodeValue.StartsWith ("_:")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  			}  			else if (nodeValue.Contains ("://")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  			}  			else if (nodeValue.Contains (":")) {  				n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  			}  			else {  				n = context.Handler.CreateBlankNode (nodeValue);  			}  		}  		else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  			if (nodeLang != null) {  				n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  			}  			else if (nodeDatatype != null) {  				n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  			}  			else {  				n = context.Handler.CreateLiteralNode (nodeValue);  			}  		}  		else {  			throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  		}  		//Check that the Variable was defined in the Header  		if (!context.Variables.Contains (var)) {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a Binding Object attempts to bind a value to the variable '" + var + "' which is not defined in the Header Object in the value for the 'vars' property!");  		}  		//Add to the result  		r.SetValue (var' n);  	}  	else {  		throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Bound Variable Object");  	}  }  else {  	throw Error (context' "Unexpected End of Input while trying to parse a Bound Variable Object");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (context.Input.TokenType == JsonToken.StartObject) {  	context.Input.Read ();  	while (context.Input.TokenType != JsonToken.EndObject) {  		token = context.Input.Value.ToString ().ToLower ();  		//Check that we get a Property Value as a String  		context.Input.Read ();  		if (context.Input.TokenType != JsonToken.String) {  			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Variable Binding");  		}  		//Extract the Information from the Object  		if (token.Equals ("value")) {  			nodeValue = context.Input.Value.ToString ();  		}  		else if (token.Equals ("type")) {  			nodeType = context.Input.Value.ToString ().ToLower ();  		}  		else if (token.Equals ("lang") || token.Equals ("xml:lang")) {  			if (nodeLang == null && nodeDatatype == null) {  				nodeLang = context.Input.Value.ToString ();  			}  			else {  				throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified");  			}  		}  		else if (token.Equals ("datatype")) {  			if (nodeDatatype == null && nodeLang == null) {  				nodeDatatype = context.Input.Value.ToString ();  			}  			else {  				throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified");  			}  		}  		else {  			throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties");  		}  		//Get Next Token  		if (!context.Input.Read ()) {  			throw new RdfParseException ("Unexpected End of Input while trying to parse a Bound Variable Object");  		}  	}  	//Validate the Information  	if (nodeType == null) {  		throw new RdfParseException ("Cannot parse a Node from the JSON where no 'type' property was specified in the JSON Object representing the Node");  	}  	if (nodeValue == null) {  		throw new RdfParseException ("Cannot parse a Node from the JSON where no 'value' property was specified in the JSON Object representing the Node");  	}  	//Turn this information into a Node  	INode n;  	if (nodeType.Equals ("uri")) {  		n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  	}  	else if (nodeType.Equals ("bnode")) {  		if (nodeValue.StartsWith ("_:")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  		}  		else if (nodeValue.Contains ("://")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  		}  		else if (nodeValue.Contains (":")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  		}  		else {  			n = context.Handler.CreateBlankNode (nodeValue);  		}  	}  	else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  		if (nodeLang != null) {  			n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  		}  		else if (nodeDatatype != null) {  			n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  		}  		else {  			n = context.Handler.CreateLiteralNode (nodeValue);  		}  	}  	else {  		throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  	}  	//Check that the Variable was defined in the Header  	if (!context.Variables.Contains (var)) {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a Binding Object attempts to bind a value to the variable '" + var + "' which is not defined in the Header Object in the value for the 'vars' property!");  	}  	//Add to the result  	r.SetValue (var' n);  }  else {  	throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Bound Variable Object");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (context.Input.TokenType == JsonToken.StartObject) {  	context.Input.Read ();  	while (context.Input.TokenType != JsonToken.EndObject) {  		token = context.Input.Value.ToString ().ToLower ();  		//Check that we get a Property Value as a String  		context.Input.Read ();  		if (context.Input.TokenType != JsonToken.String) {  			throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected a Property Value describing one of the properties of an Variable Binding");  		}  		//Extract the Information from the Object  		if (token.Equals ("value")) {  			nodeValue = context.Input.Value.ToString ();  		}  		else if (token.Equals ("type")) {  			nodeType = context.Input.Value.ToString ().ToLower ();  		}  		else if (token.Equals ("lang") || token.Equals ("xml:lang")) {  			if (nodeLang == null && nodeDatatype == null) {  				nodeLang = context.Input.Value.ToString ();  			}  			else {  				throw Error (context' "Unexpected Language Property specified for an Object Node where a Language or Datatype has already been specified");  			}  		}  		else if (token.Equals ("datatype")) {  			if (nodeDatatype == null && nodeLang == null) {  				nodeDatatype = context.Input.Value.ToString ();  			}  			else {  				throw Error (context' "Unexpected Datatype Property specified for an Object Node where a Language or Datatype has already been specified");  			}  		}  		else {  			throw Error (context' "Unexpected Property '" + token + "' specified for an Object Node' only 'value'' 'type'' 'lang' and 'datatype' are valid properties");  		}  		//Get Next Token  		if (!context.Input.Read ()) {  			throw new RdfParseException ("Unexpected End of Input while trying to parse a Bound Variable Object");  		}  	}  	//Validate the Information  	if (nodeType == null) {  		throw new RdfParseException ("Cannot parse a Node from the JSON where no 'type' property was specified in the JSON Object representing the Node");  	}  	if (nodeValue == null) {  		throw new RdfParseException ("Cannot parse a Node from the JSON where no 'value' property was specified in the JSON Object representing the Node");  	}  	//Turn this information into a Node  	INode n;  	if (nodeType.Equals ("uri")) {  		n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  	}  	else if (nodeType.Equals ("bnode")) {  		if (nodeValue.StartsWith ("_:")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  		}  		else if (nodeValue.Contains ("://")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  		}  		else if (nodeValue.Contains (":")) {  			n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  		}  		else {  			n = context.Handler.CreateBlankNode (nodeValue);  		}  	}  	else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  		if (nodeLang != null) {  			n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  		}  		else if (nodeDatatype != null) {  			n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  		}  		else {  			n = context.Handler.CreateLiteralNode (nodeValue);  		}  	}  	else {  		throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  	}  	//Check that the Variable was defined in the Header  	if (!context.Variables.Contains (var)) {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a Binding Object attempts to bind a value to the variable '" + var + "' which is not defined in the Header Object in the value for the 'vars' property!");  	}  	//Add to the result  	r.SetValue (var' n);  }  else {  	throw Error (context' "Unexpected Token '" + context.Input.TokenType.ToString () + "' encountered' expected the start of a Bound Variable Object");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeType.Equals ("uri")) {  	n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  }  else if (nodeType.Equals ("bnode")) {  	if (nodeValue.StartsWith ("_:")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  	}  	else if (nodeValue.Contains ("://")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  	}  	else if (nodeValue.Contains (":")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  	}  	else {  		n = context.Handler.CreateBlankNode (nodeValue);  	}  }  else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  	if (nodeLang != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  	}  	else if (nodeDatatype != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  	}  	else {  		n = context.Handler.CreateLiteralNode (nodeValue);  	}  }  else {  	throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeType.Equals ("uri")) {  	n = context.Handler.CreateUriNode (UriFactory.Create (nodeValue));  }  else if (nodeType.Equals ("bnode")) {  	if (nodeValue.StartsWith ("_:")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  	}  	else if (nodeValue.Contains ("://")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  	}  	else if (nodeValue.Contains (":")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  	}  	else {  		n = context.Handler.CreateBlankNode (nodeValue);  	}  }  else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  	if (nodeLang != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  	}  	else if (nodeDatatype != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  	}  	else {  		n = context.Handler.CreateLiteralNode (nodeValue);  	}  }  else {  	throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeType.Equals ("bnode")) {  	if (nodeValue.StartsWith ("_:")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  	}  	else if (nodeValue.Contains ("://")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  	}  	else if (nodeValue.Contains (":")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  	}  	else {  		n = context.Handler.CreateBlankNode (nodeValue);  	}  }  else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  	if (nodeLang != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  	}  	else if (nodeDatatype != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  	}  	else {  		n = context.Handler.CreateLiteralNode (nodeValue);  	}  }  else {  	throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeType.Equals ("bnode")) {  	if (nodeValue.StartsWith ("_:")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  	}  	else if (nodeValue.Contains ("://")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  	}  	else if (nodeValue.Contains (":")) {  		n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  	}  	else {  		n = context.Handler.CreateBlankNode (nodeValue);  	}  }  else if (nodeType.Equals ("literal") || nodeType.Equals ("typed-literal")) {  	if (nodeLang != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' nodeLang);  	}  	else if (nodeDatatype != null) {  		n = context.Handler.CreateLiteralNode (nodeValue' UriFactory.Create (nodeDatatype));  	}  	else {  		n = context.Handler.CreateLiteralNode (nodeValue);  	}  }  else {  	throw new RdfParseException ("Cannot parse a Node from the JSON where the 'type' property has a value of '" + nodeType + "' which is not one of the permitted values 'uri'' 'bnode'' 'literal' or 'typed-literal' in the JSON Object representing the Node");  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeValue.StartsWith ("_:")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  }  else if (nodeValue.Contains ("://")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  }  else if (nodeValue.Contains (":")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  }  else {  	n = context.Handler.CreateBlankNode (nodeValue);  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeValue.StartsWith ("_:")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  }  else if (nodeValue.Contains ("://")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  }  else if (nodeValue.Contains (":")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  }  else {  	n = context.Handler.CreateBlankNode (nodeValue);  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: n = context.Handler.CreateBlankNode (nodeValue.Substring (2));  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: if (nodeValue.Contains ("://")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  }  else if (nodeValue.Contains (":")) {  	n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.LastIndexOf (':') + 1));  }  else {  	n = context.Handler.CreateBlankNode (nodeValue);  }  
Magic Number,VDS.RDF.Parsing,SparqlJsonParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlJsonParser.cs,ParseBoundVariable,The following statement contains a magic number: n = context.Handler.CreateBlankNode (nodeValue.Substring (nodeValue.IndexOf ("://") + 3));  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("uri")) {  	return context.Handler.CreateUriNode (UriFactory.Create (context.Input.ReadElementContentAsString ()));  }  else if (context.Input.Name.Equals ("literal")) {  	if (context.Input.AttributeCount == 0) {  		//Literal with no Data Type/Language Specifier  		return context.Handler.CreateLiteralNode (HttpUtility.HtmlDecode (context.Input.ReadInnerXml ()));  	}  	else if (context.Input.AttributeCount == 1) {  		context.Input.MoveToNextAttribute ();  		if (context.Input.Name.Equals ("xml:lang")) {  			//Language is specified  			String lang = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' lang);  		}  		else if (context.Input.Name.Equals ("datatype")) {  			//Data Type is specified  			String dt = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' UriFactory.Create (dt));  		}  		else {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has an unknown attribute '" + context.Input.Name + "'!");  		}  	}  	else {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has too many Attributes' only 1 of 'xml:lang' or 'datatype' may be specified!");  	}  }  else if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("uri")) {  	return context.Handler.CreateUriNode (UriFactory.Create (context.Input.ReadElementContentAsString ()));  }  else if (context.Input.Name.Equals ("literal")) {  	if (context.Input.AttributeCount == 0) {  		//Literal with no Data Type/Language Specifier  		return context.Handler.CreateLiteralNode (HttpUtility.HtmlDecode (context.Input.ReadInnerXml ()));  	}  	else if (context.Input.AttributeCount == 1) {  		context.Input.MoveToNextAttribute ();  		if (context.Input.Name.Equals ("xml:lang")) {  			//Language is specified  			String lang = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' lang);  		}  		else if (context.Input.Name.Equals ("datatype")) {  			//Data Type is specified  			String dt = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' UriFactory.Create (dt));  		}  		else {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has an unknown attribute '" + context.Input.Name + "'!");  		}  	}  	else {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has too many Attributes' only 1 of 'xml:lang' or 'datatype' may be specified!");  	}  }  else if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("literal")) {  	if (context.Input.AttributeCount == 0) {  		//Literal with no Data Type/Language Specifier  		return context.Handler.CreateLiteralNode (HttpUtility.HtmlDecode (context.Input.ReadInnerXml ()));  	}  	else if (context.Input.AttributeCount == 1) {  		context.Input.MoveToNextAttribute ();  		if (context.Input.Name.Equals ("xml:lang")) {  			//Language is specified  			String lang = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' lang);  		}  		else if (context.Input.Name.Equals ("datatype")) {  			//Data Type is specified  			String dt = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' UriFactory.Create (dt));  		}  		else {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has an unknown attribute '" + context.Input.Name + "'!");  		}  	}  	else {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has too many Attributes' only 1 of 'xml:lang' or 'datatype' may be specified!");  	}  }  else if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("literal")) {  	if (context.Input.AttributeCount == 0) {  		//Literal with no Data Type/Language Specifier  		return context.Handler.CreateLiteralNode (HttpUtility.HtmlDecode (context.Input.ReadInnerXml ()));  	}  	else if (context.Input.AttributeCount == 1) {  		context.Input.MoveToNextAttribute ();  		if (context.Input.Name.Equals ("xml:lang")) {  			//Language is specified  			String lang = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' lang);  		}  		else if (context.Input.Name.Equals ("datatype")) {  			//Data Type is specified  			String dt = context.Input.Value;  			context.Input.MoveToContent ();  			return context.Handler.CreateLiteralNode (context.Input.ReadElementContentAsString ()' UriFactory.Create (dt));  		}  		else {  			throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has an unknown attribute '" + context.Input.Name + "'!");  		}  	}  	else {  		throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <literal> element has too many Attributes' only 1 of 'xml:lang' or 'datatype' may be specified!");  	}  }  else if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (context.Input.Name.Equals ("bnode")) {  	String bnodeID = context.Input.ReadElementContentAsString ();  	if (bnodeID.StartsWith ("_:")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (2));  	}  	else if (bnodeID.Contains ("://")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  	}  	else if (bnodeID.Contains (":")) {  		return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  	}  	else {  		return context.Handler.CreateBlankNode (bnodeID);  	}  }  else if (context.Input.Name.Equals ("unbound")) {  	//HACK: This is a really ancient feature of the SPARQL Results XML format (from Working Draft in 2005) which we support to ensure compatability with old pre-standardisation SPARQL endpoints (like 3store based ones)  	context.Input.ReadInnerXml ();  	return null;  }  else {  	throw new RdfParseException ("Unable to Parse a SPARQL Result Set since a <binding> element contains an unexpected element <" + context.Input.Name + ">!");  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (bnodeID.StartsWith ("_:")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (2));  }  else if (bnodeID.Contains ("://")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  }  else if (bnodeID.Contains (":")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  }  else {  	return context.Handler.CreateBlankNode (bnodeID);  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (bnodeID.StartsWith ("_:")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (2));  }  else if (bnodeID.Contains ("://")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  }  else if (bnodeID.Contains (":")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  }  else {  	return context.Handler.CreateBlankNode (bnodeID);  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: return context.Handler.CreateBlankNode (bnodeID.Substring (2));  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: if (bnodeID.Contains ("://")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  }  else if (bnodeID.Contains (":")) {  	return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.LastIndexOf (':') + 1));  }  else {  	return context.Handler.CreateBlankNode (bnodeID);  }  
Magic Number,VDS.RDF.Parsing,SparqlXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlXmlParser.cs,ParseValue,The following statement contains a magic number: return context.Handler.CreateBlankNode (bnodeID.Substring (bnodeID.IndexOf ("://") + 3));  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,The following statement contains a magic number: do {  	//Try to get the Subject  	IToken subj = context.Tokens.Dequeue ();  	INode subjNode;  	//Turn the Subject Token into a Node  	switch (subj.TokenType) {  	case Token.COMMENT:  		//Discard and continue  		continue;  	case Token.QNAME:  	case Token.URI:  		subjNode = ParserHelper.TryResolveUri (context' subj);  		break;  	case Token.BLANKNODEWITHID:  		//Blank Node with ID  		subjNode = context.Handler.CreateBlankNode (subj.Value.Substring (2));  		break;  	case Token.LEFTSQBRACKET:  		//Blank Node  		IToken next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Anonymous Blank Node  			context.Tokens.Dequeue ();  			subjNode = context.Handler.CreateBlankNode ();  		}  		else {  			//Blank Node Collection  			subjNode = context.Handler.CreateBlankNode ();  			//Do an extra call to TryParsePredicateObjectList to parse the Blank Node Collection  			this.TryParsePredicateObjectList (context' graphUri' subjNode);  		}  		break;  	case Token.LEFTBRACKET:  		//Collection  		//Check whether an Empty Collection  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection  			context.Tokens.Dequeue ();  			subjNode = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  		}  		else {  			//Collection  			subjNode = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' graphUri' subjNode);  		}  		break;  	case Token.EOF:  		throw ParserHelper.Error ("Unexpected End of File while trying to parse Triples"' subj);  	default:  		//Unexpected Token  		throw ParserHelper.Error ("Unexpected Token '" + subj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Subject of a Triple"' subj);  	}  	//Parse the Predicate Object List  	this.TryParsePredicateObjectList (context' graphUri' subjNode);  	//Expect a Dot to Terminate  	if (context.Tokens.LastTokenType != Token.DOT && context.Tokens.LastTokenType != Token.RIGHTCURLYBRACKET) {  		//We only do this if we haven't returned because we already hit the Dot Token/Right Curly Bracket  		IToken dot = context.Tokens.Dequeue ();  		if (dot.TokenType != Token.DOT && dot.TokenType != Token.RIGHTCURLYBRACKET) {  			throw ParserHelper.Error ("Unexpected Token '" + dot.GetType ().ToString () + "' encountered' expected a Dot (Line Terminator) Token to terminate Triples"' dot);  		}  	}  	//If we already hit the Right Curly Bracket return  	if (context.Tokens.LastTokenType == Token.RIGHTCURLYBRACKET)  		return;  }  while (context.Tokens.Peek ().TokenType != Token.RIGHTCURLYBRACKET);  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,The following statement contains a magic number: switch (subj.TokenType) {  case Token.COMMENT:  	//Discard and continue  	continue;  case Token.QNAME:  case Token.URI:  	subjNode = ParserHelper.TryResolveUri (context' subj);  	break;  case Token.BLANKNODEWITHID:  	//Blank Node with ID  	subjNode = context.Handler.CreateBlankNode (subj.Value.Substring (2));  	break;  case Token.LEFTSQBRACKET:  	//Blank Node  	IToken next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Anonymous Blank Node  		context.Tokens.Dequeue ();  		subjNode = context.Handler.CreateBlankNode ();  	}  	else {  		//Blank Node Collection  		subjNode = context.Handler.CreateBlankNode ();  		//Do an extra call to TryParsePredicateObjectList to parse the Blank Node Collection  		this.TryParsePredicateObjectList (context' graphUri' subjNode);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	//Check whether an Empty Collection  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection  		context.Tokens.Dequeue ();  		subjNode = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  	}  	else {  		//Collection  		subjNode = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' graphUri' subjNode);  	}  	break;  case Token.EOF:  	throw ParserHelper.Error ("Unexpected End of File while trying to parse Triples"' subj);  default:  	//Unexpected Token  	throw ParserHelper.Error ("Unexpected Token '" + subj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Subject of a Triple"' subj);  }  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseTriples,The following statement contains a magic number: subjNode = context.Handler.CreateBlankNode (subj.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The following statement contains a magic number: do {  	//After the first run through we'll need to discard commas here  	if (ok) {  		context.Tokens.Dequeue ();  	}  	//Try to get the Object  	IToken obj = context.Tokens.Dequeue ();  	IToken next;  	INode objNode;  	switch (obj.TokenType) {  	case Token.COMMENT:  		//Discard and Continue  		ok = false;  		continue;  	case Token.QNAME:  	case Token.URI:  		objNode = ParserHelper.TryResolveUri (context' obj);  		break;  	case Token.LITERAL:  	case Token.LONGLITERAL:  		//Literals  		//See whether we get a Language Specifier/Data Type next  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.LANGSPEC) {  			//Literal with Language Specifier  			context.Tokens.Dequeue ();  			objNode = context.Handler.CreateLiteralNode (obj.Value' next.Value);  		}  		else if (next.TokenType == Token.HATHAT) {  			//Literal with DataType  			context.Tokens.Dequeue ();  			//Now expect a QName/Uri Token  			next = context.Tokens.Dequeue ();  			if (next.TokenType == Token.QNAME || next.TokenType == Token.URI) {  				Uri dt = UriFactory.Create (Tools.ResolveUriOrQName (next' context.Namespaces' context.BaseUri));  				objNode = context.Handler.CreateLiteralNode (obj.Value' dt);  			}  			else {  				throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName Token to specify a Data Type after a ^^ Token"' next);  			}  		}  		else {  			//Just a string literal  			objNode = context.Handler.CreateLiteralNode (obj.Value);  		}  		break;  	case Token.PLAINLITERAL:  		//Plain Literals  		Uri plt = TurtleSpecsHelper.InferPlainLiteralType ((PlainLiteralToken)obj' TurtleSyntax.Original);  		objNode = context.Handler.CreateLiteralNode (obj.Value' plt);  		break;  	case Token.BLANKNODEWITHID:  		//Blank Node with ID  		objNode = context.Handler.CreateBlankNode (obj.Value.Substring (2));  		break;  	case Token.LEFTSQBRACKET:  		//Blank Node  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Anonymous Blank Node  			context.Tokens.Dequeue ();  			objNode = context.Handler.CreateBlankNode ();  		}  		else {  			//Blank Node Collection  			objNode = context.Handler.CreateBlankNode ();  			//Do an extra call to TryParsePredicateObjectList to parse the Blank Node Collection  			this.TryParsePredicateObjectList (context' graphUri' objNode);  		}  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		if (!ok) {  			throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list of a Blank Node Collection was parsed"' obj);  		}  		return;  	case Token.LEFTBRACKET:  		//Collection  		//Check whether an Empty Collection  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection  			context.Tokens.Dequeue ();  			objNode = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  		}  		else {  			//Collection  			objNode = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' graphUri' objNode);  		}  		break;  	case Token.EOF:  		throw ParserHelper.Error ("Unexpected End of File while trying to parse Object List"' obj);  	case Token.DOT:  	case Token.RIGHTCURLYBRACKET:  	case Token.SEMICOLON:  		if (!ok) {  			throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list was parsed"' obj);  		}  		return;  	default:  		//Unexpected Token  		throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Object of a Triple"' obj);  	}  	ok = true;  	if (!context.Handler.HandleTriple (new Triple (subj' pred' objNode' graphUri)))  		ParserHelper.Stop ();  }  while (context.Tokens.Peek ().TokenType == Token.COMMA);  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The following statement contains a magic number: switch (obj.TokenType) {  case Token.COMMENT:  	//Discard and Continue  	ok = false;  	continue;  case Token.QNAME:  case Token.URI:  	objNode = ParserHelper.TryResolveUri (context' obj);  	break;  case Token.LITERAL:  case Token.LONGLITERAL:  	//Literals  	//See whether we get a Language Specifier/Data Type next  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		//Literal with Language Specifier  		context.Tokens.Dequeue ();  		objNode = context.Handler.CreateLiteralNode (obj.Value' next.Value);  	}  	else if (next.TokenType == Token.HATHAT) {  		//Literal with DataType  		context.Tokens.Dequeue ();  		//Now expect a QName/Uri Token  		next = context.Tokens.Dequeue ();  		if (next.TokenType == Token.QNAME || next.TokenType == Token.URI) {  			Uri dt = UriFactory.Create (Tools.ResolveUriOrQName (next' context.Namespaces' context.BaseUri));  			objNode = context.Handler.CreateLiteralNode (obj.Value' dt);  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a URI/QName Token to specify a Data Type after a ^^ Token"' next);  		}  	}  	else {  		//Just a string literal  		objNode = context.Handler.CreateLiteralNode (obj.Value);  	}  	break;  case Token.PLAINLITERAL:  	//Plain Literals  	Uri plt = TurtleSpecsHelper.InferPlainLiteralType ((PlainLiteralToken)obj' TurtleSyntax.Original);  	objNode = context.Handler.CreateLiteralNode (obj.Value' plt);  	break;  case Token.BLANKNODEWITHID:  	//Blank Node with ID  	objNode = context.Handler.CreateBlankNode (obj.Value.Substring (2));  	break;  case Token.LEFTSQBRACKET:  	//Blank Node  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Anonymous Blank Node  		context.Tokens.Dequeue ();  		objNode = context.Handler.CreateBlankNode ();  	}  	else {  		//Blank Node Collection  		objNode = context.Handler.CreateBlankNode ();  		//Do an extra call to TryParsePredicateObjectList to parse the Blank Node Collection  		this.TryParsePredicateObjectList (context' graphUri' objNode);  	}  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	if (!ok) {  		throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list of a Blank Node Collection was parsed"' obj);  	}  	return;  case Token.LEFTBRACKET:  	//Collection  	//Check whether an Empty Collection  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection  		context.Tokens.Dequeue ();  		objNode = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  	}  	else {  		//Collection  		objNode = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' graphUri' objNode);  	}  	break;  case Token.EOF:  	throw ParserHelper.Error ("Unexpected End of File while trying to parse Object List"' obj);  case Token.DOT:  case Token.RIGHTCURLYBRACKET:  case Token.SEMICOLON:  	if (!ok) {  		throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered before an Object list was parsed"' obj);  	}  	return;  default:  	//Unexpected Token  	throw ParserHelper.Error ("Unexpected Token '" + obj.GetType ().ToString () + "' encountered' expected a URI/QName/Blank Node as the Object of a Triple"' obj);  }  
Magic Number,VDS.RDF.Parsing,TriGParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriGParser.cs,TryParseObjectList,The following statement contains a magic number: objNode = context.Handler.CreateBlankNode (obj.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Comments are discardable  	this.TryParseTriplePatterns (context' p);  	break;  case Token.VARIABLE:  	//Variable  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	//Must then be followed be a non-empty Property List  	context.LocalTokens.Push (next);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.LET:  	//LET assignment  	this.TryParseLetAssignment (context' p);  	break;  case Token.BIND:  	//BIND assignment  	this.TryParseBindAssignment (context' p);  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Subject of Collection  	context.LocalTokens.Push (bnode);  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		//Parse as Subject of Triples  		this.TryParsePredicateObjectList (context' p' 2);  	}  	else {  		//Parse the Collection  		this.TryParsePredicateObjectList (context' p' 2);  		//Push again for subject of Triples  		context.LocalTokens.Push (bnode);  		this.TryParsePredicateObjectList (context' p' 2);  	}  	break;  case Token.LEFTBRACKET:  	//Collection  	this.TryParseCollection (context' p' false);  	this.TryParsePredicateObjectList (context' p' 2);  	break;  case Token.FILTER:  	//FILTER Pattern  	this.TryParseFilterClause (context' p);  	break;  case Token.OPTIONAL:  	//OPTIONAL Clause  	this.TryParseOptionalClause (context' p);  	break;  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  	//EXISTS/NOT EXISTS clause  	if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended)  		throw new RdfParseException ("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");  	this.TryParseExistsClause (context' p' (next.TokenType == Token.EXISTS));  	break;  case Token.MINUS_P:  	//MINUS clause  	this.TryParseMinusClause (context' p);  	break;  case Token.SERVICE:  	//SERVICE clause  	this.TryParseServiceClause (context' p);  	break;  case Token.SELECT:  	//Sub-query  	this.TryParseSubquery (context' p);  	break;  case Token.GRAPH:  	//GRAPH Clause  	this.TryParseGraphClause (context' p);  	break;  case Token.UNION:  	//UNION Clause  	this.TryParseUnionClause (context' p);  	break;  case Token.LEFTCURLYBRACKET:  	//Nested Graph Pattern  	p.AddGraphPattern (this.TryParseGraphPattern (context' false));  	//Simplify Subqueries  	if (p.ChildGraphPatterns.Last ().IsSubQuery) {  		GraphPattern temp = p.LastChildPattern ();  		p.AddTriplePattern (temp.TriplePatterns.First ());  	}  	break;  case Token.DOT:  	//Can Discard this if last character was the end of a nested Graph pattern  	if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET) {  		//Can Discard this if the next character is not another DOT  		next = context.Tokens.Peek ();  		if (next.TokenType != Token.DOT) {  			if (next.TokenType != Token.RIGHTCURLYBRACKET) {  				this.TryParseTriplePatterns (context' p);  			}  			else {  				return;  			}  		}  		else {  			throw ParserHelper.Error ("A DOT Token cannot follow another DOT Token within a Graph Pattern"' next);  		}  	}  	else if (lasttoken == Token.SEMICOLON) {  		//Allow Trailing Semicolon  		return;  	}  	else {  		throw ParserHelper.Error ("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern"' next);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered when the start of a Triple Pattern was expected"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: if (next.TokenType == Token.RIGHTSQBRACKET) {  	//Single anonymous blank node  	context.Tokens.Dequeue ();  	//Parse as Subject of Triples  	this.TryParsePredicateObjectList (context' p' 2);  }  else {  	//Parse the Collection  	this.TryParsePredicateObjectList (context' p' 2);  	//Push again for subject of Triples  	context.LocalTokens.Push (bnode);  	this.TryParsePredicateObjectList (context' p' 2);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: if (next.TokenType == Token.RIGHTSQBRACKET) {  	//Single anonymous blank node  	context.Tokens.Dequeue ();  	//Parse as Subject of Triples  	this.TryParsePredicateObjectList (context' p' 2);  }  else {  	//Parse the Collection  	this.TryParsePredicateObjectList (context' p' 2);  	//Push again for subject of Triples  	context.LocalTokens.Push (bnode);  	this.TryParsePredicateObjectList (context' p' 2);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: if (next.TokenType == Token.RIGHTSQBRACKET) {  	//Single anonymous blank node  	context.Tokens.Dequeue ();  	//Parse as Subject of Triples  	this.TryParsePredicateObjectList (context' p' 2);  }  else {  	//Parse the Collection  	this.TryParsePredicateObjectList (context' p' 2);  	//Push again for subject of Triples  	context.LocalTokens.Push (bnode);  	this.TryParsePredicateObjectList (context' p' 2);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseTriplePatterns,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	//Peek at the Next Token  	next = context.Tokens.Peek ();  	switch (next.TokenType) {  	case Token.COMMENT:  		//Ignore Comments  		context.Tokens.Dequeue ();  		break;  	case Token.VARIABLE:  		context.LocalTokens.Push (next);  		context.Query.AddVariable (next.Value);  		context.Tokens.Dequeue ();  		break;  	case Token.URI:  	case Token.QNAME:  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  	case Token.KEYWORDA:  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HAT:  	case Token.DIVIDE:  	case Token.BITWISEOR:  	case Token.MULTIPLY:  	case Token.PLUS:  	case Token.QUESTION:  	case Token.NEGATION:  		//If we see any of these Tokens then it's a Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		if (context.LocalTokens.Count == expectedCount - 1) {  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  			// ^ and ! may be used to start a pattern  			context.Tokens.Dequeue ();  			path = context.PathParser.Parse (context' next);  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  		}  		break;  	case Token.BLANKNODE:  	case Token.BLANKNODEWITHID:  		//Generate a new Blank Node ID if required  		if (next.TokenType == Token.BLANKNODE) {  			next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		}  		//Check list of Blank Node usages  		if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  			if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  				throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  			}  		}  		else {  			context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  		}  		context.LocalTokens.Push (next);  		context.Tokens.Dequeue ();  		break;  	case Token.HATHAT:  		//Get the next Token which should be a Datatype Token  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.DATATYPE) {  			//Get the previous Token off the Stack and ensure it's a Literal  			lit = context.LocalTokens.Pop ();  			if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  				//Create a DataTyped Literal  				context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  			}  			else {  				throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.LEFTSQBRACKET:  		//Start of Blank Node Collection  		//Create a new Blank Node Token  		BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  		//Push twice' once for Object of the current Triple  		context.LocalTokens.Push (bnode);  		context.Tokens.Dequeue ();  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//Single anonymous blank node  			context.Tokens.Dequeue ();  			break;  		}  		//Blank Node Collection  		//Push again for Subject of new Triple  		context.LocalTokens.Push (bnode);  		//Recursively call self to parse the new Triple list  		this.TryParsePredicateObjectList (context' p' expectedCount + 2);  		break;  	case Token.RIGHTSQBRACKET:  		//End of Blank Node Collection  		//Allow for trailing semicolon  		if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  			context.Tokens.Dequeue ();  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTBRACKET:  		//Property Path if it's the Predicate or Collection if it's the Object  		if (context.LocalTokens.Count == expectedCount - 2) {  			//Property Path  			if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  				throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  			path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  			PathToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  		}  		else {  			//Collection  			context.Tokens.Dequeue ();  			this.TryParseCollection (context' p' false);  		}  		break;  	case Token.LANGSPEC:  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a Language Specified Literal  			context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  		}  		context.Tokens.Dequeue ();  		break;  	case Token.COMMA:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		//Push Predicate back on Stack  		context.LocalTokens.Push (temp);  		context.Tokens.Dequeue ();  		break;  	case Token.SEMICOLON:  		//End of a Triple Pattern  		//Check length of stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		break;  	case Token.DOT:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  			if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  				context.Tokens.Dequeue ();  			}  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		context.Tokens.Dequeue ();  		return;  	case Token.LEFTCURLYBRACKET:  	case Token.RIGHTCURLYBRACKET:  	case Token.OPTIONAL:  	case Token.EXISTS:  	case Token.NOTEXISTS:  	case Token.UNSAID:  	case Token.MINUS_P:  	case Token.SERVICE:  	case Token.GRAPH:  	case Token.FILTER:  		//End of the Triple Patterns  		//Allow for trailing semicolon and Blank Node Collection lists  		if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  			return;  		}  		//Check length of Stack  		if (context.LocalTokens.Count < expectedCount) {  			temp = context.LocalTokens.Peek ();  			if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  				//In this case this should be a Cardinality Modifier on a path (we hope)  				path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  				IToken pathToken = new PathToken (path);  				context.LocalTokens.Push (pathToken);  				continue;  			}  			else {  				throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  			}  		}  		else if (context.LocalTokens.Count > expectedCount) {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  		}  		obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  		temp = context.LocalTokens.Pop ();  		if (temp.TokenType == Token.PATH) {  			path = ((PathToken)temp).Path;  			p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  		}  		else {  			pred = this.TryCreatePatternItem (context' temp);  			//Add Pattern to the Graph Pattern  			p.AddTriplePattern (new TriplePattern (subj' pred' obj));  		}  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (next.TokenType) {  case Token.COMMENT:  	//Ignore Comments  	context.Tokens.Dequeue ();  	break;  case Token.VARIABLE:  	context.LocalTokens.Push (next);  	context.Query.AddVariable (next.Value);  	context.Tokens.Dequeue ();  	break;  case Token.URI:  case Token.QNAME:  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  case Token.KEYWORDA:  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HAT:  case Token.DIVIDE:  case Token.BITWISEOR:  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.NEGATION:  	//If we see any of these Tokens then it's a Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	if (context.LocalTokens.Count == expectedCount - 1) {  		path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  		// ^ and ! may be used to start a pattern  		context.Tokens.Dequeue ();  		path = context.PathParser.Parse (context' next);  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  	}  	break;  case Token.BLANKNODE:  case Token.BLANKNODEWITHID:  	//Generate a new Blank Node ID if required  	if (next.TokenType == Token.BLANKNODE) {  		next = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	}  	//Check list of Blank Node usages  	if (context.BlankNodeIDUsages.ContainsKey (next.Value)) {  		if (context.BlankNodeIDUsages [next.Value] != context.GraphPatternID) {  			throw ParserHelper.Error ("Invalid use of Blank Node Label '" + next.Value + "'' this Label has already been used in a different Graph Pattern"' next);  		}  	}  	else {  		context.BlankNodeIDUsages.Add (next.Value' context.GraphPatternID);  	}  	context.LocalTokens.Push (next);  	context.Tokens.Dequeue ();  	break;  case Token.HATHAT:  	//Get the next Token which should be a Datatype Token  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.DATATYPE) {  		//Get the previous Token off the Stack and ensure it's a Literal  		lit = context.LocalTokens.Pop ();  		if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  			//Create a DataTyped Literal  			context.LocalTokens.Push (new LiteralWithDataTypeToken (lit' (DataTypeToken)next));  		}  		else {  			throw ParserHelper.Error ("Unexpected Datatype Token' a Datatype may only be specified after a quoted Literal/Long Literal"' lit);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token"' next);  	}  	context.Tokens.Dequeue ();  	break;  case Token.LEFTSQBRACKET:  	//Start of Blank Node Collection  	//Create a new Blank Node Token  	BlankNodeWithIDToken bnode = new BlankNodeWithIDToken (context.GetNewBlankNodeID ()' 0' 0' 0);  	//Push twice' once for Object of the current Triple  	context.LocalTokens.Push (bnode);  	context.Tokens.Dequeue ();  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//Single anonymous blank node  		context.Tokens.Dequeue ();  		break;  	}  	//Blank Node Collection  	//Push again for Subject of new Triple  	context.LocalTokens.Push (bnode);  	//Recursively call self to parse the new Triple list  	this.TryParsePredicateObjectList (context' p' expectedCount + 2);  	break;  case Token.RIGHTSQBRACKET:  	//End of Blank Node Collection  	//Allow for trailing semicolon  	if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  		context.Tokens.Dequeue ();  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	pred = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	//Add Pattern to the Graph Pattern  	p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	context.Tokens.Dequeue ();  	return;  case Token.LEFTBRACKET:  	//Property Path if it's the Predicate or Collection if it's the Object  	if (context.LocalTokens.Count == expectedCount - 2) {  		//Property Path  		if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  			throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  		path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  		PathToken pathToken = new PathToken (path);  		context.LocalTokens.Push (pathToken);  	}  	else {  		//Collection  		context.Tokens.Dequeue ();  		this.TryParseCollection (context' p' false);  	}  	break;  case Token.LANGSPEC:  	//Get the previous Token off the Stack and ensure it's a Literal  	lit = context.LocalTokens.Pop ();  	if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL) {  		//Create a Language Specified Literal  		context.LocalTokens.Push (new LiteralWithLanguageSpecifierToken (lit' (LanguageSpecifierToken)next));  	}  	else {  		throw ParserHelper.Error ("Unexpected Language Specifier Token' a Language Specifier may only be specified after a quoted Literal/Long Literal"' lit);  	}  	context.Tokens.Dequeue ();  	break;  case Token.COMMA:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	//Push Predicate back on Stack  	context.LocalTokens.Push (temp);  	context.Tokens.Dequeue ();  	break;  case Token.SEMICOLON:  	//End of a Triple Pattern  	//Check length of stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	break;  case Token.DOT:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  		if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  			context.Tokens.Dequeue ();  		}  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	context.Tokens.Dequeue ();  	return;  case Token.LEFTCURLYBRACKET:  case Token.RIGHTCURLYBRACKET:  case Token.OPTIONAL:  case Token.EXISTS:  case Token.NOTEXISTS:  case Token.UNSAID:  case Token.MINUS_P:  case Token.SERVICE:  case Token.GRAPH:  case Token.FILTER:  	//End of the Triple Patterns  	//Allow for trailing semicolon and Blank Node Collection lists  	if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  		return;  	}  	//Check length of Stack  	if (context.LocalTokens.Count < expectedCount) {  		temp = context.LocalTokens.Peek ();  		if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA)) {  			//In this case this should be a Cardinality Modifier on a path (we hope)  			path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  			IToken pathToken = new PathToken (path);  			context.LocalTokens.Push (pathToken);  			continue;  		}  		else {  			throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern"' next);  		}  	}  	else if (context.LocalTokens.Count > expectedCount) {  		throw ParserHelper.Error ("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern"' next);  	}  	obj = this.TryCreatePatternItem (context' context.LocalTokens.Pop ());  	temp = context.LocalTokens.Pop ();  	if (temp.TokenType == Token.PATH) {  		path = ((PathToken)temp).Path;  		p.AddTriplePattern (new PropertyPathPattern (subj' path' obj));  	}  	else {  		pred = this.TryCreatePatternItem (context' temp);  		//Add Pattern to the Graph Pattern  		p.AddTriplePattern (new TriplePattern (subj' pred' obj));  	}  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' while trying to Parse Triple Patterns"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if (context.LocalTokens.Count == expectedCount - 1) {  	path = context.PathParser.Parse (context' context.LocalTokens.Pop ());  	PathToken pathToken = new PathToken (path);  	context.LocalTokens.Push (pathToken);  }  else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  	// ^ and ! may be used to start a pattern  	context.Tokens.Dequeue ();  	path = context.PathParser.Parse (context' next);  	PathToken pathToken = new PathToken (path);  	context.LocalTokens.Push (pathToken);  }  else {  	throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2) {  	// ^ and ! may be used to start a pattern  	context.Tokens.Dequeue ();  	path = context.PathParser.Parse (context' next);  	PathToken pathToken = new PathToken (path);  	context.LocalTokens.Push (pathToken);  }  else {  	throw ParserHelper.Error ("Encountered a '" + next.GetType ().ToString () + "' Token which is valid only after a Predicate to indicate Path Cardinality"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: this.TryParsePredicateObjectList (context' p' expectedCount + 2);  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON) {  	context.Tokens.Dequeue ();  	return;  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if (context.LocalTokens.Count == expectedCount - 2) {  	//Property Path  	if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)  		throw new RdfParseException ("Property Paths are not permitted in SPARQL 1.0");  	path = context.PathParser.Parse (context' context.Tokens.Dequeue ());  	PathToken pathToken = new PathToken (path);  	context.LocalTokens.Push (pathToken);  }  else {  	//Collection  	context.Tokens.Dequeue ();  	this.TryParseCollection (context' p' false);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0))) {  	if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET) {  		context.Tokens.Dequeue ();  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParsePredicateObjectList,The following statement contains a magic number: if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0))) {  	return;  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The following statement contains a magic number: switch (t.TokenType) {  case Token.VARIABLE:  	//Variables accept any Node as a substitution  	return new VariablePattern (t.Value);  case Token.URI:  	//Uri uses a Node Match  	if (t.Value.StartsWith ("_:")) {  		return new FixedBlankNodePattern (t.Value);  	}  	else {  		String uri = Tools.ResolveUri (t.Value' context.Query.BaseUri.ToSafeString ());  		u = UriFactory.Create (uri);  		return new NodeMatchPattern (new UriNode (null' u));  	}  case Token.QNAME:  	//QName uses a Node Match  	return new NodeMatchPattern (new UriNode (null' this.ResolveQName (context' t.Value)));  case Token.LITERAL:  case Token.LONGLITERAL:  	//Literals use Node Matches  	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' t.Value));  case Token.PLAINLITERAL:  	//Plain Literals either use an inferred Literal Node Match  	//We know it must be one of the inferrable types or the Parser would have failed at the Tokenisation stage for the Literal  	if (TurtleSpecsHelper.IsValidDouble (t.Value)) {  		//Double - Check first since to be considered a double must contain an exponent so is unique compared to   		//the other two numeric types  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble)));  	}  	else if (TurtleSpecsHelper.IsValidInteger (t.Value)) {  		//Integer - Check before decimal as any valid integer is a valid decimal  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger)));  	}  	else if (TurtleSpecsHelper.IsValidDecimal (t.Value)) {  		//Decimal - Check last since any valid integer is also a valid decimal  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal)));  	}  	else {  		//Boolean  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean)));  	}  case Token.LITERALWITHDT:  	//Literal with Datatype use Node Matches  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)t;  	if (litdt.DataType.StartsWith ("<")) {  		baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.ToString ();  		u = UriFactory.Create (Tools.ResolveUri (litdt.DataType.Substring (1' litdt.DataType.Length - 2)' baseUri));  		return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' u));  	}  	else {  		//Resolve the QName                         		return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' this.ResolveQName (context' litdt.DataType)));  	}  case Token.LITERALWITHLANG:  	//Literal with Lang Spec use Node Matches  	LiteralWithLanguageSpecifierToken litls = (LiteralWithLanguageSpecifierToken)t;  	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litls.Value' litls.Language));  case Token.BLANKNODEWITHID:  	//Blanks accept any Blank  	return new BlankNodePattern (t.Value.Substring (2));  case Token.KEYWORDA:  	return new NodeMatchPattern (new UriNode (null' UriFactory.Create (NamespaceMapper.RDF + "type")));  default:  	throw ParserHelper.Error ("Unable to Convert a '" + t.GetType ().ToString () + "' to a Pattern Item in a Triple Pattern"' t);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The following statement contains a magic number: switch (t.TokenType) {  case Token.VARIABLE:  	//Variables accept any Node as a substitution  	return new VariablePattern (t.Value);  case Token.URI:  	//Uri uses a Node Match  	if (t.Value.StartsWith ("_:")) {  		return new FixedBlankNodePattern (t.Value);  	}  	else {  		String uri = Tools.ResolveUri (t.Value' context.Query.BaseUri.ToSafeString ());  		u = UriFactory.Create (uri);  		return new NodeMatchPattern (new UriNode (null' u));  	}  case Token.QNAME:  	//QName uses a Node Match  	return new NodeMatchPattern (new UriNode (null' this.ResolveQName (context' t.Value)));  case Token.LITERAL:  case Token.LONGLITERAL:  	//Literals use Node Matches  	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' t.Value));  case Token.PLAINLITERAL:  	//Plain Literals either use an inferred Literal Node Match  	//We know it must be one of the inferrable types or the Parser would have failed at the Tokenisation stage for the Literal  	if (TurtleSpecsHelper.IsValidDouble (t.Value)) {  		//Double - Check first since to be considered a double must contain an exponent so is unique compared to   		//the other two numeric types  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble)));  	}  	else if (TurtleSpecsHelper.IsValidInteger (t.Value)) {  		//Integer - Check before decimal as any valid integer is a valid decimal  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger)));  	}  	else if (TurtleSpecsHelper.IsValidDecimal (t.Value)) {  		//Decimal - Check last since any valid integer is also a valid decimal  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal)));  	}  	else {  		//Boolean  		return new NodeMatchPattern (new LiteralNode (null' t.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean)));  	}  case Token.LITERALWITHDT:  	//Literal with Datatype use Node Matches  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)t;  	if (litdt.DataType.StartsWith ("<")) {  		baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.ToString ();  		u = UriFactory.Create (Tools.ResolveUri (litdt.DataType.Substring (1' litdt.DataType.Length - 2)' baseUri));  		return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' u));  	}  	else {  		//Resolve the QName                         		return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' this.ResolveQName (context' litdt.DataType)));  	}  case Token.LITERALWITHLANG:  	//Literal with Lang Spec use Node Matches  	LiteralWithLanguageSpecifierToken litls = (LiteralWithLanguageSpecifierToken)t;  	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litls.Value' litls.Language));  case Token.BLANKNODEWITHID:  	//Blanks accept any Blank  	return new BlankNodePattern (t.Value.Substring (2));  case Token.KEYWORDA:  	return new NodeMatchPattern (new UriNode (null' UriFactory.Create (NamespaceMapper.RDF + "type")));  default:  	throw ParserHelper.Error ("Unable to Convert a '" + t.GetType ().ToString () + "' to a Pattern Item in a Triple Pattern"' t);  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The following statement contains a magic number: if (litdt.DataType.StartsWith ("<")) {  	baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.ToString ();  	u = UriFactory.Create (Tools.ResolveUri (litdt.DataType.Substring (1' litdt.DataType.Length - 2)' baseUri));  	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' u));  }  else {  	//Resolve the QName                         	return new NodeMatchPattern (new NonNormalizedLiteralNode (null' litdt.Value' this.ResolveQName (context' litdt.DataType)));  }  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The following statement contains a magic number: u = UriFactory.Create (Tools.ResolveUri (litdt.DataType.Substring (1' litdt.DataType.Length - 2)' baseUri));  
Magic Number,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryCreatePatternItem,The following statement contains a magic number: return new BlankNodePattern (t.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Parse,The following statement contains a magic number: try {  	context.Handler.StartRdf ();  	//Initialise the Buffer  	context.Tokens.InitialiseBuffer (10);  	//Expect a BOF  	IToken start = context.Tokens.Dequeue ();  	if (start.TokenType != Token.BOF) {  		throw Error ("Unexpected Token '" + start.GetType ().ToString () + "' encountered' expected a Beginning of File Token"' start);  	}  	//Expect Triples  	IToken next = context.Tokens.Peek ();  	while (next.TokenType != Token.EOF) {  		//Discard Comments  		while (next.TokenType == Token.COMMENT) {  			context.Tokens.Dequeue ();  			next = context.Tokens.Peek ();  		}  		if (next.TokenType == Token.EOF)  			break;  		this.TryParseTriple (context);  		next = context.Tokens.Peek ();  	}  	context.Handler.EndRdf (true);  }  catch (RdfParsingTerminatedException) {  	context.Handler.EndRdf (true);  	//Discard this - it justs means the Handler told us to stop  }  catch (RdfParseException) {  	//We hit some Parsing error  	context.Handler.EndRdf (false);  	throw;  }  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,Parse,The following statement contains a magic number: context.Tokens.InitialiseBuffer (10);  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseSubject,The following statement contains a magic number: switch (subjToken.TokenType) {  case Token.BLANKNODE:  	return context.Handler.CreateBlankNode ();  case Token.BLANKNODEWITHID:  	return context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  case Token.URI:  	return context.Handler.CreateUriNode (UriFactory.Create (subjToken.Value));  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  	throw Error ("Subject cannot be a Literal in NTriples"' subjToken);  default:  	throw Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' expected a Blank Node or URI for the Subject of a Triple"' subjToken);  }  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseSubject,The following statement contains a magic number: return context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The following statement contains a magic number: switch (objToken.TokenType) {  case Token.BLANKNODE:  	return context.Handler.CreateBlankNode ();  case Token.BLANKNODEWITHID:  	return context.Handler.CreateBlankNode (objToken.Value.Substring (2));  case Token.URI:  	return context.Handler.CreateUriNode (UriFactory.Create (objToken.Value));  case Token.LITERALWITHDT:  	dt = ((LiteralWithDataTypeToken)objToken).DataType;  	dt = dt.Substring (1' dt.Length - 2);  	return context.Handler.CreateLiteralNode (objToken.Value' UriFactory.Create (dt));  case Token.LITERALWITHLANG:  	return context.Handler.CreateLiteralNode (objToken.Value' ((LiteralWithLanguageSpecifierToken)objToken).Language);  case Token.LITERAL:  	IToken next = context.Tokens.Peek ();  	//Is there a Language Specifier or Data Type?  	if (next.TokenType == Token.LANGSPEC) {  		context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (objToken.Value' next.Value);  	}  	else if (next.TokenType == Token.URI) {  		context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (objToken.Value' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Namespaces' context.BaseUri)));  	}  	else {  		return context.Handler.CreateLiteralNode (objToken.Value);  	}  default:  	throw Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered' expected a Blank Node' Literal or URI for the Object of a Triple"' objToken);  }  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The following statement contains a magic number: switch (objToken.TokenType) {  case Token.BLANKNODE:  	return context.Handler.CreateBlankNode ();  case Token.BLANKNODEWITHID:  	return context.Handler.CreateBlankNode (objToken.Value.Substring (2));  case Token.URI:  	return context.Handler.CreateUriNode (UriFactory.Create (objToken.Value));  case Token.LITERALWITHDT:  	dt = ((LiteralWithDataTypeToken)objToken).DataType;  	dt = dt.Substring (1' dt.Length - 2);  	return context.Handler.CreateLiteralNode (objToken.Value' UriFactory.Create (dt));  case Token.LITERALWITHLANG:  	return context.Handler.CreateLiteralNode (objToken.Value' ((LiteralWithLanguageSpecifierToken)objToken).Language);  case Token.LITERAL:  	IToken next = context.Tokens.Peek ();  	//Is there a Language Specifier or Data Type?  	if (next.TokenType == Token.LANGSPEC) {  		context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (objToken.Value' next.Value);  	}  	else if (next.TokenType == Token.URI) {  		context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (objToken.Value' UriFactory.Create (Tools.ResolveUriOrQName (next' context.Namespaces' context.BaseUri)));  	}  	else {  		return context.Handler.CreateLiteralNode (objToken.Value);  	}  default:  	throw Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered' expected a Blank Node' Literal or URI for the Object of a Triple"' objToken);  }  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The following statement contains a magic number: return context.Handler.CreateBlankNode (objToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NTriplesParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NTriplesParser.cs,TryParseObject,The following statement contains a magic number: dt = dt.Substring (1' dt.Length - 2);  
Magic Number,VDS.RDF.Parsing,UnicodeSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UnicodeSpecsHelper.cs,ConvertToChar,The following statement contains a magic number: try {  	//Convert to an Integer  	int i = Convert.ToInt32 (hex' 16);  	//Try to cast to a Char  	char c = (char)i;  	//Append to Output  	return c;  }  catch {  	throw new RdfParseException ("Unable to convert the String '" + hex + "' into a Unicode Character");  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (g' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (g' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (g' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (g' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (g' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (g' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (g' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (g' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (g' u.ToString ().Substring (7)' parser);  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (g' u.ToString ().Substring (8)' parser);  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: try {  	#if SILVERLIGHT  	                if (u.IsFile()) #else  	if (u.IsFile)  	#endif  	 {  		//Invoke FileLoader instead  		RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  		if (Path.DirectorySeparatorChar == '/') {  			FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  		}  		else {  			FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  		}  		return;  	}  	if (u.Scheme.Equals ("data")) {  		//Invoke DataUriLoader instead  		RaiseWarning ("This is a data: URI so invoking the DataUriLoader instead");  		DataUriLoader.Load (handler' u);  		return;  	}  	//Sanitise the URI to remove any Fragment ID  	u = Tools.StripUriFragment (u);  	#if !NO_URICACHE  	//Use Cache if possible  	String etag = String.Empty;  	String local = null;  	if (Options.UriLoaderCaching) {  		if (_cache.HasETag (u)) {  			//Get the ETag and then we'll include an If-None-Match header in our request  			etag = _cache.GetETag (u);  		}  		else if (_cache.HasLocalCopy (u' true)) {  			//Just try loading from the local copy  			local = _cache.GetLocalCopy (u);  			if (local != null) {  				try {  					FileLoader.Load (handler' local' new TurtleParser ());  				}  				catch {  					//If we get an Exception we failed to access the file successfully  					_cache.RemoveETag (u);  					_cache.RemoveLocalCopy (u);  					UriLoader.Load (handler' u' parser);  				}  				return;  			}  		}  	}  	#endif  	//Set-up the Request  	HttpWebRequest httpRequest;  	httpRequest = (HttpWebRequest)WebRequest.Create (u);  	//Want to ask for RDF formats  	if (parser != null) {  		//If a non-null parser set up a HTTP Header that is just for the given parser  		httpRequest.Accept = MimeTypesHelper.CustomHttpAcceptHeader (parser);  	}  	else {  		httpRequest.Accept = MimeTypesHelper.HttpAcceptHeader;  	}  	#if !NO_URICACHE  	if (Options.UriLoaderCaching) {  		if (!etag.Equals (String.Empty)) {  			httpRequest.Headers.Add (HttpRequestHeader.IfNoneMatch' etag);  		}  	}  	#endif  	//Use HTTP GET  	httpRequest.Method = "GET";  	#if !SILVERLIGHT  	httpRequest.Timeout = Options.UriLoaderTimeout;  	#endif  	if (_userAgent != null && !_userAgent.Equals (String.Empty)) {  		httpRequest.UserAgent = _userAgent;  	}  	#if DEBUG  	//HTTP Debugging  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (httpRequest);  	}  	#endif  	using (HttpWebResponse httpResponse = (HttpWebResponse)httpRequest.GetResponse ()) {  		#if DEBUG  		//HTTP Debugging  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (httpResponse);  		}  		#endif  		#if !NO_URICACHE  		if (Options.UriLoaderCaching) {  			//Are we using ETag based caching?  			if (!etag.Equals (String.Empty)) {  				//Did we get a Not-Modified response?  				if (httpResponse.StatusCode == HttpStatusCode.NotModified) {  					//If so then we need to load the Local Copy assuming it exists?  					if (_cache.HasLocalCopy (u' false)) {  						local = _cache.GetLocalCopy (u);  						try {  							FileLoader.Load (handler' local' new TurtleParser ());  						}  						catch {  							//If we get an Exception we failed to access the file successfully  							_cache.RemoveETag (u);  							_cache.RemoveLocalCopy (u);  							UriLoader.Load (handler' u' parser);  						}  						return;  					}  					else {  						//If the local copy didn't exist then we need to redo the response without  						//the ETag as we've lost the cached copy somehow  						_cache.RemoveETag (u);  						UriLoader.Load (handler' u' parser);  						return;  					}  				}  				//If we didn't get a Not-Modified response then we'll continue and parse the new response  			}  		}  		#endif  		//Get a Parser and Load the RDF  		if (parser == null) {  			//Only need to auto-detect the parser if a specific one wasn't specified  			parser = MimeTypesHelper.GetParser (httpResponse.ContentType);  		}  		parser.Warning += RaiseWarning;  		#if !NO_URICACHE  		//To do caching we ask the cache to give us a handler and then we tie it to  		IRdfHandler cacheHandler = _cache.ToCache (u' Tools.StripUriFragment (httpResponse.ResponseUri)' httpResponse.Headers ["ETag"]);  		if (cacheHandler != null) {  			//Note: We can ONLY use caching when we know that the Handler will accept all the data returned  			//i.e. if the Handler may trim the data in some way then we shouldn't cache the data returned  			if (handler.AcceptsAll) {  				handler = new MultiHandler (new IRdfHandler[] {  					handler'  					cacheHandler  				});  			}  			else {  				cacheHandler = null;  			}  		}  		try {  			#endif  			parser.Load (handler' new StreamReader (httpResponse.GetResponseStream ()));  			#if !NO_URICACHE  		}  		catch {  			//If we were trying to cache the response and something went wrong discard the cached copy  			_cache.RemoveETag (u);  			_cache.RemoveETag (Tools.StripUriFragment (httpResponse.ResponseUri));  			_cache.RemoveLocalCopy (u);  			_cache.RemoveLocalCopy (Tools.StripUriFragment (httpResponse.ResponseUri));  		}  		#endif  	}  }  catch (UriFormatException uriEx) {  	//Uri Format Invalid  	throw new RdfParseException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid"' uriEx);  }  catch (WebException webEx) {  	#if DEBUG  	if (webEx.Response != null && Options.HttpDebugging) {  		Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	#if !NO_URICACHE  	if (webEx.Response != null) {  		if (((HttpWebResponse)webEx.Response).StatusCode == HttpStatusCode.NotModified) {  			//If so then we need to load the Local Copy assuming it exists?  			if (_cache.HasLocalCopy (u' false)) {  				String local = _cache.GetLocalCopy (u);  				try {  					FileLoader.Load (handler' local' new TurtleParser ());  				}  				catch {  					//If we get an Exception we failed to access the file successfully  					_cache.RemoveETag (u);  					_cache.RemoveLocalCopy (u);  					UriLoader.Load (handler' u' parser);  				}  				return;  			}  			else {  				//If the local copy didn't exist then we need to redo the response without  				//the ETag as we've lost the cached copy somehow  				_cache.RemoveETag (u);  				UriLoader.Load (handler' u' parser);  				return;  			}  		}  	}  	#endif  	//Some sort of HTTP Error occurred  	throw new WebException ("A HTTP Error occurred resolving the URI '" + u.ToString () + "'"' webEx);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: try {  	#if SILVERLIGHT  	                if (u.IsFile()) #else  	if (u.IsFile)  	#endif  	 {  		//Invoke FileLoader instead  		RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  		if (Path.DirectorySeparatorChar == '/') {  			FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  		}  		else {  			FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  		}  		return;  	}  	if (u.Scheme.Equals ("data")) {  		//Invoke DataUriLoader instead  		RaiseWarning ("This is a data: URI so invoking the DataUriLoader instead");  		DataUriLoader.Load (handler' u);  		return;  	}  	//Sanitise the URI to remove any Fragment ID  	u = Tools.StripUriFragment (u);  	#if !NO_URICACHE  	//Use Cache if possible  	String etag = String.Empty;  	String local = null;  	if (Options.UriLoaderCaching) {  		if (_cache.HasETag (u)) {  			//Get the ETag and then we'll include an If-None-Match header in our request  			etag = _cache.GetETag (u);  		}  		else if (_cache.HasLocalCopy (u' true)) {  			//Just try loading from the local copy  			local = _cache.GetLocalCopy (u);  			if (local != null) {  				try {  					FileLoader.Load (handler' local' new TurtleParser ());  				}  				catch {  					//If we get an Exception we failed to access the file successfully  					_cache.RemoveETag (u);  					_cache.RemoveLocalCopy (u);  					UriLoader.Load (handler' u' parser);  				}  				return;  			}  		}  	}  	#endif  	//Set-up the Request  	HttpWebRequest httpRequest;  	httpRequest = (HttpWebRequest)WebRequest.Create (u);  	//Want to ask for RDF formats  	if (parser != null) {  		//If a non-null parser set up a HTTP Header that is just for the given parser  		httpRequest.Accept = MimeTypesHelper.CustomHttpAcceptHeader (parser);  	}  	else {  		httpRequest.Accept = MimeTypesHelper.HttpAcceptHeader;  	}  	#if !NO_URICACHE  	if (Options.UriLoaderCaching) {  		if (!etag.Equals (String.Empty)) {  			httpRequest.Headers.Add (HttpRequestHeader.IfNoneMatch' etag);  		}  	}  	#endif  	//Use HTTP GET  	httpRequest.Method = "GET";  	#if !SILVERLIGHT  	httpRequest.Timeout = Options.UriLoaderTimeout;  	#endif  	if (_userAgent != null && !_userAgent.Equals (String.Empty)) {  		httpRequest.UserAgent = _userAgent;  	}  	#if DEBUG  	//HTTP Debugging  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (httpRequest);  	}  	#endif  	using (HttpWebResponse httpResponse = (HttpWebResponse)httpRequest.GetResponse ()) {  		#if DEBUG  		//HTTP Debugging  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (httpResponse);  		}  		#endif  		#if !NO_URICACHE  		if (Options.UriLoaderCaching) {  			//Are we using ETag based caching?  			if (!etag.Equals (String.Empty)) {  				//Did we get a Not-Modified response?  				if (httpResponse.StatusCode == HttpStatusCode.NotModified) {  					//If so then we need to load the Local Copy assuming it exists?  					if (_cache.HasLocalCopy (u' false)) {  						local = _cache.GetLocalCopy (u);  						try {  							FileLoader.Load (handler' local' new TurtleParser ());  						}  						catch {  							//If we get an Exception we failed to access the file successfully  							_cache.RemoveETag (u);  							_cache.RemoveLocalCopy (u);  							UriLoader.Load (handler' u' parser);  						}  						return;  					}  					else {  						//If the local copy didn't exist then we need to redo the response without  						//the ETag as we've lost the cached copy somehow  						_cache.RemoveETag (u);  						UriLoader.Load (handler' u' parser);  						return;  					}  				}  				//If we didn't get a Not-Modified response then we'll continue and parse the new response  			}  		}  		#endif  		//Get a Parser and Load the RDF  		if (parser == null) {  			//Only need to auto-detect the parser if a specific one wasn't specified  			parser = MimeTypesHelper.GetParser (httpResponse.ContentType);  		}  		parser.Warning += RaiseWarning;  		#if !NO_URICACHE  		//To do caching we ask the cache to give us a handler and then we tie it to  		IRdfHandler cacheHandler = _cache.ToCache (u' Tools.StripUriFragment (httpResponse.ResponseUri)' httpResponse.Headers ["ETag"]);  		if (cacheHandler != null) {  			//Note: We can ONLY use caching when we know that the Handler will accept all the data returned  			//i.e. if the Handler may trim the data in some way then we shouldn't cache the data returned  			if (handler.AcceptsAll) {  				handler = new MultiHandler (new IRdfHandler[] {  					handler'  					cacheHandler  				});  			}  			else {  				cacheHandler = null;  			}  		}  		try {  			#endif  			parser.Load (handler' new StreamReader (httpResponse.GetResponseStream ()));  			#if !NO_URICACHE  		}  		catch {  			//If we were trying to cache the response and something went wrong discard the cached copy  			_cache.RemoveETag (u);  			_cache.RemoveETag (Tools.StripUriFragment (httpResponse.ResponseUri));  			_cache.RemoveLocalCopy (u);  			_cache.RemoveLocalCopy (Tools.StripUriFragment (httpResponse.ResponseUri));  		}  		#endif  	}  }  catch (UriFormatException uriEx) {  	//Uri Format Invalid  	throw new RdfParseException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid"' uriEx);  }  catch (WebException webEx) {  	#if DEBUG  	if (webEx.Response != null && Options.HttpDebugging) {  		Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	#if !NO_URICACHE  	if (webEx.Response != null) {  		if (((HttpWebResponse)webEx.Response).StatusCode == HttpStatusCode.NotModified) {  			//If so then we need to load the Local Copy assuming it exists?  			if (_cache.HasLocalCopy (u' false)) {  				String local = _cache.GetLocalCopy (u);  				try {  					FileLoader.Load (handler' local' new TurtleParser ());  				}  				catch {  					//If we get an Exception we failed to access the file successfully  					_cache.RemoveETag (u);  					_cache.RemoveLocalCopy (u);  					UriLoader.Load (handler' u' parser);  				}  				return;  			}  			else {  				//If the local copy didn't exist then we need to redo the response without  				//the ETag as we've lost the cached copy somehow  				_cache.RemoveETag (u);  				UriLoader.Load (handler' u' parser);  				return;  			}  		}  	}  	#endif  	//Some sort of HTTP Error occurred  	throw new WebException ("A HTTP Error occurred resolving the URI '" + u.ToString () + "'"' webEx);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: try {  	#if SILVERLIGHT  	                if (u.IsFile()) #else  	if (u.IsFile)  	#endif  	 {  		//Invoke FileLoader instead  		RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  		if (Path.DirectorySeparatorChar == '/') {  			FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  		}  		else {  			FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  		}  		return;  	}  	//Sanitise the URI to remove any Fragment ID  	u = Tools.StripUriFragment (u);  	//Set-up the Request  	HttpWebRequest httpRequest;  	httpRequest = (HttpWebRequest)WebRequest.Create (u);  	//Want to ask for TriG' NQuads or TriX  	if (parser != null) {  		//If a non-null parser set up a HTTP Header that is just for the given parser  		httpRequest.Accept = MimeTypesHelper.CustomHttpAcceptHeader (parser);  	}  	else {  		httpRequest.Accept = MimeTypesHelper.HttpRdfDatasetAcceptHeader;  	}  	//Use HTTP GET  	httpRequest.Method = "GET";  	#if !SILVERLIGHT  	httpRequest.Timeout = Options.UriLoaderTimeout;  	#endif  	if (_userAgent != null && !_userAgent.Equals (String.Empty)) {  		httpRequest.UserAgent = _userAgent;  	}  	#if DEBUG  	//HTTP Debugging  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (httpRequest);  	}  	#endif  	using (HttpWebResponse httpResponse = (HttpWebResponse)httpRequest.GetResponse ()) {  		#if DEBUG  		//HTTP Debugging  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (httpResponse);  		}  		#endif  		//Get a Parser and Load the RDF  		if (parser == null) {  			try {  				parser = MimeTypesHelper.GetStoreParser (httpResponse.ContentType);  				parser.Warning += RaiseStoreWarning;  				parser.Load (handler' new StreamParams (httpResponse.GetResponseStream ()));  			}  			catch (RdfParserSelectionException) {  				RaiseStoreWarning ("Unable to select a RDF Dataset parser based on Content-Type: " + httpResponse.ContentType + " - seeing if the content is an RDF Graph instead");  				try {  					//If not a RDF Dataset format see if it is a Graph  					IRdfReader rdfParser = MimeTypesHelper.GetParser (httpResponse.ContentType);  					rdfParser.Load (handler' new StreamReader (httpResponse.GetResponseStream ()));  				}  				catch (RdfParserSelectionException) {  					//Finally fall back to assuming a dataset and trying format guessing  					String data = new StreamReader (httpResponse.GetResponseStream ()).ReadToEnd ();  					parser = StringParser.GetDatasetParser (data);  					parser.Warning += RaiseStoreWarning;  					parser.Load (handler' new TextReaderParams (new StringReader (data)));  				}  			}  		}  		else {  			parser.Warning += RaiseStoreWarning;  			parser.Load (handler' new StreamParams (httpResponse.GetResponseStream ()));  		}  	}  }  catch (UriFormatException uriEx) {  	//Uri Format Invalid  	throw new RdfException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid' see inner exception for details"' uriEx);  }  catch (WebException webEx) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	//Some sort of HTTP Error occurred  	throw new WebException ("A HTTP Error occurred resolving the URI '" + u.ToString () + "'' see innner exception for details"' webEx);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: try {  	#if SILVERLIGHT  	                if (u.IsFile()) #else  	if (u.IsFile)  	#endif  	 {  		//Invoke FileLoader instead  		RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  		if (Path.DirectorySeparatorChar == '/') {  			FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  		}  		else {  			FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  		}  		return;  	}  	//Sanitise the URI to remove any Fragment ID  	u = Tools.StripUriFragment (u);  	//Set-up the Request  	HttpWebRequest httpRequest;  	httpRequest = (HttpWebRequest)WebRequest.Create (u);  	//Want to ask for TriG' NQuads or TriX  	if (parser != null) {  		//If a non-null parser set up a HTTP Header that is just for the given parser  		httpRequest.Accept = MimeTypesHelper.CustomHttpAcceptHeader (parser);  	}  	else {  		httpRequest.Accept = MimeTypesHelper.HttpRdfDatasetAcceptHeader;  	}  	//Use HTTP GET  	httpRequest.Method = "GET";  	#if !SILVERLIGHT  	httpRequest.Timeout = Options.UriLoaderTimeout;  	#endif  	if (_userAgent != null && !_userAgent.Equals (String.Empty)) {  		httpRequest.UserAgent = _userAgent;  	}  	#if DEBUG  	//HTTP Debugging  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (httpRequest);  	}  	#endif  	using (HttpWebResponse httpResponse = (HttpWebResponse)httpRequest.GetResponse ()) {  		#if DEBUG  		//HTTP Debugging  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (httpResponse);  		}  		#endif  		//Get a Parser and Load the RDF  		if (parser == null) {  			try {  				parser = MimeTypesHelper.GetStoreParser (httpResponse.ContentType);  				parser.Warning += RaiseStoreWarning;  				parser.Load (handler' new StreamParams (httpResponse.GetResponseStream ()));  			}  			catch (RdfParserSelectionException) {  				RaiseStoreWarning ("Unable to select a RDF Dataset parser based on Content-Type: " + httpResponse.ContentType + " - seeing if the content is an RDF Graph instead");  				try {  					//If not a RDF Dataset format see if it is a Graph  					IRdfReader rdfParser = MimeTypesHelper.GetParser (httpResponse.ContentType);  					rdfParser.Load (handler' new StreamReader (httpResponse.GetResponseStream ()));  				}  				catch (RdfParserSelectionException) {  					//Finally fall back to assuming a dataset and trying format guessing  					String data = new StreamReader (httpResponse.GetResponseStream ()).ReadToEnd ();  					parser = StringParser.GetDatasetParser (data);  					parser.Warning += RaiseStoreWarning;  					parser.Load (handler' new TextReaderParams (new StringReader (data)));  				}  			}  		}  		else {  			parser.Warning += RaiseStoreWarning;  			parser.Load (handler' new StreamParams (httpResponse.GetResponseStream ()));  		}  	}  }  catch (UriFormatException uriEx) {  	//Uri Format Invalid  	throw new RdfException ("Unable to load from the given URI '" + u.ToString () + "' since it's format was invalid' see inner exception for details"' uriEx);  }  catch (WebException webEx) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	//Some sort of HTTP Error occurred  	throw new WebException ("A HTTP Error occurred resolving the URI '" + u.ToString () + "'' see innner exception for details"' webEx);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (u.IsFile)  #endif   {  	//Invoke FileLoader instead  	RaiseWarning ("This is a file: URI so invoking the FileLoader instead");  	if (Path.DirectorySeparatorChar == '/') {  		FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  	}  	else {  		FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  	}  	return;  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: if (Path.DirectorySeparatorChar == '/') {  	FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  }  else {  	FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  }  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (handler' u.ToString ().Substring (7)' parser);  
Magic Number,VDS.RDF.Parsing,UriLoader,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\UriLoader.cs,Load,The following statement contains a magic number: FileLoader.Load (handler' u.ToString ().Substring (8)' parser);  
Magic Number,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionLiteralPropertyElement,The following statement contains a magic number: if (element.Attributes.Count > 2) {  	throw ParserHelper.Error ("A Literal Property Element contains too many attributes' only rdf:ID and rdf:datatype are permitted"' element);  }  else {  	//Only rdf:ID and rdf:datatype allowed  	foreach (AttributeEvent a in element.Attributes) {  		if (RdfXmlSpecsHelper.IsIDAttribute (a)) {  			ID = "#" + a.Value;  		}  		else if (RdfXmlSpecsHelper.IsDataTypeAttribute (a)) {  			datatype = a.Value;  		}  		else {  			throw ParserHelper.Error ("A Literal Property Element contains an unexpected attribute' only rdf:ID and rdf:datatype are permitted"' element);  		}  	}  }  
Magic Number,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeLiteralPropertyElement,The following statement contains a magic number: if (element.Attributes.Count > 2) {  	//Can't be more than 2 Attributes' only allowed an optional rdf:ID and a required rdf:parseType  	throw ParserHelper.Error ("An Property Element with Parse Type 'Literal' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'"' "Parse Type Literal Property Element"' element);  }  else {  	//Check the attributes that do exist  	foreach (AttributeEvent a in element.Attributes) {  		if (RdfXmlSpecsHelper.IsIDAttribute (a)) {  			ID = "#" + a.Value;  		}  		else if (a.QName.Equals ("rdf:parseType")) {  			//OK  		}  		else {  			//Invalid Attribute  			throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Literal'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'"' "Parse Type Literal Property Element"' element);  		}  	}  }  
Magic Number,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeResourcePropertyElement,The following statement contains a magic number: if (element.Attributes.Count > 2) {  	//Can't be more than 2 Attributes' only allowed an optional rdf:ID and a required rdf:parseType  	throw ParserHelper.Error ("An Property Element with Parse Type 'Resource' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'"' "Parse Type Resource Property Element"' element);  }  else {  	//Check the attributes that do exist  	foreach (AttributeEvent a in element.Attributes) {  		if (RdfXmlSpecsHelper.IsIDAttribute (a)) {  			ID = "#" + a.Value;  		}  		else if (a.QName.Equals ("rdf:parseType")) {  			//OK  		}  		else {  			//Invalid Attribute  			throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Resource'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'"' "Parse Type Resource Property Element"' element);  		}  	}  }  
Magic Number,VDS.RDF.Parsing,RdfXmlParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfXmlParser.cs,GrammarProductionParseTypeCollectionPropertyElement,The following statement contains a magic number: if (element.Attributes.Count > 2) {  	//Can't be more than 2 Attributes' only allowed an optional rdf:ID and a required rdf:parseType  	throw ParserHelper.Error ("An Property Element with Parse Type 'Collection' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'"' "Parse Type Collection Property Element"' element);  }  else {  	//Check the attributes that do exist  	foreach (AttributeEvent a in element.Attributes) {  		if (RdfXmlSpecsHelper.IsIDAttribute (a)) {  			ID = "#" + a.Value;  		}  		else if (a.QName.Equals ("rdf:parseType")) {  			//OK  		}  		else {  			//Invalid Attribute  			throw ParserHelper.Error ("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Collection'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'"' "Parse Type Collection Property Element"' element);  		}  	}  }  
Magic Number,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseResultRow,The following statement contains a magic number: while (true) {  	next = context.Tokens.Dequeue ();  	switch (next.TokenType) {  	case Token.BLANKNODEWITHID:  		if (expectComma)  			throw ParserHelper.Error ("Unexpected Blank Node' expected a comma between RDF Terms"' next);  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		INode blank = context.Handler.CreateBlankNode (next.Value.Substring (2));  		result.SetValue (context.Variables [v]' blank);  		v++;  		allowEOL = true;  		expectComma = true;  		break;  	case Token.LITERAL:  	case Token.PLAINLITERAL:  		if (expectComma)  			throw ParserHelper.Error ("Unexpected Blank Node' expected a comma between RDF Terms"' next);  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		//Try and guess what kind of term this is  		String lexicalForm = next.Value;  		INode value;  		if (lexicalForm.StartsWith ("http://") || lexicalForm.StartsWith ("https://") || lexicalForm.StartsWith ("mailto:") || lexicalForm.StartsWith ("ftp://")) {  			try {  				//Guessing a URI if starts with common URI prefix  				value = context.Handler.CreateUriNode (UriFactory.Create (lexicalForm));  			}  			catch {  				//If invalid URI fall back to treating as literal  				value = context.Handler.CreateLiteralNode (lexicalForm);  			}  		}  		else {  			value = context.Handler.CreateLiteralNode (lexicalForm);  		}  		result.SetValue (context.Variables [v]' value);  		v++;  		allowEOL = true;  		expectComma = true;  		break;  	case Token.EOL:  		if (allowEOL) {  			break;  		}  		else {  			if (v == context.Variables.Count - 1) {  				//If this is the last expected term then this must be an empty term  				v++;  				break;  			}  			throw ParserHelper.Error ("Unexpected End of Line' expected a RDF Term Token"' next);  		}  	case Token.COMMA:  		if (!expectComma) {  			//This is an empty field  			if (v >= context.Variables.Count)  				throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  			v++;  		}  		expectComma = false;  		allowEOL = false;  		break;  	case Token.EOF:  		if (!allowEOL)  			throw ParserHelper.Error ("Unexpected EOF' expected another RDF Term for the Result Row"' next);  		break;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  	}  	//Stop when we've hit the End of the Line/File  	if (next.TokenType == Token.EOL || next.TokenType == Token.EOF)  		break;  }  
Magic Number,VDS.RDF.Parsing,SparqlCsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlCsvParser.cs,TryParseResultRow,The following statement contains a magic number: switch (next.TokenType) {  case Token.BLANKNODEWITHID:  	if (expectComma)  		throw ParserHelper.Error ("Unexpected Blank Node' expected a comma between RDF Terms"' next);  	if (v >= context.Variables.Count)  		throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  	INode blank = context.Handler.CreateBlankNode (next.Value.Substring (2));  	result.SetValue (context.Variables [v]' blank);  	v++;  	allowEOL = true;  	expectComma = true;  	break;  case Token.LITERAL:  case Token.PLAINLITERAL:  	if (expectComma)  		throw ParserHelper.Error ("Unexpected Blank Node' expected a comma between RDF Terms"' next);  	if (v >= context.Variables.Count)  		throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  	//Try and guess what kind of term this is  	String lexicalForm = next.Value;  	INode value;  	if (lexicalForm.StartsWith ("http://") || lexicalForm.StartsWith ("https://") || lexicalForm.StartsWith ("mailto:") || lexicalForm.StartsWith ("ftp://")) {  		try {  			//Guessing a URI if starts with common URI prefix  			value = context.Handler.CreateUriNode (UriFactory.Create (lexicalForm));  		}  		catch {  			//If invalid URI fall back to treating as literal  			value = context.Handler.CreateLiteralNode (lexicalForm);  		}  	}  	else {  		value = context.Handler.CreateLiteralNode (lexicalForm);  	}  	result.SetValue (context.Variables [v]' value);  	v++;  	allowEOL = true;  	expectComma = true;  	break;  case Token.EOL:  	if (allowEOL) {  		break;  	}  	else {  		if (v == context.Variables.Count - 1) {  			//If this is the last expected term then this must be an empty term  			v++;  			break;  		}  		throw ParserHelper.Error ("Unexpected End of Line' expected a RDF Term Token"' next);  	}  case Token.COMMA:  	if (!expectComma) {  		//This is an empty field  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		v++;  	}  	expectComma = false;  	allowEOL = false;  	break;  case Token.EOF:  	if (!allowEOL)  		throw ParserHelper.Error ("Unexpected EOF' expected another RDF Term for the Result Row"' next);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,TryParseResultRow,The following statement contains a magic number: while (true) {  	next = context.Tokens.Dequeue ();  	switch (next.TokenType) {  	case Token.URI:  		if (expectTab)  			throw ParserHelper.Error ("Unexpected URI' expected a Tab between RDF Terms"' next);  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		INode uri = ParserHelper.TryResolveUri (context' next);  		result.SetValue (context.Variables [v]' uri);  		v++;  		allowEOL = true;  		expectTab = true;  		break;  	case Token.BLANKNODEWITHID:  		if (expectTab)  			throw ParserHelper.Error ("Unexpected Blank Node' expected a Tab between RDF Terms"' next);  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		INode blank = context.Handler.CreateBlankNode (next.Value.Substring (2));  		result.SetValue (context.Variables [v]' blank);  		v++;  		allowEOL = true;  		expectTab = true;  		break;  	case Token.LITERAL:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  		if (expectTab)  			throw ParserHelper.Error ("Unexpected Blank Node' expected a Tab between RDF Terms"' next);  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		INode lit = this.TryParseLiteral (context' next);  		result.SetValue (context.Variables [v]' lit);  		v++;  		allowEOL = true;  		expectTab = true;  		break;  	case Token.EOL:  		if (allowEOL) {  			break;  		}  		else {  			if (v == context.Variables.Count - 1) {  				//If this is the last expected term then this must be an empty term  				v++;  				break;  			}  			throw ParserHelper.Error ("Unexpected End of Line' expected a RDF Term Token"' next);  		}  	case Token.TAB:  		if (!expectTab) {  			//This is an empty field  			if (v >= context.Variables.Count)  				throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  			v++;  		}  		expectTab = false;  		allowEOL = false;  		break;  	case Token.EOF:  		if (!allowEOL)  			throw ParserHelper.Error ("Unexpected EOF' expected another RDF Term for the Result Row"' next);  		break;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  	}  	//Stop when we've hit the End of the Line/File  	if (next.TokenType == Token.EOL || next.TokenType == Token.EOF)  		break;  }  
Magic Number,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,TryParseResultRow,The following statement contains a magic number: switch (next.TokenType) {  case Token.URI:  	if (expectTab)  		throw ParserHelper.Error ("Unexpected URI' expected a Tab between RDF Terms"' next);  	if (v >= context.Variables.Count)  		throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  	INode uri = ParserHelper.TryResolveUri (context' next);  	result.SetValue (context.Variables [v]' uri);  	v++;  	allowEOL = true;  	expectTab = true;  	break;  case Token.BLANKNODEWITHID:  	if (expectTab)  		throw ParserHelper.Error ("Unexpected Blank Node' expected a Tab between RDF Terms"' next);  	if (v >= context.Variables.Count)  		throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  	INode blank = context.Handler.CreateBlankNode (next.Value.Substring (2));  	result.SetValue (context.Variables [v]' blank);  	v++;  	allowEOL = true;  	expectTab = true;  	break;  case Token.LITERAL:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	if (expectTab)  		throw ParserHelper.Error ("Unexpected Blank Node' expected a Tab between RDF Terms"' next);  	if (v >= context.Variables.Count)  		throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  	INode lit = this.TryParseLiteral (context' next);  	result.SetValue (context.Variables [v]' lit);  	v++;  	allowEOL = true;  	expectTab = true;  	break;  case Token.EOL:  	if (allowEOL) {  		break;  	}  	else {  		if (v == context.Variables.Count - 1) {  			//If this is the last expected term then this must be an empty term  			v++;  			break;  		}  		throw ParserHelper.Error ("Unexpected End of Line' expected a RDF Term Token"' next);  	}  case Token.TAB:  	if (!expectTab) {  		//This is an empty field  		if (v >= context.Variables.Count)  			throw ParserHelper.Error ("Too many RDF Terms' only expecting " + context.Variables.Count + " terms"' next);  		v++;  	}  	expectTab = false;  	allowEOL = false;  	break;  case Token.EOF:  	if (!allowEOL)  		throw ParserHelper.Error ("Unexpected EOF' expected another RDF Term for the Result Row"' next);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  }  
Magic Number,VDS.RDF.Parsing,SparqlTsvParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlTsvParser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.DATATYPE) {  	next = context.Tokens.Dequeue ();  	Uri dtUri = UriFactory.Create (next.Value.Substring (1' next.Length - 2));  	return context.Handler.CreateLiteralNode (value' dtUri);  }  else if (next.TokenType == Token.LANGSPEC) {  	next = context.Tokens.Dequeue ();  	return context.Handler.CreateLiteralNode (value' next.Value);  }  else {  	return context.Handler.CreateLiteralNode (value);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIHierPart,The following statement contains a magic number: if (value.StartsWith ("//")) {  	String reference = value.Substring (2);  	if (value.Contains ("/")) {  		String auth = value.Substring (0' value.IndexOf ('/'));  		String path = value.Substring (value.IndexOf ('/') + 1);  		return IsIAuthority (auth) && IsIPathAbEmpty (path);  	}  	else {  		return IsIAuthority (reference);  	}  }  else {  	return IsIPathAbsolute (value) || IsIPathRootless (value) || IsIPathEmpty (value);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIrelativePart,The following statement contains a magic number: if (value.StartsWith ("//")) {  	String reference = value.Substring (2);  	if (value.Contains ("/")) {  		String auth = value.Substring (0' value.IndexOf ('/'));  		String path = value.Substring (value.IndexOf ('/') + 1);  		return IsIAuthority (auth) && IsIPathAbEmpty (path);  	}  	else {  		return IsIAuthority (reference);  	}  }  else {  	return IsIPathAbsolute (value) || IsIPathNoScheme (value) || IsIPathEmpty (value);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == ':') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == ':') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: if (cs [i] == ':') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: if (cs [i] == ':') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: if (!IsPctEncoded (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIUserInfo,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsUnreserved (cs [i]) && !IsSubDelims (cs [i])) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: if (!IsPctEncoded (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIRegName,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsIpChar (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else {  		if (!IsIpChar (new String (cs [i]' 1)))  			return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsIpChar (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else {  		if (!IsIpChar (new String (cs [i]' 1)))  			return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsIpChar (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else {  	if (!IsIpChar (new String (cs [i]' 1)))  		return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsIpChar (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else {  	if (!IsIpChar (new String (cs [i]' 1)))  		return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: if (!IsIpChar (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNz,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsIpChar (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else {  		if (!(cs [i] == '@' || IsSubDelims (cs [i]) || IsIUnreserved (cs [i])))  			return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '%') {  		if (!IsIpChar (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else {  		if (!(cs [i] == '@' || IsSubDelims (cs [i]) || IsIUnreserved (cs [i])))  			return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsIpChar (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else {  	if (!(cs [i] == '@' || IsSubDelims (cs [i]) || IsIUnreserved (cs [i])))  		return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsIpChar (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else {  	if (!(cs [i] == '@' || IsSubDelims (cs [i]) || IsIUnreserved (cs [i])))  		return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: if (!IsIpChar (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsISegmentNzNc,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '/' || cs [i] == '?') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsIpChar (new String (cs [i]' 1))) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '/' || cs [i] == '?') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsIpChar (new String (cs [i]' 1))) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: if (cs [i] == '/' || cs [i] == '?') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: if (cs [i] == '/' || cs [i] == '?') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: if (!IsPctEncoded (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIQuery,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '/' || cs [i] == '?') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsIpChar (new String (cs [i]' 1))) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: while (i < cs.Length) {  	if (cs [i] == '/' || cs [i] == '?') {  		//OK  	}  	else if (cs [i] == '%') {  		if (!IsPctEncoded (new String (new char[] {  			cs [i]'  			cs [i + 1]'  			cs [i + 2]  		})))  			return false;  		i += 2;  	}  	else if (!IsIpChar (new String (cs [i]' 1))) {  		return false;  	}  	i++;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: if (cs [i] == '/' || cs [i] == '?') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: if (cs [i] == '/' || cs [i] == '?') {  	//OK  }  else if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: if (cs [i] == '%') {  	if (!IsPctEncoded (new String (new char[] {  		cs [i]'  		cs [i + 1]'  		cs [i + 2]  	})))  		return false;  	i += 2;  }  else if (!IsIpChar (new String (cs [i]' 1))) {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: if (!IsPctEncoded (new String (new char[] {  	cs [i]'  	cs [i + 1]'  	cs [i + 2]  })))  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIFragment,The following statement contains a magic number: i += 2;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPLiteral,The following statement contains a magic number: if (value.StartsWith ("[") && value.EndsWith ("]")) {  	String literal = value.Substring (1' value.Length - 2);  	return IsIPv6Address (literal) || IsIPvFuture (literal);  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (value.Contains ("::")) {  	String start = value.Substring (0' value.IndexOf ("::"));  	String rest = value.Substring (value.IndexOf ("::") + 2);  	String[] startChunks = start.Split (':');  	if (!startChunks.All (c => IsH16 (c)))  		return false;  	switch (startChunks.Length) {  	case 1:  	case 2:  	case 3:  		String[] restChunks = rest.Split (new char[] {  			':'  		}' 6 - startChunks.Length);  		return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  	case 4:  		if (!rest.Contains (':'))  			return false;  		return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  	case 5:  		return IsLs32 (rest);  	case 6:  		return IsH16 (rest);  	case 7:  		return rest.Equals (String.Empty);  	default:  		return false;  	}  }  else {  	String[] chunks = value.Split (new char[] {  		':'  	}' 7);  	if (chunks.Length < 7)  		return false;  	return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: switch (startChunks.Length) {  case 1:  case 2:  case 3:  	String[] restChunks = rest.Split (new char[] {  		':'  	}' 6 - startChunks.Length);  	return restChunks.Take (restChunks.Length - 1).All (c => IsH16 (c)) && IsLs32 (restChunks [restChunks.Length - 1]);  case 4:  	if (!rest.Contains (':'))  		return false;  	return IsH16 (rest.Substring (0' rest.IndexOf (':'))) && IsLs32 (rest.Substring (rest.IndexOf (':') + 1));  case 5:  	return IsLs32 (rest);  case 6:  	return IsH16 (rest);  case 7:  	return rest.Equals (String.Empty);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: if (chunks.Length < 7)  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv6Address,The following statement contains a magic number: return chunks.Take (6).All (c => IsH16 (c)) && IsLs32 (chunks [6]);  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsH16,The following statement contains a magic number: if (value.Length < 1 || value.Length > 4)  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv4Address,The following statement contains a magic number: if (value.Contains (".")) {  	String[] octets = value.Split ('.');  	if (octets.Length != 4)  		return false;  	return octets.All (o => IsDecOctet (o));  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsIPv4Address,The following statement contains a magic number: if (octets.Length != 4)  	return false;  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsDecOctet,The following statement contains a magic number: switch (value.Length) {  case 1:  	return Char.IsDigit (value [0]);  case 2:  	return value.ToCharArray ().All (c => Char.IsDigit (c));  case 3:  	return (value [0] == '1' || value [0] == '2') && (value [1] == '0' || value [1] == '1' || value [1] == '2' || value [1] == '3' || value [1] == '4' || value [1] == '5') && Char.IsDigit (value [2]);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsDecOctet,The following statement contains a magic number: switch (value.Length) {  case 1:  	return Char.IsDigit (value [0]);  case 2:  	return value.ToCharArray ().All (c => Char.IsDigit (c));  case 3:  	return (value [0] == '1' || value [0] == '2') && (value [1] == '0' || value [1] == '1' || value [1] == '2' || value [1] == '3' || value [1] == '4' || value [1] == '5') && Char.IsDigit (value [2]);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsDecOctet,The following statement contains a magic number: switch (value.Length) {  case 1:  	return Char.IsDigit (value [0]);  case 2:  	return value.ToCharArray ().All (c => Char.IsDigit (c));  case 3:  	return (value [0] == '1' || value [0] == '2') && (value [1] == '0' || value [1] == '1' || value [1] == '2' || value [1] == '3' || value [1] == '4' || value [1] == '5') && Char.IsDigit (value [2]);  default:  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsDecOctet,The following statement contains a magic number: return (value [0] == '1' || value [0] == '2') && (value [1] == '0' || value [1] == '1' || value [1] == '2' || value [1] == '3' || value [1] == '4' || value [1] == '5') && Char.IsDigit (value [2]);  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsPctEncoded,The following statement contains a magic number: if (value.StartsWith ("%")) {  	if (value.Length == 3) {  		return IsHexDigit (value [1]) && IsHexDigit (value [2]);  	}  	else {  		return false;  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsPctEncoded,The following statement contains a magic number: if (value.StartsWith ("%")) {  	if (value.Length == 3) {  		return IsHexDigit (value [1]) && IsHexDigit (value [2]);  	}  	else {  		return false;  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsPctEncoded,The following statement contains a magic number: if (value.Length == 3) {  	return IsHexDigit (value [1]) && IsHexDigit (value [2]);  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsPctEncoded,The following statement contains a magic number: if (value.Length == 3) {  	return IsHexDigit (value [1]) && IsHexDigit (value [2]);  }  else {  	return false;  }  
Magic Number,VDS.RDF.Parsing,IriSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\IriSpecsHelper.cs,IsPctEncoded,The following statement contains a magic number: return IsHexDigit (value [1]) && IsHexDigit (value [2]);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Parse,The following statement contains a magic number: try {  	context.Handler.StartRdf ();  	//Initialise Buffer and start parsing  	context.Tokens.InitialiseBuffer (10);  	IToken next = context.Tokens.Dequeue ();  	if (next.TokenType != Token.BOF) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a BOF Token"' next);  	}  	do {  		next = context.Tokens.Peek ();  		switch (next.TokenType) {  		case Token.BASEDIRECTIVE:  		case Token.PREFIXDIRECTIVE:  		case Token.KEYWORDDIRECTIVE:  			this.TryParseDirective (context);  			break;  		case Token.FORALL:  			this.TryParseForAll (context);  			break;  		case Token.FORSOME:  			this.TryParseForSome (context);  			break;  		case Token.COMMENT:  			//Discard and ignore  			context.Tokens.Dequeue ();  			break;  		case Token.BLANKNODE:  		case Token.BLANKNODEWITHID:  		case Token.LEFTBRACKET:  		case Token.LEFTCURLYBRACKET:  		case Token.LEFTSQBRACKET:  		case Token.LITERAL:  		case Token.LITERALWITHDT:  		case Token.LITERALWITHLANG:  		case Token.LONGLITERAL:  		case Token.PLAINLITERAL:  		case Token.QNAME:  		case Token.URI:  			//Valid Subject of a Triple  			this.TryParseTriples (context);  			break;  		case Token.KEYWORDA:  			//'a' Keyword only valid as Predicate  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' the 'a' Keyword is only valid as a Predicate in Notation 3"' next);  		case Token.EOF:  			//OK - the loop will now terminate since we've seen the End of File  			break;  		default:  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  		}  	}  	while (next.TokenType != Token.EOF);  	context.Handler.EndRdf (true);  }  catch (RdfParsingTerminatedException) {  	context.Handler.EndRdf (true);  	//Discard this - it justs means the Handler told us to stop  }  catch {  	context.Handler.EndRdf (false);  	throw;  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,Parse,The following statement contains a magic number: context.Tokens.InitialiseBuffer (10);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseTriples,The following statement contains a magic number: switch (subjToken.TokenType) {  case Token.BLANKNODE:  	subj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	subj = context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  	break;  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//An Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		subj = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "nil"));  	}  	else {  		subj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' subj);  	}  	break;  case Token.LEFTCURLYBRACKET:  	//Start of a Graph Literal  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTCURLYBRACKET) {  		//An Empty Graph Literal  		context.Tokens.Dequeue ();  		subj = context.Handler.CreateGraphLiteralNode ();  	}  	else {  		subj = this.TryParseGraphLiteral (context);  	}  	break;  case Token.LEFTSQBRACKET:  	//Start of a Blank Node collection?  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//An anoynmous Blank Node  		context.Tokens.Dequeue ();  		subj = context.Handler.CreateBlankNode ();  	}  	else {  		//Start of a Blank Node Collection  		subj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' subj' true);  	}  	break;  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	//Literal Subjects valid in N3  	subj = this.TryParseLiteral (context' subjToken);  	break;  case Token.QNAME:  case Token.URI:  	subj = ParserHelper.TryResolveUri (context' subjToken);  	break;  case Token.VARIABLE:  	subj = context.Handler.CreateVariableNode (subjToken.Value.Substring (1));  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' this Token is not valid as the subject of a Triple"' subjToken);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseTriples,The following statement contains a magic number: subj = context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The following statement contains a magic number: do {  	predToken = context.Tokens.Dequeue ();  	if (context.TraceParsing) {  		Console.WriteLine ("Attempting to parse Predicate Object List from the Predicate Token '" + predToken.GetType ().ToString () + "'");  	}  	switch (predToken.TokenType) {  	case Token.BLANKNODE:  		pred = context.Handler.CreateBlankNode ();  		break;  	case Token.BLANKNODEWITHID:  		pred = context.Handler.CreateBlankNode (predToken.Value.Substring (2));  		break;  	case Token.COMMENT:  		//Discard and continue  		continue;  	case Token.EQUALS:  		//= Keyword  		pred = context.Handler.CreateUriNode (UriFactory.Create (SameAsUri));  		break;  	case Token.EXCLAMATION:  	case Token.HAT:  		//Path  		subj = this.TryParsePath (context' subj);  		this.TryParsePredicateObjectList (context' subj' bnodeList);  		return;  	case Token.IMPLIEDBY:  		//<= keyword  		pred = context.Handler.CreateUriNode (UriFactory.Create (ImpliesUri));  		reverse = true;  		break;  	case Token.IMPLIES:  		//=> keyword  		pred = context.Handler.CreateUriNode (UriFactory.Create (ImpliesUri));  		break;  	case Token.KEYWORDA:  		//'a' Keyword  		pred = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "type"));  		break;  	case Token.LEFTBRACKET:  		//Start of a collection so create a new Blank Node to be it's first subject  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//An Empty Collection => rdf:nil  			context.Tokens.Dequeue ();  			pred = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "nil"));  		}  		else {  			pred = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' pred);  		}  		break;  	case Token.LEFTCURLYBRACKET:  		//Graph Literals not allowed as Predicates  		throw ParserHelper.Error ("Unexpected Left Curly Bracket encountered' Graph Literals are not valid as Predicates in Notation 3"' predToken);  	case Token.LEFTSQBRACKET:  		//Start of a Blank Node collection?  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//An anoynmous Blank Node  			context.Tokens.Dequeue ();  			pred = context.Handler.CreateBlankNode ();  		}  		else {  			//Start of a Blank Node Collection  			pred = context.Handler.CreateBlankNode ();  			this.TryParsePredicateObjectList (context' pred' true);  		}  		break;  	case Token.RIGHTCURLYBRACKET:  		if (context.GraphLiteralMode) {  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' predToken);  		}  	case Token.RIGHTSQBRACKET:  		//If the last token was a semicolon and we're parsing a Blank Node Predicate Object list  		//then a trailing semicolon is permitted  		if (bnodeList) {  			if (context.Tokens.LastTokenType == Token.SEMICOLON) {  				return;  			}  			else {  				//If Predicate is not null then we've seen at least one valid Triple and this is just the end of the Blank Node Predicate Object list  				if (pred != null) {  					return;  				}  				else {  					throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Blank Node Predicate Object list' expected a valid Predicate"' predToken);  				}  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Predicate Object list"' predToken);  		}  	case Token.QNAME:  	case Token.URI:  		pred = ParserHelper.TryResolveUri (context' predToken);  		break;  	case Token.VARIABLE:  		pred = context.Handler.CreateVariableNode (predToken.Value.Substring (1));  		break;  	case Token.EOF:  		throw ParserHelper.Error ("Unexpected end of file while trying to parse a Predicate Object list"' predToken);  	default:  		throw ParserHelper.Error ("Unexpected Token '" + predToken.GetType ().ToString () + "' encountered while trying to parse a Predicate Object list"' predToken);  	}  	this.TryParseObjectList (context' subj' pred' bnodeList' reverse);  	if (context.Tokens.LastTokenType == Token.DOT && !bnodeList)  		return;  	//Dot terminates a normal Predicate Object list  	if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && bnodeList)  		return;  	//Trailing semicolon may terminate a Blank Node Predicate Object list  	if (context.Tokens.LastTokenType == Token.SEMICOLON && context.Tokens.Peek ().TokenType == Token.DOT) {  		//Dot terminates a Predicate Object list with a trailing semicolon  		context.Tokens.Dequeue ();  		return;  	}  	if (context.Tokens.LastTokenType == Token.RIGHTCURLYBRACKET && context.GraphLiteralMode)  		return;  	//Right Curly Bracket terminates a Graph Literal  }  while (true);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The following statement contains a magic number: switch (predToken.TokenType) {  case Token.BLANKNODE:  	pred = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	pred = context.Handler.CreateBlankNode (predToken.Value.Substring (2));  	break;  case Token.COMMENT:  	//Discard and continue  	continue;  case Token.EQUALS:  	//= Keyword  	pred = context.Handler.CreateUriNode (UriFactory.Create (SameAsUri));  	break;  case Token.EXCLAMATION:  case Token.HAT:  	//Path  	subj = this.TryParsePath (context' subj);  	this.TryParsePredicateObjectList (context' subj' bnodeList);  	return;  case Token.IMPLIEDBY:  	//<= keyword  	pred = context.Handler.CreateUriNode (UriFactory.Create (ImpliesUri));  	reverse = true;  	break;  case Token.IMPLIES:  	//=> keyword  	pred = context.Handler.CreateUriNode (UriFactory.Create (ImpliesUri));  	break;  case Token.KEYWORDA:  	//'a' Keyword  	pred = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "type"));  	break;  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//An Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		pred = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "nil"));  	}  	else {  		pred = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' pred);  	}  	break;  case Token.LEFTCURLYBRACKET:  	//Graph Literals not allowed as Predicates  	throw ParserHelper.Error ("Unexpected Left Curly Bracket encountered' Graph Literals are not valid as Predicates in Notation 3"' predToken);  case Token.LEFTSQBRACKET:  	//Start of a Blank Node collection?  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//An anoynmous Blank Node  		context.Tokens.Dequeue ();  		pred = context.Handler.CreateBlankNode ();  	}  	else {  		//Start of a Blank Node Collection  		pred = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' pred' true);  	}  	break;  case Token.RIGHTCURLYBRACKET:  	if (context.GraphLiteralMode) {  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' predToken);  	}  case Token.RIGHTSQBRACKET:  	//If the last token was a semicolon and we're parsing a Blank Node Predicate Object list  	//then a trailing semicolon is permitted  	if (bnodeList) {  		if (context.Tokens.LastTokenType == Token.SEMICOLON) {  			return;  		}  		else {  			//If Predicate is not null then we've seen at least one valid Triple and this is just the end of the Blank Node Predicate Object list  			if (pred != null) {  				return;  			}  			else {  				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Blank Node Predicate Object list' expected a valid Predicate"' predToken);  			}  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Right Square Bracket encountered while trying to parse a Predicate Object list"' predToken);  	}  case Token.QNAME:  case Token.URI:  	pred = ParserHelper.TryResolveUri (context' predToken);  	break;  case Token.VARIABLE:  	pred = context.Handler.CreateVariableNode (predToken.Value.Substring (1));  	break;  case Token.EOF:  	throw ParserHelper.Error ("Unexpected end of file while trying to parse a Predicate Object list"' predToken);  default:  	throw ParserHelper.Error ("Unexpected Token '" + predToken.GetType ().ToString () + "' encountered while trying to parse a Predicate Object list"' predToken);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParsePredicateObjectList,The following statement contains a magic number: pred = context.Handler.CreateBlankNode (predToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The following statement contains a magic number: do {  	objToken = context.Tokens.Dequeue ();  	if (context.TraceParsing) {  		Console.WriteLine ("Attempting to parse an Object List from the Object Token '" + objToken.GetType ().ToString () + "'");  	}  	switch (objToken.TokenType) {  	case Token.BLANKNODE:  		obj = context.Handler.CreateBlankNode ();  		break;  	case Token.BLANKNODEWITHID:  		obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  		break;  	case Token.COMMA:  		//Discard and continue - set object to null so we know we're expected to complete a triple  		if (obj != null) {  			obj = null;  			continue;  		}  		else {  			throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.COMMENT:  		//Discard and ignore  		continue;  	case Token.DOT:  		if (obj != null) {  			//OK to return if we've seen a valid Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.EXCLAMATION:  	case Token.HAT:  		//Path  		pred = this.TryParsePath (context' pred);  		this.TryParseObjectList (context' subj' pred' bnodeList' reverse);  		return;  	case Token.LEFTBRACKET:  		//Start of a collection so create a new Blank Node to be it's first subject  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection => rdf:nil  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "nil"));  		}  		else {  			obj = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' obj);  		}  		break;  	case Token.LEFTCURLYBRACKET:  		//Start of a Graph Literal  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTCURLYBRACKET) {  			//An Empty Graph Literal  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateGraphLiteralNode ();  		}  		else {  			obj = this.TryParseGraphLiteral (context);  		}  		break;  	case Token.LEFTSQBRACKET:  		//Start of a Blank Node collection?  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//An anonymous Blank Node  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateBlankNode ();  		}  		else {  			//Start of a Blank Node Collection  			obj = context.Handler.CreateBlankNode ();  			this.TryParsePredicateObjectList (context' obj' true);  		}  		break;  	case Token.LITERAL:  	case Token.LITERALWITHDT:  	case Token.LITERALWITHLANG:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  		obj = this.TryParseLiteral (context' objToken);  		break;  	case Token.RIGHTCURLYBRACKET:  		if (context.GraphLiteralMode) {  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' objToken);  		}  	case Token.RIGHTSQBRACKET:  		if (bnodeList) {  			if (obj != null) {  				//Ok to return if we've seen a Triple  				return;  			}  			else {  				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken);  		}  	case Token.SEMICOLON:  		if (obj != null) {  			//Ok to return if we've seen a Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.QNAME:  	case Token.URI:  		obj = ParserHelper.TryResolveUri (context' objToken);  		break;  	case Token.VARIABLE:  		obj = context.Handler.CreateVariableNode (objToken.Value.Substring (1));  		break;  	case Token.EOF:  		throw ParserHelper.Error ("Unexpected end of file while trying to parse an Object list"' objToken);  	default:  		throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken);  	}  	//Watch out for Paths  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.EXCLAMATION || next.TokenType == Token.HAT) {  		context.Tokens.Dequeue ();  		obj = this.TryParsePath (context' obj);  	}  	//Assert the Triple  	if (!reverse) {  		if (!context.Handler.HandleTriple (new Triple (subj' pred' obj' context.VariableContext)))  			ParserHelper.Stop ();  	}  	else {  		//When reversed this means the predicate was Implied By (<=)  		if (!context.Handler.HandleTriple (new Triple (obj' pred' subj' context.VariableContext)))  			ParserHelper.Stop ();  	}  	//Expect a comma/semicolon/dot terminator if we are to continue  	next = context.Tokens.Peek ();  	if (context.GraphLiteralMode) {  		if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.DOT && next.TokenType != Token.RIGHTCURLYBRACKET) {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple or a } to terminate the Graph Literal"' next);  		}  	}  	else if (bnodeList) {  		//If in a Blank Node list a dot is not permitted but a ] is  		if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.RIGHTSQBRACKET) {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Blank Node Object List' expected a comma' semicolon or ] to terminate the current Triple/list"' next);  		}  	}  	else if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.DOT) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The following statement contains a magic number: switch (objToken.TokenType) {  case Token.BLANKNODE:  	obj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  	break;  case Token.COMMA:  	//Discard and continue - set object to null so we know we're expected to complete a triple  	if (obj != null) {  		obj = null;  		continue;  	}  	else {  		throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.COMMENT:  	//Discard and ignore  	continue;  case Token.DOT:  	if (obj != null) {  		//OK to return if we've seen a valid Triple  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.EXCLAMATION:  case Token.HAT:  	//Path  	pred = this.TryParsePath (context' pred);  	this.TryParseObjectList (context' subj' pred' bnodeList' reverse);  	return;  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateUriNode (UriFactory.Create (NamespaceMapper.RDF + "nil"));  	}  	else {  		obj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' obj);  	}  	break;  case Token.LEFTCURLYBRACKET:  	//Start of a Graph Literal  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTCURLYBRACKET) {  		//An Empty Graph Literal  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateGraphLiteralNode ();  	}  	else {  		obj = this.TryParseGraphLiteral (context);  	}  	break;  case Token.LEFTSQBRACKET:  	//Start of a Blank Node collection?  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//An anonymous Blank Node  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateBlankNode ();  	}  	else {  		//Start of a Blank Node Collection  		obj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' obj' true);  	}  	break;  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	obj = this.TryParseLiteral (context' objToken);  	break;  case Token.RIGHTCURLYBRACKET:  	if (context.GraphLiteralMode) {  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Right Curly Bracket encountered but not expecting the end of a Graph Literal"' objToken);  	}  case Token.RIGHTSQBRACKET:  	if (bnodeList) {  		if (obj != null) {  			//Ok to return if we've seen a Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken);  	}  case Token.SEMICOLON:  	if (obj != null) {  		//Ok to return if we've seen a Triple  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.QNAME:  case Token.URI:  	obj = ParserHelper.TryResolveUri (context' objToken);  	break;  case Token.VARIABLE:  	obj = context.Handler.CreateVariableNode (objToken.Value.Substring (1));  	break;  case Token.EOF:  	throw ParserHelper.Error ("Unexpected end of file while trying to parse an Object list"' objToken);  default:  	throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseObjectList,The following statement contains a magic number: obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,The following statement contains a magic number: do {  	next = context.Tokens.Dequeue ();  	if (context.TraceParsing) {  		Console.WriteLine ("Trying to parse a Collection item from Token '" + next.GetType ().ToString () + "'");  	}  	switch (next.TokenType) {  	case Token.BLANKNODE:  		obj = context.Handler.CreateBlankNode ();  		break;  	case Token.BLANKNODEWITHID:  		obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  		break;  	case Token.COMMENT:  		//Discard and continue  		continue;  	case Token.LEFTBRACKET:  		//Nested Collection?  		temp = context.Tokens.Peek ();  		if (temp.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection => rdf:nil  			context.Tokens.Dequeue ();  			obj = rdfNil;  		}  		else {  			//Collection  			obj = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' obj);  		}  		break;  	case Token.LEFTCURLYBRACKET:  		//Graph Literal  		temp = context.Tokens.Peek ();  		if (temp.TokenType == Token.RIGHTCURLYBRACKET) {  			//Empty Graph Literal  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateGraphLiteralNode ();  		}  		else {  			//Graph Literal  			obj = this.TryParseGraphLiteral (context);  		}  		break;  	case Token.LEFTSQBRACKET:  		//Allowed Blank Node Collections as part of a Collection  		temp = context.Tokens.Peek ();  		if (temp.TokenType == Token.RIGHTSQBRACKET) {  			//Anonymous Blank Node  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateBlankNode ();  		}  		else {  			//Blank Node Collection  			obj = context.Handler.CreateBlankNode ();  			this.TryParsePredicateObjectList (context' obj' true);  		}  		break;  	case Token.LITERAL:  	case Token.LITERALWITHDT:  	case Token.LITERALWITHLANG:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  		obj = this.TryParseLiteral (context' next);  		break;  	case Token.RIGHTBRACKET:  		//We might terminate here if someone put a comment before the end of the Collection  		if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj' context.VariableContext)))  			ParserHelper.Stop ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil' context.VariableContext)))  			ParserHelper.Stop ();  		return;  	case Token.QNAME:  	case Token.URI:  		obj = ParserHelper.TryResolveUri (context' next);  		break;  	case Token.VARIABLE:  		obj = context.Handler.CreateVariableNode (next.Value.Substring (1));  		break;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next);  	}  	//Watch out for Paths  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.EXCLAMATION || next.TokenType == Token.HAT) {  		context.Tokens.Dequeue ();  		obj = this.TryParsePath (context' obj);  	}  	//Assert the relevant Triples  	if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj' context.VariableContext)))  		ParserHelper.Stop ();  	if (context.Tokens.Peek ().TokenType == Token.RIGHTBRACKET) {  		//End of the Collection  		context.Tokens.Dequeue ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil' context.VariableContext)))  			ParserHelper.Stop ();  		return;  	}  	else {  		//More stuff in the collection  		nextSubj = context.Handler.CreateBlankNode ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' nextSubj' context.VariableContext)))  			ParserHelper.Stop ();  		subj = nextSubj;  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,The following statement contains a magic number: switch (next.TokenType) {  case Token.BLANKNODE:  	obj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  	break;  case Token.COMMENT:  	//Discard and continue  	continue;  case Token.LEFTBRACKET:  	//Nested Collection?  	temp = context.Tokens.Peek ();  	if (temp.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		obj = rdfNil;  	}  	else {  		//Collection  		obj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' obj);  	}  	break;  case Token.LEFTCURLYBRACKET:  	//Graph Literal  	temp = context.Tokens.Peek ();  	if (temp.TokenType == Token.RIGHTCURLYBRACKET) {  		//Empty Graph Literal  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateGraphLiteralNode ();  	}  	else {  		//Graph Literal  		obj = this.TryParseGraphLiteral (context);  	}  	break;  case Token.LEFTSQBRACKET:  	//Allowed Blank Node Collections as part of a Collection  	temp = context.Tokens.Peek ();  	if (temp.TokenType == Token.RIGHTSQBRACKET) {  		//Anonymous Blank Node  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateBlankNode ();  	}  	else {  		//Blank Node Collection  		obj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' obj' true);  	}  	break;  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	obj = this.TryParseLiteral (context' next);  	break;  case Token.RIGHTBRACKET:  	//We might terminate here if someone put a comment before the end of the Collection  	if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj' context.VariableContext)))  		ParserHelper.Stop ();  	if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil' context.VariableContext)))  		ParserHelper.Stop ();  	return;  case Token.QNAME:  case Token.URI:  	obj = ParserHelper.TryResolveUri (context' next);  	break;  case Token.VARIABLE:  	obj = context.Handler.CreateVariableNode (next.Value.Substring (1));  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseCollection,The following statement contains a magic number: obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: switch (lit.TokenType) {  case Token.LITERAL:  case Token.LONGLITERAL:  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		//Has a Language Specifier  		next = context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (lit.Value' next.Value);  	}  	else if (next.TokenType == Token.HATHAT) {  		//Discard the ^^  		next = context.Tokens.Dequeue ();  		//Has a Datatype  		next = context.Tokens.Dequeue ();  		if (next.TokenType == Token.DATATYPE) {  			try {  				if (next.Value.StartsWith ("<")) {  					dturi = next.Value.Substring (1' next.Value.Length - 2);  					return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  				}  				else {  					dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  					return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  				}  			}  			catch (RdfException rdfEx) {  				throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next);  		}  	}  	else {  		//Just an untyped Literal  		return context.Handler.CreateLiteralNode (lit.Value);  	}  case Token.LITERALWITHDT:  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)lit;  	try {  		if (litdt.DataType.StartsWith ("<")) {  			dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  	}  case Token.LITERALWITHLANG:  	LiteralWithLanguageSpecifierToken langlit = (LiteralWithLanguageSpecifierToken)lit;  	return context.Handler.CreateLiteralNode (langlit.Value' langlit.Language);  case Token.PLAINLITERAL:  	//Attempt to infer Type  	if (TurtleSpecsHelper.IsValidPlainLiteral (lit.Value' TurtleSyntax.Original)) {  		if (TurtleSpecsHelper.IsValidDouble (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble));  		}  		else if (TurtleSpecsHelper.IsValidInteger (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger));  		}  		else if (TurtleSpecsHelper.IsValidDecimal (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal));  		}  		else {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean));  		}  	}  	else {  		throw ParserHelper.Error ("The value '" + lit.Value + "' is not valid as a Plain Literal in Turtle"' lit);  	}  default:  	throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: switch (lit.TokenType) {  case Token.LITERAL:  case Token.LONGLITERAL:  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		//Has a Language Specifier  		next = context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (lit.Value' next.Value);  	}  	else if (next.TokenType == Token.HATHAT) {  		//Discard the ^^  		next = context.Tokens.Dequeue ();  		//Has a Datatype  		next = context.Tokens.Dequeue ();  		if (next.TokenType == Token.DATATYPE) {  			try {  				if (next.Value.StartsWith ("<")) {  					dturi = next.Value.Substring (1' next.Value.Length - 2);  					return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  				}  				else {  					dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  					return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  				}  			}  			catch (RdfException rdfEx) {  				throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next);  		}  	}  	else {  		//Just an untyped Literal  		return context.Handler.CreateLiteralNode (lit.Value);  	}  case Token.LITERALWITHDT:  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)lit;  	try {  		if (litdt.DataType.StartsWith ("<")) {  			dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  	}  case Token.LITERALWITHLANG:  	LiteralWithLanguageSpecifierToken langlit = (LiteralWithLanguageSpecifierToken)lit;  	return context.Handler.CreateLiteralNode (langlit.Value' langlit.Language);  case Token.PLAINLITERAL:  	//Attempt to infer Type  	if (TurtleSpecsHelper.IsValidPlainLiteral (lit.Value' TurtleSyntax.Original)) {  		if (TurtleSpecsHelper.IsValidDouble (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble));  		}  		else if (TurtleSpecsHelper.IsValidInteger (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger));  		}  		else if (TurtleSpecsHelper.IsValidDecimal (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal));  		}  		else {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean));  		}  	}  	else {  		throw ParserHelper.Error ("The value '" + lit.Value + "' is not valid as a Plain Literal in Turtle"' lit);  	}  default:  	throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.LANGSPEC) {  	//Has a Language Specifier  	next = context.Tokens.Dequeue ();  	return context.Handler.CreateLiteralNode (lit.Value' next.Value);  }  else if (next.TokenType == Token.HATHAT) {  	//Discard the ^^  	next = context.Tokens.Dequeue ();  	//Has a Datatype  	next = context.Tokens.Dequeue ();  	if (next.TokenType == Token.DATATYPE) {  		try {  			if (next.Value.StartsWith ("<")) {  				dturi = next.Value.Substring (1' next.Value.Length - 2);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  			}  			else {  				dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  			}  		}  		catch (RdfException rdfEx) {  			throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next);  	}  }  else {  	//Just an untyped Literal  	return context.Handler.CreateLiteralNode (lit.Value);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.HATHAT) {  	//Discard the ^^  	next = context.Tokens.Dequeue ();  	//Has a Datatype  	next = context.Tokens.Dequeue ();  	if (next.TokenType == Token.DATATYPE) {  		try {  			if (next.Value.StartsWith ("<")) {  				dturi = next.Value.Substring (1' next.Value.Length - 2);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  			}  			else {  				dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  			}  		}  		catch (RdfException rdfEx) {  			throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next);  	}  }  else {  	//Just an untyped Literal  	return context.Handler.CreateLiteralNode (lit.Value);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.DATATYPE) {  	try {  		if (next.Value.StartsWith ("<")) {  			dturi = next.Value.Substring (1' next.Value.Length - 2);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  	}  }  else {  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Datatype Token after a ^^ datatype specifier"' next);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: try {  	if (next.Value.StartsWith ("<")) {  		dturi = next.Value.Substring (1' next.Value.Length - 2);  		return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  	}  	else {  		dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  		return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  	}  }  catch (RdfException rdfEx) {  	throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: if (next.Value.StartsWith ("<")) {  	dturi = next.Value.Substring (1' next.Value.Length - 2);  	return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  }  else {  	dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  	return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: dturi = next.Value.Substring (1' next.Value.Length - 2);  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: try {  	if (litdt.DataType.StartsWith ("<")) {  		dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  		return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  	}  	else {  		dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  		return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  	}  }  catch (RdfException rdfEx) {  	throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: if (litdt.DataType.StartsWith ("<")) {  	dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  	return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  }  else {  	dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  	return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  }  
Magic Number,VDS.RDF.Parsing,Notation3Parser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Notation3Parser.cs,TryParseLiteral,The following statement contains a magic number: dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  
Magic Number,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveCurie,The following statement contains a magic number: if (curie.StartsWith ("_:")) {  	//The CURIE is for a Blank Node  	if (curie.Equals ("_:")) {  		return context.Handler.CreateBlankNode ("_");  	}  	else {  		return context.Handler.CreateBlankNode (curie.Substring (2));  	}  }  else {  	//CURIE is for a URI  	if (context.Syntax == RdfASyntax.RDFa_1_0) {  		//RDFa 1.0  		if (curie.StartsWith (":")) {  			return context.Handler.CreateUriNode (UriFactory.Create (XHtmlVocabNamespace + curie.Substring (1)));  		}  		else if (curie.Contains (":")) {  			return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (curie' evalContext.NamespaceMap' evalContext.BaseUri)));  		}  		else {  			throw new RdfParseException ("The value '" + curie + "' is not valid as a CURIE as it does not have a prefix");  		}  	}  	else {  		//RDFa 1.1  		return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveQName (curie' evalContext.NamespaceMap' evalContext.BaseUri)));  	}  }  
Magic Number,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveCurie,The following statement contains a magic number: if (curie.Equals ("_:")) {  	return context.Handler.CreateBlankNode ("_");  }  else {  	return context.Handler.CreateBlankNode (curie.Substring (2));  }  
Magic Number,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveCurie,The following statement contains a magic number: return context.Handler.CreateBlankNode (curie.Substring (2));  
Magic Number,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveUriOrCurie,The following statement contains a magic number: try {  	if (uriref.StartsWith ("[")) {  		//CURIE  		String curie = uriref.Substring (1' uriref.Length - 2);  		return this.ResolveCurie (context' evalContext' curie);  	}  	else if (this.IsCurie (evalContext' uriref)) {  		//CURIE  		return this.ResolveCurie (context' evalContext' uriref);  	}  	else {  		//URI  		return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (uriref' evalContext.BaseUri.ToSafeString ())));  	}  }  catch (RdfException) {  	this.OnWarning ("Unable to resolve a URI or CURIE since the value '" + uriref + "' does not contain a valid URI/CURIE or it cannot be resolved to a URI given the in-scope namespace prefixes and Base URI");  	return null;  }  
Magic Number,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ResolveUriOrCurie,The following statement contains a magic number: if (uriref.StartsWith ("[")) {  	//CURIE  	String curie = uriref.Substring (1' uriref.Length - 2);  	return this.ResolveCurie (context' evalContext' curie);  }  else if (this.IsCurie (evalContext' uriref)) {  	//CURIE  	return this.ResolveCurie (context' evalContext' uriref);  }  else {  	//URI  	return context.Handler.CreateUriNode (UriFactory.Create (Tools.ResolveUri (uriref' evalContext.BaseUri.ToSafeString ())));  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,The following statement contains a magic number: try {  	context.Handler.StartRdf ();  	//Initialise Buffer and start parsing  	context.Tokens.InitialiseBuffer (10);  	IToken next = context.Tokens.Dequeue ();  	if (next.TokenType != Token.BOF) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a BOF Token"' next);  	}  	do {  		next = context.Tokens.Peek ();  		switch (next.TokenType) {  		case Token.AT:  			this.TryParseDirective (context);  			break;  		case Token.COMMENT:  			//Discard and ignore  			context.Tokens.Dequeue ();  			break;  		case Token.BLANKNODE:  		case Token.BLANKNODEWITHID:  		case Token.LEFTBRACKET:  		case Token.LEFTSQBRACKET:  		case Token.QNAME:  		case Token.URI:  			//Valid Subject of a Triple  			this.TryParseTriples (context);  			break;  		case Token.LITERAL:  		case Token.LITERALWITHDT:  		case Token.LITERALWITHLANG:  		case Token.LONGLITERAL:  			//Literals not valid as Subjects  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' Literals are not valid as Subjects in Turtle"' next);  		case Token.KEYWORDA:  			//'a' Keyword only valid as Predicate  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' the 'a' Keyword is only valid as a Predicate in Turtle"' next);  		case Token.EOF:  			//OK - the loop will now terminate since we've seen the End of File  			break;  		default:  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered"' next);  		}  	}  	while (next.TokenType != Token.EOF);  	context.Handler.EndRdf (true);  }  catch (RdfParsingTerminatedException) {  	context.Handler.EndRdf (true);  	//Discard this - it justs means the Handler told us to stop  }  catch {  	context.Handler.EndRdf (false);  	throw;  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,Parse,The following statement contains a magic number: context.Tokens.InitialiseBuffer (10);  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseTriples,The following statement contains a magic number: switch (subjToken.TokenType) {  case Token.BLANKNODE:  	subj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	subj = context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  	break;  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//An Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		subj = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  	}  	else {  		subj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' subj);  	}  	break;  case Token.LEFTSQBRACKET:  	//Start of a Blank Node collection?  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//An anoynmous Blank Node  		context.Tokens.Dequeue ();  		subj = context.Handler.CreateBlankNode ();  	}  	else {  		//Start of a Blank Node Collection  		subj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' subj' true);  	}  	break;  case Token.QNAME:  case Token.URI:  	subj = ParserHelper.TryResolveUri (context' subjToken);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + subjToken.GetType ().ToString () + "' encountered' this Token is not valid as the subject of a Triple"' subjToken);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseTriples,The following statement contains a magic number: subj = context.Handler.CreateBlankNode (subjToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The following statement contains a magic number: do {  	objToken = context.Tokens.Dequeue ();  	if (context.TraceParsing) {  		Console.WriteLine ("Attempting to parse an Object List from the Object Token '" + objToken.GetType ().ToString () + "'");  	}  	switch (objToken.TokenType) {  	case Token.BLANKNODE:  		obj = context.Handler.CreateBlankNode ();  		break;  	case Token.BLANKNODEWITHID:  		obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  		break;  	case Token.COMMA:  		//Discard and continue - set object to null so we know we're expected to complete a triple  		if (obj != null) {  			obj = null;  			continue;  		}  		else {  			throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.COMMENT:  		//Discard and ignore  		continue;  	case Token.DOT:  		if (obj != null) {  			//OK to return if we've seen a valid Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.LEFTBRACKET:  		//Start of a collection so create a new Blank Node to be it's first subject  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection => rdf:nil  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  		}  		else {  			obj = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' obj);  		}  		break;  	case Token.LEFTSQBRACKET:  		//Start of a Blank Node collection?  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTSQBRACKET) {  			//An anonymous Blank Node  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateBlankNode ();  		}  		else {  			//Start of a Blank Node Collection  			obj = context.Handler.CreateBlankNode ();  			this.TryParsePredicateObjectList (context' obj' true);  		}  		break;  	case Token.LITERAL:  	case Token.LITERALWITHDT:  	case Token.LITERALWITHLANG:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  		obj = this.TryParseLiteral (context' objToken);  		break;  	case Token.RIGHTSQBRACKET:  		if (bnodeList) {  			if (obj != null) {  				//Ok to return if we've seen a Triple  				return;  			}  			else {  				throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken);  			}  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken);  		}  	case Token.SEMICOLON:  		if (obj != null) {  			//Ok to return if we've seen a Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  		}  	case Token.QNAME:  	case Token.URI:  		obj = ParserHelper.TryResolveUri (context' objToken);  		break;  	case Token.EOF:  		throw ParserHelper.Error ("Unexpected end of file while trying to parse an Object list"' objToken);  	default:  		throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken);  	}  	//Assert the Triple  	if (!context.Handler.HandleTriple (new Triple (subj' pred' obj)))  		ParserHelper.Stop ();  	//Expect a comma/semicolon/dot terminator if we are to continue  	next = context.Tokens.Peek ();  	if (bnodeList) {  		//If in a Blank Node list a dot is not permitted but a ] is  		if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.RIGHTSQBRACKET) {  			throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Blank Node Object List' expected a comma' semicolon or ] to terminate the current Triple/list"' next);  		}  	}  	else if (next.TokenType != Token.COMMA && next.TokenType != Token.SEMICOLON && next.TokenType != Token.DOT) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse an Object list' expected a comma' semicolon or dot to terminate the current Triple"' next);  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The following statement contains a magic number: switch (objToken.TokenType) {  case Token.BLANKNODE:  	obj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  	break;  case Token.COMMA:  	//Discard and continue - set object to null so we know we're expected to complete a triple  	if (obj != null) {  		obj = null;  		continue;  	}  	else {  		throw ParserHelper.Error ("Unexpected Comma Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.COMMENT:  	//Discard and ignore  	continue;  case Token.DOT:  	if (obj != null) {  		//OK to return if we've seen a valid Triple  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Dot Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  	}  	else {  		obj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' obj);  	}  	break;  case Token.LEFTSQBRACKET:  	//Start of a Blank Node collection?  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTSQBRACKET) {  		//An anonymous Blank Node  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateBlankNode ();  	}  	else {  		//Start of a Blank Node Collection  		obj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' obj' true);  	}  	break;  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	obj = this.TryParseLiteral (context' objToken);  	break;  case Token.RIGHTSQBRACKET:  	if (bnodeList) {  		if (obj != null) {  			//Ok to return if we've seen a Triple  			return;  		}  		else {  			throw ParserHelper.Error ("Unexpected Right Square Bracket encountered' expecting a valid object for the current Blank Node Predicate Object list"' objToken);  		}  	}  	else {  		throw ParserHelper.Error ("Unexpected Right Square Bracket encountered but not expecting the end of a Blank Node Predicate Object list"' objToken);  	}  case Token.SEMICOLON:  	if (obj != null) {  		//Ok to return if we've seen a Triple  		return;  	}  	else {  		throw ParserHelper.Error ("Unexpected Semicolon Triple terminator encountered' expected a valid Object for the current Triple"' objToken);  	}  case Token.QNAME:  case Token.URI:  	obj = ParserHelper.TryResolveUri (context' objToken);  	break;  case Token.EOF:  	throw ParserHelper.Error ("Unexpected end of file while trying to parse an Object list"' objToken);  default:  	throw ParserHelper.Error ("Unexpected Token '" + objToken.GetType ().ToString () + "' encountered while trying to parse an Object list"' objToken);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseObjectList,The following statement contains a magic number: obj = context.Handler.CreateBlankNode (objToken.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseCollection,The following statement contains a magic number: do {  	next = context.Tokens.Dequeue ();  	if (context.TraceParsing) {  		Console.WriteLine ("Trying to parse a Collection item from Token '" + next.GetType ().ToString () + "'");  	}  	switch (next.TokenType) {  	case Token.BLANKNODE:  		obj = context.Handler.CreateBlankNode ();  		break;  	case Token.BLANKNODEWITHID:  		obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  		break;  	case Token.COMMENT:  		//Discard and continue  		continue;  	case Token.LEFTBRACKET:  		//Start of a collection so create a new Blank Node to be it's first subject  		next = context.Tokens.Peek ();  		if (next.TokenType == Token.RIGHTBRACKET) {  			//Empty Collection => rdf:nil  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  		}  		else {  			obj = context.Handler.CreateBlankNode ();  			this.TryParseCollection (context' obj);  		}  		break;  	case Token.LEFTSQBRACKET:  		//Allowed Blank Node Collections as part of a Collection  		IToken temp = context.Tokens.Peek ();  		if (temp.TokenType == Token.RIGHTSQBRACKET) {  			//Anonymous Blank Node  			context.Tokens.Dequeue ();  			obj = context.Handler.CreateBlankNode ();  		}  		else {  			//Blank Node Collection  			obj = context.Handler.CreateBlankNode ();  			this.TryParsePredicateObjectList (context' obj' true);  		}  		break;  	case Token.LITERAL:  	case Token.LITERALWITHDT:  	case Token.LITERALWITHLANG:  	case Token.LONGLITERAL:  	case Token.PLAINLITERAL:  		obj = this.TryParseLiteral (context' next);  		break;  	case Token.QNAME:  	case Token.URI:  		obj = ParserHelper.TryResolveUri (context' next);  		break;  	case Token.RIGHTBRACKET:  		//We might terminate here if someone put a comment before the end of the Collection  		if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj)))  			ParserHelper.Stop ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil)))  			ParserHelper.Stop ();  		return;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next);  	}  	//Assert the relevant Triples  	if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj)))  		ParserHelper.Stop ();  	if (context.Tokens.Peek ().TokenType == Token.RIGHTBRACKET) {  		//End of the Collection  		context.Tokens.Dequeue ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil)))  			ParserHelper.Stop ();  		return;  	}  	else {  		//More stuff in the collection  		nextSubj = context.Handler.CreateBlankNode ();  		if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' nextSubj)))  			ParserHelper.Stop ();  		subj = nextSubj;  	}  }  while (true);  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseCollection,The following statement contains a magic number: switch (next.TokenType) {  case Token.BLANKNODE:  	obj = context.Handler.CreateBlankNode ();  	break;  case Token.BLANKNODEWITHID:  	obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  	break;  case Token.COMMENT:  	//Discard and continue  	continue;  case Token.LEFTBRACKET:  	//Start of a collection so create a new Blank Node to be it's first subject  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.RIGHTBRACKET) {  		//Empty Collection => rdf:nil  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateUriNode (UriFactory.Create (RdfSpecsHelper.RdfListNil));  	}  	else {  		obj = context.Handler.CreateBlankNode ();  		this.TryParseCollection (context' obj);  	}  	break;  case Token.LEFTSQBRACKET:  	//Allowed Blank Node Collections as part of a Collection  	IToken temp = context.Tokens.Peek ();  	if (temp.TokenType == Token.RIGHTSQBRACKET) {  		//Anonymous Blank Node  		context.Tokens.Dequeue ();  		obj = context.Handler.CreateBlankNode ();  	}  	else {  		//Blank Node Collection  		obj = context.Handler.CreateBlankNode ();  		this.TryParsePredicateObjectList (context' obj' true);  	}  	break;  case Token.LITERAL:  case Token.LITERALWITHDT:  case Token.LITERALWITHLANG:  case Token.LONGLITERAL:  case Token.PLAINLITERAL:  	obj = this.TryParseLiteral (context' next);  	break;  case Token.QNAME:  case Token.URI:  	obj = ParserHelper.TryResolveUri (context' next);  	break;  case Token.RIGHTBRACKET:  	//We might terminate here if someone put a comment before the end of the Collection  	if (!context.Handler.HandleTriple (new Triple (subj' rdfFirst' obj)))  		ParserHelper.Stop ();  	if (!context.Handler.HandleTriple (new Triple (subj' rdfRest' rdfNil)))  		ParserHelper.Stop ();  	return;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered while trying to parse a Collection"' next);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseCollection,The following statement contains a magic number: obj = context.Handler.CreateBlankNode (next.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: switch (lit.TokenType) {  case Token.LITERAL:  case Token.LONGLITERAL:  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		//Has a Language Specifier  		next = context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (lit.Value' next.Value);  	}  	else if (next.TokenType == Token.DATATYPE) {  		//Has a Datatype  		next = context.Tokens.Dequeue ();  		try {  			if (next.Value.StartsWith ("<")) {  				dturi = next.Value.Substring (1' next.Value.Length - 2);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  			}  			else {  				dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  			}  		}  		catch (RdfException rdfEx) {  			throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  		}  	}  	else {  		//Just an untyped Literal  		return context.Handler.CreateLiteralNode (lit.Value);  	}  case Token.LITERALWITHDT:  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)lit;  	try {  		if (litdt.DataType.StartsWith ("<")) {  			dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  	}  case Token.LITERALWITHLANG:  	LiteralWithLanguageSpecifierToken langlit = (LiteralWithLanguageSpecifierToken)lit;  	return context.Handler.CreateLiteralNode (langlit.Value' langlit.Language);  case Token.PLAINLITERAL:  	//Attempt to infer Type  	if (TurtleSpecsHelper.IsValidPlainLiteral (lit.Value' this._syntax)) {  		if (TurtleSpecsHelper.IsValidDouble (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble));  		}  		else if (TurtleSpecsHelper.IsValidInteger (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger));  		}  		else if (TurtleSpecsHelper.IsValidDecimal (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal));  		}  		else {  			return context.Handler.CreateLiteralNode (lit.Value.ToLower ()' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean));  		}  	}  	else {  		throw ParserHelper.Error ("The value '" + lit.Value + "' is not valid as a Plain Literal in Turtle"' lit);  	}  default:  	throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: switch (lit.TokenType) {  case Token.LITERAL:  case Token.LONGLITERAL:  	next = context.Tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		//Has a Language Specifier  		next = context.Tokens.Dequeue ();  		return context.Handler.CreateLiteralNode (lit.Value' next.Value);  	}  	else if (next.TokenType == Token.DATATYPE) {  		//Has a Datatype  		next = context.Tokens.Dequeue ();  		try {  			if (next.Value.StartsWith ("<")) {  				dturi = next.Value.Substring (1' next.Value.Length - 2);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  			}  			else {  				dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  				return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  			}  		}  		catch (RdfException rdfEx) {  			throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  		}  	}  	else {  		//Just an untyped Literal  		return context.Handler.CreateLiteralNode (lit.Value);  	}  case Token.LITERALWITHDT:  	LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)lit;  	try {  		if (litdt.DataType.StartsWith ("<")) {  			dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  	}  case Token.LITERALWITHLANG:  	LiteralWithLanguageSpecifierToken langlit = (LiteralWithLanguageSpecifierToken)lit;  	return context.Handler.CreateLiteralNode (langlit.Value' langlit.Language);  case Token.PLAINLITERAL:  	//Attempt to infer Type  	if (TurtleSpecsHelper.IsValidPlainLiteral (lit.Value' this._syntax)) {  		if (TurtleSpecsHelper.IsValidDouble (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDouble));  		}  		else if (TurtleSpecsHelper.IsValidInteger (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeInteger));  		}  		else if (TurtleSpecsHelper.IsValidDecimal (lit.Value)) {  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDecimal));  		}  		else {  			return context.Handler.CreateLiteralNode (lit.Value.ToLower ()' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeBoolean));  		}  	}  	else {  		throw ParserHelper.Error ("The value '" + lit.Value + "' is not valid as a Plain Literal in Turtle"' lit);  	}  default:  	throw ParserHelper.Error ("Unexpected Token '" + lit.GetType ().ToString () + "' encountered' expected a valid Literal Token to convert to a Node"' lit);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.LANGSPEC) {  	//Has a Language Specifier  	next = context.Tokens.Dequeue ();  	return context.Handler.CreateLiteralNode (lit.Value' next.Value);  }  else if (next.TokenType == Token.DATATYPE) {  	//Has a Datatype  	next = context.Tokens.Dequeue ();  	try {  		if (next.Value.StartsWith ("<")) {  			dturi = next.Value.Substring (1' next.Value.Length - 2);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  	}  }  else {  	//Just an untyped Literal  	return context.Handler.CreateLiteralNode (lit.Value);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: if (next.TokenType == Token.DATATYPE) {  	//Has a Datatype  	next = context.Tokens.Dequeue ();  	try {  		if (next.Value.StartsWith ("<")) {  			dturi = next.Value.Substring (1' next.Value.Length - 2);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  		}  		else {  			dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  			return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  		}  	}  	catch (RdfException rdfEx) {  		throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  	}  }  else {  	//Just an untyped Literal  	return context.Handler.CreateLiteralNode (lit.Value);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: try {  	if (next.Value.StartsWith ("<")) {  		dturi = next.Value.Substring (1' next.Value.Length - 2);  		return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  	}  	else {  		dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  		return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  	}  }  catch (RdfException rdfEx) {  	throw new RdfParseException ("Unable to resolve the Datatype '" + next.Value + "' due to the following error:\n" + rdfEx.Message' next' rdfEx);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: if (next.Value.StartsWith ("<")) {  	dturi = next.Value.Substring (1' next.Value.Length - 2);  	return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  }  else {  	dturi = Tools.ResolveQName (next.Value' context.Namespaces' context.BaseUri);  	return context.Handler.CreateLiteralNode (lit.Value' UriFactory.Create (dturi));  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: dturi = next.Value.Substring (1' next.Value.Length - 2);  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: try {  	if (litdt.DataType.StartsWith ("<")) {  		dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  		return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  	}  	else {  		dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  		return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  	}  }  catch (RdfException rdfEx) {  	throw new RdfParseException ("Unable to resolve the Datatype '" + litdt.DataType + "' due to the following error:\n" + rdfEx.Message' litdt' rdfEx);  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: if (litdt.DataType.StartsWith ("<")) {  	dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  	return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (Tools.ResolveUri (dturi' context.BaseUri.ToSafeString ())));  }  else {  	dturi = Tools.ResolveQName (litdt.DataType' context.Namespaces' context.BaseUri);  	return context.Handler.CreateLiteralNode (litdt.Value' UriFactory.Create (dturi));  }  
Magic Number,VDS.RDF.Parsing,TurtleParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TurtleParser.cs,TryParseLiteral,The following statement contains a magic number: dturi = litdt.DataType.Substring (1' litdt.DataType.Length - 2);  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: if (next.TokenType == Token.DOT) {  	return null;  }  else {  	INode context;  	switch (next.TokenType) {  	case Token.BLANKNODEWITHID:  		context = new BlankNode (null' next.Value.Substring (2));  		break;  	case Token.URI:  		context = new UriNode (null' UriFactory.Create (next.Value));  		break;  	case Token.LITERAL:  		//Check for Datatype/Language  		IToken temp = tokens.Peek ();  		if (temp.TokenType == Token.LANGSPEC) {  			tokens.Dequeue ();  			context = new LiteralNode (null' next.Value' temp.Value);  		}  		else if (temp.TokenType == Token.DATATYPE) {  			tokens.Dequeue ();  			context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  		}  		else {  			context = new LiteralNode (null' next.Value);  		}  		break;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Context of the Triple"' next);  	}  	//Ensure we then see a . to terminate the Quad  	next = tokens.Dequeue ();  	if (next.TokenType != Token.DOT) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Dot Token (Line Terminator) to terminate a Triple"' next);  	}  	//Finally return the Context URI  	if (context.NodeType == NodeType.Uri) {  		return ((IUriNode)context).Uri;  	}  	else if (context.NodeType == NodeType.Blank) {  		return UriFactory.Create ("nquads:bnode:" + context.GetHashCode ());  	}  	else if (context.NodeType == NodeType.Literal) {  		return UriFactory.Create ("nquads:literal:" + context.GetHashCode ());  	}  	else {  		throw ParserHelper.Error ("Cannot turn a Node of type '" + context.GetType ().ToString () + "' into a Context URI for a Triple"' next);  	}  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: if (next.TokenType == Token.DOT) {  	return null;  }  else {  	INode context;  	switch (next.TokenType) {  	case Token.BLANKNODEWITHID:  		context = new BlankNode (null' next.Value.Substring (2));  		break;  	case Token.URI:  		context = new UriNode (null' UriFactory.Create (next.Value));  		break;  	case Token.LITERAL:  		//Check for Datatype/Language  		IToken temp = tokens.Peek ();  		if (temp.TokenType == Token.LANGSPEC) {  			tokens.Dequeue ();  			context = new LiteralNode (null' next.Value' temp.Value);  		}  		else if (temp.TokenType == Token.DATATYPE) {  			tokens.Dequeue ();  			context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  		}  		else {  			context = new LiteralNode (null' next.Value);  		}  		break;  	default:  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Context of the Triple"' next);  	}  	//Ensure we then see a . to terminate the Quad  	next = tokens.Dequeue ();  	if (next.TokenType != Token.DOT) {  		throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Dot Token (Line Terminator) to terminate a Triple"' next);  	}  	//Finally return the Context URI  	if (context.NodeType == NodeType.Uri) {  		return ((IUriNode)context).Uri;  	}  	else if (context.NodeType == NodeType.Blank) {  		return UriFactory.Create ("nquads:bnode:" + context.GetHashCode ());  	}  	else if (context.NodeType == NodeType.Literal) {  		return UriFactory.Create ("nquads:literal:" + context.GetHashCode ());  	}  	else {  		throw ParserHelper.Error ("Cannot turn a Node of type '" + context.GetType ().ToString () + "' into a Context URI for a Triple"' next);  	}  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: switch (next.TokenType) {  case Token.BLANKNODEWITHID:  	context = new BlankNode (null' next.Value.Substring (2));  	break;  case Token.URI:  	context = new UriNode (null' UriFactory.Create (next.Value));  	break;  case Token.LITERAL:  	//Check for Datatype/Language  	IToken temp = tokens.Peek ();  	if (temp.TokenType == Token.LANGSPEC) {  		tokens.Dequeue ();  		context = new LiteralNode (null' next.Value' temp.Value);  	}  	else if (temp.TokenType == Token.DATATYPE) {  		tokens.Dequeue ();  		context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  	}  	else {  		context = new LiteralNode (null' next.Value);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Context of the Triple"' next);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: switch (next.TokenType) {  case Token.BLANKNODEWITHID:  	context = new BlankNode (null' next.Value.Substring (2));  	break;  case Token.URI:  	context = new UriNode (null' UriFactory.Create (next.Value));  	break;  case Token.LITERAL:  	//Check for Datatype/Language  	IToken temp = tokens.Peek ();  	if (temp.TokenType == Token.LANGSPEC) {  		tokens.Dequeue ();  		context = new LiteralNode (null' next.Value' temp.Value);  	}  	else if (temp.TokenType == Token.DATATYPE) {  		tokens.Dequeue ();  		context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  	}  	else {  		context = new LiteralNode (null' next.Value);  	}  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + next.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Context of the Triple"' next);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: context = new BlankNode (null' next.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: if (temp.TokenType == Token.LANGSPEC) {  	tokens.Dequeue ();  	context = new LiteralNode (null' next.Value' temp.Value);  }  else if (temp.TokenType == Token.DATATYPE) {  	tokens.Dequeue ();  	context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  }  else {  	context = new LiteralNode (null' next.Value);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: if (temp.TokenType == Token.DATATYPE) {  	tokens.Dequeue ();  	context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  }  else {  	context = new LiteralNode (null' next.Value);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseContext,The following statement contains a magic number: context = new LiteralNode (null' next.Value' UriFactory.Create (temp.Value.Substring (1' temp.Value.Length - 2)));  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: switch (s.TokenType) {  case Token.BLANKNODEWITHID:  	subj = handler.CreateBlankNode (s.Value.Substring (2));  	break;  case Token.URI:  	subj = ParserHelper.TryResolveUri (handler' s);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + s.GetType ().ToString () + "' encountered' expected a Blank Node/URI as the Subject of a Triple"' s);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: subj = handler.CreateBlankNode (s.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: switch (o.TokenType) {  case Token.BLANKNODEWITHID:  	obj = handler.CreateBlankNode (o.Value.Substring (2));  	break;  case Token.LITERAL:  	obj = handler.CreateLiteralNode (o.Value);  	break;  case Token.LITERALWITHDT:  	String dtUri = ((LiteralWithDataTypeToken)o).DataType;  	obj = handler.CreateLiteralNode (o.Value' UriFactory.Create (dtUri.Substring (1' dtUri.Length - 2)));  	break;  case Token.LITERALWITHLANG:  	obj = handler.CreateLiteralNode (o.Value' ((LiteralWithLanguageSpecifierToken)o).Language);  	break;  case Token.URI:  	obj = ParserHelper.TryResolveUri (handler' o);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + o.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Object of a Triple"' o);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: switch (o.TokenType) {  case Token.BLANKNODEWITHID:  	obj = handler.CreateBlankNode (o.Value.Substring (2));  	break;  case Token.LITERAL:  	obj = handler.CreateLiteralNode (o.Value);  	break;  case Token.LITERALWITHDT:  	String dtUri = ((LiteralWithDataTypeToken)o).DataType;  	obj = handler.CreateLiteralNode (o.Value' UriFactory.Create (dtUri.Substring (1' dtUri.Length - 2)));  	break;  case Token.LITERALWITHLANG:  	obj = handler.CreateLiteralNode (o.Value' ((LiteralWithLanguageSpecifierToken)o).Language);  	break;  case Token.URI:  	obj = ParserHelper.TryResolveUri (handler' o);  	break;  default:  	throw ParserHelper.Error ("Unexpected Token '" + o.GetType ().ToString () + "' encountered' expected a Blank Node/Literal/URI as the Object of a Triple"' o);  }  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: obj = handler.CreateBlankNode (o.Value.Substring (2));  
Magic Number,VDS.RDF.Parsing,NQuadsParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\NQuadsParser.cs,TryParseTriple,The following statement contains a magic number: obj = handler.CreateLiteralNode (o.Value' UriFactory.Create (dtUri.Substring (1' dtUri.Length - 2)));  
Magic Number,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The following statement contains a magic number: if (tripleEl.ChildNodes.Count < 3)  	throw new RdfParseException ("<triple> element has too few child nodes (" + tripleEl.ChildNodes.Count + ") - 3 child nodes are expected");  
Magic Number,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The following statement contains a magic number: if (tripleEl.ChildNodes.Count > 3)  	throw new RdfParseException ("<triple> element has too many child nodes (" + tripleEl.ChildNodes.Count + ") - 3 child nodes are expected");  
Magic Number,VDS.RDF.Parsing,TriXParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\TriXParser.cs,TryParseTriple,The following statement contains a magic number: objEl = tripleEl.ChildNodes [2];  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,The following statement contains a magic number: if (tokens.Count > 0) {  	IToken next = tokens.Peek ();  	if (next.TokenType == Token.LANGSPEC) {  		tokens.Dequeue ();  		return new ConstantTerm (new LiteralNode (null' str.Value' next.Value));  	}  	else if (next.TokenType == Token.HATHAT) {  		tokens.Dequeue ();  		//Should be a DataTypeToken afterwards  		next = tokens.Dequeue ();  		LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken (str' (DataTypeToken)next);  		;  		Uri u;  		if (next.Value.StartsWith ("<")) {  			u = UriFactory.Create (next.Value.Substring (1' next.Value.Length - 2));  		}  		else {  			//Resolve the QName  			u = UriFactory.Create (Tools.ResolveQName (next.Value' this._nsmapper' this._baseUri));  		}  		if (SparqlSpecsHelper.GetNumericTypeFromDataTypeUri (u) != SparqlNumericType.NaN) {  			//Should be a Number  			return this.TryParseNumericLiteral (dtlit' tokens);  		}  		else if (XmlSpecsHelper.XmlSchemaDataTypeBoolean.Equals (u.ToString ())) {  			//Appears to be a Boolean  			bool b;  			if (Boolean.TryParse (dtlit.Value' out b)) {  				return new ConstantTerm (new BooleanNode (null' b));  			}  			else {  				return new ConstantTerm (new StringNode (null' dtlit.Value' dtlit.DataType));  			}  		}  		else {  			//Just a datatyped Literal Node  			return new ConstantTerm (new LiteralNode (null' str.Value' u));  		}  	}  	else {  		return new ConstantTerm (new LiteralNode (null' str.Value));  	}  }  else {  	return new ConstantTerm (new LiteralNode (null' str.Value));  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,The following statement contains a magic number: if (next.TokenType == Token.LANGSPEC) {  	tokens.Dequeue ();  	return new ConstantTerm (new LiteralNode (null' str.Value' next.Value));  }  else if (next.TokenType == Token.HATHAT) {  	tokens.Dequeue ();  	//Should be a DataTypeToken afterwards  	next = tokens.Dequeue ();  	LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken (str' (DataTypeToken)next);  	;  	Uri u;  	if (next.Value.StartsWith ("<")) {  		u = UriFactory.Create (next.Value.Substring (1' next.Value.Length - 2));  	}  	else {  		//Resolve the QName  		u = UriFactory.Create (Tools.ResolveQName (next.Value' this._nsmapper' this._baseUri));  	}  	if (SparqlSpecsHelper.GetNumericTypeFromDataTypeUri (u) != SparqlNumericType.NaN) {  		//Should be a Number  		return this.TryParseNumericLiteral (dtlit' tokens);  	}  	else if (XmlSpecsHelper.XmlSchemaDataTypeBoolean.Equals (u.ToString ())) {  		//Appears to be a Boolean  		bool b;  		if (Boolean.TryParse (dtlit.Value' out b)) {  			return new ConstantTerm (new BooleanNode (null' b));  		}  		else {  			return new ConstantTerm (new StringNode (null' dtlit.Value' dtlit.DataType));  		}  	}  	else {  		//Just a datatyped Literal Node  		return new ConstantTerm (new LiteralNode (null' str.Value' u));  	}  }  else {  	return new ConstantTerm (new LiteralNode (null' str.Value));  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,The following statement contains a magic number: if (next.TokenType == Token.HATHAT) {  	tokens.Dequeue ();  	//Should be a DataTypeToken afterwards  	next = tokens.Dequeue ();  	LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken (str' (DataTypeToken)next);  	;  	Uri u;  	if (next.Value.StartsWith ("<")) {  		u = UriFactory.Create (next.Value.Substring (1' next.Value.Length - 2));  	}  	else {  		//Resolve the QName  		u = UriFactory.Create (Tools.ResolveQName (next.Value' this._nsmapper' this._baseUri));  	}  	if (SparqlSpecsHelper.GetNumericTypeFromDataTypeUri (u) != SparqlNumericType.NaN) {  		//Should be a Number  		return this.TryParseNumericLiteral (dtlit' tokens);  	}  	else if (XmlSpecsHelper.XmlSchemaDataTypeBoolean.Equals (u.ToString ())) {  		//Appears to be a Boolean  		bool b;  		if (Boolean.TryParse (dtlit.Value' out b)) {  			return new ConstantTerm (new BooleanNode (null' b));  		}  		else {  			return new ConstantTerm (new StringNode (null' dtlit.Value' dtlit.DataType));  		}  	}  	else {  		//Just a datatyped Literal Node  		return new ConstantTerm (new LiteralNode (null' str.Value' u));  	}  }  else {  	return new ConstantTerm (new LiteralNode (null' str.Value));  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,The following statement contains a magic number: if (next.Value.StartsWith ("<")) {  	u = UriFactory.Create (next.Value.Substring (1' next.Value.Length - 2));  }  else {  	//Resolve the QName  	u = UriFactory.Create (Tools.ResolveQName (next.Value' this._nsmapper' this._baseUri));  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseRdfLiteral,The following statement contains a magic number: u = UriFactory.Create (next.Value.Substring (1' next.Value.Length - 2));  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,The following statement contains a magic number: switch (literal.TokenType) {  case Token.PLAINLITERAL:  	//Use Regular Expressions to see what type it is  	if (SparqlSpecsHelper.IsInteger (literal.Value)) {  		return new ConstantTerm (new LongNode (null' Int64.Parse (literal.Value)));  	}  	else if (SparqlSpecsHelper.IsDecimal (literal.Value)) {  		return new ConstantTerm (new DecimalNode (null' Decimal.Parse (literal.Value)));  	}  	else if (SparqlSpecsHelper.IsDouble (literal.Value)) {  		return new ConstantTerm (new DoubleNode (null' Double.Parse (literal.Value)));  	}  	else {  		throw Error ("The Plain Literal '" + literal.Value + "' is not a valid Integer' Decimal or Double"' literal);  	}  case Token.LITERALWITHDT:  	//Get the Data Type Uri  	String dt = ((LiteralWithDataTypeToken)literal).DataType;  	String dtUri;  	if (dt.StartsWith ("<")) {  		String baseUri = (this._baseUri == null) ? String.Empty : this._baseUri.ToString ();  		dtUri = Tools.ResolveUri (dt.Substring (1' dt.Length - 2)' baseUri);  	}  	else {  		dtUri = Tools.ResolveQName (dt' this._nsmapper' this._baseUri);  	}  	//Return a Numeric Expression Term if it's an Integer/Decimal/Double  	if (XmlSpecsHelper.XmlSchemaDataTypeInteger.Equals (dtUri) && SparqlSpecsHelper.IsInteger (literal.Value)) {  		return new ConstantTerm (new LongNode (null' Int64.Parse (literal.Value)));  	}  	else if (XmlSpecsHelper.XmlSchemaDataTypeDecimal.Equals (dtUri) && SparqlSpecsHelper.IsDecimal (literal.Value)) {  		return new ConstantTerm (new DecimalNode (null' Decimal.Parse (literal.Value)));  	}  	else if (XmlSpecsHelper.XmlSchemaDataTypeFloat.Equals (dtUri) && SparqlSpecsHelper.IsFloat (literal.Value)) {  		return new ConstantTerm (new FloatNode (null' Single.Parse (literal.Value)));  	}  	else if (XmlSpecsHelper.XmlSchemaDataTypeDouble.Equals (dtUri) && SparqlSpecsHelper.IsDouble (literal.Value)) {  		return new ConstantTerm (new DoubleNode (null' Double.Parse (literal.Value)));  	}  	else {  		throw Error ("The Literal '" + literal.Value + "' with Datatype URI '" + dtUri + "' is not a valid Integer' Decimal or Double"' literal);  	}  case Token.LITERAL:  	//Check if there's a Datatype following the Literal  	if (tokens.Count > 0) {  		IToken next = tokens.Peek ();  		if (next.TokenType == Token.HATHAT) {  			tokens.Dequeue ();  			//Should now see a DataTypeToken  			DataTypeToken datatype = (DataTypeToken)tokens.Dequeue ();  			LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken (literal' datatype);  			//Self-recurse to save replicating code  			return this.TryParseNumericLiteral (dtlit' tokens);  		}  	}  	//Use Regex to see if it's a Integer/Decimal/Double  	if (SparqlSpecsHelper.IsInteger (literal.Value)) {  		return new ConstantTerm (new LongNode (null' Int64.Parse (literal.Value)));  	}  	else if (SparqlSpecsHelper.IsDecimal (literal.Value)) {  		return new ConstantTerm (new DecimalNode (null' Decimal.Parse (literal.Value)));  	}  	else if (SparqlSpecsHelper.IsDouble (literal.Value)) {  		return new ConstantTerm (new DoubleNode (null' Double.Parse (literal.Value)));  	}  	else {  		//Otherwise treat as a Node Expression  		throw Error ("The Literal '" + literal.Value + "' is not a valid Integer' Decimal or Double"' literal);  	}  default:  	throw Error ("Unexpected Token '" + literal.GetType ().ToString () + "' encountered while trying to parse a Numeric Literal"' literal);  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,The following statement contains a magic number: if (dt.StartsWith ("<")) {  	String baseUri = (this._baseUri == null) ? String.Empty : this._baseUri.ToString ();  	dtUri = Tools.ResolveUri (dt.Substring (1' dt.Length - 2)' baseUri);  }  else {  	dtUri = Tools.ResolveQName (dt' this._nsmapper' this._baseUri);  }  
Magic Number,VDS.RDF.Query,SparqlExpressionParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlExpressionParser.cs,TryParseNumericLiteral,The following statement contains a magic number: dtUri = Tools.ResolveUri (dt.Substring (1' dt.Length - 2)' baseUri);  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: if (outString.Length > 3) {  	return outString.Substring (0' outString.Length - 3);  }  else {  	return String.Empty;  }  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: if (outString.Length > 3) {  	return outString.Substring (0' outString.Length - 3);  }  else {  	return String.Empty;  }  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: return outString.Substring (0' outString.Length - 3);  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: if (outString.Length > 3) {  	return outString.Substring (0' outString.Length - 3);  }  else {  	return String.Empty;  }  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: if (outString.Length > 3) {  	return outString.Substring (0' outString.Length - 3);  }  else {  	return String.Empty;  }  
Magic Number,VDS.RDF.Query,SparqlResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlResult.cs,ToString,The following statement contains a magic number: return outString.Substring (0' outString.Length - 3);  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._rootGraphPattern != null) {  	if (this._rootGraphPattern.IsEmpty && (int)this._type >= (int)SparqlQueryType.Select) {  		output.Remove (output.Length - 2' 2);  		output.Append (" ");  		output.Append (this._rootGraphPattern.ToString ());  	}  	else {  		output.AppendLine (this._rootGraphPattern.ToString ());  	}  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._rootGraphPattern != null) {  	if (this._rootGraphPattern.IsEmpty && (int)this._type >= (int)SparqlQueryType.Select) {  		output.Remove (output.Length - 2' 2);  		output.Append (" ");  		output.Append (this._rootGraphPattern.ToString ());  	}  	else {  		output.AppendLine (this._rootGraphPattern.ToString ());  	}  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._rootGraphPattern.IsEmpty && (int)this._type >= (int)SparqlQueryType.Select) {  	output.Remove (output.Length - 2' 2);  	output.Append (" ");  	output.Append (this._rootGraphPattern.ToString ());  }  else {  	output.AppendLine (this._rootGraphPattern.ToString ());  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._rootGraphPattern.IsEmpty && (int)this._type >= (int)SparqlQueryType.Select) {  	output.Remove (output.Length - 2' 2);  	output.Append (" ");  	output.Append (this._rootGraphPattern.ToString ());  }  else {  	output.AppendLine (this._rootGraphPattern.ToString ());  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: output.Remove (output.Length - 2' 2);  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: output.Remove (output.Length - 2' 2);  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._having != null) {  	output.Append ("HAVING ");  	String having = this._having.ToString ();  	output.Append (having.Substring (7' having.Length - 8));  	output.Append (' ');  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: if (this._having != null) {  	output.Append ("HAVING ");  	String having = this._having.ToString ();  	output.Append (having.Substring (7' having.Length - 8));  	output.Append (' ');  }  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: output.Append (having.Substring (7' having.Length - 8));  
Magic Number,VDS.RDF.Query,SparqlQuery,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlQuery.cs,ToString,The following statement contains a magic number: output.Append (having.Substring (7' having.Length - 8));  
Magic Number,VDS.RDF.Query,SparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlRemoteEndpoint.cs,QueryInternal,The following statement contains a magic number: if (longQuery || queryUri.Length > 2048 || this.HttpMode == "POST") {  	//Long Uri/HTTP POST Mode so use POST  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (HttpUtility.UrlEncode (sparqlQuery));  	//Add the Default Graph URI(s)  	foreach (String defaultGraph in this._defaultGraphUris) {  		if (!defaultGraph.Equals (String.Empty)) {  			queryUri.Append ("&default-graph-uri=");  			queryUri.Append (Uri.EscapeDataString (defaultGraph));  		}  	}  	//Add the Named Graph URI(s)  	foreach (String namedGraph in this._namedGraphUris) {  		if (!namedGraph.Equals (String.Empty)) {  			queryUri.Append ("&named-graph-uri=");  			queryUri.Append (Uri.EscapeDataString (namedGraph));  		}  	}  	httpResponse = this.ExecuteQuery (this.Uri' postData.ToString ()' acceptHeader);  }  else {  	//Make the query normally via GET  	httpResponse = this.ExecuteQuery (UriFactory.Create (queryUri.ToString ())' String.Empty' acceptHeader);  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (cs [startIndex] == '%') {  	if (startIndex > cs.Length - 2) {  		//If we saw a base % but there are not two subsequent characters not a valid PLX escape  		return false;  	}  	else {  		char a = cs [startIndex + 1];  		char b = cs [startIndex + 2];  		if (IsHex (a) && IsHex (b)) {  			//Valid % encoding  			endIndex = startIndex + 2;  			return true;  		}  		else {  			return false;  		}  	}  }  else if (cs [startIndex] == '\\') {  	if (startIndex >= cs.Length - 1) {  		//If we saw a backslash but no subsequent character not a valid PLX escape  		return false;  	}  	else {  		char c = cs [startIndex + 1];  		switch (c) {  		case '_':  		case '-':  		case '.':  		case '|':  		case '$':  		case '&':  		case '\'':  		case '(':  		case ')':  		case '*':  		case '+':  		case ''':  		case ';':  		case '=':  		case ':':  		case '/':  		case '?':  		case '#':  		case '@':  		case '%':  			//Valid Escape  			endIndex = startIndex + 1;  			return true;  		default:  			return false;  		}  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (cs [startIndex] == '%') {  	if (startIndex > cs.Length - 2) {  		//If we saw a base % but there are not two subsequent characters not a valid PLX escape  		return false;  	}  	else {  		char a = cs [startIndex + 1];  		char b = cs [startIndex + 2];  		if (IsHex (a) && IsHex (b)) {  			//Valid % encoding  			endIndex = startIndex + 2;  			return true;  		}  		else {  			return false;  		}  	}  }  else if (cs [startIndex] == '\\') {  	if (startIndex >= cs.Length - 1) {  		//If we saw a backslash but no subsequent character not a valid PLX escape  		return false;  	}  	else {  		char c = cs [startIndex + 1];  		switch (c) {  		case '_':  		case '-':  		case '.':  		case '|':  		case '$':  		case '&':  		case '\'':  		case '(':  		case ')':  		case '*':  		case '+':  		case ''':  		case ';':  		case '=':  		case ':':  		case '/':  		case '?':  		case '#':  		case '@':  		case '%':  			//Valid Escape  			endIndex = startIndex + 1;  			return true;  		default:  			return false;  		}  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (cs [startIndex] == '%') {  	if (startIndex > cs.Length - 2) {  		//If we saw a base % but there are not two subsequent characters not a valid PLX escape  		return false;  	}  	else {  		char a = cs [startIndex + 1];  		char b = cs [startIndex + 2];  		if (IsHex (a) && IsHex (b)) {  			//Valid % encoding  			endIndex = startIndex + 2;  			return true;  		}  		else {  			return false;  		}  	}  }  else if (cs [startIndex] == '\\') {  	if (startIndex >= cs.Length - 1) {  		//If we saw a backslash but no subsequent character not a valid PLX escape  		return false;  	}  	else {  		char c = cs [startIndex + 1];  		switch (c) {  		case '_':  		case '-':  		case '.':  		case '|':  		case '$':  		case '&':  		case '\'':  		case '(':  		case ')':  		case '*':  		case '+':  		case ''':  		case ';':  		case '=':  		case ':':  		case '/':  		case '?':  		case '#':  		case '@':  		case '%':  			//Valid Escape  			endIndex = startIndex + 1;  			return true;  		default:  			return false;  		}  	}  }  else {  	return false;  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (startIndex > cs.Length - 2) {  	//If we saw a base % but there are not two subsequent characters not a valid PLX escape  	return false;  }  else {  	char a = cs [startIndex + 1];  	char b = cs [startIndex + 2];  	if (IsHex (a) && IsHex (b)) {  		//Valid % encoding  		endIndex = startIndex + 2;  		return true;  	}  	else {  		return false;  	}  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (startIndex > cs.Length - 2) {  	//If we saw a base % but there are not two subsequent characters not a valid PLX escape  	return false;  }  else {  	char a = cs [startIndex + 1];  	char b = cs [startIndex + 2];  	if (IsHex (a) && IsHex (b)) {  		//Valid % encoding  		endIndex = startIndex + 2;  		return true;  	}  	else {  		return false;  	}  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (startIndex > cs.Length - 2) {  	//If we saw a base % but there are not two subsequent characters not a valid PLX escape  	return false;  }  else {  	char a = cs [startIndex + 1];  	char b = cs [startIndex + 2];  	if (IsHex (a) && IsHex (b)) {  		//Valid % encoding  		endIndex = startIndex + 2;  		return true;  	}  	else {  		return false;  	}  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: if (IsHex (a) && IsHex (b)) {  	//Valid % encoding  	endIndex = startIndex + 2;  	return true;  }  else {  	return false;  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,IsPLX,The following statement contains a magic number: endIndex = startIndex + 2;  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The following statement contains a magic number: if (value.Contains ('\\') || value.Contains ('%')) {  	StringBuilder output = new StringBuilder ();  	output.Append (value.Substring (0' value.IndexOf (':')));  	char[] cs = value.ToCharArray ();  	for (int i = output.Length; i < cs.Length; i++) {  		if (cs [i] == '\\') {  			if (i == cs.Length - 1)  				throw new RdfParseException ("Invalid backslash to start an escape at the end of the Local Name' expecting a single character after the backslash");  			char esc = cs [i + 1];  			switch (esc) {  			case '_':  			case '-':  			case '.':  			case '|':  			case '$':  			case '&':  			case '\'':  			case '(':  			case ')':  			case '*':  			case '+':  			case ''':  			case ';':  			case '=':  			case ':':  			case '/':  			case '?':  			case '#':  			case '@':  			case '%':  				output.Append (esc);  				i++;  				break;  			default:  				throw new RdfParseException ("Invalid character after a backslash' a backslash can only be used to escape a limited set (_-.|$&\\()*+';=:/?#@%) of characters in a Local Name");  			}  		}  		else if (cs [i] == '%') {  			if (i > cs.Length - 2) {  				throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly");  			}  			else {  				#if !SILVERLIGHT  				output.Append (Uri.HexUnescape (value' ref i));  				#else  				                            output.Append(SilverlightExtensions.HexUnescape(value' ref i)); #endif  				i--;  			}  		}  		else {  			output.Append (cs [i]);  		}  	}  	return output.ToString ();  }  else {  	return value;  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The following statement contains a magic number: for (int i = output.Length; i < cs.Length; i++) {  	if (cs [i] == '\\') {  		if (i == cs.Length - 1)  			throw new RdfParseException ("Invalid backslash to start an escape at the end of the Local Name' expecting a single character after the backslash");  		char esc = cs [i + 1];  		switch (esc) {  		case '_':  		case '-':  		case '.':  		case '|':  		case '$':  		case '&':  		case '\'':  		case '(':  		case ')':  		case '*':  		case '+':  		case ''':  		case ';':  		case '=':  		case ':':  		case '/':  		case '?':  		case '#':  		case '@':  		case '%':  			output.Append (esc);  			i++;  			break;  		default:  			throw new RdfParseException ("Invalid character after a backslash' a backslash can only be used to escape a limited set (_-.|$&\\()*+';=:/?#@%) of characters in a Local Name");  		}  	}  	else if (cs [i] == '%') {  		if (i > cs.Length - 2) {  			throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly");  		}  		else {  			#if !SILVERLIGHT  			output.Append (Uri.HexUnescape (value' ref i));  			#else  			                            output.Append(SilverlightExtensions.HexUnescape(value' ref i)); #endif  			i--;  		}  	}  	else {  		output.Append (cs [i]);  	}  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The following statement contains a magic number: if (cs [i] == '\\') {  	if (i == cs.Length - 1)  		throw new RdfParseException ("Invalid backslash to start an escape at the end of the Local Name' expecting a single character after the backslash");  	char esc = cs [i + 1];  	switch (esc) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		output.Append (esc);  		i++;  		break;  	default:  		throw new RdfParseException ("Invalid character after a backslash' a backslash can only be used to escape a limited set (_-.|$&\\()*+';=:/?#@%) of characters in a Local Name");  	}  }  else if (cs [i] == '%') {  	if (i > cs.Length - 2) {  		throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly");  	}  	else {  		#if !SILVERLIGHT  		output.Append (Uri.HexUnescape (value' ref i));  		#else  		                            output.Append(SilverlightExtensions.HexUnescape(value' ref i)); #endif  		i--;  	}  }  else {  	output.Append (cs [i]);  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The following statement contains a magic number: if (cs [i] == '%') {  	if (i > cs.Length - 2) {  		throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly");  	}  	else {  		#if !SILVERLIGHT  		output.Append (Uri.HexUnescape (value' ref i));  		#else  		                            output.Append(SilverlightExtensions.HexUnescape(value' ref i)); #endif  		i--;  	}  }  else {  	output.Append (cs [i]);  }  
Magic Number,VDS.RDF.Query,SparqlSpecsHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlSpecsHelper.cs,UnescapeQName,The following statement contains a magic number: if (i > cs.Length - 2) {  	throw new RdfParseException ("Invalid % to start a percent encoded character in a Local Name' two hex digits are required after a %' use \\% to denote a percent character directly");  }  else {  	#if !SILVERLIGHT  	output.Append (Uri.HexUnescape (value' ref i));  	#else  	                            output.Append(SilverlightExtensions.HexUnescape(value' ref i)); #endif  	i--;  }  
Magic Number,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The following statement contains a magic number: if (!this._ignoreFailedRequests && !asyncResults.All (r => r.IsCompleted)) {  	for (int i = 0; i < asyncCalls.Count; i++) {  		try {  			asyncCalls [i].EndInvoke (asyncResults [i]);  		}  		catch {  			//Exceptions don't matter as we're just ensuring all the EndInvoke() calls are made  		}  	}  	throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds");  }  
Magic Number,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultGraph,The following statement contains a magic number: throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds");  
Magic Number,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The following statement contains a magic number: if (!this._ignoreFailedRequests && !asyncResults.All (r => r.IsCompleted)) {  	for (int i = 0; i < asyncCalls.Count; i++) {  		try {  			asyncCalls [i].EndInvoke (asyncResults [i]);  		}  		catch {  			//Exceptions don't matter as we're just ensuring all the EndInvoke() calls are made  		}  	}  	throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds");  }  
Magic Number,VDS.RDF.Query,FederatedSparqlRemoteEndpoint,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\FederatedSparqlRemoteEndpoint.cs,QueryWithResultSet,The following statement contains a magic number: throw new RdfQueryTimeoutException ("Federated Querying failed due to one/more endpoints failing to return results within the Timeout specified which is currently " + (base.Timeout / 1000) + " seconds");  
Magic Number,VDS.RDF.Query,BaseSparqlView,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlView.cs,UpdateView,The following statement contains a magic number: if (this._asyncResult != null) {  	this._asyncResult.AsyncWaitHandle.WaitOne (new TimeSpan (1000));  }  else {  	this.UpdateViewInternal ();  }  
Magic Number,VDS.RDF.Query,BaseSparqlView,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlView.cs,UpdateView,The following statement contains a magic number: this._asyncResult.AsyncWaitHandle.WaitOne (new TimeSpan (1000));  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: try {  	//Generate the ChangeSet Batch  	IGraph g = this.GenerateChangeSet (additions' removals);  	if (g == null)  		return TalisUpdateResult.NotRequired;  	//Null so no changes need persisting  	if (g.IsEmpty)  		return TalisUpdateResult.NotRequired;  	//Empty so no changes need persisting  	//Create the Request  	request = this.CreateRequest (servicePath' new Dictionary<string' string> ());  	request.Method = "POST";  	request.ContentType = TalisChangeSetMIMEType;  	//Write the RDF/XML to the Request Stream  	RdfXmlWriter writer = new RdfXmlWriter ();  	writer.Save (g' new StreamWriter (request.GetRequestStream ()));  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Make the Request  	using (response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		//What sort of Update Result did we get?  		int code = (int)response.StatusCode;  		response.Close ();  		if (code == 200 || code == 201) {  			return TalisUpdateResult.Synchronous;  		}  		else if (code == 202) {  			return TalisUpdateResult.Asynchronous;  		}  		else if (code == 204) {  			return TalisUpdateResult.Done;  		}  		else {  			return TalisUpdateResult.Unknown;  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		//Got a Response so we can analyse the Response Code  		response = (HttpWebResponse)webEx.Response;  		int code = (int)response.StatusCode;  		throw Error (code' webEx);  	}  	//Didn't get a Response  	throw;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: try {  	//Generate the ChangeSet Batch  	IGraph g = this.GenerateChangeSet (additions' removals);  	if (g == null)  		return TalisUpdateResult.NotRequired;  	//Null so no changes need persisting  	if (g.IsEmpty)  		return TalisUpdateResult.NotRequired;  	//Empty so no changes need persisting  	//Create the Request  	request = this.CreateRequest (servicePath' new Dictionary<string' string> ());  	request.Method = "POST";  	request.ContentType = TalisChangeSetMIMEType;  	//Write the RDF/XML to the Request Stream  	RdfXmlWriter writer = new RdfXmlWriter ();  	writer.Save (g' new StreamWriter (request.GetRequestStream ()));  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Make the Request  	using (response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		//What sort of Update Result did we get?  		int code = (int)response.StatusCode;  		response.Close ();  		if (code == 200 || code == 201) {  			return TalisUpdateResult.Synchronous;  		}  		else if (code == 202) {  			return TalisUpdateResult.Asynchronous;  		}  		else if (code == 204) {  			return TalisUpdateResult.Done;  		}  		else {  			return TalisUpdateResult.Unknown;  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		//Got a Response so we can analyse the Response Code  		response = (HttpWebResponse)webEx.Response;  		int code = (int)response.StatusCode;  		throw Error (code' webEx);  	}  	//Didn't get a Response  	throw;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: try {  	//Generate the ChangeSet Batch  	IGraph g = this.GenerateChangeSet (additions' removals);  	if (g == null)  		return TalisUpdateResult.NotRequired;  	//Null so no changes need persisting  	if (g.IsEmpty)  		return TalisUpdateResult.NotRequired;  	//Empty so no changes need persisting  	//Create the Request  	request = this.CreateRequest (servicePath' new Dictionary<string' string> ());  	request.Method = "POST";  	request.ContentType = TalisChangeSetMIMEType;  	//Write the RDF/XML to the Request Stream  	RdfXmlWriter writer = new RdfXmlWriter ();  	writer.Save (g' new StreamWriter (request.GetRequestStream ()));  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Make the Request  	using (response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		//What sort of Update Result did we get?  		int code = (int)response.StatusCode;  		response.Close ();  		if (code == 200 || code == 201) {  			return TalisUpdateResult.Synchronous;  		}  		else if (code == 202) {  			return TalisUpdateResult.Asynchronous;  		}  		else if (code == 204) {  			return TalisUpdateResult.Done;  		}  		else {  			return TalisUpdateResult.Unknown;  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		//Got a Response so we can analyse the Response Code  		response = (HttpWebResponse)webEx.Response;  		int code = (int)response.StatusCode;  		throw Error (code' webEx);  	}  	//Didn't get a Response  	throw;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: try {  	//Generate the ChangeSet Batch  	IGraph g = this.GenerateChangeSet (additions' removals);  	if (g == null)  		return TalisUpdateResult.NotRequired;  	//Null so no changes need persisting  	if (g.IsEmpty)  		return TalisUpdateResult.NotRequired;  	//Empty so no changes need persisting  	//Create the Request  	request = this.CreateRequest (servicePath' new Dictionary<string' string> ());  	request.Method = "POST";  	request.ContentType = TalisChangeSetMIMEType;  	//Write the RDF/XML to the Request Stream  	RdfXmlWriter writer = new RdfXmlWriter ();  	writer.Save (g' new StreamWriter (request.GetRequestStream ()));  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Make the Request  	using (response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		//What sort of Update Result did we get?  		int code = (int)response.StatusCode;  		response.Close ();  		if (code == 200 || code == 201) {  			return TalisUpdateResult.Synchronous;  		}  		else if (code == 202) {  			return TalisUpdateResult.Asynchronous;  		}  		else if (code == 204) {  			return TalisUpdateResult.Done;  		}  		else {  			return TalisUpdateResult.Unknown;  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		//Got a Response so we can analyse the Response Code  		response = (HttpWebResponse)webEx.Response;  		int code = (int)response.StatusCode;  		throw Error (code' webEx);  	}  	//Didn't get a Response  	throw;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: using (response = (HttpWebResponse)request.GetResponse ()) {  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugResponse (response);  	}  	#endif  	//What sort of Update Result did we get?  	int code = (int)response.StatusCode;  	response.Close ();  	if (code == 200 || code == 201) {  		return TalisUpdateResult.Synchronous;  	}  	else if (code == 202) {  		return TalisUpdateResult.Asynchronous;  	}  	else if (code == 204) {  		return TalisUpdateResult.Done;  	}  	else {  		return TalisUpdateResult.Unknown;  	}  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: using (response = (HttpWebResponse)request.GetResponse ()) {  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugResponse (response);  	}  	#endif  	//What sort of Update Result did we get?  	int code = (int)response.StatusCode;  	response.Close ();  	if (code == 200 || code == 201) {  		return TalisUpdateResult.Synchronous;  	}  	else if (code == 202) {  		return TalisUpdateResult.Asynchronous;  	}  	else if (code == 204) {  		return TalisUpdateResult.Done;  	}  	else {  		return TalisUpdateResult.Unknown;  	}  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: using (response = (HttpWebResponse)request.GetResponse ()) {  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugResponse (response);  	}  	#endif  	//What sort of Update Result did we get?  	int code = (int)response.StatusCode;  	response.Close ();  	if (code == 200 || code == 201) {  		return TalisUpdateResult.Synchronous;  	}  	else if (code == 202) {  		return TalisUpdateResult.Asynchronous;  	}  	else if (code == 204) {  		return TalisUpdateResult.Done;  	}  	else {  		return TalisUpdateResult.Unknown;  	}  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: using (response = (HttpWebResponse)request.GetResponse ()) {  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugResponse (response);  	}  	#endif  	//What sort of Update Result did we get?  	int code = (int)response.StatusCode;  	response.Close ();  	if (code == 200 || code == 201) {  		return TalisUpdateResult.Synchronous;  	}  	else if (code == 202) {  		return TalisUpdateResult.Asynchronous;  	}  	else if (code == 204) {  		return TalisUpdateResult.Done;  	}  	else {  		return TalisUpdateResult.Unknown;  	}  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 200 || code == 201) {  	return TalisUpdateResult.Synchronous;  }  else if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 200 || code == 201) {  	return TalisUpdateResult.Synchronous;  }  else if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 200 || code == 201) {  	return TalisUpdateResult.Synchronous;  }  else if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 200 || code == 201) {  	return TalisUpdateResult.Synchronous;  }  else if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 202) {  	return TalisUpdateResult.Asynchronous;  }  else if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,UpdateInternal,The following statement contains a magic number: if (code == 204) {  	return TalisUpdateResult.Done;  }  else {  	return TalisUpdateResult.Unknown;  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,TalisPlatformConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\TalisPlatformConnector.cs,Error,The following statement contains a magic number: switch (code) {  case 400:  	//Response should contain a message telling us what was wrong  	String data = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();  	return new TalisException ("Required Parameter Missing/Malformed: " + data' ex);  case 403:  	return new TalisException ("Access to this service is not permitted using the provided Credentials"' ex);  case 405:  	return new TalisException ("Service doesn't support the HTTP Method used"' ex);  case 406:  	return new TalisException ("Requested Content Types are not available from this Service"' ex);  case 413:  	return new TalisException ("Request was too large for this Service and was rejected"' ex);  case 415:  	return new TalisException ("Content submitted to Talis was in an unsupported format"' ex);  case 422:  	return new TalisException ("RDF submitted to Talis is not valid"' ex);  case 500:  	return new TalisException ("Talis reported an Internal Server Error' your request may have timed out"' ex);  case 507:  	return new TalisException ("Talis Platform has insufficient storage to process the Request at this time"' ex);  default:  	return new TalisException ("Unknown Error accessing the Talis Platform"' ex);  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,The following statement contains a magic number: try {  	//First off parse the Query to see what kind of query it is  	SparqlQuery q;  	try {  		q = this._parser.ParseFromString (sparqlQuery);  	}  	catch (RdfParseException parseEx) {  		throw;  	}  	catch (Exception ex) {  		throw new RdfStorageException ("An unexpected error occurred while trying to parse the SPARQL Query prior to sending it to the Store' see inner exception for details"' ex);  	}  	//Now select the Accept Header based on the query type  	String accept = (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask) ? MimeTypesHelper.HttpSparqlAcceptHeader : MimeTypesHelper.HttpAcceptHeader;  	//Create the Request  	HttpWebRequest request;  	Dictionary<String' String> queryParams = new Dictionary<string' string> ();  	if (sparqlQuery.Length < 2048) {  		queryParams.Add ("query"' sparqlQuery);  		request = this.CreateRequest ("/sparql"' accept' "GET"' queryParams);  	}  	else {  		request = this.CreateRequest ("/sparql"' accept' "POST"' queryParams);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("query=");  		postData.Append (HttpUtility.UrlEncode (sparqlQuery));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		StreamReader data = new StreamReader (response.GetResponseStream ());  		String ctype = response.ContentType;  		if (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask) {  			//ASK/SELECT should return SPARQL Results  			ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' q.QueryType == SparqlQueryType.Ask);  			resreader.Load (resultsHandler' data);  			response.Close ();  		}  		else {  			//CONSTRUCT/DESCRIBE should return a Graph  			IRdfReader rdfreader = MimeTypesHelper.GetParser (ctype);  			rdfreader.Load (rdfHandler' data);  			response.Close ();  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  		}  		#endif  		if (webEx.Response.ContentLength > 0) {  			try {  				String responseText = new StreamReader (webEx.Response.GetResponseStream ()).ReadToEnd ();  				throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx);  			}  			catch {  				throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  			}  		}  		else {  			throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  		}  	}  	else {  		throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  	}  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,Query,The following statement contains a magic number: if (sparqlQuery.Length < 2048) {  	queryParams.Add ("query"' sparqlQuery);  	request = this.CreateRequest ("/sparql"' accept' "GET"' queryParams);  }  else {  	request = this.CreateRequest ("/sparql"' accept' "POST"' queryParams);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (HttpUtility.UrlEncode (sparqlQuery));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._hasCredentials) {  	if (this._apiKey != null) {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  	}  	else {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  	}  }  else {  	return this._baseUri;  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._hasCredentials) {  	if (this._apiKey != null) {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  	}  	else {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  	}  }  else {  	return this._baseUri;  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._hasCredentials) {  	if (this._apiKey != null) {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  	}  	else {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  	}  }  else {  	return this._baseUri;  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._hasCredentials) {  	if (this._apiKey != null) {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  	}  	else {  		return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  	}  }  else {  	return this._baseUri;  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._apiKey != null) {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  }  else {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._apiKey != null) {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  }  else {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._apiKey != null) {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  }  else {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: if (this._apiKey != null) {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  }  else {  	return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  }  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._apiKey) + "@" + this._baseUri.Substring (7);  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  
Magic Number,VDS.RDF.Storage,DydraConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\DydraConnector.cs,GetCredentialedUri,The following statement contains a magic number: return this._baseUri.Substring (0' 7) + Uri.EscapeUriString (this._username) + ":" + Uri.EscapeUriString (this._pwd) + "@" + this._baseUri.Substring (7);  
Magic Number,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The following statement contains a magic number: try {  	HttpWebRequest request;  	String tID = (this._activeTrans == null) ? String.Empty : "/" + this._activeTrans;  	//String accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  	String accept = MimeTypesHelper.CustomHttpAcceptHeader (MimeTypesHelper.SparqlResultsXml.Concat (MimeTypesHelper.Definitions.Where (d => d.CanParseRdf).SelectMany (d => d.MimeTypes)));  	//Create the Request  	Dictionary<String' String> queryParams = new Dictionary<string' string> ();  	if (sparqlQuery.Length < 2048) {  		queryParams.Add ("query"' sparqlQuery);  		request = this.CreateRequest (this._kb + tID + "/query"' accept' "GET"' queryParams);  	}  	else {  		request = this.CreateRequest (this._kb + tID + "/query"' accept' "POST"' queryParams);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("query=");  		postData.Append (Uri.EscapeDataString (sparqlQuery));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		StreamReader data = new StreamReader (response.GetResponseStream ());  		String ctype = response.ContentType;  		try {  			//Is the Content Type referring to a Sparql Result Set format?  			ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' Regex.IsMatch (sparqlQuery' "ASK"' RegexOptions.IgnoreCase));  			resreader.Load (resultsHandler' data);  			response.Close ();  		}  		catch (RdfParserSelectionException) {  			//If we get a Parser Selection exception then the Content Type isn't valid for a Sparql Result Set  			//Is the Content Type referring to a RDF format?  			IRdfReader rdfreader = MimeTypesHelper.GetParser (ctype);  			rdfreader.Load (rdfHandler' data);  			response.Close ();  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  		}  		#endif  		if (webEx.Response.ContentLength > 0) {  			try {  				String responseText = new StreamReader (webEx.Response.GetResponseStream ()).ReadToEnd ();  				throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx);  			}  			catch {  				throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  			}  		}  		else {  			throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  		}  	}  	else {  		throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  	}  }  
Magic Number,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,Query,The following statement contains a magic number: if (sparqlQuery.Length < 2048) {  	queryParams.Add ("query"' sparqlQuery);  	request = this.CreateRequest (this._kb + tID + "/query"' accept' "GET"' queryParams);  }  else {  	request = this.CreateRequest (this._kb + tID + "/query"' accept' "POST"' queryParams);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (Uri.EscapeDataString (sparqlQuery));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,FusekiConnector,The following statement contains a magic number: this._updateUri = serviceUri.Substring (0' serviceUri.Length - 4) + "update";  
Magic Number,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,FusekiConnector,The following statement contains a magic number: this._queryUri = serviceUri.Substring (0' serviceUri.Length - 4) + "query";  
Magic Number,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,Query,The following statement contains a magic number: try {  	HttpWebRequest request;  	//Create the Request  	String queryUri = this._queryUri;  	if (sparqlQuery.Length < 2048) {  		queryUri += "?query=" + Uri.EscapeDataString (sparqlQuery);  		request = (HttpWebRequest)WebRequest.Create (queryUri);  		request.Method = "GET";  		request.Accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  		request = base.GetProxiedRequest (request);  	}  	else {  		request = (HttpWebRequest)WebRequest.Create (queryUri);  		request.Method = "POST";  		request.Accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  		request = base.GetProxiedRequest (request);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("query=");  		postData.Append (Uri.EscapeDataString (sparqlQuery));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		StreamReader data = new StreamReader (response.GetResponseStream ());  		String ctype = response.ContentType;  		try {  			//Is the Content Type referring to a Sparql Result Set format?  			ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' true);  			resreader.Load (resultsHandler' data);  			response.Close ();  		}  		catch (RdfParserSelectionException) {  			//If we get a Parse exception then the Content Type isn't valid for a Sparql Result Set  			//Is the Content Type referring to a RDF format?  			IRdfReader rdfreader = MimeTypesHelper.GetParser (ctype);  			rdfreader.Load (rdfHandler' data);  			response.Close ();  		}  	}  }  catch (WebException webEx) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  }  
Magic Number,VDS.RDF.Storage,FusekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FusekiConnector.cs,Query,The following statement contains a magic number: if (sparqlQuery.Length < 2048) {  	queryUri += "?query=" + Uri.EscapeDataString (sparqlQuery);  	request = (HttpWebRequest)WebRequest.Create (queryUri);  	request.Method = "GET";  	request.Accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  	request = base.GetProxiedRequest (request);  }  else {  	request = (HttpWebRequest)WebRequest.Create (queryUri);  	request.Method = "POST";  	request.Accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  	request = base.GetProxiedRequest (request);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (Uri.EscapeDataString (sparqlQuery));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,CreateStore,The following statement contains a magic number: try {  	Dictionary<String' String> createParams = new Dictionary<string' string> ();  	createParams.Add ("override"' "false");  	request = this.CreateRequest ("repositories/" + storeID' "*/*"' "PUT"' createParams);  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	using (response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		response.Close ();  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		#if DEBUG  		if (Options.HttpDebugging) {  			if (webEx.Response != null)  				Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  		}  		#endif  		//Got a Response so we can analyse the Response Code  		response = (HttpWebResponse)webEx.Response;  		int code = (int)response.StatusCode;  		if (code == 400) {  			//OK - Just means the Store already exists  		}  		else {  			throw;  		}  	}  	else {  		throw;  	}  }  finally {  	this._store = storeID;  }  
Magic Number,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,CreateStore,The following statement contains a magic number: if (webEx.Response != null) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	//Got a Response so we can analyse the Response Code  	response = (HttpWebResponse)webEx.Response;  	int code = (int)response.StatusCode;  	if (code == 400) {  		//OK - Just means the Store already exists  	}  	else {  		throw;  	}  }  else {  	throw;  }  
Magic Number,VDS.RDF.Storage,AllegroGraphConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\AllegroGraphConnector.cs,CreateStore,The following statement contains a magic number: if (code == 400) {  	//OK - Just means the Store already exists  }  else {  	throw;  }  
Magic Number,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,FourStoreConnector,The following statement contains a magic number: this._endpoint.Timeout = 60000;  
Magic Number,VDS.RDF.Storage,FourStoreConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\FourStoreConnector.cs,FourStoreConnector,The following statement contains a magic number: this._updateEndpoint.Timeout = 60000;  
Magic Number,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Query,The following statement contains a magic number: try {  	HttpWebRequest request;  	//Create the Request  	Dictionary<String' String> queryParams = new Dictionary<string' string> ();  	if (sparqlQuery.Length < 2048) {  		queryParams.Add ("query"' sparqlQuery);  		request = this.CreateRequest (this._queryService' MimeTypesHelper.HttpRdfOrSparqlAcceptHeader' "GET"' queryParams);  	}  	else {  		request = this.CreateRequest (this._queryService' MimeTypesHelper.HttpRdfOrSparqlAcceptHeader' "POST"' queryParams);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("query=");  		postData.Append (HttpUtility.UrlEncode (sparqlQuery));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		StreamReader data = new StreamReader (response.GetResponseStream ());  		String ctype = response.ContentType;  		try {  			//Is the Content Type referring to a Sparql Result Set format?  			ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' true);  			resreader.Load (resultsHandler' data);  			response.Close ();  		}  		catch (RdfParserSelectionException) {  			//If we get a Parse exception then the Content Type isn't valid for a Sparql Result Set  			//Is the Content Type referring to a RDF format?  			IRdfReader rdfreader = MimeTypesHelper.GetParser (ctype);  			rdfreader.Load (rdfHandler' data);  			response.Close ();  		}  	}  }  catch (WebException webEx) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  }  
Magic Number,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Query,The following statement contains a magic number: if (sparqlQuery.Length < 2048) {  	queryParams.Add ("query"' sparqlQuery);  	request = this.CreateRequest (this._queryService' MimeTypesHelper.HttpRdfOrSparqlAcceptHeader' "GET"' queryParams);  }  else {  	request = this.CreateRequest (this._queryService' MimeTypesHelper.HttpRdfOrSparqlAcceptHeader' "POST"' queryParams);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (HttpUtility.UrlEncode (sparqlQuery));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Update,The following statement contains a magic number: try {  	HttpWebRequest request;  	//Create the Request  	Dictionary<String' String> updateParams = new Dictionary<string' string> ();  	if (sparqlUpdate.Length < 2048) {  		updateParams.Add ("update"' sparqlUpdate);  		request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "GET"' updateParams);  	}  	else {  		request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "POST"' updateParams);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("update=");  		postData.Append (HttpUtility.UrlEncode (sparqlUpdate));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		//If we get here then it was OK  		response.Close ();  	}  }  catch (WebException webEx) {  	#if DEBUG  	if (Options.HttpDebugging) {  		if (webEx.Response != null)  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  	}  	#endif  	throw new SparqlUpdateException ("A HTTP error occurred while attempting to Update the Store"' webEx);  }  
Magic Number,VDS.RDF.Storage,JosekiConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\JosekiConnector.cs,Update,The following statement contains a magic number: if (sparqlUpdate.Length < 2048) {  	updateParams.Add ("update"' sparqlUpdate);  	request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "GET"' updateParams);  }  else {  	request = this.CreateRequest (this._updateService' MimeTypesHelper.Any' "POST"' updateParams);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("update=");  	postData.Append (HttpUtility.UrlEncode (sparqlUpdate));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Query,The following statement contains a magic number: try {  	//Pre-parse the query to determine what the Query Type is  	bool isAsk = false;  	SparqlQuery q = null;  	try {  		q = this._parser.ParseFromString (sparqlQuery);  		isAsk = q.QueryType == SparqlQueryType.Ask;  	}  	catch {  		//If parsing error fallback to naive detection  		isAsk = Regex.IsMatch (sparqlQuery' "ASK"' RegexOptions.IgnoreCase);  	}  	//Select Accept Header  	String accept;  	if (q != null) {  		accept = (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask ? MimeTypesHelper.HttpSparqlAcceptHeader : MimeTypesHelper.HttpAcceptHeader);  	}  	else {  		accept = MimeTypesHelper.HttpRdfOrSparqlAcceptHeader;  	}  	HttpWebRequest request;  	//Create the Request  	Dictionary<String' String> queryParams = new Dictionary<string' string> ();  	if (sparqlQuery.Length < 2048 && !this._postAllQueries) {  		queryParams.Add ("query"' EscapeQuery (sparqlQuery));  		request = this.CreateRequest (this._repositoriesPrefix + this._store + this._queryPath' accept' "GET"' queryParams);  	}  	else {  		request = this.CreateRequest (this._repositoriesPrefix + this._store + this._queryPath' accept' "POST"' queryParams);  		//Build the Post Data and add to the Request Body  		request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  		StringBuilder postData = new StringBuilder ();  		postData.Append ("query=");  		postData.Append (Uri.EscapeDataString (EscapeQuery (sparqlQuery)));  		StreamWriter writer = new StreamWriter (request.GetRequestStream ());  		writer.Write (postData);  		writer.Close ();  	}  	#if DEBUG  	if (Options.HttpDebugging) {  		Tools.HttpDebugRequest (request);  	}  	#endif  	//Get the Response and process based on the Content Type  	using (HttpWebResponse response = (HttpWebResponse)request.GetResponse ()) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse (response);  		}  		#endif  		StreamReader data = new StreamReader (response.GetResponseStream ());  		String ctype = response.ContentType;  		try {  			//Is the Content Type referring to a Sparql Result Set format?  			ISparqlResultsReader resreader = MimeTypesHelper.GetSparqlParser (ctype' isAsk);  			resreader.Load (resultsHandler' data);  			response.Close ();  		}  		catch (RdfParserSelectionException) {  			//If we get a Parser Selection exception then the Content Type isn't valid for a Sparql Result Set  			//Is the Content Type referring to a RDF format?  			IRdfReader rdfreader = MimeTypesHelper.GetParser (ctype);  			if (q != null && (SparqlSpecsHelper.IsSelectQuery (q.QueryType) || q.QueryType == SparqlQueryType.Ask)) {  				SparqlRdfParser resreader = new SparqlRdfParser (rdfreader);  				resreader.Load (resultsHandler' data);  			}  			else {  				rdfreader.Load (rdfHandler' data);  			}  			response.Close ();  		}  	}  }  catch (WebException webEx) {  	if (webEx.Response != null) {  		#if DEBUG  		if (Options.HttpDebugging) {  			Tools.HttpDebugResponse ((HttpWebResponse)webEx.Response);  		}  		#endif  		if (webEx.Response.ContentLength > 0) {  			try {  				String responseText = new StreamReader (webEx.Response.GetResponseStream ()).ReadToEnd ();  				throw new RdfQueryException ("A HTTP error occured while querying the Store.  Store returned the following error message: " + responseText' webEx);  			}  			catch {  				throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  			}  		}  		else {  			throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  		}  	}  	else {  		throw new RdfQueryException ("A HTTP error occurred while querying the Store"' webEx);  	}  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,Query,The following statement contains a magic number: if (sparqlQuery.Length < 2048 && !this._postAllQueries) {  	queryParams.Add ("query"' EscapeQuery (sparqlQuery));  	request = this.CreateRequest (this._repositoriesPrefix + this._store + this._queryPath' accept' "GET"' queryParams);  }  else {  	request = this.CreateRequest (this._repositoriesPrefix + this._store + this._queryPath' accept' "POST"' queryParams);  	//Build the Post Data and add to the Request Body  	request.ContentType = MimeTypesHelper.WWWFormURLEncoded;  	StringBuilder postData = new StringBuilder ();  	postData.Append ("query=");  	postData.Append (Uri.EscapeDataString (EscapeQuery (sparqlQuery)));  	StreamWriter writer = new StreamWriter (request.GetRequestStream ());  	writer.Write (postData);  	writer.Close ();  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,EscapeQuery,The following statement contains a magic number: foreach (char c in query.ToCharArray ()) {  	if (c <= 255) {  		output.Append (c);  	}  	else if (c <= 65535) {  		output.Append ("\\u");  		output.Append (((int)c).ToString ("x4"));  	}  	else {  		output.Append ("\\U");  		output.Append (((int)c).ToString ("x8"));  	}  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,EscapeQuery,The following statement contains a magic number: foreach (char c in query.ToCharArray ()) {  	if (c <= 255) {  		output.Append (c);  	}  	else if (c <= 65535) {  		output.Append ("\\u");  		output.Append (((int)c).ToString ("x4"));  	}  	else {  		output.Append ("\\U");  		output.Append (((int)c).ToString ("x8"));  	}  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,EscapeQuery,The following statement contains a magic number: if (c <= 255) {  	output.Append (c);  }  else if (c <= 65535) {  	output.Append ("\\u");  	output.Append (((int)c).ToString ("x4"));  }  else {  	output.Append ("\\U");  	output.Append (((int)c).ToString ("x8"));  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,EscapeQuery,The following statement contains a magic number: if (c <= 255) {  	output.Append (c);  }  else if (c <= 65535) {  	output.Append ("\\u");  	output.Append (((int)c).ToString ("x4"));  }  else {  	output.Append ("\\U");  	output.Append (((int)c).ToString ("x8"));  }  
Magic Number,VDS.RDF.Storage,BaseSesameHttpProtocolConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\SesameHttpProtocolConnector.cs,EscapeQuery,The following statement contains a magic number: if (c <= 65535) {  	output.Append ("\\u");  	output.Append (((int)c).ToString ("x4"));  }  else {  	output.Append ("\\U");  	output.Append (((int)c).ToString ("x8"));  }  
Magic Number,VDS.RDF.Update.Protocol,GenericProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\GenericProtocolProcessor.cs,ProcessPatch,The following statement contains a magic number: if (context.Request.ContentLength > 0) {  	if (context.Request.ContentType.Equals ("application/sparql-update")) {  		//Try and parse the SPARQL Update  		//No error handling here as we assume the calling IHttpHandler does that  		String patchData;  		using (StreamReader reader = new StreamReader (context.Request.InputStream)) {  			patchData = reader.ReadToEnd ();  			reader.Close ();  		}  		SparqlUpdateParser parser = new SparqlUpdateParser ();  		SparqlUpdateCommandSet cmds = parser.ParseFromString (patchData);  		//Assuming that we've got here i.e. the SPARQL Updates are parseable then  		//we need to check that they actually affect the relevant Graph  		if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  			GenericUpdateProcessor processor = new GenericUpdateProcessor (this._manager);  			processor.ProcessCommandSet (cmds);  			processor.Flush ();  		}  		else {  			//One/More commands either do no affect a Single Graph or don't affect the Graph  			//implied by the HTTP Request so give a 422 response  			context.Response.StatusCode = 422;  			return;  		}  	}  	else {  		//Don't understand other forms of PATCH requests  		context.Response.StatusCode = (int)HttpStatusCode.UnsupportedMediaType;  		return;  	}  }  else {  	//Empty Request is a Bad Request  	context.Response.StatusCode = (int)HttpStatusCode.BadRequest;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,GenericProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\GenericProtocolProcessor.cs,ProcessPatch,The following statement contains a magic number: if (context.Request.ContentType.Equals ("application/sparql-update")) {  	//Try and parse the SPARQL Update  	//No error handling here as we assume the calling IHttpHandler does that  	String patchData;  	using (StreamReader reader = new StreamReader (context.Request.InputStream)) {  		patchData = reader.ReadToEnd ();  		reader.Close ();  	}  	SparqlUpdateParser parser = new SparqlUpdateParser ();  	SparqlUpdateCommandSet cmds = parser.ParseFromString (patchData);  	//Assuming that we've got here i.e. the SPARQL Updates are parseable then  	//we need to check that they actually affect the relevant Graph  	if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  		GenericUpdateProcessor processor = new GenericUpdateProcessor (this._manager);  		processor.ProcessCommandSet (cmds);  		processor.Flush ();  	}  	else {  		//One/More commands either do no affect a Single Graph or don't affect the Graph  		//implied by the HTTP Request so give a 422 response  		context.Response.StatusCode = 422;  		return;  	}  }  else {  	//Don't understand other forms of PATCH requests  	context.Response.StatusCode = (int)HttpStatusCode.UnsupportedMediaType;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,GenericProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\GenericProtocolProcessor.cs,ProcessPatch,The following statement contains a magic number: if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  	GenericUpdateProcessor processor = new GenericUpdateProcessor (this._manager);  	processor.ProcessCommandSet (cmds);  	processor.Flush ();  }  else {  	//One/More commands either do no affect a Single Graph or don't affect the Graph  	//implied by the HTTP Request so give a 422 response  	context.Response.StatusCode = 422;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,GenericProtocolProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\GenericProtocolProcessor.cs,ProcessPatch,The following statement contains a magic number: context.Response.StatusCode = 422;  
Magic Number,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,ProcessPatch,The following statement contains a magic number: if (context.Request.ContentLength > 0) {  	if (context.Request.ContentType.Equals ("application/sparql-update")) {  		//Try and parse the SPARQL Update  		//No error handling here as we assume the calling IHttpHandler does that  		String patchData;  		using (StreamReader reader = new StreamReader (context.Request.InputStream)) {  			patchData = reader.ReadToEnd ();  			reader.Close ();  		}  		SparqlUpdateCommandSet cmds = this._parser.ParseFromString (patchData);  		//Assuming that we've got here i.e. the SPARQL Updates are parseable then  		//we need to check that they actually affect the relevant Graph  		if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  			this._updateProcessor.ProcessCommandSet (cmds);  			this._updateProcessor.Flush ();  		}  		else {  			//One/More commands either do no affect a Single Graph or don't affect the Graph  			//implied by the HTTP Request so give a 422 response  			context.Response.StatusCode = 422;  			return;  		}  	}  	else {  		//Don't understand other forms of PATCH requests  		context.Response.StatusCode = (int)HttpStatusCode.UnsupportedMediaType;  		return;  	}  }  else {  	//Empty Request is a Bad Request  	context.Response.StatusCode = (int)HttpStatusCode.BadRequest;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,ProcessPatch,The following statement contains a magic number: if (context.Request.ContentType.Equals ("application/sparql-update")) {  	//Try and parse the SPARQL Update  	//No error handling here as we assume the calling IHttpHandler does that  	String patchData;  	using (StreamReader reader = new StreamReader (context.Request.InputStream)) {  		patchData = reader.ReadToEnd ();  		reader.Close ();  	}  	SparqlUpdateCommandSet cmds = this._parser.ParseFromString (patchData);  	//Assuming that we've got here i.e. the SPARQL Updates are parseable then  	//we need to check that they actually affect the relevant Graph  	if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  		this._updateProcessor.ProcessCommandSet (cmds);  		this._updateProcessor.Flush ();  	}  	else {  		//One/More commands either do no affect a Single Graph or don't affect the Graph  		//implied by the HTTP Request so give a 422 response  		context.Response.StatusCode = 422;  		return;  	}  }  else {  	//Don't understand other forms of PATCH requests  	context.Response.StatusCode = (int)HttpStatusCode.UnsupportedMediaType;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,ProcessPatch,The following statement contains a magic number: if (cmds.Commands.All (c => c.AffectsSingleGraph && c.AffectsGraph (graphUri))) {  	this._updateProcessor.ProcessCommandSet (cmds);  	this._updateProcessor.Flush ();  }  else {  	//One/More commands either do no affect a Single Graph or don't affect the Graph  	//implied by the HTTP Request so give a 422 response  	context.Response.StatusCode = 422;  	return;  }  
Magic Number,VDS.RDF.Update.Protocol,ProtocolToUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Protocol\ProtocolToUpdateProcessor.cs,ProcessPatch,The following statement contains a magic number: context.Response.StatusCode = 422;  
Magic Number,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateOutput,The following statement contains a magic number: if ((subjNodes / triples) > 0.75)  	hiSpeed = true;  
Magic Number,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (!c.IsExplicit) {  	output.Append ('(');  	while (c.Triples.Count > 0) {  		if (context.PrettyPrint && !first)  			output.Append (new String (' '' indent));  		first = false;  		output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent));  		c.Triples.RemoveAt (0);  		if (c.Triples.Count > 0) {  			output.Append (' ');  		}  	}  	output.Append (')');  }  else {  	if (c.Triples.Count == 0) {  		//Empty Collection  		//Can represent as a single Blank Node []  		output.Append ("[]");  	}  	else {  		output.Append ('[');  		while (c.Triples.Count > 0) {  			if (context.PrettyPrint && !first)  				output.Append (new String (' '' indent));  			first = false;  			String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  			output.Append (temp);  			output.Append (' ');  			int addIndent;  			if (temp.Contains ('\n')) {  				addIndent = temp.Split ('\n').Last ().Length;  			}  			else {  				addIndent = temp.Length;  			}  			output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  			c.Triples.RemoveAt (0);  			if (c.Triples.Count > 0) {  				output.AppendLine (" ; ");  				output.Append (' ');  			}  		}  		output.Append (']');  	}  }  
Magic Number,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (c.Triples.Count == 0) {  	//Empty Collection  	//Can represent as a single Blank Node []  	output.Append ("[]");  }  else {  	output.Append ('[');  	while (c.Triples.Count > 0) {  		if (context.PrettyPrint && !first)  			output.Append (new String (' '' indent));  		first = false;  		String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  		output.Append (temp);  		output.Append (' ');  		int addIndent;  		if (temp.Contains ('\n')) {  			addIndent = temp.Split ('\n').Last ().Length;  		}  		else {  			addIndent = temp.Length;  		}  		output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  		c.Triples.RemoveAt (0);  		if (c.Triples.Count > 0) {  			output.AppendLine (" ; ");  			output.Append (' ');  		}  	}  	output.Append (']');  }  
Magic Number,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: while (c.Triples.Count > 0) {  	if (context.PrettyPrint && !first)  		output.Append (new String (' '' indent));  	first = false;  	String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  	output.Append (temp);  	output.Append (' ');  	int addIndent;  	if (temp.Contains ('\n')) {  		addIndent = temp.Split ('\n').Last ().Length;  	}  	else {  		addIndent = temp.Length;  	}  	output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  	c.Triples.RemoveAt (0);  	if (c.Triples.Count > 0) {  		output.AppendLine (" ; ");  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing,CompressingTurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\CompressingTurtleWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  
Magic Number,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateTripleOutput,The following statement contains a magic number: if ((subjNodes / triples) > 0.75)  	hiSpeed = true;  
Magic Number,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateTripleOutput,The following statement contains a magic number: if (globalContext.CompressionLevel == WriterCompressionLevel.None || hiSpeed && context.HighSpeedModePermitted) {  	//Use High Speed Write Mode  	String indentation = new String (' '' 4);  	context.Output.Write (indentation);  	if (globalContext.CompressionLevel > WriterCompressionLevel.None)  		context.Output.WriteLine ("# Written using High Speed Mode");  	foreach (Triple t in context.Graph.Triples) {  		context.Output.Write (indentation);  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Subject' TripleSegment.Subject));  		context.Output.Write (' ');  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate));  		context.Output.Write (' ');  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Object' TripleSegment.Object));  		context.Output.WriteLine (".");  	}  }  else {  	//Get the Triples as a Sorted List  	List<Triple> ts = context.Graph.Triples.ToList ();  	ts.Sort ();  	//Variables we need to track our writing  	INode lastSubj' lastPred;  	lastSubj = lastPred = null;  	int subjIndent = 0' predIndent = 0;  	int baseIndent = 4;  	String temp;  	for (int i = 0; i < ts.Count; i++) {  		Triple t = ts [i];  		if (lastSubj == null || !t.Subject.Equals (lastSubj)) {  			//Terminate previous Triples  			if (lastSubj != null)  				context.Output.WriteLine (".");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' baseIndent));  			//Start a new set of Triples  			temp = this.GenerateNodeOutput (globalContext' context' t.Subject' TripleSegment.Subject);  			context.Output.Write (temp);  			context.Output.Write (" ");  			subjIndent = baseIndent + temp.Length + 1;  			lastSubj = t.Subject;  			//Write the first Predicate  			temp = this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate);  			context.Output.Write (temp);  			context.Output.Write (" ");  			predIndent = temp.Length + 1;  			lastPred = t.Predicate;  		}  		else if (lastPred == null || !t.Predicate.Equals (lastPred)) {  			//Terminate previous Predicate Object list  			context.Output.WriteLine (";");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' subjIndent));  			//Write the next Predicate  			temp = this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate);  			context.Output.Write (temp);  			context.Output.Write (" ");  			predIndent = temp.Length + 1;  			lastPred = t.Predicate;  		}  		else {  			//Continue Object List  			context.Output.WriteLine ("'");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' subjIndent + predIndent));  		}  		//Write the Object  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Object' TripleSegment.Object));  	}  	//Terminate Triples  	if (ts.Count > 0)  		context.Output.WriteLine (".");  }  
Magic Number,VDS.RDF.Writing,TriGWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriGWriter.cs,GenerateTripleOutput,The following statement contains a magic number: if (globalContext.CompressionLevel == WriterCompressionLevel.None || hiSpeed && context.HighSpeedModePermitted) {  	//Use High Speed Write Mode  	String indentation = new String (' '' 4);  	context.Output.Write (indentation);  	if (globalContext.CompressionLevel > WriterCompressionLevel.None)  		context.Output.WriteLine ("# Written using High Speed Mode");  	foreach (Triple t in context.Graph.Triples) {  		context.Output.Write (indentation);  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Subject' TripleSegment.Subject));  		context.Output.Write (' ');  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate));  		context.Output.Write (' ');  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Object' TripleSegment.Object));  		context.Output.WriteLine (".");  	}  }  else {  	//Get the Triples as a Sorted List  	List<Triple> ts = context.Graph.Triples.ToList ();  	ts.Sort ();  	//Variables we need to track our writing  	INode lastSubj' lastPred;  	lastSubj = lastPred = null;  	int subjIndent = 0' predIndent = 0;  	int baseIndent = 4;  	String temp;  	for (int i = 0; i < ts.Count; i++) {  		Triple t = ts [i];  		if (lastSubj == null || !t.Subject.Equals (lastSubj)) {  			//Terminate previous Triples  			if (lastSubj != null)  				context.Output.WriteLine (".");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' baseIndent));  			//Start a new set of Triples  			temp = this.GenerateNodeOutput (globalContext' context' t.Subject' TripleSegment.Subject);  			context.Output.Write (temp);  			context.Output.Write (" ");  			subjIndent = baseIndent + temp.Length + 1;  			lastSubj = t.Subject;  			//Write the first Predicate  			temp = this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate);  			context.Output.Write (temp);  			context.Output.Write (" ");  			predIndent = temp.Length + 1;  			lastPred = t.Predicate;  		}  		else if (lastPred == null || !t.Predicate.Equals (lastPred)) {  			//Terminate previous Predicate Object list  			context.Output.WriteLine (";");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' subjIndent));  			//Write the next Predicate  			temp = this.GenerateNodeOutput (globalContext' context' t.Predicate' TripleSegment.Predicate);  			context.Output.Write (temp);  			context.Output.Write (" ");  			predIndent = temp.Length + 1;  			lastPred = t.Predicate;  		}  		else {  			//Continue Object List  			context.Output.WriteLine ("'");  			if (context.PrettyPrint)  				context.Output.Write (new String (' '' subjIndent + predIndent));  		}  		//Write the Object  		context.Output.Write (this.GenerateNodeOutput (globalContext' context' t.Object' TripleSegment.Object));  	}  	//Terminate Triples  	if (ts.Count > 0)  		context.Output.WriteLine (".");  }  
Magic Number,VDS.RDF.Writing,WriterHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\WriterUtilities.cs,FindCollections,The following statement contains a magic number: foreach (KeyValuePair<INode' OutputRdfCollection> kvp in cs) {  	OutputRdfCollection c = kvp.Value;  	if (c.IsExplicit) {  		//For explicit collections if all Triples mentioning the Target Blank Node are in the Collection then can't compress  		//If there are no Triples in the Collection then this is a single use Blank Node so can always compress  		if (c.Triples.Count > 0 && c.Triples.Count == context.Graph.GetTriples (kvp.Key).Count ()) {  			context.Collections.Remove (kvp.Key);  		}  	}  	else {  		//For implicit collections if the number of Triples in the Collection is exactly ((t*3) - 1) those in the Graph then  		//can't compress i.e. the collection is not linked to anything else  		//Or if the number of mentions compared to the expected mentions differs by more than 1 then  		//can't compress i.e. the collection is linked to more than one thing  		int mentions = context.Graph.GetTriples (kvp.Key).Count ();  		int expectedMentions = ((c.Triples.Count * 3) - 1);  		if (expectedMentions == mentions || mentions - expectedMentions != 1) {  			context.Collections.Remove (kvp.Key);  		}  	}  }  
Magic Number,VDS.RDF.Writing,WriterHelper,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\WriterUtilities.cs,FindCollections,The following statement contains a magic number: if (c.IsExplicit) {  	//For explicit collections if all Triples mentioning the Target Blank Node are in the Collection then can't compress  	//If there are no Triples in the Collection then this is a single use Blank Node so can always compress  	if (c.Triples.Count > 0 && c.Triples.Count == context.Graph.GetTriples (kvp.Key).Count ()) {  		context.Collections.Remove (kvp.Key);  	}  }  else {  	//For implicit collections if the number of Triples in the Collection is exactly ((t*3) - 1) those in the Graph then  	//can't compress i.e. the collection is not linked to anything else  	//Or if the number of mentions compared to the expected mentions differs by more than 1 then  	//can't compress i.e. the collection is linked to more than one thing  	int mentions = context.Graph.GetTriples (kvp.Key).Count ();  	int expectedMentions = ((c.Triples.Count * 3) - 1);  	if (expectedMentions == mentions || mentions - expectedMentions != 1) {  		context.Collections.Remove (kvp.Key);  	}  }  
Magic Number,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The following statement contains a magic number: if (subj.NodeType == NodeType.Uri) {  	context.Writer.WriteAttributeString ("rdf"' "about"' NamespaceMapper.RDF' Uri.EscapeUriString (subj.ToString ()));  }  else {  	//Can omit the rdf:nodeID if nesting level is > 2 i.e. not a top level subject node  	if (context.NamespaceMap.NestingLevel <= 2) {  		context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)subj).InternalID));  	}  }  
Magic Number,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateSubjectOutput,The following statement contains a magic number: if (context.NamespaceMap.NestingLevel <= 2) {  	context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)subj).InternalID));  }  
Magic Number,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (!c.IsExplicit) {  	if (context.NamespaceMap.NestingLevel > 2) {  		//Need to set the Predicate to have a rdf:parseType of Resource  		context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  	}  	int length = c.Triples.Count;  	while (c.Triples.Count > 0) {  		//Get the Next Item and generate the rdf:first element  		INode next = c.Triples.First ().Object;  		c.Triples.RemoveAt (0);  		context.NamespaceMap.IncrementNesting ();  		context.Writer.WriteStartElement ("rdf"' "first"' NamespaceMapper.RDF);  		//Set the value of the rdf:first Item  		switch (next.NodeType) {  		case NodeType.Blank:  			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)next).InternalID));  			break;  		case NodeType.GraphLiteral:  			throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  		case NodeType.Literal:  			this.GenerateLiteralOutput (context' (ILiteralNode)next);  			break;  		case NodeType.Uri:  			this.GenerateUriOutput (context' (IUriNode)next' "rdf:resource");  			break;  		default:  			throw new RdfOutputException (WriterErrorMessages.UnknownNodeTypeUnserializable ("RDF/XML"));  		}  		//Now generate the rdf:rest element  		context.NamespaceMap.DecrementNesting ();  		context.Writer.WriteEndElement ();  		context.NamespaceMap.IncrementNesting ();  		context.Writer.WriteStartElement ("rdf"' "rest"' NamespaceMapper.RDF);  		if (c.Triples.Count >= 1) {  			//Set Parse Type to resource  			context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  		}  		else {  			//Terminate list with an rdf:nil  			context.Writer.WriteStartAttribute ("rdf"' "resource"' NamespaceMapper.RDF);  			context.Writer.WriteRaw ("&rdf;nil");  			context.Writer.WriteEndAttribute ();  		}  	}  	for (int i = 0; i < length; i++) {  		context.NamespaceMap.DecrementNesting ();  		context.Writer.WriteEndElement ();  	}  }  else {  	if (c.Triples.Count == 0) {  		//Terminate the Blank Node triple by adding a rdf:nodeID attribute  		context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  	}  	else {  		//Need to set the Predicate to have a rdf:parseType of Resource  		if (context.NamespaceMap.NestingLevel > 2) {  			//Need to set the Predicate to have a rdf:parseType of Resource  			context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  		}  		//Output the Predicate Object list  		while (c.Triples.Count > 0) {  			Triple t = c.Triples [0];  			c.Triples.RemoveAt (0);  			INode nextPred = t.Predicate;  			INode nextObj = t.Object;  			//Generate the predicate  			this.GeneratePredicateNode (context' nextPred);  			//Output the Object  			switch (nextObj.NodeType) {  			case NodeType.Blank:  				if (context.Collections.ContainsKey (nextObj)) {  					//Output a Collection  					this.GenerateCollectionOutput (context' nextObj);  				}  				else {  					context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  				}  				break;  			case NodeType.GraphLiteral:  				throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  			case NodeType.Literal:  				this.GenerateLiteralOutput (context' (ILiteralNode)nextObj);  				break;  			case NodeType.Uri:  				this.GenerateUriOutput (context' (IUriNode)nextObj' "rdf:resource");  				break;  			default:  				throw new RdfOutputException (WriterErrorMessages.UnknownNodeTypeUnserializable ("RDF/XML"));  			}  			context.Writer.WriteEndElement ();  		}  	}  }  
Magic Number,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (!c.IsExplicit) {  	if (context.NamespaceMap.NestingLevel > 2) {  		//Need to set the Predicate to have a rdf:parseType of Resource  		context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  	}  	int length = c.Triples.Count;  	while (c.Triples.Count > 0) {  		//Get the Next Item and generate the rdf:first element  		INode next = c.Triples.First ().Object;  		c.Triples.RemoveAt (0);  		context.NamespaceMap.IncrementNesting ();  		context.Writer.WriteStartElement ("rdf"' "first"' NamespaceMapper.RDF);  		//Set the value of the rdf:first Item  		switch (next.NodeType) {  		case NodeType.Blank:  			context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)next).InternalID));  			break;  		case NodeType.GraphLiteral:  			throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  		case NodeType.Literal:  			this.GenerateLiteralOutput (context' (ILiteralNode)next);  			break;  		case NodeType.Uri:  			this.GenerateUriOutput (context' (IUriNode)next' "rdf:resource");  			break;  		default:  			throw new RdfOutputException (WriterErrorMessages.UnknownNodeTypeUnserializable ("RDF/XML"));  		}  		//Now generate the rdf:rest element  		context.NamespaceMap.DecrementNesting ();  		context.Writer.WriteEndElement ();  		context.NamespaceMap.IncrementNesting ();  		context.Writer.WriteStartElement ("rdf"' "rest"' NamespaceMapper.RDF);  		if (c.Triples.Count >= 1) {  			//Set Parse Type to resource  			context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  		}  		else {  			//Terminate list with an rdf:nil  			context.Writer.WriteStartAttribute ("rdf"' "resource"' NamespaceMapper.RDF);  			context.Writer.WriteRaw ("&rdf;nil");  			context.Writer.WriteEndAttribute ();  		}  	}  	for (int i = 0; i < length; i++) {  		context.NamespaceMap.DecrementNesting ();  		context.Writer.WriteEndElement ();  	}  }  else {  	if (c.Triples.Count == 0) {  		//Terminate the Blank Node triple by adding a rdf:nodeID attribute  		context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  	}  	else {  		//Need to set the Predicate to have a rdf:parseType of Resource  		if (context.NamespaceMap.NestingLevel > 2) {  			//Need to set the Predicate to have a rdf:parseType of Resource  			context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  		}  		//Output the Predicate Object list  		while (c.Triples.Count > 0) {  			Triple t = c.Triples [0];  			c.Triples.RemoveAt (0);  			INode nextPred = t.Predicate;  			INode nextObj = t.Object;  			//Generate the predicate  			this.GeneratePredicateNode (context' nextPred);  			//Output the Object  			switch (nextObj.NodeType) {  			case NodeType.Blank:  				if (context.Collections.ContainsKey (nextObj)) {  					//Output a Collection  					this.GenerateCollectionOutput (context' nextObj);  				}  				else {  					context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  				}  				break;  			case NodeType.GraphLiteral:  				throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  			case NodeType.Literal:  				this.GenerateLiteralOutput (context' (ILiteralNode)nextObj);  				break;  			case NodeType.Uri:  				this.GenerateUriOutput (context' (IUriNode)nextObj' "rdf:resource");  				break;  			default:  				throw new RdfOutputException (WriterErrorMessages.UnknownNodeTypeUnserializable ("RDF/XML"));  			}  			context.Writer.WriteEndElement ();  		}  	}  }  
Magic Number,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (context.NamespaceMap.NestingLevel > 2) {  	//Need to set the Predicate to have a rdf:parseType of Resource  	context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  }  
Magic Number,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (c.Triples.Count == 0) {  	//Terminate the Blank Node triple by adding a rdf:nodeID attribute  	context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  }  else {  	//Need to set the Predicate to have a rdf:parseType of Resource  	if (context.NamespaceMap.NestingLevel > 2) {  		//Need to set the Predicate to have a rdf:parseType of Resource  		context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  	}  	//Output the Predicate Object list  	while (c.Triples.Count > 0) {  		Triple t = c.Triples [0];  		c.Triples.RemoveAt (0);  		INode nextPred = t.Predicate;  		INode nextObj = t.Object;  		//Generate the predicate  		this.GeneratePredicateNode (context' nextPred);  		//Output the Object  		switch (nextObj.NodeType) {  		case NodeType.Blank:  			if (context.Collections.ContainsKey (nextObj)) {  				//Output a Collection  				this.GenerateCollectionOutput (context' nextObj);  			}  			else {  				context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)key).InternalID));  			}  			break;  		case NodeType.GraphLiteral:  			throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  		case NodeType.Literal:  			this.GenerateLiteralOutput (context' (ILiteralNode)nextObj);  			break;  		case NodeType.Uri:  			this.GenerateUriOutput (context' (IUriNode)nextObj' "rdf:resource");  			break;  		default:  			throw new RdfOutputException (WriterErrorMessages.UnknownNodeTypeUnserializable ("RDF/XML"));  		}  		context.Writer.WriteEndElement ();  	}  }  
Magic Number,VDS.RDF.Writing,RdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfXmlWriter.cs,GenerateCollectionOutput,The following statement contains a magic number: if (context.NamespaceMap.NestingLevel > 2) {  	//Need to set the Predicate to have a rdf:parseType of Resource  	context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Resource");  }  
Magic Number,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateOutput,The following statement contains a magic number: if ((subjNodes / triples) > 0.75)  	hiSpeed = true;  
Magic Number,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,The following statement contains a magic number: if (!c.IsExplicit) {  	output.Append ('(');  	while (c.Triples.Count > 0) {  		if (context.PrettyPrint && !first)  			output.Append (new String (' '' indent));  		first = false;  		output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent));  		c.Triples.RemoveAt (0);  		if (c.Triples.Count > 0) {  			output.Append (' ');  		}  	}  	output.Append (')');  }  else {  	if (c.Triples.Count == 0) {  		//Empty Collection  		//Can represent as a single Blank Node []  		output.Append ("[]");  	}  	else {  		output.Append ('[');  		while (c.Triples.Count > 0) {  			if (context.PrettyPrint && !first)  				output.Append (new String (' '' indent));  			first = false;  			String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  			output.Append (temp);  			output.Append (' ');  			int addIndent;  			if (temp.Contains ('\n')) {  				addIndent = temp.Split ('\n').Last ().Length;  			}  			else {  				addIndent = temp.Length;  			}  			output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  			c.Triples.RemoveAt (0);  			if (c.Triples.Count > 0) {  				output.AppendLine (" ; ");  				output.Append (' ');  			}  		}  		output.Append (']');  	}  }  
Magic Number,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,The following statement contains a magic number: if (c.Triples.Count == 0) {  	//Empty Collection  	//Can represent as a single Blank Node []  	output.Append ("[]");  }  else {  	output.Append ('[');  	while (c.Triples.Count > 0) {  		if (context.PrettyPrint && !first)  			output.Append (new String (' '' indent));  		first = false;  		String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  		output.Append (temp);  		output.Append (' ');  		int addIndent;  		if (temp.Contains ('\n')) {  			addIndent = temp.Split ('\n').Last ().Length;  		}  		else {  			addIndent = temp.Length;  		}  		output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  		c.Triples.RemoveAt (0);  		if (c.Triples.Count > 0) {  			output.AppendLine (" ; ");  			output.Append (' ');  		}  	}  	output.Append (']');  }  
Magic Number,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,The following statement contains a magic number: while (c.Triples.Count > 0) {  	if (context.PrettyPrint && !first)  		output.Append (new String (' '' indent));  	first = false;  	String temp = this.GenerateNodeOutput (context' c.Triples.First ().Predicate' TripleSegment.Predicate' indent);  	output.Append (temp);  	output.Append (' ');  	int addIndent;  	if (temp.Contains ('\n')) {  		addIndent = temp.Split ('\n').Last ().Length;  	}  	else {  		addIndent = temp.Length;  	}  	output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  	c.Triples.RemoveAt (0);  	if (c.Triples.Count > 0) {  		output.AppendLine (" ; ");  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing,Notation3Writer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Notation3Writer.cs,GenerateCollectionOutput,The following statement contains a magic number: output.Append (this.GenerateNodeOutput (context' c.Triples.First ().Object' TripleSegment.Object' indent + 2 + addIndent));  
Magic Number,VDS.RDF.Writing,TriXWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriXWriter.cs,GraphToTriX,The following statement contains a magic number: if (!WriterHelper.IsDefaultGraph (g.BaseUri)) {  	if (!g.BaseUri.ToString ().StartsWith ("trix:local:")) {  		writer.WriteStartElement ("uri");  		writer.WriteRaw (WriterHelper.EncodeForXml (g.BaseUri.ToString ()));  		writer.WriteEndElement ();  	}  	else {  		writer.WriteStartElement ("id");  		writer.WriteRaw (WriterHelper.EncodeForXml (g.BaseUri.ToString ().Substring (11)));  		writer.WriteEndElement ();  	}  }  
Magic Number,VDS.RDF.Writing,TriXWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriXWriter.cs,GraphToTriX,The following statement contains a magic number: if (!g.BaseUri.ToString ().StartsWith ("trix:local:")) {  	writer.WriteStartElement ("uri");  	writer.WriteRaw (WriterHelper.EncodeForXml (g.BaseUri.ToString ()));  	writer.WriteEndElement ();  }  else {  	writer.WriteStartElement ("id");  	writer.WriteRaw (WriterHelper.EncodeForXml (g.BaseUri.ToString ().Substring (11)));  	writer.WriteEndElement ();  }  
Magic Number,VDS.RDF.Writing,TriXWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TriXWriter.cs,GraphToTriX,The following statement contains a magic number: writer.WriteRaw (WriterHelper.EncodeForXml (g.BaseUri.ToString ().Substring (11)));  
Magic Number,VDS.RDF.Writing,TurtleWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\TurtleWriter.cs,GenerateOutput,The following statement contains a magic number: if ((subjNodes / triples) > 0.75)  	hiSpeed = true;  
Magic Number,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,TryGetDataType,The following statement contains a magic number: if (next == '<') {  	//Uri for Data Type  	IToken temp = this.TryGetUri ();  	if (this._nquadsMode) {  		//Wrap in a DataType token  		return new DataTypeToken ("<" + temp.Value + ">"' temp.StartLine' temp.StartPosition - 3' temp.EndPosition + 1);  	}  	else {  		return temp;  	}  }  else {  	throw UnexpectedCharacter (next' "expected a < to start a URI to specify a Data Type for a Typed Literal");  }  
Magic Number,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,TryGetDataType,The following statement contains a magic number: if (this._nquadsMode) {  	//Wrap in a DataType token  	return new DataTypeToken ("<" + temp.Value + ">"' temp.StartLine' temp.StartPosition - 3' temp.EndPosition + 1);  }  else {  	return temp;  }  
Magic Number,VDS.RDF.Parsing.Tokens,NTriplesTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\NTriplesTokeniser.cs,TryGetDataType,The following statement contains a magic number: return new DataTypeToken ("<" + temp.Value + ">"' temp.StartLine' temp.StartPosition - 3' temp.EndPosition + 1);  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: switch (next) {  case '\\':  	//Backslash escape  	if (mode != TokeniserEscapeMode.QName) {  		//Consume this one Backslash  		this.ConsumeCharacter ();  		//If this was a backslash escape i.e. \\  		//Then need to check whether the subsequent character could be confused with a valid escape  		//in the tokenised output and if so insert another backslash into the output  		next = this.Peek ();  		switch (next) {  		case 't':  		case 'n':  		case 'r':  		case 'u':  		case 'U':  			this._output.Append ("\\");  			break;  		}  		return;  	}  	else {  		goto default;  	}  case '"':  	//Quote escape (only valid in Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiterals || mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '\'':  	//Single Quote Escape (only valid in Alternate Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '>':  	//End Uri Escape (only valid in URIs)  	if (mode == TokeniserEscapeMode.Uri) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  #region White Space Escapes  case 'n':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\n");  		return;  	}  	else {  		goto default;  	}  case 'r':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\r");  		return;  	}  	else {  		goto default;  	}  case 't':  	//Tab Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real Tab to the output  		this.SkipCharacter ();  		this._output.Append ("\t");  		return;  	}  	else {  		goto default;  	}  #endregion  #region Unicode Escapes  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  #endregion  default:  	//Not an escape character  	if (mode != TokeniserEscapeMode.QName) {  		//Append the \ and then return  		//Processing continues normally in the caller function  		this._output.Append ("\\");  		return;  	}  	else {  		throw Error ("Unexpected Backslash Character encountered in a QName' the Backslash Character can only be used for Unicode escapes (\\u and \\U) in QNames");  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: switch (next) {  case '\\':  	//Backslash escape  	if (mode != TokeniserEscapeMode.QName) {  		//Consume this one Backslash  		this.ConsumeCharacter ();  		//If this was a backslash escape i.e. \\  		//Then need to check whether the subsequent character could be confused with a valid escape  		//in the tokenised output and if so insert another backslash into the output  		next = this.Peek ();  		switch (next) {  		case 't':  		case 'n':  		case 'r':  		case 'u':  		case 'U':  			this._output.Append ("\\");  			break;  		}  		return;  	}  	else {  		goto default;  	}  case '"':  	//Quote escape (only valid in Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiterals || mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '\'':  	//Single Quote Escape (only valid in Alternate Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '>':  	//End Uri Escape (only valid in URIs)  	if (mode == TokeniserEscapeMode.Uri) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  #region White Space Escapes  case 'n':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\n");  		return;  	}  	else {  		goto default;  	}  case 'r':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\r");  		return;  	}  	else {  		goto default;  	}  case 't':  	//Tab Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real Tab to the output  		this.SkipCharacter ();  		this._output.Append ("\t");  		return;  	}  	else {  		goto default;  	}  #endregion  #region Unicode Escapes  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  #endregion  default:  	//Not an escape character  	if (mode != TokeniserEscapeMode.QName) {  		//Append the \ and then return  		//Processing continues normally in the caller function  		this._output.Append ("\\");  		return;  	}  	else {  		throw Error ("Unexpected Backslash Character encountered in a QName' the Backslash Character can only be used for Unicode escapes (\\u and \\U) in QNames");  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: switch (next) {  case '\\':  	//Backslash escape  	if (mode != TokeniserEscapeMode.QName) {  		//Consume this one Backslash  		this.ConsumeCharacter ();  		//If this was a backslash escape i.e. \\  		//Then need to check whether the subsequent character could be confused with a valid escape  		//in the tokenised output and if so insert another backslash into the output  		next = this.Peek ();  		switch (next) {  		case 't':  		case 'n':  		case 'r':  		case 'u':  		case 'U':  			this._output.Append ("\\");  			break;  		}  		return;  	}  	else {  		goto default;  	}  case '"':  	//Quote escape (only valid in Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiterals || mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '\'':  	//Single Quote Escape (only valid in Alternate Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '>':  	//End Uri Escape (only valid in URIs)  	if (mode == TokeniserEscapeMode.Uri) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  #region White Space Escapes  case 'n':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\n");  		return;  	}  	else {  		goto default;  	}  case 'r':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\r");  		return;  	}  	else {  		goto default;  	}  case 't':  	//Tab Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real Tab to the output  		this.SkipCharacter ();  		this._output.Append ("\t");  		return;  	}  	else {  		goto default;  	}  #endregion  #region Unicode Escapes  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  #endregion  default:  	//Not an escape character  	if (mode != TokeniserEscapeMode.QName) {  		//Append the \ and then return  		//Processing continues normally in the caller function  		this._output.Append ("\\");  		return;  	}  	else {  		throw Error ("Unexpected Backslash Character encountered in a QName' the Backslash Character can only be used for Unicode escapes (\\u and \\U) in QNames");  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: switch (next) {  case '\\':  	//Backslash escape  	if (mode != TokeniserEscapeMode.QName) {  		//Consume this one Backslash  		this.ConsumeCharacter ();  		//If this was a backslash escape i.e. \\  		//Then need to check whether the subsequent character could be confused with a valid escape  		//in the tokenised output and if so insert another backslash into the output  		next = this.Peek ();  		switch (next) {  		case 't':  		case 'n':  		case 'r':  		case 'u':  		case 'U':  			this._output.Append ("\\");  			break;  		}  		return;  	}  	else {  		goto default;  	}  case '"':  	//Quote escape (only valid in Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiterals || mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '\'':  	//Single Quote Escape (only valid in Alternate Quoted Literals)  	if (mode == TokeniserEscapeMode.QuotedLiteralsAlternate) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  case '>':  	//End Uri Escape (only valid in URIs)  	if (mode == TokeniserEscapeMode.Uri) {  		//Consume and return  		this.ConsumeCharacter ();  		return;  	}  	else {  		goto default;  	}  #region White Space Escapes  case 'n':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\n");  		return;  	}  	else {  		goto default;  	}  case 'r':  	//New Line Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real New Line to the output  		this.SkipCharacter ();  		this._output.Append ("\r");  		return;  	}  	else {  		goto default;  	}  case 't':  	//Tab Escape  	if (mode != TokeniserEscapeMode.QName) {  		//Discard and append a real Tab to the output  		this.SkipCharacter ();  		this._output.Append ("\t");  		return;  	}  	else {  		goto default;  	}  #endregion  #region Unicode Escapes  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  #endregion  default:  	//Not an escape character  	if (mode != TokeniserEscapeMode.QName) {  		//Append the \ and then return  		//Processing continues normally in the caller function  		this._output.Append ("\\");  		return;  	}  	else {  		throw Error ("Unexpected Backslash Character encountered in a QName' the Backslash Character can only be used for Unicode escapes (\\u and \\U) in QNames");  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: while (localOutput.Length < 4 && this.IsHexDigit (next)) {  	localOutput.Append (next);  	this.SkipCharacter ();  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: if (localOutput.Length != 4) {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  }  else if (localOutput.ToString ().Equals ("0000")) {  	//Ignore the null escape  }  else {  	this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: while (localOutput.Length < 8 && this.IsHexDigit (next)) {  	localOutput.Append (next);  	this.SkipCharacter ();  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following statement contains a magic number: if (localOutput.Length != 8) {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  }  else if (localOutput.ToString ().Equals ("00000000")) {  	//Ignore the null escape  }  else {  	this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '\\') {  	//Backslash based escape  	next = this.Peek ();  	switch (next) {  	case '_':  	case '-':  	case '.':  	case '|':  	case '$':  	case '&':  	case '\'':  	case '(':  	case ')':  	case '*':  	case '+':  	case ''':  	case ';':  	case '=':  	case ':':  	case '/':  	case '?':  	case '#':  	case '@':  	case '%':  		//Escapable Characters  		this._output.Append ('\\');  		this.ConsumeCharacter ();  		return;  	case 'u':  		//Need to consume the u first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Four Hex Digits  		while (localOutput.Length < 4 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get four Hex Digits  		if (localOutput.Length != 4) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("0000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	case 'U':  		//Need to consume the U first  		localOutput = new StringBuilder ();  		this.SkipCharacter ();  		next = this.Peek ();  		//Try to get Eight Hex Digits  		while (localOutput.Length < 8 && this.IsHexDigit (next)) {  			localOutput.Append (next);  			this.SkipCharacter ();  			next = this.Peek ();  		}  		//Did we get eight Hex Digits  		if (localOutput.Length != 8) {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  		}  		else if (localOutput.ToString ().Equals ("00000000")) {  			//Ignore the null escape  		}  		else {  			this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  		}  		return;  	default:  		throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  	}  }  else if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: switch (next) {  case '_':  case '-':  case '.':  case '|':  case '$':  case '&':  case '\'':  case '(':  case ')':  case '*':  case '+':  case ''':  case ';':  case '=':  case ':':  case '/':  case '?':  case '#':  case '@':  case '%':  	//Escapable Characters  	this._output.Append ('\\');  	this.ConsumeCharacter ();  	return;  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  default:  	throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: switch (next) {  case '_':  case '-':  case '.':  case '|':  case '$':  case '&':  case '\'':  case '(':  case ')':  case '*':  case '+':  case ''':  case ';':  case '=':  case ':':  case '/':  case '?':  case '#':  case '@':  case '%':  	//Escapable Characters  	this._output.Append ('\\');  	this.ConsumeCharacter ();  	return;  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  default:  	throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: switch (next) {  case '_':  case '-':  case '.':  case '|':  case '$':  case '&':  case '\'':  case '(':  case ')':  case '*':  case '+':  case ''':  case ';':  case '=':  case ':':  case '/':  case '?':  case '#':  case '@':  case '%':  	//Escapable Characters  	this._output.Append ('\\');  	this.ConsumeCharacter ();  	return;  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  default:  	throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: switch (next) {  case '_':  case '-':  case '.':  case '|':  case '$':  case '&':  case '\'':  case '(':  case ')':  case '*':  case '+':  case ''':  case ';':  case '=':  case ':':  case '/':  case '?':  case '#':  case '@':  case '%':  	//Escapable Characters  	this._output.Append ('\\');  	this.ConsumeCharacter ();  	return;  case 'u':  	//Need to consume the u first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Four Hex Digits  	while (localOutput.Length < 4 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get four Hex Digits  	if (localOutput.Length != 4) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("0000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  case 'U':  	//Need to consume the U first  	localOutput = new StringBuilder ();  	this.SkipCharacter ();  	next = this.Peek ();  	//Try to get Eight Hex Digits  	while (localOutput.Length < 8 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get eight Hex Digits  	if (localOutput.Length != 8) {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  	}  	else if (localOutput.ToString ().Equals ("00000000")) {  		//Ignore the null escape  	}  	else {  		this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  	}  	return;  default:  	throw Error ("Unexpected Backslash Character encountered in a Local Name' the Backslash Character can only be used for Unicode escapes (\\u and \\U) and a limited set of special characters (_-.|&'()*+';=/?#@%) in Local Names");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: while (localOutput.Length < 4 && this.IsHexDigit (next)) {  	localOutput.Append (next);  	this.SkipCharacter ();  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (localOutput.Length != 4) {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\u Escape must be followed by four Hex Digits");  }  else if (localOutput.ToString ().Equals ("0000")) {  	//Ignore the null escape  }  else {  	this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: while (localOutput.Length < 8 && this.IsHexDigit (next)) {  	localOutput.Append (next);  	this.SkipCharacter ();  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (localOutput.Length != 8) {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + " encountered while trying to parse Unicode Escape from Content:\n" + this._output.ToString () + "\nThe \\U Escape must be followed by eight Hex Digits");  }  else if (localOutput.ToString ().Equals ("00000000")) {  	//Ignore the null escape  }  else {  	this._output.Append (UnicodeSpecsHelper.ConvertToChar (localOutput.ToString ()));  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (next == '%') {  	localOutput = new StringBuilder ();  	localOutput.Append (next);  	next = this.Peek ();  	while (localOutput.Length < 3 && this.IsHexDigit (next)) {  		localOutput.Append (next);  		this.SkipCharacter ();  		next = this.Peek ();  	}  	//Did we get % followed by two hex digits  	if (localOutput.Length != 3) {  		throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  	}  	#if !SILVERLIGHT  	else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  	#else  	                else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif  	 {  		throw Error ("Invalid % encoded character encountered");  	}  	else {  		this._output.Append (localOutput.ToString ());  	}  }  else {  	throw Error ("HandleSparqlLocalNameEscapes() was called but the next character is not a % or \\ as expected");  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: while (localOutput.Length < 3 && this.IsHexDigit (next)) {  	localOutput.Append (next);  	this.SkipCharacter ();  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleSparqlLocalNameEscapes,The following statement contains a magic number: if (localOutput.Length != 3) {  	throw Error ("Encountered a % character in a Local Name but the required two hex digits were not present after it' please use \\% if you wish to represent the percent character");  }  #if !SILVERLIGHT  else if (!Uri.IsHexEncoding (localOutput.ToString ()' 0))  #else                  else if (SilverlightExtensions.IsHexEncoding(localOutput.ToString()' 0)) #endif   {  	throw Error ("Invalid % encoded character encountered");  }  else {  	this._output.Append (localOutput.ToString ());  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Dequeue,The following statement contains a magic number: if (this._tokens.Count > 0) {  	try {  		Monitor.Enter (this._tokens);  		return base.Dequeue ();  	}  	finally {  		Monitor.Exit (this._tokens);  	}  }  else {  	if (!this._finished) {  		//Wait for something to be Tokenised  		while (this._tokens.Count == 0) {  			Thread.Sleep (50);  		}  	}  	try {  		Monitor.Enter (this._tokens);  		return base.Dequeue ();  	}  	finally {  		Monitor.Exit (this._tokens);  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Dequeue,The following statement contains a magic number: if (!this._finished) {  	//Wait for something to be Tokenised  	while (this._tokens.Count == 0) {  		Thread.Sleep (50);  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Dequeue,The following statement contains a magic number: while (this._tokens.Count == 0) {  	Thread.Sleep (50);  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Dequeue,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Peek,The following statement contains a magic number: if (this._tokens.Count > 0) {  	try {  		Monitor.Enter (this._tokens);  		return base.Peek ();  	}  	finally {  		Monitor.Enter (this._tokens);  	}  }  else {  	if (!this._finished) {  		//Wait for something to be Tokenised  		while (this._tokens.Count == 0) {  			Thread.Sleep (50);  		}  	}  	try {  		Monitor.Enter (this._tokens);  		return base.Peek ();  	}  	finally {  		Monitor.Enter (this._tokens);  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Peek,The following statement contains a magic number: if (!this._finished) {  	//Wait for something to be Tokenised  	while (this._tokens.Count == 0) {  		Thread.Sleep (50);  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Peek,The following statement contains a magic number: while (this._tokens.Count == 0) {  	Thread.Sleep (50);  }  
Magic Number,VDS.RDF.Parsing.Tokens,AsynchronousBufferedTokenQueue,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BufferedTokenQueue.cs,Peek,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The following statement contains a magic number: while (Char.IsDigit (next) || next == '-' || next == '+' || next == 'e' || next == 'E' || (next == '.' && !dotoccurred)) {  	//Consume the Character  	this.ConsumeCharacter ();  	if (next == '-' || next == '+') {  		if (signoccurred || expoccurred) {  			char last = this.Value [this.Value.Length - 2];  			if (expoccurred) {  				if (last != 'e' && last != 'E') {  					//Can't occur here as isn't directly after the exponent  					throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  				}  			}  			else {  				//Negative sign already seen  				throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  			}  		}  		else {  			signoccurred = true;  			//Check this is at the start of the string  			if (this.Length > 1) {  				throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  			}  		}  	}  	else if (next == 'e' || next == 'E') {  		if (expoccurred) {  			//Exponent already seen  			throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier can only occur once in a Numeric Literal");  		}  		else {  			expoccurred = true;  			//Check that it isn't the start of the string  			if (this.Length == 1) {  				throw UnexpectedCharacter (next' "The Exponent specifier cannot occur at the start of a Numeric Literal");  			}  		}  	}  	else if (next == '.') {  		dotoccurred = true;  	}  	next = this.Peek ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The following statement contains a magic number: if (next == '-' || next == '+') {  	if (signoccurred || expoccurred) {  		char last = this.Value [this.Value.Length - 2];  		if (expoccurred) {  			if (last != 'e' && last != 'E') {  				//Can't occur here as isn't directly after the exponent  				throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  			}  		}  		else {  			//Negative sign already seen  			throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  		}  	}  	else {  		signoccurred = true;  		//Check this is at the start of the string  		if (this.Length > 1) {  			throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  		}  	}  }  else if (next == 'e' || next == 'E') {  	if (expoccurred) {  		//Exponent already seen  		throw Error ("Unexpected Character (Code " + (int)next + " e\nThe Exponent specifier can only occur once in a Numeric Literal");  	}  	else {  		expoccurred = true;  		//Check that it isn't the start of the string  		if (this.Length == 1) {  			throw UnexpectedCharacter (next' "The Exponent specifier cannot occur at the start of a Numeric Literal");  		}  	}  }  else if (next == '.') {  	dotoccurred = true;  }  
Magic Number,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetNumericLiteral,The following statement contains a magic number: if (signoccurred || expoccurred) {  	char last = this.Value [this.Value.Length - 2];  	if (expoccurred) {  		if (last != 'e' && last != 'E') {  			//Can't occur here as isn't directly after the exponent  			throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  		}  	}  	else {  		//Negative sign already seen  		throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  	}  }  else {  	signoccurred = true;  	//Check this is at the start of the string  	if (this.Length > 1) {  		throw UnexpectedCharacter (next' "The +/- Sign can only occur at the start of a Numeric Literal or at the start of the Exponent");  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: do {  	switch (directiveExpected) {  	case -1:  		//Not sure which directive we might see yet  		if (next == 'b' || next == 'B') {  			directiveExpected = 2;  		}  		else if (next == 'p' || next == 'P') {  			directiveExpected = 1;  		}  		else if (next == 'k' || next == 'K') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  		}  		else if (next == 'f' || next == 'F') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  		}  		else {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  		}  		break;  	case 1:  		//Expecting a Prefix Directive  		while (this.Length < 6) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Prefix Directive  			this.LastTokenType = Token.PREFIXDIRECTIVE;  			return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			//Not what we expected so Error  			throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  		}  	case 2:  		//Expecting a Base Directive  		while (this.Length < 4) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Base Directive  			this.LastTokenType = Token.BASEDIRECTIVE;  			return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			throw Error ("Expected a Base Directive and got '" + this.Value + "'");  		}  	default:  		throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  	}  	//Should only hit this once when we do the first case to decide which directive we'll get  }  while (true);  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: do {  	switch (directiveExpected) {  	case -1:  		//Not sure which directive we might see yet  		if (next == 'b' || next == 'B') {  			directiveExpected = 2;  		}  		else if (next == 'p' || next == 'P') {  			directiveExpected = 1;  		}  		else if (next == 'k' || next == 'K') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  		}  		else if (next == 'f' || next == 'F') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  		}  		else {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  		}  		break;  	case 1:  		//Expecting a Prefix Directive  		while (this.Length < 6) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Prefix Directive  			this.LastTokenType = Token.PREFIXDIRECTIVE;  			return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			//Not what we expected so Error  			throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  		}  	case 2:  		//Expecting a Base Directive  		while (this.Length < 4) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Base Directive  			this.LastTokenType = Token.BASEDIRECTIVE;  			return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			throw Error ("Expected a Base Directive and got '" + this.Value + "'");  		}  	default:  		throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  	}  	//Should only hit this once when we do the first case to decide which directive we'll get  }  while (true);  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: do {  	switch (directiveExpected) {  	case -1:  		//Not sure which directive we might see yet  		if (next == 'b' || next == 'B') {  			directiveExpected = 2;  		}  		else if (next == 'p' || next == 'P') {  			directiveExpected = 1;  		}  		else if (next == 'k' || next == 'K') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  		}  		else if (next == 'f' || next == 'F') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  		}  		else {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  		}  		break;  	case 1:  		//Expecting a Prefix Directive  		while (this.Length < 6) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Prefix Directive  			this.LastTokenType = Token.PREFIXDIRECTIVE;  			return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			//Not what we expected so Error  			throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  		}  	case 2:  		//Expecting a Base Directive  		while (this.Length < 4) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Base Directive  			this.LastTokenType = Token.BASEDIRECTIVE;  			return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			throw Error ("Expected a Base Directive and got '" + this.Value + "'");  		}  	default:  		throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  	}  	//Should only hit this once when we do the first case to decide which directive we'll get  }  while (true);  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: do {  	switch (directiveExpected) {  	case -1:  		//Not sure which directive we might see yet  		if (next == 'b' || next == 'B') {  			directiveExpected = 2;  		}  		else if (next == 'p' || next == 'P') {  			directiveExpected = 1;  		}  		else if (next == 'k' || next == 'K') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  		}  		else if (next == 'f' || next == 'F') {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  		}  		else {  			throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  		}  		break;  	case 1:  		//Expecting a Prefix Directive  		while (this.Length < 6) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Prefix Directive  			this.LastTokenType = Token.PREFIXDIRECTIVE;  			return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			//Not what we expected so Error  			throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  		}  	case 2:  		//Expecting a Base Directive  		while (this.Length < 4) {  			this.ConsumeCharacter ();  		}  		if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  			//Got a Base Directive  			this.LastTokenType = Token.BASEDIRECTIVE;  			return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  		}  		else {  			throw Error ("Expected a Base Directive and got '" + this.Value + "'");  		}  	default:  		throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  	}  	//Should only hit this once when we do the first case to decide which directive we'll get  }  while (true);  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: switch (directiveExpected) {  case -1:  	//Not sure which directive we might see yet  	if (next == 'b' || next == 'B') {  		directiveExpected = 2;  	}  	else if (next == 'p' || next == 'P') {  		directiveExpected = 1;  	}  	else if (next == 'k' || next == 'K') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  	}  	else if (next == 'f' || next == 'F') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  	}  	else {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  	}  	break;  case 1:  	//Expecting a Prefix Directive  	while (this.Length < 6) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Prefix Directive  		this.LastTokenType = Token.PREFIXDIRECTIVE;  		return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		//Not what we expected so Error  		throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  	}  case 2:  	//Expecting a Base Directive  	while (this.Length < 4) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Base Directive  		this.LastTokenType = Token.BASEDIRECTIVE;  		return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		throw Error ("Expected a Base Directive and got '" + this.Value + "'");  	}  default:  	throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: switch (directiveExpected) {  case -1:  	//Not sure which directive we might see yet  	if (next == 'b' || next == 'B') {  		directiveExpected = 2;  	}  	else if (next == 'p' || next == 'P') {  		directiveExpected = 1;  	}  	else if (next == 'k' || next == 'K') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  	}  	else if (next == 'f' || next == 'F') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  	}  	else {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  	}  	break;  case 1:  	//Expecting a Prefix Directive  	while (this.Length < 6) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Prefix Directive  		this.LastTokenType = Token.PREFIXDIRECTIVE;  		return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		//Not what we expected so Error  		throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  	}  case 2:  	//Expecting a Base Directive  	while (this.Length < 4) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Base Directive  		this.LastTokenType = Token.BASEDIRECTIVE;  		return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		throw Error ("Expected a Base Directive and got '" + this.Value + "'");  	}  default:  	throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: switch (directiveExpected) {  case -1:  	//Not sure which directive we might see yet  	if (next == 'b' || next == 'B') {  		directiveExpected = 2;  	}  	else if (next == 'p' || next == 'P') {  		directiveExpected = 1;  	}  	else if (next == 'k' || next == 'K') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  	}  	else if (next == 'f' || next == 'F') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  	}  	else {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  	}  	break;  case 1:  	//Expecting a Prefix Directive  	while (this.Length < 6) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Prefix Directive  		this.LastTokenType = Token.PREFIXDIRECTIVE;  		return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		//Not what we expected so Error  		throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  	}  case 2:  	//Expecting a Base Directive  	while (this.Length < 4) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Base Directive  		this.LastTokenType = Token.BASEDIRECTIVE;  		return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		throw Error ("Expected a Base Directive and got '" + this.Value + "'");  	}  default:  	throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: switch (directiveExpected) {  case -1:  	//Not sure which directive we might see yet  	if (next == 'b' || next == 'B') {  		directiveExpected = 2;  	}  	else if (next == 'p' || next == 'P') {  		directiveExpected = 1;  	}  	else if (next == 'k' || next == 'K') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  	}  	else if (next == 'f' || next == 'F') {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  	}  	else {  		throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  	}  	break;  case 1:  	//Expecting a Prefix Directive  	while (this.Length < 6) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("prefix"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Prefix Directive  		this.LastTokenType = Token.PREFIXDIRECTIVE;  		return new PrefixDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		//Not what we expected so Error  		throw Error ("Expected a Prefix Directive and got '" + this.Value + "'");  	}  case 2:  	//Expecting a Base Directive  	while (this.Length < 4) {  		this.ConsumeCharacter ();  	}  	if (this.Value.Equals ("base"' StringComparison.InvariantCultureIgnoreCase)) {  		//Got a Base Directive  		this.LastTokenType = Token.BASEDIRECTIVE;  		return new BaseDirectiveToken (this.CurrentLine' this.StartPosition);  	}  	else {  		throw Error ("Expected a Base Directive and got '" + this.Value + "'");  	}  default:  	throw Error ("Unknown Parsing Error in TurtleTokeniser.TryGetDirectiveToken()");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: if (next == 'b' || next == 'B') {  	directiveExpected = 2;  }  else if (next == 'p' || next == 'P') {  	directiveExpected = 1;  }  else if (next == 'k' || next == 'K') {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a Keywords Directive which is not valid in Turtle");  }  else if (next == 'f' || next == 'F') {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nThis appears to be the start of a forAll or forSome Quantification which is not valid in Turtle");  }  else {  	throw Error ("Unexpected Character (Code " + (int)next + "): " + next + "\nExpected the start of a Base/Prefix directive");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: directiveExpected = 2;  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: while (this.Length < 6) {  	this.ConsumeCharacter ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetDirectiveToken,The following statement contains a magic number: while (this.Length < 4) {  	this.ConsumeCharacter ();  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The following statement contains a magic number: if (colonoccurred && (!dotoccurred || this._syntax == TurtleSyntax.W3C)) {  	//A QName must contain a Colon at some point  	String qname = this.Value;  	//Was this a Blank Node  	if (qname.StartsWith ("_:")) {  		//Blank Node with an ID  		if (qname.Length == 2) {  			//No ID  			return new BlankNodeToken (this.CurrentLine' this.StartPosition);  		}  		else {  			//User specified ID  			return new BlankNodeWithIDToken (qname' this.CurrentLine' this.StartPosition' this.EndPosition);  		}  	}  	else if (qname.StartsWith ("-")) {  		//Illegal use of - to start a QName  		throw Error ("The - Character cannot be used at the start of a QName");  	}  	else if (qname.StartsWith (".")) {  		//Illegal use of . to start a QName  		throw Error ("The . Character cannot be used at the start of a QName");  	}  	else {  		if (qname.Length > 1) {  			//Check Illegal use of - or a Digit to start a Local Name  			String[] localname = qname.Split (':');  			if (localname [1].Length >= 1) {  				if (localname [1].StartsWith ("-")) {  					throw Error ("The - Character cannot be used as the start of a Local Name within a QName");  				}  				//Check for Illegal use of a Digit to start a Local Name  				char[] lnamechar = localname [1].Substring (0' 1).ToCharArray ();  				if (Char.IsDigit (lnamechar [0]) && this._syntax == TurtleSyntax.Original) {  					throw Error ("A Local Name within a QName may not start with a Number");  				}  			}  		}  		//QNames can't start with a Digit  		char[] firstchar = qname.Substring (0' 1).ToCharArray ();  		if (Char.IsDigit (firstchar [0])) {  			throw Error ("A QName may not start with a Number");  		}  		//Normal QName  		this.LastTokenType = Token.QNAME;  		return new QNameToken (qname' this.CurrentLine' this.StartPosition' this.EndPosition);  	}  }  else {  	//If we don't see a Colon then have to assume a Plain Literal  	//BUT we also need to check it's not a keyword  	String value = this.Value;  	if (value.Equals ("a")) {  		//The 'a' Keyword  		this.LastTokenType = Token.KEYWORDA;  		return new KeywordAToken (this.CurrentLine' this.StartPosition);  	}  	else if (value.Equals ("is")) {  		//This 'is' Keyword  		throw Error ("The 'is' Keyword is not Valid in Turtle");  	}  	else if (value.Equals ("of")) {  		//The 'of' Keyword  		throw Error ("The 'of' Keyword is not Valid in Turtle");  	}  	else {  		//Must be a Plain Literal  		if (!TurtleSpecsHelper.IsValidPlainLiteral (value' this._syntax)) {  			throw Error ("The value of the Plain Literal '" + value + "' is not valid in Turtle.  Turtle supports Boolean' Integer' Decimal and Double Plain Literals");  		}  		this.LastTokenType = Token.PLAINLITERAL;  		return new PlainLiteralToken (value' this.CurrentLine' this.StartPosition' this.EndPosition);  	}  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The following statement contains a magic number: if (qname.StartsWith ("_:")) {  	//Blank Node with an ID  	if (qname.Length == 2) {  		//No ID  		return new BlankNodeToken (this.CurrentLine' this.StartPosition);  	}  	else {  		//User specified ID  		return new BlankNodeWithIDToken (qname' this.CurrentLine' this.StartPosition' this.EndPosition);  	}  }  else if (qname.StartsWith ("-")) {  	//Illegal use of - to start a QName  	throw Error ("The - Character cannot be used at the start of a QName");  }  else if (qname.StartsWith (".")) {  	//Illegal use of . to start a QName  	throw Error ("The . Character cannot be used at the start of a QName");  }  else {  	if (qname.Length > 1) {  		//Check Illegal use of - or a Digit to start a Local Name  		String[] localname = qname.Split (':');  		if (localname [1].Length >= 1) {  			if (localname [1].StartsWith ("-")) {  				throw Error ("The - Character cannot be used as the start of a Local Name within a QName");  			}  			//Check for Illegal use of a Digit to start a Local Name  			char[] lnamechar = localname [1].Substring (0' 1).ToCharArray ();  			if (Char.IsDigit (lnamechar [0]) && this._syntax == TurtleSyntax.Original) {  				throw Error ("A Local Name within a QName may not start with a Number");  			}  		}  	}  	//QNames can't start with a Digit  	char[] firstchar = qname.Substring (0' 1).ToCharArray ();  	if (Char.IsDigit (firstchar [0])) {  		throw Error ("A QName may not start with a Number");  	}  	//Normal QName  	this.LastTokenType = Token.QNAME;  	return new QNameToken (qname' this.CurrentLine' this.StartPosition' this.EndPosition);  }  
Magic Number,VDS.RDF.Parsing.Tokens,TurtleTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TurtleTokeniser.cs,TryGetQNameToken,The following statement contains a magic number: if (qname.Length == 2) {  	//No ID  	return new BlankNodeToken (this.CurrentLine' this.StartPosition);  }  else {  	//User specified ID  	return new BlankNodeWithIDToken (qname' this.CurrentLine' this.StartPosition' this.EndPosition);  }  
Magic Number,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetDataType,The following statement contains a magic number: if (next == '<') {  	//Uri for Data Type  	IToken temp = this.TryGetUri ();  	return new DataTypeToken ("<" + temp.Value + ">"' temp.StartLine' temp.StartPosition - 3' temp.EndPosition + 1);  }  else {  	throw UnexpectedCharacter (next' "expected a < to start a URI to specify a Data Type for a Typed Literal");  }  
Magic Number,VDS.RDF.Parsing.Tokens,TsvTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\TsvTokeniser.cs,TryGetDataType,The following statement contains a magic number: return new DataTypeToken ("<" + temp.Value + ">"' temp.StartLine' temp.StartPosition - 3' temp.EndPosition + 1);  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (this.ShouldReorder) {  	if (gp.TriplePatterns.Count > 0) {  		//After we sort which gives us a rough optimisation we then may want to reorder  		//based on the Variables that occurred previous to us OR if we're the Root Graph Pattern  		if (!variables.Any ()) {  			//Optimise this Graph Pattern  			//No previously occurring variables so must be the first Graph Pattern  			if (gp.TriplePatterns.Count > 1) {  				HashSet<String> currVariables = new HashSet<String> ();  				gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  				for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  					if (currVariables.Count == 0) {  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  						continue;  					}  					else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  						this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					}  					else {  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					}  				}  			}  		}  		else {  			//Optimise this Graph Pattern based on previously occurring variables  			if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  				this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  			}  			else if (gp.TriplePatterns.Count > 2) {  				//In the case where there are more than 2 patterns then we can try and reorder these  				//in order to further optimise the pattern  				this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  			}  		}  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (this.ShouldReorder) {  	if (gp.TriplePatterns.Count > 0) {  		//After we sort which gives us a rough optimisation we then may want to reorder  		//based on the Variables that occurred previous to us OR if we're the Root Graph Pattern  		if (!variables.Any ()) {  			//Optimise this Graph Pattern  			//No previously occurring variables so must be the first Graph Pattern  			if (gp.TriplePatterns.Count > 1) {  				HashSet<String> currVariables = new HashSet<String> ();  				gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  				for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  					if (currVariables.Count == 0) {  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  						continue;  					}  					else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  						this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					}  					else {  						gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					}  				}  			}  		}  		else {  			//Optimise this Graph Pattern based on previously occurring variables  			if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  				this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  			}  			else if (gp.TriplePatterns.Count > 2) {  				//In the case where there are more than 2 patterns then we can try and reorder these  				//in order to further optimise the pattern  				this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  			}  		}  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 0) {  	//After we sort which gives us a rough optimisation we then may want to reorder  	//based on the Variables that occurred previous to us OR if we're the Root Graph Pattern  	if (!variables.Any ()) {  		//Optimise this Graph Pattern  		//No previously occurring variables so must be the first Graph Pattern  		if (gp.TriplePatterns.Count > 1) {  			HashSet<String> currVariables = new HashSet<String> ();  			gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  			for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  				if (currVariables.Count == 0) {  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					continue;  				}  				else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  					this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				}  				else {  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				}  			}  		}  	}  	else {  		//Optimise this Graph Pattern based on previously occurring variables  		if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  			this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  		}  		else if (gp.TriplePatterns.Count > 2) {  			//In the case where there are more than 2 patterns then we can try and reorder these  			//in order to further optimise the pattern  			this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  		}  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 0) {  	//After we sort which gives us a rough optimisation we then may want to reorder  	//based on the Variables that occurred previous to us OR if we're the Root Graph Pattern  	if (!variables.Any ()) {  		//Optimise this Graph Pattern  		//No previously occurring variables so must be the first Graph Pattern  		if (gp.TriplePatterns.Count > 1) {  			HashSet<String> currVariables = new HashSet<String> ();  			gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  			for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  				if (currVariables.Count == 0) {  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  					continue;  				}  				else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  					this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				}  				else {  					gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				}  			}  		}  	}  	else {  		//Optimise this Graph Pattern based on previously occurring variables  		if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  			this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  		}  		else if (gp.TriplePatterns.Count > 2) {  			//In the case where there are more than 2 patterns then we can try and reorder these  			//in order to further optimise the pattern  			this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  		}  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (!variables.Any ()) {  	//Optimise this Graph Pattern  	//No previously occurring variables so must be the first Graph Pattern  	if (gp.TriplePatterns.Count > 1) {  		HashSet<String> currVariables = new HashSet<String> ();  		gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  		for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  			if (currVariables.Count == 0) {  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				continue;  			}  			else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  				this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  			}  			else {  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  			}  		}  	}  }  else {  	//Optimise this Graph Pattern based on previously occurring variables  	if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  		this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  	}  	else if (gp.TriplePatterns.Count > 2) {  		//In the case where there are more than 2 patterns then we can try and reorder these  		//in order to further optimise the pattern  		this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (!variables.Any ()) {  	//Optimise this Graph Pattern  	//No previously occurring variables so must be the first Graph Pattern  	if (gp.TriplePatterns.Count > 1) {  		HashSet<String> currVariables = new HashSet<String> ();  		gp.TriplePatterns [0].Variables.ForEach (v => currVariables.Add (v));  		for (int i = 1; i < gp.TriplePatterns.Count - 1; i++) {  			if (currVariables.Count == 0) {  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  				continue;  			}  			else if (currVariables.IsDisjoint (gp.TriplePatterns [i].Variables)) {  				this.TryReorderPatterns (gp' currVariables.ToList ()' i + 1' i);  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  			}  			else {  				gp.TriplePatterns [i].Variables.ForEach (v => currVariables.Add (v));  			}  		}  	}  }  else {  	//Optimise this Graph Pattern based on previously occurring variables  	if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  		this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  	}  	else if (gp.TriplePatterns.Count > 2) {  		//In the case where there are more than 2 patterns then we can try and reorder these  		//in order to further optimise the pattern  		this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  	}  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  	this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  }  else if (gp.TriplePatterns.Count > 2) {  	//In the case where there are more than 2 patterns then we can try and reorder these  	//in order to further optimise the pattern  	this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 && !gp.TriplePatterns [0].Variables.Any (v => variables.Contains (v)) && variables.Intersect (ourVariables).Any ()) {  	this.TryReorderPatterns (gp' variables.ToList ()' 1' 0);  }  else if (gp.TriplePatterns.Count > 2) {  	//In the case where there are more than 2 patterns then we can try and reorder these  	//in order to further optimise the pattern  	this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 2) {  	//In the case where there are more than 2 patterns then we can try and reorder these  	//in order to further optimise the pattern  	this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: if (gp.TriplePatterns.Count > 2) {  	//In the case where there are more than 2 patterns then we can try and reorder these  	//in order to further optimise the pattern  	this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  }  
Magic Number,VDS.RDF.Query.Optimisation,BaseQueryOptimiser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Optimisation\BaseQueryOptimiser.cs,Optimise,The following statement contains a magic number: this.TryReorderPatterns (gp' gp.TriplePatterns [0].Variables' 2' 1);  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The following statement contains a magic number: if (this._isUnion) {  	indent = new String (' '' 2);  	for (int i = 0; i < this._graphPatterns.Count; i++) {  		if (i > 0)  			output.Append (indent);  		String temp = this._graphPatterns [i].ToString ();  		if (!temp.Contains ('\n')) {  			output.Append (temp + " ");  		}  		else {  			String[] lines = temp.Split ('\n');  			for (int j = 0; j < lines.Length; j++) {  				if (j > 0)  					output.Append (indent);  				output.Append (lines [j]);  				if (j < lines.Length - 1)  					output.AppendLine ();  			}  		}  		output.AppendLine ();  		if (i < this._graphPatterns.Count - 1) {  			output.Append (indent);  			output.AppendLine (" UNION ");  		}  	}  	return output.ToString ();  }  else if (this._isGraph || this._isService) {  	if (this._isGraph) {  		output.Append ("GRAPH ");  	}  	else {  		output.Append ("SERVICE ");  		if (this._isSilent)  			output.Append ("SILENT ");  	}  	switch (this._graphSpecifier.TokenType) {  	case Token.QNAME:  		output.Append (this._graphSpecifier.Value);  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this._graphSpecifier.Value);  		output.Append ('>');  		break;  	case Token.VARIABLE:  	default:  		output.Append (this._graphSpecifier.Value);  		break;  	}  	output.Append (" ");  }  else if (this._isOptional) {  	if (this._isExists) {  		output.Append ("EXISTS ");  	}  	else if (this._isNotExists) {  		output.Append ("NOT EXISTS ");  	}  	else {  		output.Append ("OPTIONAL ");  	}  }  else if (this._isMinus) {  	output.Append ("MINUS ");  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The following statement contains a magic number: indent = new String (' '' 2);  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The following statement contains a magic number: if (linebreaks) {  	output.AppendLine ();  	indent = new String (' '' 2);  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToString,The following statement contains a magic number: indent = new String (' '' 2);  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The following statement contains a magic number: if (this._isUnion) {  	//If this Graph Pattern represents a UNION of Graph Patterns turn into a series of UNIONs  	ISparqlAlgebra union = new Union (this._graphPatterns [0].ToAlgebra ()' this._graphPatterns [1].ToAlgebra ());  	if (this._graphPatterns.Count > 2) {  		for (int i = 2; i < this._graphPatterns.Count; i++) {  			union = new Union (union' this._graphPatterns [i].ToAlgebra ());  		}  	}  	//If there's a FILTER apply it over the Union  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		return new Filter (union' this.Filter);  	}  	else {  		return union;  	}  }  else if (this._graphPatterns.Count == 0) {  	//If there are no Child Graph Patterns then this is a BGP  	ISparqlAlgebra bgp = new Bgp (this._triplePatterns);  	if (this._unplacedAssignments.Count > 0) {  		//If we have any unplaced LETs these get Joined onto the BGP  		bgp = Join.CreateJoin (bgp' new Bgp (this._unplacedAssignments));  	}  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		if (this._isOptional && !(this._isExists || this._isNotExists)) {  			//If we contain an unplaced FILTER and we're an OPTIONAL then the FILTER  			//applies over the LEFT JOIN and will have been added elsewhere in the Algebra transform  			return bgp;  		}  		else {  			ISparqlAlgebra complex = bgp;  			//If we contain an unplaced FILTER and we're not an OPTIONAL the FILTER  			//applies here  			return new Filter (bgp' this.Filter);  		}  	}  	else {  		//We're not filtered (or all FILTERs were placed in the BGP) so we're just a BGP  		return bgp;  	}  }  else {  	//Create a basic BGP to start with  	ISparqlAlgebra complex = new Bgp ();  	if (this._triplePatterns.Count > 0) {  		complex = new Bgp (this._triplePatterns);  	}  	//Then Join each of the Graph Patterns as appropriate  	foreach (GraphPattern gp in this._graphPatterns) {  		if (gp.IsGraph) {  			//A GRAPH clause means a Join of the current pattern to a Graph clause  			complex = Join.CreateJoin (complex' new Algebra.Graph (gp.ToAlgebra ()' gp.GraphSpecifier));  		}  		else if (gp.IsOptional) {  			if (gp.IsExists || gp.IsNotExists) {  				//An EXISTS/NOT EXISTS means an Exists Join of the current pattern to the EXISTS/NOT EXISTS clause  				complex = new ExistsJoin (complex' gp.ToAlgebra ()' gp.IsExists);  			}  			else {  				//An OPTIONAL means a Left Join of the current pattern to the OPTIONAL clause  				//with a possible FILTER applied over the LeftJoin  				if (gp.IsFiltered && gp.Filter != null) {  					//If the OPTIONAL clause has an unplaced FILTER it applies over the Left Join  					complex = new LeftJoin (complex' gp.ToAlgebra ()' gp.Filter);  				}  				else {  					complex = new LeftJoin (complex' gp.ToAlgebra ());  				}  			}  		}  		else if (gp.IsMinus) {  			//Always introduce a Minus here even if the Minus is disjoint since during evaluation we'll choose  			//not to execute it if it's disjoint  			complex = new Minus (complex' gp.ToAlgebra ());  		}  		else if (gp.IsService) {  			complex = Join.CreateJoin (complex' new Service (gp.GraphSpecifier' gp' gp.IsSilent));  		}  		else {  			//Otherwise we just join the pattern to the existing pattern  			complex = Join.CreateJoin (complex' gp.ToAlgebra ());  		}  	}  	if (this._unplacedAssignments.Count > 0) {  		//Unplaced assignments get Joined as a BGP here  		complex = Join.CreateJoin (complex' new Bgp (this._unplacedAssignments));  	}  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		if (this._isOptional && !(this._isExists || this._isNotExists)) {  			//If there's an unplaced FILTER and we're an OPTIONAL then the FILTER will  			//apply over the LeftJoin and is applied elsewhere in the Algebra transform  			return complex;  		}  		else {  			if (this._filter != null || this._unplacedFilters.Count > 0) {  				//If there's an unplaced FILTER and we're not an OPTIONAL pattern we apply  				//the FILTER here  				return new Filter (complex' this.Filter);  			}  			else {  				return complex;  			}  		}  	}  	else {  		//If no FILTER just return the transform  		return complex;  	}  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The following statement contains a magic number: if (this._isUnion) {  	//If this Graph Pattern represents a UNION of Graph Patterns turn into a series of UNIONs  	ISparqlAlgebra union = new Union (this._graphPatterns [0].ToAlgebra ()' this._graphPatterns [1].ToAlgebra ());  	if (this._graphPatterns.Count > 2) {  		for (int i = 2; i < this._graphPatterns.Count; i++) {  			union = new Union (union' this._graphPatterns [i].ToAlgebra ());  		}  	}  	//If there's a FILTER apply it over the Union  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		return new Filter (union' this.Filter);  	}  	else {  		return union;  	}  }  else if (this._graphPatterns.Count == 0) {  	//If there are no Child Graph Patterns then this is a BGP  	ISparqlAlgebra bgp = new Bgp (this._triplePatterns);  	if (this._unplacedAssignments.Count > 0) {  		//If we have any unplaced LETs these get Joined onto the BGP  		bgp = Join.CreateJoin (bgp' new Bgp (this._unplacedAssignments));  	}  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		if (this._isOptional && !(this._isExists || this._isNotExists)) {  			//If we contain an unplaced FILTER and we're an OPTIONAL then the FILTER  			//applies over the LEFT JOIN and will have been added elsewhere in the Algebra transform  			return bgp;  		}  		else {  			ISparqlAlgebra complex = bgp;  			//If we contain an unplaced FILTER and we're not an OPTIONAL the FILTER  			//applies here  			return new Filter (bgp' this.Filter);  		}  	}  	else {  		//We're not filtered (or all FILTERs were placed in the BGP) so we're just a BGP  		return bgp;  	}  }  else {  	//Create a basic BGP to start with  	ISparqlAlgebra complex = new Bgp ();  	if (this._triplePatterns.Count > 0) {  		complex = new Bgp (this._triplePatterns);  	}  	//Then Join each of the Graph Patterns as appropriate  	foreach (GraphPattern gp in this._graphPatterns) {  		if (gp.IsGraph) {  			//A GRAPH clause means a Join of the current pattern to a Graph clause  			complex = Join.CreateJoin (complex' new Algebra.Graph (gp.ToAlgebra ()' gp.GraphSpecifier));  		}  		else if (gp.IsOptional) {  			if (gp.IsExists || gp.IsNotExists) {  				//An EXISTS/NOT EXISTS means an Exists Join of the current pattern to the EXISTS/NOT EXISTS clause  				complex = new ExistsJoin (complex' gp.ToAlgebra ()' gp.IsExists);  			}  			else {  				//An OPTIONAL means a Left Join of the current pattern to the OPTIONAL clause  				//with a possible FILTER applied over the LeftJoin  				if (gp.IsFiltered && gp.Filter != null) {  					//If the OPTIONAL clause has an unplaced FILTER it applies over the Left Join  					complex = new LeftJoin (complex' gp.ToAlgebra ()' gp.Filter);  				}  				else {  					complex = new LeftJoin (complex' gp.ToAlgebra ());  				}  			}  		}  		else if (gp.IsMinus) {  			//Always introduce a Minus here even if the Minus is disjoint since during evaluation we'll choose  			//not to execute it if it's disjoint  			complex = new Minus (complex' gp.ToAlgebra ());  		}  		else if (gp.IsService) {  			complex = Join.CreateJoin (complex' new Service (gp.GraphSpecifier' gp' gp.IsSilent));  		}  		else {  			//Otherwise we just join the pattern to the existing pattern  			complex = Join.CreateJoin (complex' gp.ToAlgebra ());  		}  	}  	if (this._unplacedAssignments.Count > 0) {  		//Unplaced assignments get Joined as a BGP here  		complex = Join.CreateJoin (complex' new Bgp (this._unplacedAssignments));  	}  	if (this._isFiltered && (this._filter != null || this._unplacedFilters.Count > 0)) {  		if (this._isOptional && !(this._isExists || this._isNotExists)) {  			//If there's an unplaced FILTER and we're an OPTIONAL then the FILTER will  			//apply over the LeftJoin and is applied elsewhere in the Algebra transform  			return complex;  		}  		else {  			if (this._filter != null || this._unplacedFilters.Count > 0) {  				//If there's an unplaced FILTER and we're not an OPTIONAL pattern we apply  				//the FILTER here  				return new Filter (complex' this.Filter);  			}  			else {  				return complex;  			}  		}  	}  	else {  		//If no FILTER just return the transform  		return complex;  	}  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The following statement contains a magic number: if (this._graphPatterns.Count > 2) {  	for (int i = 2; i < this._graphPatterns.Count; i++) {  		union = new Union (union' this._graphPatterns [i].ToAlgebra ());  	}  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The following statement contains a magic number: if (this._graphPatterns.Count > 2) {  	for (int i = 2; i < this._graphPatterns.Count; i++) {  		union = new Union (union' this._graphPatterns [i].ToAlgebra ());  	}  }  
Magic Number,VDS.RDF.Query.Patterns,GraphPattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\GraphPattern.cs,ToAlgebra,The following statement contains a magic number: for (int i = 2; i < this._graphPatterns.Count; i++) {  	union = new Union (union' this._graphPatterns [i].ToAlgebra ());  }  
Magic Number,VDS.RDF.Query.Patterns,SetDistinctnessComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetHashCode,The following statement contains a magic number: if (this._vars.Count == 0) {  	return obj.GetHashCode ();  }  else {  	StringBuilder output = new StringBuilder ();  	foreach (String var in this._vars) {  		output.Append ("?" + var + " = " + obj [var].ToSafeString ());  		output.Append (" ' ");  	}  	output.Remove (output.Length - 3' 3);  	return output.ToString ().GetHashCode ();  }  
Magic Number,VDS.RDF.Query.Patterns,SetDistinctnessComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetHashCode,The following statement contains a magic number: if (this._vars.Count == 0) {  	return obj.GetHashCode ();  }  else {  	StringBuilder output = new StringBuilder ();  	foreach (String var in this._vars) {  		output.Append ("?" + var + " = " + obj [var].ToSafeString ());  		output.Append (" ' ");  	}  	output.Remove (output.Length - 3' 3);  	return output.ToString ().GetHashCode ();  }  
Magic Number,VDS.RDF.Query.Patterns,SetDistinctnessComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetHashCode,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Patterns,SetDistinctnessComparer,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\TriplePattern.cs,GetHashCode,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Patterns,FixedBlankNodePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\FixedBlankNodePattern.cs,FixedBlankNodePattern,The following statement contains a magic number: if (id.StartsWith ("_:")) {  	this._id = id.Substring (2);  }  else {  	this._id = id;  }  
Magic Number,VDS.RDF.Query.Patterns,FixedBlankNodePattern,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Patterns\FixedBlankNodePattern.cs,FixedBlankNodePattern,The following statement contains a magic number: this._id = id.Substring (2);  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (ArqFunctionFactory.ArqFunctionsNamespace)) {  	func = func.Substring (ArqFunctionFactory.ArqFunctionsNamespace.Length);  	ISparqlExpression arqFunc = null;  	switch (func) {  	case ArqFunctionFactory.BNode:  		if (args.Count == 1) {  			arqFunc = new BNodeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  		}  		break;  	case ArqFunctionFactory.E:  		if (args.Count == 0) {  			arqFunc = new EFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  		}  		break;  	case ArqFunctionFactory.LocalName:  		if (args.Count == 1) {  			arqFunc = new LocalNameFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  		}  		break;  	case ArqFunctionFactory.Max:  		if (args.Count == 2) {  			arqFunc = new MaxFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  		}  		break;  	case ArqFunctionFactory.Min:  		if (args.Count == 2) {  			arqFunc = new MinFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  		}  		break;  	case ArqFunctionFactory.Namespace:  		if (args.Count == 1) {  			arqFunc = new NamespaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  		}  		break;  	case ArqFunctionFactory.Now:  		if (args.Count == 0) {  			arqFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  		}  		break;  	case ArqFunctionFactory.Pi:  		if (args.Count == 0) {  			arqFunc = new PiFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  		}  		break;  	case ArqFunctionFactory.Sha1Sum:  		if (args.Count == 1) {  			arqFunc = new Sha1Function (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  		}  		break;  	case ArqFunctionFactory.StrJoin:  		if (args.Count >= 2) {  			arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  		}  		break;  	case ArqFunctionFactory.Substr:  	case ArqFunctionFactory.Substring:  		if (args.Count == 2) {  			arqFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  		}  		break;  	}  	if (arqFunc != null) {  		expr = arqFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (ArqFunctionFactory.ArqFunctionsNamespace)) {  	func = func.Substring (ArqFunctionFactory.ArqFunctionsNamespace.Length);  	ISparqlExpression arqFunc = null;  	switch (func) {  	case ArqFunctionFactory.BNode:  		if (args.Count == 1) {  			arqFunc = new BNodeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  		}  		break;  	case ArqFunctionFactory.E:  		if (args.Count == 0) {  			arqFunc = new EFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  		}  		break;  	case ArqFunctionFactory.LocalName:  		if (args.Count == 1) {  			arqFunc = new LocalNameFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  		}  		break;  	case ArqFunctionFactory.Max:  		if (args.Count == 2) {  			arqFunc = new MaxFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  		}  		break;  	case ArqFunctionFactory.Min:  		if (args.Count == 2) {  			arqFunc = new MinFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  		}  		break;  	case ArqFunctionFactory.Namespace:  		if (args.Count == 1) {  			arqFunc = new NamespaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  		}  		break;  	case ArqFunctionFactory.Now:  		if (args.Count == 0) {  			arqFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  		}  		break;  	case ArqFunctionFactory.Pi:  		if (args.Count == 0) {  			arqFunc = new PiFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  		}  		break;  	case ArqFunctionFactory.Sha1Sum:  		if (args.Count == 1) {  			arqFunc = new Sha1Function (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  		}  		break;  	case ArqFunctionFactory.StrJoin:  		if (args.Count >= 2) {  			arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  		}  		break;  	case ArqFunctionFactory.Substr:  	case ArqFunctionFactory.Substring:  		if (args.Count == 2) {  			arqFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  		}  		break;  	}  	if (arqFunc != null) {  		expr = arqFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (ArqFunctionFactory.ArqFunctionsNamespace)) {  	func = func.Substring (ArqFunctionFactory.ArqFunctionsNamespace.Length);  	ISparqlExpression arqFunc = null;  	switch (func) {  	case ArqFunctionFactory.BNode:  		if (args.Count == 1) {  			arqFunc = new BNodeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  		}  		break;  	case ArqFunctionFactory.E:  		if (args.Count == 0) {  			arqFunc = new EFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  		}  		break;  	case ArqFunctionFactory.LocalName:  		if (args.Count == 1) {  			arqFunc = new LocalNameFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  		}  		break;  	case ArqFunctionFactory.Max:  		if (args.Count == 2) {  			arqFunc = new MaxFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  		}  		break;  	case ArqFunctionFactory.Min:  		if (args.Count == 2) {  			arqFunc = new MinFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  		}  		break;  	case ArqFunctionFactory.Namespace:  		if (args.Count == 1) {  			arqFunc = new NamespaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  		}  		break;  	case ArqFunctionFactory.Now:  		if (args.Count == 0) {  			arqFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  		}  		break;  	case ArqFunctionFactory.Pi:  		if (args.Count == 0) {  			arqFunc = new PiFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  		}  		break;  	case ArqFunctionFactory.Sha1Sum:  		if (args.Count == 1) {  			arqFunc = new Sha1Function (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  		}  		break;  	case ArqFunctionFactory.StrJoin:  		if (args.Count >= 2) {  			arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  		}  		break;  	case ArqFunctionFactory.Substr:  	case ArqFunctionFactory.Substring:  		if (args.Count == 2) {  			arqFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  		}  		break;  	}  	if (arqFunc != null) {  		expr = arqFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (ArqFunctionFactory.ArqFunctionsNamespace)) {  	func = func.Substring (ArqFunctionFactory.ArqFunctionsNamespace.Length);  	ISparqlExpression arqFunc = null;  	switch (func) {  	case ArqFunctionFactory.BNode:  		if (args.Count == 1) {  			arqFunc = new BNodeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  		}  		break;  	case ArqFunctionFactory.E:  		if (args.Count == 0) {  			arqFunc = new EFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  		}  		break;  	case ArqFunctionFactory.LocalName:  		if (args.Count == 1) {  			arqFunc = new LocalNameFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  		}  		break;  	case ArqFunctionFactory.Max:  		if (args.Count == 2) {  			arqFunc = new MaxFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  		}  		break;  	case ArqFunctionFactory.Min:  		if (args.Count == 2) {  			arqFunc = new MinFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  		}  		break;  	case ArqFunctionFactory.Namespace:  		if (args.Count == 1) {  			arqFunc = new NamespaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  		}  		break;  	case ArqFunctionFactory.Now:  		if (args.Count == 0) {  			arqFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  		}  		break;  	case ArqFunctionFactory.Pi:  		if (args.Count == 0) {  			arqFunc = new PiFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  		}  		break;  	case ArqFunctionFactory.Sha1Sum:  		if (args.Count == 1) {  			arqFunc = new Sha1Function (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  		}  		break;  	case ArqFunctionFactory.StrJoin:  		if (args.Count >= 2) {  			arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  		}  		break;  	case ArqFunctionFactory.Substr:  	case ArqFunctionFactory.Substring:  		if (args.Count == 2) {  			arqFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  		}  		break;  	}  	if (arqFunc != null) {  		expr = arqFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (ArqFunctionFactory.ArqFunctionsNamespace)) {  	func = func.Substring (ArqFunctionFactory.ArqFunctionsNamespace.Length);  	ISparqlExpression arqFunc = null;  	switch (func) {  	case ArqFunctionFactory.BNode:  		if (args.Count == 1) {  			arqFunc = new BNodeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  		}  		break;  	case ArqFunctionFactory.E:  		if (args.Count == 0) {  			arqFunc = new EFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  		}  		break;  	case ArqFunctionFactory.LocalName:  		if (args.Count == 1) {  			arqFunc = new LocalNameFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  		}  		break;  	case ArqFunctionFactory.Max:  		if (args.Count == 2) {  			arqFunc = new MaxFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  		}  		break;  	case ArqFunctionFactory.Min:  		if (args.Count == 2) {  			arqFunc = new MinFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  		}  		break;  	case ArqFunctionFactory.Namespace:  		if (args.Count == 1) {  			arqFunc = new NamespaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  		}  		break;  	case ArqFunctionFactory.Now:  		if (args.Count == 0) {  			arqFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  		}  		break;  	case ArqFunctionFactory.Pi:  		if (args.Count == 0) {  			arqFunc = new PiFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  		}  		break;  	case ArqFunctionFactory.Sha1Sum:  		if (args.Count == 1) {  			arqFunc = new Sha1Function (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  		}  		break;  	case ArqFunctionFactory.StrJoin:  		if (args.Count >= 2) {  			arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  		}  		break;  	case ArqFunctionFactory.Substr:  	case ArqFunctionFactory.Substring:  		if (args.Count == 2) {  			arqFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  		}  		break;  	}  	if (arqFunc != null) {  		expr = arqFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	arqFunc = new MaxFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	arqFunc = new MinFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count >= 2) {  	arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	arqFunc = new SubstringFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	arqFunc = new SubstringFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  }  
Magic Number,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (LeviathanFunctionFactory.LeviathanFunctionsNamespace)) {  	func = func.Substring (LeviathanFunctionFactory.LeviathanFunctionsNamespace.Length);  	ISparqlExpression lvnFunc = null;  	switch (func) {  	case LeviathanFunctionFactory.All:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Any:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Cartesian:  		if (args.Count == 4) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  		}  		else if (args.Count == 6) {  			lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  		}  		break;  	case LeviathanFunctionFactory.Cube:  		if (args.Count == 1) {  			lvnFunc = new CubeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  		}  		break;  	case LeviathanFunctionFactory.DegreesToRadians:  		if (args.Count == 1) {  			lvnFunc = new DegreesToRadiansFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  		}  		break;  	case LeviathanFunctionFactory.E:  		if (args.Count == 1) {  			lvnFunc = new EFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  		}  		break;  	case LeviathanFunctionFactory.Factorial:  		if (args.Count == 1) {  			lvnFunc = new FactorialFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  		}  		break;  	case LeviathanFunctionFactory.Ln:  		if (args.Count == 1) {  			lvnFunc = new LeviathanNaturalLogFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  		}  		break;  	case LeviathanFunctionFactory.Log:  		if (args.Count == 1) {  			lvnFunc = new LogFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new LogFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  		}  		break;  	case LeviathanFunctionFactory.MD5Hash:  		if (args.Count == 1) {  			lvnFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  		}  		break;  	case LeviathanFunctionFactory.Median:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Mode:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  		}  		break;  	case LeviathanFunctionFactory.None:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMax:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  		}  		break;  	case LeviathanFunctionFactory.NumericMin:  		if (args.Count == 1) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  		}  		else if (args.Count == 2 && args.First () is DistinctModifier) {  			lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  		}  		break;  	case LeviathanFunctionFactory.Power:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new PowerFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  		}  		break;  	case LeviathanFunctionFactory.Pythagoras:  		if (args.Count == 2) {  			lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  		}  		break;  	case LeviathanFunctionFactory.RadiansToDegrees:  		if (args.Count == 1) {  			lvnFunc = new RadiansToDegreesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  		}  		break;  	case LeviathanFunctionFactory.Random:  		if (args.Count == 0) {  			lvnFunc = new RandomFunction ();  		}  		else if (args.Count == 1) {  			lvnFunc = new RandomFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RandomFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  		}  		break;  	case LeviathanFunctionFactory.Reciprocal:  		if (args.Count == 1) {  			lvnFunc = new ReciprocalFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  		}  		break;  	case LeviathanFunctionFactory.Root:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else if (args.Count == 2) {  			lvnFunc = new RootFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  		}  		break;  	case LeviathanFunctionFactory.Sha256Hash:  		if (args.Count == 1) {  			lvnFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  		}  		break;  	case LeviathanFunctionFactory.Square:  		if (args.Count == 1) {  			lvnFunc = new SquareFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  		}  		break;  	case LeviathanFunctionFactory.SquareRoot:  		if (args.Count == 1) {  			lvnFunc = new SquareRootFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  		}  		break;  	case LeviathanFunctionFactory.Ten:  		if (args.Count == 1) {  			lvnFunc = new TenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCos:  	case LeviathanFunctionFactory.TrigCosInv:  		if (args.Count == 1) {  			lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCosec:  	case LeviathanFunctionFactory.TrigCosecInv:  		if (args.Count == 1) {  			lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigCotan:  	case LeviathanFunctionFactory.TrigCotanInv:  		if (args.Count == 1) {  			lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSec:  	case LeviathanFunctionFactory.TrigSecInv:  		if (args.Count == 1) {  			lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigSin:  	case LeviathanFunctionFactory.TrigSinInv:  		if (args.Count == 1) {  			lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	case LeviathanFunctionFactory.TrigTan:  	case LeviathanFunctionFactory.TrigTanInv:  		if (args.Count == 1) {  			lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  		}  		break;  	}  	if (lvnFunc != null) {  		expr = lvnFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  }  else if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 6) {  	lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new LogFunction (args.First ());  }  else if (args.Count == 2) {  	lvnFunc = new LogFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	lvnFunc = new LogFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  }  else if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2 && args.First () is DistinctModifier) {  	lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new SquareFunction (args.First ());  }  else if (args.Count == 2) {  	lvnFunc = new PowerFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	lvnFunc = new PowerFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 0) {  	lvnFunc = new RandomFunction ();  }  else if (args.Count == 1) {  	lvnFunc = new RandomFunction (args.First ());  }  else if (args.Count == 2) {  	lvnFunc = new RandomFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new RandomFunction (args.First ());  }  else if (args.Count == 2) {  	lvnFunc = new RandomFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	lvnFunc = new RandomFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	lvnFunc = new SquareRootFunction (args.First ());  }  else if (args.Count == 2) {  	lvnFunc = new RootFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  }  
Magic Number,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	lvnFunc = new RootFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (SparqlFunctionsNamespace)) {  	func = func.Substring (SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace.Length);  	func = func.ToUpper ();  	//If any Scalar Arguments are present then can't be a SPARQL Function UNLESS it is  	//a GROUP_CONCAT function and it has the SEPARATOR argument  	if (scalarArguments.Count > 0) {  		if (func.Equals (SparqlSpecsHelper.SparqlKeywordGroupConcat) && scalarArguments.Count == 1 && scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			//OK  		}  		else {  			expr = null;  			return false;  		}  	}  	//Q: Will there be special URIs for the DISTINCT modified forms of aggregates?  	ISparqlExpression sparqlFunc = null;  	switch (func) {  	case SparqlSpecsHelper.SparqlKeywordAbs:  		if (args.Count == 1) {  			sparqlFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordAvg:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordBound:  		if (args.Count == 1) {  			if (args [0] is VariableTerm) {  				sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  			}  			else {  				throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCeil:  		if (args.Count == 1) {  			sparqlFunc = new CeilFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCoalesce:  		if (args.Count >= 1) {  			sparqlFunc = new CoalesceFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordConcat:  		if (args.Count >= 1) {  			sparqlFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordContains:  		if (args.Count == 2) {  			sparqlFunc = new ContainsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordCount:  		//Q: What will the URIs be for the special forms of COUNT?  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDataType:  		if (args.Count == 1) {  			sparqlFunc = new DataTypeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordDay:  		if (args.Count == 1) {  			sparqlFunc = new DayFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  		if (args.Count == 1) {  			sparqlFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordFloor:  		if (args.Count == 1) {  			sparqlFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordGroupConcat:  		if (args.Count == 1) {  			if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  			}  			else {  				sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  			}  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordHours:  		if (args.Count == 1) {  			sparqlFunc = new HoursFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIf:  		if (args.Count == 3) {  			sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsBlank:  		if (args.Count == 1) {  			sparqlFunc = new IsBlankFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsIri:  		if (args.Count == 1) {  			sparqlFunc = new IsIriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsLiteral:  		if (args.Count == 1) {  			sparqlFunc = new IsLiteralFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsNumeric:  		if (args.Count == 1) {  			sparqlFunc = new IsNumericFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordIsUri:  		if (args.Count == 1) {  			sparqlFunc = new IsUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLang:  		if (args.Count == 1) {  			sparqlFunc = new LangFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLangMatches:  		if (args.Count == 2) {  			sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordLCase:  		if (args.Count == 1) {  			sparqlFunc = new LCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMax:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMD5:  		if (args.Count == 1) {  			sparqlFunc = new MD5HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMin:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMinutes:  		if (args.Count == 1) {  			sparqlFunc = new MinutesFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordMonth:  		if (args.Count == 1) {  			sparqlFunc = new MonthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordNow:  		if (args.Count == 0) {  			sparqlFunc = new NowFunction ();  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRegex:  		if (args.Count == 2) {  			sparqlFunc = new RegexFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordRound:  		if (args.Count == 1) {  			sparqlFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSameTerm:  		if (args.Count == 2) {  			sparqlFunc = new SameTermFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSample:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSeconds:  		if (args.Count == 1) {  			sparqlFunc = new SecondsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha1:  		if (args.Count == 1) {  			sparqlFunc = new Sha1HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha256:  		if (args.Count == 1) {  			sparqlFunc = new Sha256HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha384:  		if (args.Count == 1) {  			sparqlFunc = new Sha384HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSha512:  		if (args.Count == 1) {  			sparqlFunc = new Sha512HashFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStr:  		if (args.Count == 1) {  			sparqlFunc = new StrFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrDt:  		if (args.Count == 2) {  			sparqlFunc = new StrDtFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrEnds:  		if (args.Count == 2) {  			sparqlFunc = new StrEndsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLang:  		if (args.Count == 2) {  			sparqlFunc = new StrLangFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrLen:  		if (args.Count == 1) {  			sparqlFunc = new StrLenFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordStrStarts:  		if (args.Count == 2) {  			sparqlFunc = new StrStartsFunction (args [0]' args [1]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSubStr:  		if (args.Count == 2) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]);  		}  		else if (args.Count == 3) {  			sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordSum:  		if (args.Count == 1) {  			sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTimezone:  		if (args.Count == 1) {  			sparqlFunc = new TimezoneFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordTz:  		if (args.Count == 1) {  			sparqlFunc = new TZFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUCase:  		if (args.Count == 1) {  			sparqlFunc = new UCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordUri:  		if (args.Count == 1) {  			sparqlFunc = new IriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  		}  		break;  	case SparqlSpecsHelper.SparqlKeywordYear:  		if (args.Count == 1) {  			sparqlFunc = new YearFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  		}  		break;  	}  	if (sparqlFunc != null) {  		expr = sparqlFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new ContainsFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new RegexFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new RegexFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new RegexFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new SameTermFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new StrDtFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new StrEndsFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new StrLangFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new StrStartsFunction (args [0]' args [1]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]);  }  else if (args.Count == 3) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  }  
Magic Number,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (func.StartsWith (XPathFunctionFactory.XPathFunctionsNamespace)) {  	func = func.Substring (XPathFunctionFactory.XPathFunctionsNamespace.Length);  	ISparqlExpression xpathFunc = null;  	switch (func) {  	case XPathFunctionFactory.Absolute:  		if (args.Count == 1) {  			xpathFunc = new AbsFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  		}  		break;  	case XPathFunctionFactory.AdjustDateTimeToTimezone:  		throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  	case XPathFunctionFactory.Boolean:  		if (args.Count == 1) {  			xpathFunc = new BooleanFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  		}  		throw new NotSupportedException ("XPath boolean() function is not supported");  	case XPathFunctionFactory.Ceiling:  		if (args.Count == 1) {  			xpathFunc = new CeilingFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  		}  		break;  	case XPathFunctionFactory.Compare:  		if (args.Count == 2) {  			xpathFunc = new CompareFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  		}  		break;  	case XPathFunctionFactory.Concat:  		if (args.Count == 2) {  			xpathFunc = new ConcatFunction (args.First ()' args.Last ());  		}  		else if (args.Count > 2) {  			xpathFunc = new ConcatFunction (args);  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  		}  		break;  	case XPathFunctionFactory.Contains:  		if (args.Count == 2) {  			xpathFunc = new ContainsFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  		}  		break;  	case XPathFunctionFactory.DayFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new DayFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.EncodeForURI:  		if (args.Count == 1) {  			xpathFunc = new EncodeForUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  		}  		break;  	case XPathFunctionFactory.EndsWith:  		if (args.Count == 2) {  			xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  		}  		break;  	#if !NO_WEB  	case XPathFunctionFactory.EscapeHtmlURI:  		if (args.Count == 1) {  			xpathFunc = new EscapeHtmlUriFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  		}  		break;  	#endif  	case XPathFunctionFactory.False:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' false));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  		}  		break;  	case XPathFunctionFactory.Floor:  		if (args.Count == 1) {  			xpathFunc = new FloorFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  		}  		break;  	case XPathFunctionFactory.HoursFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new HoursFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.LowerCase:  		if (args.Count == 1) {  			xpathFunc = new LowerCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  		}  		break;  	case XPathFunctionFactory.Matches:  		if (args.Count == 2) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  		}  		break;  	case XPathFunctionFactory.MinutesFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MinutesFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.MonthFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new MonthFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.NormalizeSpace:  		if (args.Count == 1) {  			xpathFunc = new NormalizeSpaceFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#if !NO_NORM  	case XPathFunctionFactory.NormalizeUnicode:  		if (args.Count == 1) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  		}  		break;  	#endif  	case XPathFunctionFactory.Not:  		if (args.Count == 1) {  			xpathFunc = new NotExpression (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  		}  		break;  	case XPathFunctionFactory.Replace:  		if (args.Count == 3) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  		}  		else if (args.Count == 4) {  			xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  		}  		break;  	case XPathFunctionFactory.Round:  		if (args.Count == 1) {  			xpathFunc = new RoundFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  		}  		break;  	#if !SILVERLIGHT  	case XPathFunctionFactory.RoundHalfToEven:  		if (args.Count == 1) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ());  		}  		else if (args.Count == 2) {  			xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  		}  		break;  	#endif  	case XPathFunctionFactory.SecondsFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new SecondsFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.StartsWith:  		if (args.Count == 2) {  			xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  		}  		break;  	case XPathFunctionFactory.StringJoin:  		if (args.Count == 1) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  		}  		else if (args.Count == 2) {  			xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  		}  		break;  	case XPathFunctionFactory.StringLength:  		if (args.Count == 1) {  			xpathFunc = new StringLengthFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  		}  		break;  	case XPathFunctionFactory.Substring:  		if (args.Count == 2) {  			xpathFunc = new SubstringFunction (args.First ()' args.Last ());  		}  		else if (args.Count == 3) {  			xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  		}  		break;  	case XPathFunctionFactory.SubstringAfter:  		if (args.Count == 2) {  			xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  		}  		break;  	case XPathFunctionFactory.SubstringBefore:  		if (args.Count == 2) {  			xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  		}  		break;  	case XPathFunctionFactory.TimezoneFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  		}  		break;  	case XPathFunctionFactory.Translate:  		throw new NotSupportedException ("XPath translate() function is not supported");  	case XPathFunctionFactory.True:  		if (args.Count == 0) {  			xpathFunc = new ConstantTerm (new BooleanNode (null' true));  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  		}  		break;  	case XPathFunctionFactory.UpperCase:  		if (args.Count == 1) {  			xpathFunc = new UpperCaseFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  		}  		break;  	case XPathFunctionFactory.YearFromDateTime:  		if (args.Count == 1) {  			xpathFunc = new YearFromDateTimeFunction (args.First ());  		}  		else {  			throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  		}  		break;  	}  	if (xpathFunc != null) {  		expr = xpathFunc;  		return true;  	}  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new CompareFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new ConcatFunction (args.First ()' args.Last ());  }  else if (args.Count > 2) {  	xpathFunc = new ConcatFunction (args);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new ConcatFunction (args.First ()' args.Last ());  }  else if (args.Count > 2) {  	xpathFunc = new ConcatFunction (args);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count > 2) {  	xpathFunc = new ConcatFunction (args);  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new ContainsFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	xpathFunc = new NormalizeUnicodeFunction (args.First ());  }  else if (args.Count == 2) {  	xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  }  else if (args.Count == 4) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  }  else if (args.Count == 4) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  }  else if (args.Count == 4) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 4) {  	xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	xpathFunc = new RoundHalfToEvenFunction (args.First ());  }  else if (args.Count == 2) {  	xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 1) {  	xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  }  else if (args.Count == 2) {  	xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new SubstringFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new SubstringFunction (args.First ()' args.Last ());  }  else if (args.Count == 3) {  	xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 3) {  	xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  }  
Magic Number,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following statement contains a magic number: if (args.Count == 2) {  	xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  }  else {  	throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  }  
Magic Number,VDS.RDF.Query.Algebra,Filter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Filter.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,Filter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Filter.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,LeftJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AlgebraJoinClasses.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,LeftJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\AlgebraJoinClasses.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The following statement contains a magic number: if (lhsResult is NullMultiset) {  	context.OutputMultiset = lhsResult;  }  else if (lhsResult.IsEmpty) {  	context.OutputMultiset = new NullMultiset ();  }  else {  	//Wait for RHS to complete  	if (!rhs.IsCompleted) {  		if (context.RemainingTimeout > 0) {  			rhs.AsyncWaitHandle.WaitOne (new TimeSpan (0' 0' 0' 0' (int)context.RemainingTimeout));  		}  		else {  			rhs.AsyncWaitHandle.WaitOne ();  		}  		context.CheckTimeout ();  	}  	if (this._rhsResult == null) {  		if (this._rhsError != null)  			throw this._rhsError;  		Thread.Sleep (10);  	}  	if (this._rhsResult == null)  		throw new RdfQueryException ("Unknown error in parallel join evaluation' RHS is reported completed without errors but no result is available");  	//Compute the product of the two sides  	context.OutputMultiset = lhsResult.Product (this._rhsResult);  }  
Magic Number,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The following statement contains a magic number: if (lhsResult.IsEmpty) {  	context.OutputMultiset = new NullMultiset ();  }  else {  	//Wait for RHS to complete  	if (!rhs.IsCompleted) {  		if (context.RemainingTimeout > 0) {  			rhs.AsyncWaitHandle.WaitOne (new TimeSpan (0' 0' 0' 0' (int)context.RemainingTimeout));  		}  		else {  			rhs.AsyncWaitHandle.WaitOne ();  		}  		context.CheckTimeout ();  	}  	if (this._rhsResult == null) {  		if (this._rhsError != null)  			throw this._rhsError;  		Thread.Sleep (10);  	}  	if (this._rhsResult == null)  		throw new RdfQueryException ("Unknown error in parallel join evaluation' RHS is reported completed without errors but no result is available");  	//Compute the product of the two sides  	context.OutputMultiset = lhsResult.Product (this._rhsResult);  }  
Magic Number,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The following statement contains a magic number: if (this._rhsResult == null) {  	if (this._rhsError != null)  		throw this._rhsError;  	Thread.Sleep (10);  }  
Magic Number,VDS.RDF.Query.Algebra,ParallelJoin,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\ParallelisedJoinClasses.cs,Evaluate,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,VDS.RDF.Query.Algebra,VariableRestrictionFilter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\RestrictionFilters.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,VariableRestrictionFilter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\RestrictionFilters.cs,ToString,The following statement contains a magic number: filter = filter.Substring (7' filter.Length - 8);  
Magic Number,VDS.RDF.Query.Algebra,Set,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Set.cs,ToString,The following statement contains a magic number: if (this._values.Count > 0)  	output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Algebra,Set,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Set.cs,ToString,The following statement contains a magic number: if (this._values.Count > 0)  	output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Algebra,Set,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Set.cs,ToString,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Algebra,Set,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Set.cs,ToString,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._g != null) {  	temp = this._g.CreateBlankNode ();  }  else if (this._factory != null) {  	temp = this._factory.CreateBlankNode ();  }  else if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._g != null) {  	temp = this._g.CreateBlankNode ();  }  else if (this._factory != null) {  	temp = this._factory.CreateBlankNode ();  }  else if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._factory != null) {  	temp = this._factory.CreateBlankNode ();  }  else if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._factory != null) {  	temp = this._factory.CreateBlankNode ();  }  else if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: if (this._s != null) {  	temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  }  else {  	temp = new BlankNode (this._g' id.Substring (2));  }  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: temp = new BlankNode (this._g' id.Substring (2) + "-" + this._s.ID);  
Magic Number,VDS.RDF.Query.Construct,ConstructContext,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Construct\ConstructContext.cs,GetBlankNode,The following statement contains a magic number: temp = new BlankNode (this._g' id.Substring (2));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CubeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CubeFunction.cs,Evaluate,The following statement contains a magic number: switch (temp.NumericType) {  case SparqlNumericType.Integer:  	long l = temp.AsInteger ();  	return new LongNode (null' l * l * l);  case SparqlNumericType.Decimal:  	decimal d = temp.AsDecimal ();  	return new DecimalNode (null' d * d * d);  case SparqlNumericType.Float:  	float f = temp.AsFloat ();  	return new FloatNode (null' f * f * f);  case SparqlNumericType.Double:  	double dbl = temp.AsDouble ();  	return new DoubleNode (null' Math.Pow (dbl' 3));  case SparqlNumericType.NaN:  default:  	throw new RdfQueryException ("Cannot square a non-numeric argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CubeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CubeFunction.cs,Evaluate,The following statement contains a magic number: return new DoubleNode (null' Math.Pow (dbl' 3));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,PythagoreanDistanceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\PythagoreanDistanceFunction.cs,Evaluate,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (x.AsDouble ()' 2) + Math.Pow (y.AsDouble ()' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,PythagoreanDistanceFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\PythagoreanDistanceFunction.cs,Evaluate,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (x.AsDouble ()' 2) + Math.Pow (y.AsDouble ()' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RandomFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RandomFunction.cs,RandomFunction,The following statement contains a magic number: this._args = 2;  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RandomFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RandomFunction.cs,ToString,The following statement contains a magic number: switch (this._args) {  case 1:  	output.Append (this._rightExpr.ToString ());  	break;  case 2:  	output.Append (this._leftExpr.ToString ());  	output.Append (''');  	output.Append (this._rightExpr.ToString ());  	break;  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareFunction.cs,Evaluate,The following statement contains a magic number: switch (temp.NumericType) {  case SparqlNumericType.Integer:  	long l = temp.AsInteger ();  	return new LongNode (null' l * l);  case SparqlNumericType.Decimal:  	decimal d = temp.AsDecimal ();  	return new DecimalNode (null' d * d);  case SparqlNumericType.Float:  	float f = temp.AsFloat ();  	return new FloatNode (null' f * f);  case SparqlNumericType.Double:  	double dbl = temp.AsDouble ();  	return new DoubleNode (null' Math.Pow (dbl' 2));  case SparqlNumericType.NaN:  default:  	throw new RdfQueryException ("Cannot square a non-numeric argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,SquareFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\SquareFunction.cs,Evaluate,The following statement contains a magic number: return new DoubleNode (null' Math.Pow (dbl' 2));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,TenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\TenFunction.cs,Evaluate,The following statement contains a magic number: switch (temp.NumericType) {  case SparqlNumericType.Integer:  case SparqlNumericType.Decimal:  case SparqlNumericType.Float:  case SparqlNumericType.Double:  	return new DoubleNode (null' Math.Pow (10' temp.AsDouble ()));  case SparqlNumericType.NaN:  default:  	throw new RdfQueryException ("Cannot square a non-numeric argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,TenFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\TenFunction.cs,Evaluate,The following statement contains a magic number: return new DoubleNode (null' Math.Pow (10' temp.AsDouble ()));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianDistance2D,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (dX' 2) + Math.Pow (dY' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianDistance2D,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (dX' 2) + Math.Pow (dY' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianDistance3D,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (dX' 2) + Math.Pow (dY' 2) + Math.Pow (dZ' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianDistance3D,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (dX' 2) + Math.Pow (dY' 2) + Math.Pow (dZ' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,CartesianFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\CartesianFunctions.cs,CartesianDistance3D,The following statement contains a magic number: return new DoubleNode (null' Math.Sqrt (Math.Pow (dX' 2) + Math.Pow (dY' 2) + Math.Pow (dZ' 2)));  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (temp != null) {  	DateTimeOffset dt = temp.AsDateTime ();  	//Regex based check to see if the value has a Timezone component  	//If not then the result is a null  	if (!Regex.IsMatch (temp.AsString ()' "(Z|[+-]\\d{2}:\\d{2})$"))  		return new StringNode (null' string.Empty);  	//Now we have a DateTime we can try and return the Timezone  	if (dt.Offset.Equals (TimeSpan.Zero)) {  		//If Zero it was specified as Z (which means UTC so zero offset)  		return new StringNode (null' "Z");  	}  	else {  		//If the Offset is outside the range -14 to 14 this is considered invalid  		if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  			return null;  		//Otherwise it has an offset which is a given number of hours (and minutes)  		return new StringNode (null' dt.Offset.Hours.ToString ("00") + ":" + dt.Offset.Minutes.ToString ("00"));  	}  }  else {  	throw new RdfQueryException ("Unable to evaluate a Date Time function on a null argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (temp != null) {  	DateTimeOffset dt = temp.AsDateTime ();  	//Regex based check to see if the value has a Timezone component  	//If not then the result is a null  	if (!Regex.IsMatch (temp.AsString ()' "(Z|[+-]\\d{2}:\\d{2})$"))  		return new StringNode (null' string.Empty);  	//Now we have a DateTime we can try and return the Timezone  	if (dt.Offset.Equals (TimeSpan.Zero)) {  		//If Zero it was specified as Z (which means UTC so zero offset)  		return new StringNode (null' "Z");  	}  	else {  		//If the Offset is outside the range -14 to 14 this is considered invalid  		if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  			return null;  		//Otherwise it has an offset which is a given number of hours (and minutes)  		return new StringNode (null' dt.Offset.Hours.ToString ("00") + ":" + dt.Offset.Minutes.ToString ("00"));  	}  }  else {  	throw new RdfQueryException ("Unable to evaluate a Date Time function on a null argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Equals (TimeSpan.Zero)) {  	//If Zero it was specified as Z (which means UTC so zero offset)  	return new StringNode (null' "Z");  }  else {  	//If the Offset is outside the range -14 to 14 this is considered invalid  	if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  		return null;  	//Otherwise it has an offset which is a given number of hours (and minutes)  	return new StringNode (null' dt.Offset.Hours.ToString ("00") + ":" + dt.Offset.Minutes.ToString ("00"));  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Equals (TimeSpan.Zero)) {  	//If Zero it was specified as Z (which means UTC so zero offset)  	return new StringNode (null' "Z");  }  else {  	//If the Offset is outside the range -14 to 14 this is considered invalid  	if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  		return null;  	//Otherwise it has an offset which is a given number of hours (and minutes)  	return new StringNode (null' dt.Offset.Hours.ToString ("00") + ":" + dt.Offset.Minutes.ToString ("00"));  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  	return null;  
Magic Number,VDS.RDF.Query.Expressions.Functions.Sparql.DateTime,TZFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Sparql\DateTime\TZFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  	return null;  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (temp != null) {  	DateTimeOffset dt = temp.AsDateTime ();  	//Regex based check to see if the value has a Timezone component  	//If not then the result is a null  	if (!Regex.IsMatch (temp.AsString ()' "(Z|[+-]\\d{2}:\\d{2})$"))  		return null;  	//Now we have a DateTime we can try and return the Timezone  	if (dt.Offset.Equals (TimeSpan.Zero)) {  		//If Zero it was specified as Z (which means UTC so zero offset)  		return new StringNode (null' "PT0S"' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  	}  	else {  		//If the Offset is outside the range -14 to 14 this is considered invalid  		if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  			return null;  		//Otherwise it has an offset which is a given number of hours and minutse  		string offset = "PT" + Math.Abs (dt.Offset.Hours) + "H";  		if (dt.Offset.Hours < 0)  			offset = "-" + offset;  		if (dt.Offset.Minutes != 0)  			offset = offset + Math.Abs (dt.Offset.Minutes) + "M";  		if (dt.Offset.Hours == 0 && dt.Offset.Minutes < 0)  			offset = "-" + offset;  		return new StringNode (null' offset' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  	}  }  else {  	throw new RdfQueryException ("Unable to evaluate an XPath Date Time function on a null argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (temp != null) {  	DateTimeOffset dt = temp.AsDateTime ();  	//Regex based check to see if the value has a Timezone component  	//If not then the result is a null  	if (!Regex.IsMatch (temp.AsString ()' "(Z|[+-]\\d{2}:\\d{2})$"))  		return null;  	//Now we have a DateTime we can try and return the Timezone  	if (dt.Offset.Equals (TimeSpan.Zero)) {  		//If Zero it was specified as Z (which means UTC so zero offset)  		return new StringNode (null' "PT0S"' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  	}  	else {  		//If the Offset is outside the range -14 to 14 this is considered invalid  		if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  			return null;  		//Otherwise it has an offset which is a given number of hours and minutse  		string offset = "PT" + Math.Abs (dt.Offset.Hours) + "H";  		if (dt.Offset.Hours < 0)  			offset = "-" + offset;  		if (dt.Offset.Minutes != 0)  			offset = offset + Math.Abs (dt.Offset.Minutes) + "M";  		if (dt.Offset.Hours == 0 && dt.Offset.Minutes < 0)  			offset = "-" + offset;  		return new StringNode (null' offset' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  	}  }  else {  	throw new RdfQueryException ("Unable to evaluate an XPath Date Time function on a null argument");  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Equals (TimeSpan.Zero)) {  	//If Zero it was specified as Z (which means UTC so zero offset)  	return new StringNode (null' "PT0S"' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  }  else {  	//If the Offset is outside the range -14 to 14 this is considered invalid  	if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  		return null;  	//Otherwise it has an offset which is a given number of hours and minutse  	string offset = "PT" + Math.Abs (dt.Offset.Hours) + "H";  	if (dt.Offset.Hours < 0)  		offset = "-" + offset;  	if (dt.Offset.Minutes != 0)  		offset = offset + Math.Abs (dt.Offset.Minutes) + "M";  	if (dt.Offset.Hours == 0 && dt.Offset.Minutes < 0)  		offset = "-" + offset;  	return new StringNode (null' offset' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Equals (TimeSpan.Zero)) {  	//If Zero it was specified as Z (which means UTC so zero offset)  	return new StringNode (null' "PT0S"' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  }  else {  	//If the Offset is outside the range -14 to 14 this is considered invalid  	if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  		return null;  	//Otherwise it has an offset which is a given number of hours and minutse  	string offset = "PT" + Math.Abs (dt.Offset.Hours) + "H";  	if (dt.Offset.Hours < 0)  		offset = "-" + offset;  	if (dt.Offset.Minutes != 0)  		offset = offset + Math.Abs (dt.Offset.Minutes) + "M";  	if (dt.Offset.Hours == 0 && dt.Offset.Minutes < 0)  		offset = "-" + offset;  	return new StringNode (null' offset' UriFactory.Create (XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration));  }  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  	return null;  
Magic Number,VDS.RDF.Query.Expressions.Functions.XPath.DateTime,TimezoneFromDateTimeFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\XPath\DateTime\TimezoneFromDateTimeFunction.cs,Evaluate,The following statement contains a magic number: if (dt.Offset.Hours < -14 || dt.Offset.Hours > 14)  	return null;  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterService,The following statement contains a magic number: if (!this.Endpoint.Uri.EndsWith ("cluster/")) {  	this._clusterUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("cluster/") + 8);  }  else {  	this._clusterUri = this.Endpoint.Uri;  }  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterService,The following statement contains a magic number: this._clusterUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("cluster/") + 8);  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The following statement contains a magic number: if (number < 2)  	throw new RdfReasoningException ("Pellet Server requires the number of Clusters to be at least 2");  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The following statement contains a magic number: if (number < 2)  	throw new RdfReasoningException ("Pellet Server requires the number of Clusters to be at least 2");  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The following statement contains a magic number: if (number < 2)  	throw new RdfReasoningException ("Pellet Server requires the number of Clusters to be at least 2");  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ClusterService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ClusterService.cs,ClusterRaw,The following statement contains a magic number: if (number < 2)  	throw new RdfReasoningException ("Pellet Server requires the number of Clusters to be at least 2");  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,SimilarityService,The following statement contains a magic number: if (!this.Endpoint.Uri.EndsWith ("similarity/")) {  	this._similarityUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("similarity/") + 11);  }  else {  	this._similarityUri = this.Endpoint.Uri;  }  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,SimilarityService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\SimilarityService.cs,SimilarityService,The following statement contains a magic number: this._similarityUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("similarity/") + 11);  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,PredictService,The following statement contains a magic number: if (!this.Endpoint.Uri.EndsWith ("predict/")) {  	this._predictUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("predict/") + 8);  }  else {  	this._predictUri = this.Endpoint.Uri;  }  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,PredictService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\PredictService.cs,PredictService,The following statement contains a magic number: this._predictUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("predict/") + 8);  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ExplainService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ExplainServices.cs,ExplainService,The following statement contains a magic number: if (!this.Endpoint.Uri.EndsWith ("explain")) {  	this._explainUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("explain") + 7);  }  else {  	this._explainUri = this.Endpoint.Uri;  }  
Magic Number,VDS.RDF.Query.Inference.Pellet.Services,ExplainService,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\Pellet\Services\ExplainServices.cs,ExplainService,The following statement contains a magic number: this._explainUri = this.Endpoint.Uri.Substring (0' this.Endpoint.Uri.IndexOf ("explain") + 7);  
Magic Number,VDS.RDF.Writing.Formatting,NTriplesFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\NTriplesFormatter.cs,FormatChar,The following statement contains a magic number: if (c <= 127) {  	//ASCII  	return c.ToString ();  }  else {  	if (c <= 65535) {  		//Small Unicode Escape required  		return "\\u" + ((int)c).ToString ("X4");  	}  	else {  		//Big Unicode Escape required  		return "\\U" + ((int)c).ToString ("X8");  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,NTriplesFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\NTriplesFormatter.cs,FormatChar,The following statement contains a magic number: if (c <= 127) {  	//ASCII  	return c.ToString ();  }  else {  	if (c <= 65535) {  		//Small Unicode Escape required  		return "\\u" + ((int)c).ToString ("X4");  	}  	else {  		//Big Unicode Escape required  		return "\\U" + ((int)c).ToString ("X8");  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,NTriplesFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\NTriplesFormatter.cs,FormatChar,The following statement contains a magic number: if (c <= 65535) {  	//Small Unicode Escape required  	return "\\u" + ((int)c).ToString ("X4");  }  else {  	//Big Unicode Escape required  	return "\\U" + ((int)c).ToString ("X8");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: try {  	this._tempBaseUri = query.BaseUri;  	StringBuilder output = new StringBuilder ();  	//Base and Prefix Declarations if not a sub-query  	if (!query.IsSubQuery) {  		if (query.BaseUri != null) {  			output.AppendLine ("BASE <" + this.FormatUri (query.BaseUri.ToString ()) + ">");  		}  		foreach (String prefix in this._qnameMapper.Prefixes) {  			output.AppendLine ("PREFIX " + prefix + ": <" + this.FormatUri (this._qnameMapper.GetNamespaceUri (prefix).ToString ()) + ">");  		}  		//Use a Blank Line to separate Prologue from Query where necessary  		if (query.BaseUri != null || this._qnameMapper.Prefixes.Any ()) {  			output.AppendLine ();  		}  	}  	//Next up is the Query Verb  	switch (query.QueryType) {  	case SparqlQueryType.Ask:  		output.Append ("ASK ");  		break;  	case SparqlQueryType.Construct:  		output.AppendLine ("CONSTRUCT");  		//Add in the Construct Pattern  		output.AppendLine (this.Format (query.ConstructTemplate));  		break;  	case SparqlQueryType.Describe:  		output.Append ("DESCRIBE ");  		output.AppendLine (this.FormatDescribeVariablesList (query));  		break;  	case SparqlQueryType.DescribeAll:  		output.Append ("DESCRIBE * ");  		break;  	case SparqlQueryType.Select:  		output.Append ("SELECT ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	case SparqlQueryType.SelectAll:  		output.AppendLine ("SELECT *");  		break;  	case SparqlQueryType.SelectAllDistinct:  		output.AppendLine ("SELECT DISTINCT *");  		break;  	case SparqlQueryType.SelectAllReduced:  		output.AppendLine ("SELECT REDUCED *");  		break;  	case SparqlQueryType.SelectDistinct:  		output.Append ("SELECT DISTINCT ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	case SparqlQueryType.SelectReduced:  		output.Append ("SELECT REDUCED ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	default:  		throw new RdfOutputException ("Cannot Format an Unknown Query Type");  	}  	//Then add in FROM and FROM NAMED if not a sub-query  	if (!query.IsSubQuery) {  		foreach (Uri u in query.DefaultGraphs) {  			output.AppendLine ("FROM <" + this.FormatUri (u) + ">");  		}  		foreach (Uri u in query.NamedGraphs) {  			output.AppendLine ("FROM NAMED <" + this.FormatUri (u) + ">");  		}  	}  	//Then the WHERE clause (unless there isn't one)  	if (query.RootGraphPattern == null) {  		if (query.QueryType != SparqlQueryType.Describe)  			throw new RdfOutputException ("Cannot Format a SPARQL Query as it has no Graph Pattern for the WHERE clause and is not a DESCRIBE query");  	}  	else {  		if (query.RootGraphPattern.IsEmpty) {  			output.AppendLine ("WHERE { }");  		}  		else {  			output.AppendLine ("WHERE");  			if (query.RootGraphPattern.HasModifier) {  				output.AppendLine ("{");  			}  			output.AppendLine (this.Format (query.RootGraphPattern));  		}  	}  	//Then a GROUP BY  	if (query.GroupBy != null) {  		output.Append ("GROUP BY ");  		output.AppendLine (this.FormatGroupBy (query.GroupBy));  	}  	//Then a HAVING  	if (query.Having != null) {  		output.Append ("HAVING ");  		output.Append ('(');  		output.Append (this.FormatExpression (query.Having.Expression));  		output.AppendLine (")");  	}  	//Then ORDER BY  	if (query.OrderBy != null) {  		output.Append ("ORDER BY ");  		output.AppendLine (this.FormatOrderBy (query.OrderBy));  	}  	//Then LIMIT and OFFSET  	if (query.Limit >= 0)  		output.AppendLine ("LIMIT " + query.Limit);  	if (query.Offset > 0)  		output.AppendLine ("OFFSET " + query.Offset);  	//Finally BINDINGS  	if (query.Bindings != null) {  		output.Append ("BINDINGS ");  		foreach (String var in query.Bindings.Variables) {  			output.Append ("?" + var);  			output.Append (' ');  		}  		if (query.Bindings.Variables.Any ())  			output.AppendLine ();  		output.Append ('{');  		bool multipleTuples = query.Bindings.Tuples.Count () > 1;  		if (multipleTuples)  			output.AppendLine ();  		foreach (BindingTuple tuple in query.Bindings.Tuples) {  			if (tuple.IsEmpty) {  				if (multipleTuples) {  					output.AppendLineIndented ("()"' 2);  				}  				else {  					output.Append (" () ");  				}  				continue;  			}  			if (multipleTuples) {  				output.AppendIndented ("("' 2);  			}  			else {  				output.Append ("(");  			}  			foreach (String var in query.Bindings.Variables) {  				output.Append (' ');  				if (tuple [var] == null) {  					output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  				}  				else {  					output.Append (this.Format (tuple [var]' null));  				}  			}  			if (multipleTuples) {  				output.AppendLine (")");  			}  			else {  				output.Append (')');  			}  		}  		output.AppendLine ("}");  	}  	return output.ToString ();  }  finally {  	this._tempBaseUri = null;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: try {  	this._tempBaseUri = query.BaseUri;  	StringBuilder output = new StringBuilder ();  	//Base and Prefix Declarations if not a sub-query  	if (!query.IsSubQuery) {  		if (query.BaseUri != null) {  			output.AppendLine ("BASE <" + this.FormatUri (query.BaseUri.ToString ()) + ">");  		}  		foreach (String prefix in this._qnameMapper.Prefixes) {  			output.AppendLine ("PREFIX " + prefix + ": <" + this.FormatUri (this._qnameMapper.GetNamespaceUri (prefix).ToString ()) + ">");  		}  		//Use a Blank Line to separate Prologue from Query where necessary  		if (query.BaseUri != null || this._qnameMapper.Prefixes.Any ()) {  			output.AppendLine ();  		}  	}  	//Next up is the Query Verb  	switch (query.QueryType) {  	case SparqlQueryType.Ask:  		output.Append ("ASK ");  		break;  	case SparqlQueryType.Construct:  		output.AppendLine ("CONSTRUCT");  		//Add in the Construct Pattern  		output.AppendLine (this.Format (query.ConstructTemplate));  		break;  	case SparqlQueryType.Describe:  		output.Append ("DESCRIBE ");  		output.AppendLine (this.FormatDescribeVariablesList (query));  		break;  	case SparqlQueryType.DescribeAll:  		output.Append ("DESCRIBE * ");  		break;  	case SparqlQueryType.Select:  		output.Append ("SELECT ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	case SparqlQueryType.SelectAll:  		output.AppendLine ("SELECT *");  		break;  	case SparqlQueryType.SelectAllDistinct:  		output.AppendLine ("SELECT DISTINCT *");  		break;  	case SparqlQueryType.SelectAllReduced:  		output.AppendLine ("SELECT REDUCED *");  		break;  	case SparqlQueryType.SelectDistinct:  		output.Append ("SELECT DISTINCT ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	case SparqlQueryType.SelectReduced:  		output.Append ("SELECT REDUCED ");  		output.AppendLine (this.FormatVariablesList (query.Variables));  		break;  	default:  		throw new RdfOutputException ("Cannot Format an Unknown Query Type");  	}  	//Then add in FROM and FROM NAMED if not a sub-query  	if (!query.IsSubQuery) {  		foreach (Uri u in query.DefaultGraphs) {  			output.AppendLine ("FROM <" + this.FormatUri (u) + ">");  		}  		foreach (Uri u in query.NamedGraphs) {  			output.AppendLine ("FROM NAMED <" + this.FormatUri (u) + ">");  		}  	}  	//Then the WHERE clause (unless there isn't one)  	if (query.RootGraphPattern == null) {  		if (query.QueryType != SparqlQueryType.Describe)  			throw new RdfOutputException ("Cannot Format a SPARQL Query as it has no Graph Pattern for the WHERE clause and is not a DESCRIBE query");  	}  	else {  		if (query.RootGraphPattern.IsEmpty) {  			output.AppendLine ("WHERE { }");  		}  		else {  			output.AppendLine ("WHERE");  			if (query.RootGraphPattern.HasModifier) {  				output.AppendLine ("{");  			}  			output.AppendLine (this.Format (query.RootGraphPattern));  		}  	}  	//Then a GROUP BY  	if (query.GroupBy != null) {  		output.Append ("GROUP BY ");  		output.AppendLine (this.FormatGroupBy (query.GroupBy));  	}  	//Then a HAVING  	if (query.Having != null) {  		output.Append ("HAVING ");  		output.Append ('(');  		output.Append (this.FormatExpression (query.Having.Expression));  		output.AppendLine (")");  	}  	//Then ORDER BY  	if (query.OrderBy != null) {  		output.Append ("ORDER BY ");  		output.AppendLine (this.FormatOrderBy (query.OrderBy));  	}  	//Then LIMIT and OFFSET  	if (query.Limit >= 0)  		output.AppendLine ("LIMIT " + query.Limit);  	if (query.Offset > 0)  		output.AppendLine ("OFFSET " + query.Offset);  	//Finally BINDINGS  	if (query.Bindings != null) {  		output.Append ("BINDINGS ");  		foreach (String var in query.Bindings.Variables) {  			output.Append ("?" + var);  			output.Append (' ');  		}  		if (query.Bindings.Variables.Any ())  			output.AppendLine ();  		output.Append ('{');  		bool multipleTuples = query.Bindings.Tuples.Count () > 1;  		if (multipleTuples)  			output.AppendLine ();  		foreach (BindingTuple tuple in query.Bindings.Tuples) {  			if (tuple.IsEmpty) {  				if (multipleTuples) {  					output.AppendLineIndented ("()"' 2);  				}  				else {  					output.Append (" () ");  				}  				continue;  			}  			if (multipleTuples) {  				output.AppendIndented ("("' 2);  			}  			else {  				output.Append ("(");  			}  			foreach (String var in query.Bindings.Variables) {  				output.Append (' ');  				if (tuple [var] == null) {  					output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  				}  				else {  					output.Append (this.Format (tuple [var]' null));  				}  			}  			if (multipleTuples) {  				output.AppendLine (")");  			}  			else {  				output.Append (')');  			}  		}  		output.AppendLine ("}");  	}  	return output.ToString ();  }  finally {  	this._tempBaseUri = null;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (query.Bindings != null) {  	output.Append ("BINDINGS ");  	foreach (String var in query.Bindings.Variables) {  		output.Append ("?" + var);  		output.Append (' ');  	}  	if (query.Bindings.Variables.Any ())  		output.AppendLine ();  	output.Append ('{');  	bool multipleTuples = query.Bindings.Tuples.Count () > 1;  	if (multipleTuples)  		output.AppendLine ();  	foreach (BindingTuple tuple in query.Bindings.Tuples) {  		if (tuple.IsEmpty) {  			if (multipleTuples) {  				output.AppendLineIndented ("()"' 2);  			}  			else {  				output.Append (" () ");  			}  			continue;  		}  		if (multipleTuples) {  			output.AppendIndented ("("' 2);  		}  		else {  			output.Append ("(");  		}  		foreach (String var in query.Bindings.Variables) {  			output.Append (' ');  			if (tuple [var] == null) {  				output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  			}  			else {  				output.Append (this.Format (tuple [var]' null));  			}  		}  		if (multipleTuples) {  			output.AppendLine (")");  		}  		else {  			output.Append (')');  		}  	}  	output.AppendLine ("}");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (query.Bindings != null) {  	output.Append ("BINDINGS ");  	foreach (String var in query.Bindings.Variables) {  		output.Append ("?" + var);  		output.Append (' ');  	}  	if (query.Bindings.Variables.Any ())  		output.AppendLine ();  	output.Append ('{');  	bool multipleTuples = query.Bindings.Tuples.Count () > 1;  	if (multipleTuples)  		output.AppendLine ();  	foreach (BindingTuple tuple in query.Bindings.Tuples) {  		if (tuple.IsEmpty) {  			if (multipleTuples) {  				output.AppendLineIndented ("()"' 2);  			}  			else {  				output.Append (" () ");  			}  			continue;  		}  		if (multipleTuples) {  			output.AppendIndented ("("' 2);  		}  		else {  			output.Append ("(");  		}  		foreach (String var in query.Bindings.Variables) {  			output.Append (' ');  			if (tuple [var] == null) {  				output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  			}  			else {  				output.Append (this.Format (tuple [var]' null));  			}  		}  		if (multipleTuples) {  			output.AppendLine (")");  		}  		else {  			output.Append (')');  		}  	}  	output.AppendLine ("}");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (BindingTuple tuple in query.Bindings.Tuples) {  	if (tuple.IsEmpty) {  		if (multipleTuples) {  			output.AppendLineIndented ("()"' 2);  		}  		else {  			output.Append (" () ");  		}  		continue;  	}  	if (multipleTuples) {  		output.AppendIndented ("("' 2);  	}  	else {  		output.Append ("(");  	}  	foreach (String var in query.Bindings.Variables) {  		output.Append (' ');  		if (tuple [var] == null) {  			output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  		}  		else {  			output.Append (this.Format (tuple [var]' null));  		}  	}  	if (multipleTuples) {  		output.AppendLine (")");  	}  	else {  		output.Append (')');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (BindingTuple tuple in query.Bindings.Tuples) {  	if (tuple.IsEmpty) {  		if (multipleTuples) {  			output.AppendLineIndented ("()"' 2);  		}  		else {  			output.Append (" () ");  		}  		continue;  	}  	if (multipleTuples) {  		output.AppendIndented ("("' 2);  	}  	else {  		output.Append ("(");  	}  	foreach (String var in query.Bindings.Variables) {  		output.Append (' ');  		if (tuple [var] == null) {  			output.AppendLine (SparqlSpecsHelper.SparqlKeywordUndef);  		}  		else {  			output.Append (this.Format (tuple [var]' null));  		}  	}  	if (multipleTuples) {  		output.AppendLine (")");  	}  	else {  		output.Append (')');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (tuple.IsEmpty) {  	if (multipleTuples) {  		output.AppendLineIndented ("()"' 2);  	}  	else {  		output.Append (" () ");  	}  	continue;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (multipleTuples) {  	output.AppendLineIndented ("()"' 2);  }  else {  	output.Append (" () ");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented ("()"' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (multipleTuples) {  	output.AppendIndented ("("' 2);  }  else {  	output.Append ("(");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendIndented ("("' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.IsUnion) {  	for (int i = 0; i < gp.ChildGraphPatterns.Count; i++) {  		output.Append (this.Format (gp.ChildGraphPatterns [i]));  		if (i < gp.ChildGraphPatterns.Count - 1) {  			output.AppendLine ();  			output.AppendLine ("UNION");  		}  	}  	return output.ToString ();  }  else if (gp.IsGraph || gp.IsService) {  	if (gp.IsGraph) {  		output.Append ("GRAPH ");  	}  	else {  		output.Append ("SERVICE ");  		if (gp.IsSilent)  			output.Append ("SILENT ");  	}  	switch (gp.GraphSpecifier.TokenType) {  	case Token.QNAME:  		try {  			String uri = Tools.ResolveQName (gp.GraphSpecifier.Value' this._qnameMapper' this._tempBaseUri);  			//If the QName resolves OK in the context of the Namespace Map we're using to format this then we  			//can print the QName as-is  			output.Append (gp.GraphSpecifier.Value);  		}  		catch {  			//If the QName fails to resolve then can't format in the context  			throw new RdfOutputException ("Cannot format the Graph/Service Specifier QName " + gp.GraphSpecifier.Value + " as the Namespace Mapper in use for this Formatter cannot resolve the QName");  		}  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (gp.GraphSpecifier.Value));  		output.Append ('>');  		break;  	case Token.VARIABLE:  	default:  		output.Append (gp.GraphSpecifier.Value);  		break;  	}  	output.Append (' ');  }  else if (gp.IsSubQuery) {  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (((SubQueryPattern)gp.TriplePatterns [0]).SubQuery)' 2);  	output.AppendLine ("}");  	return output.ToString ();  }  else if (gp.IsOptional) {  	output.Append ("OPTIONAL ");  }  else if (gp.IsExists) {  	output.Append ("EXISTS ");  }  else if (gp.IsNotExists) {  	output.Append ("NOT EXISTS ");  }  else if (gp.IsMinus) {  	output.Append ("MINUS ");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.IsGraph || gp.IsService) {  	if (gp.IsGraph) {  		output.Append ("GRAPH ");  	}  	else {  		output.Append ("SERVICE ");  		if (gp.IsSilent)  			output.Append ("SILENT ");  	}  	switch (gp.GraphSpecifier.TokenType) {  	case Token.QNAME:  		try {  			String uri = Tools.ResolveQName (gp.GraphSpecifier.Value' this._qnameMapper' this._tempBaseUri);  			//If the QName resolves OK in the context of the Namespace Map we're using to format this then we  			//can print the QName as-is  			output.Append (gp.GraphSpecifier.Value);  		}  		catch {  			//If the QName fails to resolve then can't format in the context  			throw new RdfOutputException ("Cannot format the Graph/Service Specifier QName " + gp.GraphSpecifier.Value + " as the Namespace Mapper in use for this Formatter cannot resolve the QName");  		}  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (gp.GraphSpecifier.Value));  		output.Append ('>');  		break;  	case Token.VARIABLE:  	default:  		output.Append (gp.GraphSpecifier.Value);  		break;  	}  	output.Append (' ');  }  else if (gp.IsSubQuery) {  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (((SubQueryPattern)gp.TriplePatterns [0]).SubQuery)' 2);  	output.AppendLine ("}");  	return output.ToString ();  }  else if (gp.IsOptional) {  	output.Append ("OPTIONAL ");  }  else if (gp.IsExists) {  	output.Append ("EXISTS ");  }  else if (gp.IsNotExists) {  	output.Append ("NOT EXISTS ");  }  else if (gp.IsMinus) {  	output.Append ("MINUS ");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.IsSubQuery) {  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (((SubQueryPattern)gp.TriplePatterns [0]).SubQuery)' 2);  	output.AppendLine ("}");  	return output.ToString ();  }  else if (gp.IsOptional) {  	output.Append ("OPTIONAL ");  }  else if (gp.IsExists) {  	output.Append ("EXISTS ");  }  else if (gp.IsNotExists) {  	output.Append ("NOT EXISTS ");  }  else if (gp.IsMinus) {  	output.Append ("MINUS ");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented (this.Format (((SubQueryPattern)gp.TriplePatterns [0]).SubQuery)' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) {  	output.AppendLine ("{");  	foreach (ITriplePattern tp in gp.TriplePatterns) {  		output.AppendLineIndented (this.Format (tp)' 2);  	}  	foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  		output.AppendLineIndented (this.Format (ap)' 2);  	}  	foreach (GraphPattern child in gp.ChildGraphPatterns) {  		output.AppendLineIndented (this.Format (child)' 2);  	}  	foreach (ISparqlFilter fp in gp.UnplacedFilters) {  		output.AppendIndented ("FILTER("' 2);  		output.Append (this.FormatExpression (fp.Expression));  		output.AppendLine (")");  	}  	output.Append ("}");  }  else if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) {  	output.AppendLine ("{");  	foreach (ITriplePattern tp in gp.TriplePatterns) {  		output.AppendLineIndented (this.Format (tp)' 2);  	}  	foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  		output.AppendLineIndented (this.Format (ap)' 2);  	}  	foreach (GraphPattern child in gp.ChildGraphPatterns) {  		output.AppendLineIndented (this.Format (child)' 2);  	}  	foreach (ISparqlFilter fp in gp.UnplacedFilters) {  		output.AppendIndented ("FILTER("' 2);  		output.Append (this.FormatExpression (fp.Expression));  		output.AppendLine (")");  	}  	output.Append ("}");  }  else if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) {  	output.AppendLine ("{");  	foreach (ITriplePattern tp in gp.TriplePatterns) {  		output.AppendLineIndented (this.Format (tp)' 2);  	}  	foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  		output.AppendLineIndented (this.Format (ap)' 2);  	}  	foreach (GraphPattern child in gp.ChildGraphPatterns) {  		output.AppendLineIndented (this.Format (child)' 2);  	}  	foreach (ISparqlFilter fp in gp.UnplacedFilters) {  		output.AppendIndented ("FILTER("' 2);  		output.Append (this.FormatExpression (fp.Expression));  		output.AppendLine (")");  	}  	output.Append ("}");  }  else if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) {  	output.AppendLine ("{");  	foreach (ITriplePattern tp in gp.TriplePatterns) {  		output.AppendLineIndented (this.Format (tp)' 2);  	}  	foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  		output.AppendLineIndented (this.Format (ap)' 2);  	}  	foreach (GraphPattern child in gp.ChildGraphPatterns) {  		output.AppendLineIndented (this.Format (child)' 2);  	}  	foreach (ISparqlFilter fp in gp.UnplacedFilters) {  		output.AppendIndented ("FILTER("' 2);  		output.Append (this.FormatExpression (fp.Expression));  		output.AppendLine (")");  	}  	output.Append ("}");  }  else if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count > 1 || gp.HasChildGraphPatterns || (gp.TriplePatterns.Count <= 1 && gp.Filter != null) || gp.UnplacedAssignments.Count () > 0 || gp.UnplacedFilters.Count () > 0) {  	output.AppendLine ("{");  	foreach (ITriplePattern tp in gp.TriplePatterns) {  		output.AppendLineIndented (this.Format (tp)' 2);  	}  	foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  		output.AppendLineIndented (this.Format (ap)' 2);  	}  	foreach (GraphPattern child in gp.ChildGraphPatterns) {  		output.AppendLineIndented (this.Format (child)' 2);  	}  	foreach (ISparqlFilter fp in gp.UnplacedFilters) {  		output.AppendIndented ("FILTER("' 2);  		output.Append (this.FormatExpression (fp.Expression));  		output.AppendLine (")");  	}  	output.Append ("}");  }  else if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (ITriplePattern tp in gp.TriplePatterns) {  	output.AppendLineIndented (this.Format (tp)' 2);  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented (this.Format (tp)' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (IAssignmentPattern ap in gp.UnplacedAssignments) {  	output.AppendLineIndented (this.Format (ap)' 2);  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented (this.Format (ap)' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (GraphPattern child in gp.ChildGraphPatterns) {  	output.AppendLineIndented (this.Format (child)' 2);  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented (this.Format (child)' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: foreach (ISparqlFilter fp in gp.UnplacedFilters) {  	output.AppendIndented ("FILTER("' 2);  	output.Append (this.FormatExpression (fp.Expression));  	output.AppendLine (")");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendIndented ("FILTER("' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.TriplePatterns.Count == 0) {  	if (gp.Filter != null) {  		output.AppendIndented ("{ FILTER("' 2);  		output.Append (this.FormatExpression (gp.Filter.Expression));  		output.AppendLine (") }");  	}  	else {  		output.Append ("{ }");  	}  }  else {  	output.Append ("{ ");  	output.Append (this.Format (gp.TriplePatterns [0]));  	output.Append (" }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (gp.Filter != null) {  	output.AppendIndented ("{ FILTER("' 2);  	output.Append (this.FormatExpression (gp.Filter.Expression));  	output.AppendLine (") }");  }  else {  	output.Append ("{ }");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendIndented ("{ FILTER("' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (tp is TriplePattern) {  	TriplePattern match = (TriplePattern)tp;  	output.Append (this.Format (match.Subject' TripleSegment.Subject));  	output.Append (' ');  	output.Append (this.Format (match.Predicate' TripleSegment.Predicate));  	output.Append (' ');  	output.Append (this.Format (match.Object' TripleSegment.Object));  	output.Append (" .");  }  else if (tp is FilterPattern) {  	FilterPattern filter = (FilterPattern)tp;  	output.Append ("FILTER(");  	output.Append (this.FormatExpression (filter.Filter.Expression));  	output.Append (")");  }  else if (tp is SubQueryPattern) {  	SubQueryPattern subquery = (SubQueryPattern)tp;  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (subquery.SubQuery)' 2);  	output.AppendLine ("}");  }  else if (tp is PropertyPathPattern) {  	PropertyPathPattern path = (PropertyPathPattern)tp;  	output.Append (this.Format (path.Subject' TripleSegment.Subject));  	output.Append (' ');  	output.Append (this.FormatPath (path.Path));  	output.Append (' ');  	output.Append (this.Format (path.Object' TripleSegment.Object));  	output.Append (" .");  }  else if (tp is LetPattern) {  	LetPattern let = (LetPattern)tp;  	output.Append ("LET(?");  	output.Append (let.VariableName);  	output.Append (" := ");  	output.Append (this.FormatExpression (let.AssignExpression));  	output.Append (")");  }  else if (tp is BindPattern) {  	BindPattern bind = (BindPattern)tp;  	output.Append ("BIND (");  	output.Append (this.FormatExpression (bind.AssignExpression));  	output.Append (" AS ?");  	output.Append (bind.VariableName);  	output.Append (")");  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ITriplePattern implementation as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (tp is FilterPattern) {  	FilterPattern filter = (FilterPattern)tp;  	output.Append ("FILTER(");  	output.Append (this.FormatExpression (filter.Filter.Expression));  	output.Append (")");  }  else if (tp is SubQueryPattern) {  	SubQueryPattern subquery = (SubQueryPattern)tp;  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (subquery.SubQuery)' 2);  	output.AppendLine ("}");  }  else if (tp is PropertyPathPattern) {  	PropertyPathPattern path = (PropertyPathPattern)tp;  	output.Append (this.Format (path.Subject' TripleSegment.Subject));  	output.Append (' ');  	output.Append (this.FormatPath (path.Path));  	output.Append (' ');  	output.Append (this.Format (path.Object' TripleSegment.Object));  	output.Append (" .");  }  else if (tp is LetPattern) {  	LetPattern let = (LetPattern)tp;  	output.Append ("LET(?");  	output.Append (let.VariableName);  	output.Append (" := ");  	output.Append (this.FormatExpression (let.AssignExpression));  	output.Append (")");  }  else if (tp is BindPattern) {  	BindPattern bind = (BindPattern)tp;  	output.Append ("BIND (");  	output.Append (this.FormatExpression (bind.AssignExpression));  	output.Append (" AS ?");  	output.Append (bind.VariableName);  	output.Append (")");  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ITriplePattern implementation as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: if (tp is SubQueryPattern) {  	SubQueryPattern subquery = (SubQueryPattern)tp;  	output.AppendLine ("{");  	output.AppendLineIndented (this.Format (subquery.SubQuery)' 2);  	output.AppendLine ("}");  }  else if (tp is PropertyPathPattern) {  	PropertyPathPattern path = (PropertyPathPattern)tp;  	output.Append (this.Format (path.Subject' TripleSegment.Subject));  	output.Append (' ');  	output.Append (this.FormatPath (path.Path));  	output.Append (' ');  	output.Append (this.Format (path.Object' TripleSegment.Object));  	output.Append (" .");  }  else if (tp is LetPattern) {  	LetPattern let = (LetPattern)tp;  	output.Append ("LET(?");  	output.Append (let.VariableName);  	output.Append (" := ");  	output.Append (this.FormatExpression (let.AssignExpression));  	output.Append (")");  }  else if (tp is BindPattern) {  	BindPattern bind = (BindPattern)tp;  	output.Append ("BIND (");  	output.Append (this.FormatExpression (bind.AssignExpression));  	output.Append (" AS ?");  	output.Append (bind.VariableName);  	output.Append (")");  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ITriplePattern implementation as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,Format,The following statement contains a magic number: output.AppendLineIndented (this.Format (subquery.SubQuery)' 2);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: for (int i = 0; i < varList.Count; i++) {  	SparqlVariable v = varList [i];  	if (v.IsAggregate) {  		onLine += 2;  		output.Append ('(');  		output.Append (this.FormatAggregate (v.Aggregate));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else if (v.IsProjection) {  		onLine += 3;  		output.Append ('(');  		output.Append (this.FormatExpression (v.Projection));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else {  		onLine += 1;  		output.Append (v.ToString ());  	}  	//Maximum of 6 things per line (aggregates worth 2 and expression worth 3)  	if (onLine >= 6 && i < varList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < varList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: for (int i = 0; i < varList.Count; i++) {  	SparqlVariable v = varList [i];  	if (v.IsAggregate) {  		onLine += 2;  		output.Append ('(');  		output.Append (this.FormatAggregate (v.Aggregate));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else if (v.IsProjection) {  		onLine += 3;  		output.Append ('(');  		output.Append (this.FormatExpression (v.Projection));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else {  		onLine += 1;  		output.Append (v.ToString ());  	}  	//Maximum of 6 things per line (aggregates worth 2 and expression worth 3)  	if (onLine >= 6 && i < varList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < varList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: for (int i = 0; i < varList.Count; i++) {  	SparqlVariable v = varList [i];  	if (v.IsAggregate) {  		onLine += 2;  		output.Append ('(');  		output.Append (this.FormatAggregate (v.Aggregate));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else if (v.IsProjection) {  		onLine += 3;  		output.Append ('(');  		output.Append (this.FormatExpression (v.Projection));  		output.Append (" AS ?");  		output.Append (v.Name);  		output.Append (')');  	}  	else {  		onLine += 1;  		output.Append (v.ToString ());  	}  	//Maximum of 6 things per line (aggregates worth 2 and expression worth 3)  	if (onLine >= 6 && i < varList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < varList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: if (v.IsAggregate) {  	onLine += 2;  	output.Append ('(');  	output.Append (this.FormatAggregate (v.Aggregate));  	output.Append (" AS ?");  	output.Append (v.Name);  	output.Append (')');  }  else if (v.IsProjection) {  	onLine += 3;  	output.Append ('(');  	output.Append (this.FormatExpression (v.Projection));  	output.Append (" AS ?");  	output.Append (v.Name);  	output.Append (')');  }  else {  	onLine += 1;  	output.Append (v.ToString ());  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: if (v.IsAggregate) {  	onLine += 2;  	output.Append ('(');  	output.Append (this.FormatAggregate (v.Aggregate));  	output.Append (" AS ?");  	output.Append (v.Name);  	output.Append (')');  }  else if (v.IsProjection) {  	onLine += 3;  	output.Append ('(');  	output.Append (this.FormatExpression (v.Projection));  	output.Append (" AS ?");  	output.Append (v.Name);  	output.Append (')');  }  else {  	onLine += 1;  	output.Append (v.ToString ());  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: onLine += 2;  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: if (v.IsProjection) {  	onLine += 3;  	output.Append ('(');  	output.Append (this.FormatExpression (v.Projection));  	output.Append (" AS ?");  	output.Append (v.Name);  	output.Append (')');  }  else {  	onLine += 1;  	output.Append (v.ToString ());  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: onLine += 3;  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatVariablesList,The following statement contains a magic number: if (onLine >= 6 && i < varList.Count - 1) {  	output.AppendLine ();  }  else if (i < varList.Count - 1) {  	output.Append (' ');  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: for (int i = 0; i < tokenList.Count; i++) {  	IToken t = tokenList [i];  	switch (t.TokenType) {  	case Token.VARIABLE:  		output.Append (t.Value);  		onLine++;  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (t.Value));  		output.Append ('>');  		onLine += 3;  		break;  	case Token.QNAME:  		//If the QName has the same Namespace URI in this Formatter as in the Query then format  		//as a QName otherwise expand to a full URI  		String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  		if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  			output.AppendLine (t.Value);  			onLine += 2;  		}  		else if (q.NamespaceMap.HasNamespace (prefix)) {  			output.Append ('<');  			output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  			output.Append ('>');  			onLine += 3;  		}  		else {  			throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  		}  		break;  	}  	//Maximum of 6 things per line (URIs worth 3 and QNames worth 2)  	if (onLine >= 6 && i < tokenList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < tokenList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: for (int i = 0; i < tokenList.Count; i++) {  	IToken t = tokenList [i];  	switch (t.TokenType) {  	case Token.VARIABLE:  		output.Append (t.Value);  		onLine++;  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (t.Value));  		output.Append ('>');  		onLine += 3;  		break;  	case Token.QNAME:  		//If the QName has the same Namespace URI in this Formatter as in the Query then format  		//as a QName otherwise expand to a full URI  		String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  		if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  			output.AppendLine (t.Value);  			onLine += 2;  		}  		else if (q.NamespaceMap.HasNamespace (prefix)) {  			output.Append ('<');  			output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  			output.Append ('>');  			onLine += 3;  		}  		else {  			throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  		}  		break;  	}  	//Maximum of 6 things per line (URIs worth 3 and QNames worth 2)  	if (onLine >= 6 && i < tokenList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < tokenList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: for (int i = 0; i < tokenList.Count; i++) {  	IToken t = tokenList [i];  	switch (t.TokenType) {  	case Token.VARIABLE:  		output.Append (t.Value);  		onLine++;  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (t.Value));  		output.Append ('>');  		onLine += 3;  		break;  	case Token.QNAME:  		//If the QName has the same Namespace URI in this Formatter as in the Query then format  		//as a QName otherwise expand to a full URI  		String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  		if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  			output.AppendLine (t.Value);  			onLine += 2;  		}  		else if (q.NamespaceMap.HasNamespace (prefix)) {  			output.Append ('<');  			output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  			output.Append ('>');  			onLine += 3;  		}  		else {  			throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  		}  		break;  	}  	//Maximum of 6 things per line (URIs worth 3 and QNames worth 2)  	if (onLine >= 6 && i < tokenList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < tokenList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: for (int i = 0; i < tokenList.Count; i++) {  	IToken t = tokenList [i];  	switch (t.TokenType) {  	case Token.VARIABLE:  		output.Append (t.Value);  		onLine++;  		break;  	case Token.URI:  		output.Append ('<');  		output.Append (this.FormatUri (t.Value));  		output.Append ('>');  		onLine += 3;  		break;  	case Token.QNAME:  		//If the QName has the same Namespace URI in this Formatter as in the Query then format  		//as a QName otherwise expand to a full URI  		String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  		if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  			output.AppendLine (t.Value);  			onLine += 2;  		}  		else if (q.NamespaceMap.HasNamespace (prefix)) {  			output.Append ('<');  			output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  			output.Append ('>');  			onLine += 3;  		}  		else {  			throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  		}  		break;  	}  	//Maximum of 6 things per line (URIs worth 3 and QNames worth 2)  	if (onLine >= 6 && i < tokenList.Count - 1) {  		output.AppendLine ();  	}  	else if (i < tokenList.Count - 1) {  		output.Append (' ');  	}  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: switch (t.TokenType) {  case Token.VARIABLE:  	output.Append (t.Value);  	onLine++;  	break;  case Token.URI:  	output.Append ('<');  	output.Append (this.FormatUri (t.Value));  	output.Append ('>');  	onLine += 3;  	break;  case Token.QNAME:  	//If the QName has the same Namespace URI in this Formatter as in the Query then format  	//as a QName otherwise expand to a full URI  	String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  	if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  		output.AppendLine (t.Value);  		onLine += 2;  	}  	else if (q.NamespaceMap.HasNamespace (prefix)) {  		output.Append ('<');  		output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  		output.Append ('>');  		onLine += 3;  	}  	else {  		throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  	}  	break;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: switch (t.TokenType) {  case Token.VARIABLE:  	output.Append (t.Value);  	onLine++;  	break;  case Token.URI:  	output.Append ('<');  	output.Append (this.FormatUri (t.Value));  	output.Append ('>');  	onLine += 3;  	break;  case Token.QNAME:  	//If the QName has the same Namespace URI in this Formatter as in the Query then format  	//as a QName otherwise expand to a full URI  	String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  	if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  		output.AppendLine (t.Value);  		onLine += 2;  	}  	else if (q.NamespaceMap.HasNamespace (prefix)) {  		output.Append ('<');  		output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  		output.Append ('>');  		onLine += 3;  	}  	else {  		throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  	}  	break;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: switch (t.TokenType) {  case Token.VARIABLE:  	output.Append (t.Value);  	onLine++;  	break;  case Token.URI:  	output.Append ('<');  	output.Append (this.FormatUri (t.Value));  	output.Append ('>');  	onLine += 3;  	break;  case Token.QNAME:  	//If the QName has the same Namespace URI in this Formatter as in the Query then format  	//as a QName otherwise expand to a full URI  	String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  	if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  		output.AppendLine (t.Value);  		onLine += 2;  	}  	else if (q.NamespaceMap.HasNamespace (prefix)) {  		output.Append ('<');  		output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  		output.Append ('>');  		onLine += 3;  	}  	else {  		throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  	}  	break;  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: onLine += 3;  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  	output.AppendLine (t.Value);  	onLine += 2;  }  else if (q.NamespaceMap.HasNamespace (prefix)) {  	output.Append ('<');  	output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  	output.Append ('>');  	onLine += 3;  }  else {  	throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  	output.AppendLine (t.Value);  	onLine += 2;  }  else if (q.NamespaceMap.HasNamespace (prefix)) {  	output.Append ('<');  	output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  	output.Append ('>');  	onLine += 3;  }  else {  	throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: onLine += 2;  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: if (q.NamespaceMap.HasNamespace (prefix)) {  	output.Append ('<');  	output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  	output.Append ('>');  	onLine += 3;  }  else {  	throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: onLine += 3;  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following statement contains a magic number: if (onLine >= 6 && i < tokenList.Count - 1) {  	output.AppendLine ();  }  else if (i < tokenList.Count - 1) {  	output.Append (' ');  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is AlternativePath) {  	AlternativePath alt = (AlternativePath)path;  	output.Append ('(');  	output.Append (this.FormatPath (alt.LhsPath));  	output.Append (" | ");  	output.Append (this.FormatPath (alt.RhsPath));  	output.Append (')');  }  else if (path is FixedCardinality) {  	FixedCardinality card = (FixedCardinality)path;  	if (card.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (card.Path));  	if (card.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (card.MaxCardinality);  	output.Append ('}');  }  else if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is AlternativePath) {  	AlternativePath alt = (AlternativePath)path;  	output.Append ('(');  	output.Append (this.FormatPath (alt.LhsPath));  	output.Append (" | ");  	output.Append (this.FormatPath (alt.RhsPath));  	output.Append (')');  }  else if (path is FixedCardinality) {  	FixedCardinality card = (FixedCardinality)path;  	if (card.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (card.Path));  	if (card.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (card.MaxCardinality);  	output.Append ('}');  }  else if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is FixedCardinality) {  	FixedCardinality card = (FixedCardinality)path;  	if (card.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (card.Path));  	if (card.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (card.MaxCardinality);  	output.Append ('}');  }  else if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is FixedCardinality) {  	FixedCardinality card = (FixedCardinality)path;  	if (card.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (card.Path));  	if (card.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (card.MaxCardinality);  	output.Append ('}');  }  else if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is InversePath) {  	InversePath inv = (InversePath)path;  	output.Append ('^');  	if (inv.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (inv.Path));  	if (inv.Path is BaseBinaryPath)  		output.Append (')');  }  else if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NOrMore) {  	NOrMore nOrMore = (NOrMore)path;  	if (nOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nOrMore.Path));  	if (nOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nOrMore.MinCardinality);  	output.Append ("'}");  }  else if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NToM) {  	NToM nToM = (NToM)path;  	if (nToM.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (nToM.Path));  	if (nToM.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('{');  	output.Append (nToM.MinCardinality);  	output.Append (''');  	output.Append (nToM.MaxCardinality);  	output.Append ('}');  }  else if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is OneOrMore) {  	OneOrMore oneOrMore = (OneOrMore)path;  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (oneOrMore.Path));  	if (oneOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('+');  }  else if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is Property) {  	Property prop = (Property)path;  	output.Append (this.Format (prop.Predicate' TripleSegment.Predicate));  }  else if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is SequencePath) {  	SequencePath seq = (SequencePath)path;  	output.Append (this.FormatPath (seq.LhsPath));  	output.Append (" / ");  	output.Append (this.FormatPath (seq.RhsPath));  }  else if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroOrMore) {  	ZeroOrMore zeroOrMore = (ZeroOrMore)path;  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrMore.Path));  	if (zeroOrMore.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('*');  }  else if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroOrOne) {  	ZeroOrOne zeroOrOne = (ZeroOrOne)path;  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroOrOne.Path));  	if (zeroOrOne.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ('?');  }  else if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is ZeroToN) {  	ZeroToN zeroToN = (ZeroToN)path;  	if (zeroToN.Path is BaseBinaryPath)  		output.Append ('(');  	output.Append (this.FormatPath (zeroToN.Path));  	if (zeroToN.Path is BaseBinaryPath)  		output.Append (')');  	output.Append ("{'");  	output.Append (zeroToN.MaxCardinality);  	output.Append ('}');  }  else if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: if (path is NegatedSet) {  	NegatedSet negSet = (NegatedSet)path;  	output.Append ('!');  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append ('(');  	foreach (Property p in negSet.Properties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	foreach (Property p in negSet.InverseProperties) {  		output.Append (this.FormatPath (p));  		output.Append (" | ");  	}  	output.Remove (output.Length - 3' 3);  	if (negSet.Properties.Count () + negSet.InverseProperties.Count () > 1)  		output.Append (')');  }  else {  	throw new RdfOutputException ("Unable to Format an unknown ISparqlPath implementations as a String");  }  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatPath,The following statement contains a magic number: output.Remove (output.Length - 3' 3);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInts,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 4' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToInts,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 4' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Check (a_in' 1' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongs,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 8' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Check (a_in' 1' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Check (a_in' 1' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongs,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 8' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: a_length -= 4
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 4) {  	a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: a_length -= 4
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToIntsSwapOrder,The following statement contains a magic number: a_result [i++] = ((int)a_in [a_index++] << 24) | ((int)a_in [a_index++] << 16) | ((int)a_in [a_index++] << 8) | a_in [a_index++];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongSwapOrder,The following statement contains a magic number: return ((ulong)a_in [a_index++] << 56) | ((ulong)a_in [a_index++] << 48) | ((ulong)a_in [a_index++] << 40) | ((ulong)a_in [a_index++] << 32) | ((ulong)a_in [a_index++] << 24) | ((ulong)a_in [a_index++] << 16) | ((ulong)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULong,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntSwapOrder,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntSwapOrder,The following statement contains a magic number: return ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntSwapOrder,The following statement contains a magic number: return ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUIntSwapOrder,The following statement contains a magic number: return ((uint)a_in [a_index++] << 24) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index++] << 8) | a_in [a_index];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInt,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInt,The following statement contains a magic number: return (uint)a_in [a_index++] | ((uint)a_in [a_index++] << 8) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index] << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInt,The following statement contains a magic number: return (uint)a_in [a_index++] | ((uint)a_in [a_index++] << 8) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index] << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUInt,The following statement contains a magic number: return (uint)a_in [a_index++] | ((uint)a_in [a_index++] << 8) | ((uint)a_in [a_index++] << 16) | ((uint)a_in [a_index] << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_length -= 8
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToULongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((ulong)a_in [a_index_in++] << 56) | ((ulong)a_in [a_index_in++] << 48) | ((ulong)a_in [a_index_in++] << 40) | ((ulong)a_in [a_index_in++] << 32) | ((ulong)a_in [a_index_in++] << 24) | ((ulong)a_in [a_index_in++] << 16) | ((ulong)a_in [a_index_in++] << 8) | ((ulong)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: for (int i = a_index_out; a_length > 0; a_length -= 8) {  	a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_length -= 8
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToLongsSwapOrder,The following statement contains a magic number: a_result [i++] = (((long)a_in [a_index_in++] << 56) | ((long)a_in [a_index_in++] << 48) | ((long)a_in [a_index_in++] << 40) | ((long)a_in [a_index_in++] << 32) | ((long)a_in [a_index_in++] << 24) | ((long)a_in [a_index_in++] << 16) | ((long)a_in [a_index_in++] << 8) | ((long)a_in [a_index_in++]));  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertCharsToBytes,The following statement contains a magic number: Check (a_in' 2' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertCharsToBytes,The following statement contains a magic number: Check (a_in' 2' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertShortsToBytes,The following statement contains a magic number: Check (a_in' 2' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUShortsToBytes,The following statement contains a magic number: Check (a_in' 2' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytes,The following statement contains a magic number: Check (a_in' 4' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytes,The following statement contains a magic number: Check (a_in' 4' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 4' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 4' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 16);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytes,The following statement contains a magic number: Check (a_in' 4' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytes,The following statement contains a magic number: Check (a_in' 4' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 4' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 4' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 16);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytes,The following statement contains a magic number: Check (a_in' 8' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytes,The following statement contains a magic number: Check (a_in' 8' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 8' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_ulong >> 56) | ((a_ulong & 0x00FF000000000000) >> 40) | ((a_ulong & 0x0000FF0000000000) >> 24) | ((a_ulong & 0x000000FF00000000) >> 8) | ((a_ulong & 0x00000000FF000000) << 8) | ((a_ulong & 0x0000000000FF0000) << 24) | ((a_ulong & 0x000000000000FF00) << 40) | (a_ulong << 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_int >> 24) | ((a_int & 0x00FF0000) >> 8) | ((a_int & 0x0000FF00) << 8) | (a_int << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_int >> 24) | ((a_int & 0x00FF0000) >> 8) | ((a_int & 0x0000FF00) << 8) | (a_int << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_int >> 24) | ((a_int & 0x00FF0000) >> 8) | ((a_int & 0x0000FF00) << 8) | (a_int << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,SwapOrder,The following statement contains a magic number: return (a_int >> 24) | ((a_int & 0x00FF0000) >> 8) | ((a_int & 0x0000FF00) << 8) | (a_int << 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 8' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 48);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 40);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 32);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 16);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytes,The following statement contains a magic number: Check (a_in' 8' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytes,The following statement contains a magic number: Check (a_in' 8' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytes,The following statement contains a magic number: Check (a_in' 8' a_result' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' a_result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' a_result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 8' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: Check (a_in' 8' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: for (int j = 0; a_length > 0; a_length--' a_index++) {  	result [j++] = (byte)(a_in [a_index] >> 56);  	result [j++] = (byte)(a_in [a_index] >> 48);  	result [j++] = (byte)(a_in [a_index] >> 40);  	result [j++] = (byte)(a_in [a_index] >> 32);  	result [j++] = (byte)(a_in [a_index] >> 24);  	result [j++] = (byte)(a_in [a_index] >> 16);  	result [j++] = (byte)(a_in [a_index] >> 8);  	result [j++] = (byte)a_in [a_index];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 48);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 40);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 32);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 16);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongsToBytesSwapOrder,The following statement contains a magic number: result [j++] = (byte)(a_in [a_index] >> 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoublesToBytes,The following statement contains a magic number: Check (a_in' 8' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoublesToBytes,The following statement contains a magic number: Check (a_in' 8' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoublesToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoublesToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 8' result' 0' a_length * 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatsToBytes,The following statement contains a magic number: Check (a_in' 4' 1);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatsToBytes,The following statement contains a magic number: Check (a_in' 4' 1' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatsToBytes,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index * 4' result' 0' a_length * 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: if (a_group) {  	string[] ar = BitConverter.ToString (a_in).ToUpper ().Split (new char[] {  		'-'  	});  	hex = "";  	for (int i = 0; i < ar.Length / 4; i++) {  		if (i != 0)  			hex += "-";  		hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  	}  }  else  	hex = hex.Replace ("-"' "");  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: for (int i = 0; i < ar.Length / 4; i++) {  	if (i != 0)  		hex += "-";  	hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  }  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToHexString,The following statement contains a magic number: hex += ar [i * 4] + ar [i * 4 + 1] + ar [i * 4 + 2] + ar [i * 4 + 3];  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertHexStringToBytes,The following statement contains a magic number: Debug.Assert (a_in.Length % 2 == 0);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertHexStringToBytes,The following statement contains a magic number: for (int i = 0; i < result.Length; i++)  	result [i] = Byte.Parse (a_in.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertHexStringToBytes,The following statement contains a magic number: for (int i = 0; i < result.Length; i++)  	result [i] = Byte.Parse (a_in.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertHexStringToBytes,The following statement contains a magic number: result [i] = Byte.Parse (a_in.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertHexStringToBytes,The following statement contains a magic number: result [i] = Byte.Parse (a_in.Substring (i * 2' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToChars,The following statement contains a magic number: Check (a_in' 1' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToShorts,The following statement contains a magic number: Check (a_in' 1' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToUShorts,The following statement contains a magic number: Check (a_in' 1' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Check (a_in' 1' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Check (a_in' 1' a_result' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Check (a_in' 1' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Check (a_in' 1' a_result' 4' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloats,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 4' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDouble,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Check (a_in' 1' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Check (a_in' 1' a_result' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Check (a_in' 1' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Check (a_in' 1' a_result' 8' a_index_in' a_length' a_index_out);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToDoubles,The following statement contains a magic number: Buffer.BlockCopy (a_in' a_index_in' a_result' a_index_out * 8' a_length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertBytesToFloat,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_in.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatToBytes,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertFloatToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertCharToBytes,The following statement contains a magic number: Debug.Assert (a_index + 2 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertCharToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertShortToBytes,The following statement contains a magic number: Debug.Assert (a_index + 2 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertShortToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUShortToBytes,The following statement contains a magic number: Debug.Assert (a_index + 2 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUShortToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 2);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntToBytes,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertIntToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntToBytes,The following statement contains a magic number: Debug.Assert (a_index + 4 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertUIntToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 4);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongToBytes,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_out.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertLongToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_out' a_index' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytes,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_out.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_out' a_index' 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_out.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 56);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 48);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 40);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 32);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 24);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 16);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertULongToBytesSwapOrder,The following statement contains a magic number: a_out [a_index++] = (byte)(a_in >> 8);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoubleToBytes,The following statement contains a magic number: Debug.Assert (a_index + 8 <= a_result.Length);  
Magic Number,HashLib,Converters,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\Converters.cs,ConvertDoubleToBytes,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (a_in)' 0' a_result' a_index' 8);  
Magic Number,HashLib,HashResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\HashResult.cs,GetUInt,The following statement contains a magic number: if (m_hash.Length != 4)  	throw new InvalidOperationException ();  
Magic Number,HashLib,HashResult,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\HashResult.cs,GetULong,The following statement contains a magic number: if (m_hash.Length != 8)  	throw new InvalidOperationException ();  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,Initialize,The following statement contains a magic number: m_state [2] = 0x98badcfe;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,Initialize,The following statement contains a magic number: m_state [3] = 0x10325476;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 7) | (A >> (32 - 7))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 12) | (D >> (32 - 12))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 17) | (C >> (32 - 17))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 22) | (B >> (32 - 22))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 5) | (A >> (32 - 5))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 9) | (D >> (32 - 9))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 14) | (C >> (32 - 14))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 20) | (B >> (32 - 20))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 4) | (A >> (32 - 4))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 11) | (D >> (32 - 11))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 16) | (C >> (32 - 16))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 23) | (B >> (32 - 23))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: A = ((A << 6) | (A >> (32 - 6))) + B;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: D = ((D << 10) | (D >> (32 - 10))) + A;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: C = ((C << 15) | (C >> (32 - 15))) + D;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: B = ((B << 21) | (B >> (32 - 21))) + C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: m_state [2] += C;  
Magic Number,HashLib.Crypto,MD5,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MD5.cs,TransformBlock,The following statement contains a magic number: m_state [3] += D;  
Magic Number,HashLib.Crypto,MDBase,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\MDBase.cs,Finish,The following statement contains a magic number: padindex += 8;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,GetResult,The following statement contains a magic number: return Converters.ConvertUIntsToBytesSwapOrder (m_state' 0' 7);  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [2] = 0x3070dd17;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [3] = 0xf70e5939;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [4] = 0xffc00b31;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [5] = 0x68581511;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [6] = 0x64f98fa7;  
Magic Number,HashLib.Crypto,SHA224,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA224.cs,Initialize,The following statement contains a magic number: m_state [7] = 0xbefa4fa4;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,Finish,The following statement contains a magic number: padindex += 8;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 16; r < 64; r++) {  	uint T = data [r - 2];  	uint T2 = data [r - 15];  	data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: data [r] = (((T >> 17) | (T << 15)) ^ ((T >> 19) | (T << 13)) ^ (T >> 10)) + data [r - 7] + (((T2 >> 7) | (T2 << 25)) ^ ((T2 >> 18) | (T2 << 14)) ^ (T2 >> 3)) + data [r - 16];  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: for (int r = 0; r < 64; r++) {  	uint T = s_K [r] + data [r] + H + (((E >> 6) | (E << 26)) ^ ((E >> 11) | (E << 21)) ^ ((E >> 25) | (E << 7))) + ((E & F) ^ (~E & G));  	uint T2 = (((A >> 2) | (A << 30)) ^ ((A >> 13) | (A << 19)) ^ ((A >> 22) | (A << 10))) + ((A & B) ^ (A & C) ^ (B & C));  	H = G;  	G = F;  	F = E;  	E = D + T;  	D = C;  	C = B;  	B = A;  	A = T + T2;  }  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [2] += C;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [3] += D;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [4] += E;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [5] += F;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [6] += G;  
Magic Number,HashLib.Crypto,SHA256Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA256Base.cs,TransformBlock,The following statement contains a magic number: m_state [7] += H;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,GetResult,The following statement contains a magic number: return Converters.ConvertULongsToBytesSwapOrder (m_state' 0' 6);  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [2] = 0x9159015a3070dd17;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [3] = 0x152fecd8f70e5939;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [4] = 0x67332667ffc00b31;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [5] = 0x8eb44a8768581511;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [6] = 0xdb0c2e0d64f98fa7;  
Magic Number,HashLib.Crypto,SHA384,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA384.cs,Initialize,The following statement contains a magic number: m_state [7] = 0x47b5481dbefa4fa4;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [2] = 0x3c6ef372fe94f82b;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [3] = 0xa54ff53a5f1d36f1;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [4] = 0x510e527fade682d1;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [5] = 0x9b05688c2b3e6c1f;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [6] = 0x1f83d9abfb41bd6b;  
Magic Number,HashLib.Crypto,SHA512,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512.cs,Initialize,The following statement contains a magic number: m_state [7] = 0x5be0cd19137e2179;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,Finish,The following statement contains a magic number: padindex += 8;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,Finish,The following statement contains a magic number: padindex += 8;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 16; i <= 79; ++i) {  	ulong T0 = data [i - 15];  	ulong T1 = data [i - 2];  	data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: data [i] = (((T1 << 45) | (T1 >> 19)) ^ ((T1 << 3) | (T1 >> 61)) ^ (T1 >> 6)) + data [i - 7] + (((T0 << 63) | (T0 >> 1)) ^ ((T0 << 56) | (T0 >> 8)) ^ (T0 >> 7)) + data [i - 16];  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: for (int i = 0' t = 0; i < 10; i++) {  	h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  	d += h;  	h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  	g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  	c += g;  	g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  	f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  	b += f;  	f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  	e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  	a += e;  	e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  	d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  	h += d;  	d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  	c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  	g += c;  	c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  	b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  	f += b;  	b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  	a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  	e += a;  	a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  }  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += s_K [t] + data [t++] + (((e << 50) | (e >> 14)) ^ ((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41))) + ((e & f) ^ (~e & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: h += (((a << 36) | (a >> 28)) ^ ((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39))) + ((a & b) ^ (a & c) ^ (b & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += s_K [t] + data [t++] + (((d << 50) | (d >> 14)) ^ ((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41))) + ((d & e) ^ (~d & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: g += (((h << 36) | (h >> 28)) ^ ((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39))) + ((h & a) ^ (h & b) ^ (a & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += s_K [t] + data [t++] + (((c << 50) | (c >> 14)) ^ ((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41))) + ((c & d) ^ (~c & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: f += (((g << 36) | (g >> 28)) ^ ((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39))) + ((g & h) ^ (g & a) ^ (h & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += s_K [t] + data [t++] + (((b << 50) | (b >> 14)) ^ ((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41))) + ((b & c) ^ (~b & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: e += (((f << 36) | (f >> 28)) ^ ((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39))) + ((f & g) ^ (f & h) ^ (g & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += s_K [t] + data [t++] + (((a << 50) | (a >> 14)) ^ ((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41))) + ((a & b) ^ (~a & c));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: d += (((e << 36) | (e >> 28)) ^ ((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39))) + ((e & f) ^ (e & g) ^ (f & g));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += s_K [t] + data [t++] + (((h << 50) | (h >> 14)) ^ ((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41))) + ((h & a) ^ (~h & b));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: c += (((d << 36) | (d >> 28)) ^ ((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39))) + ((d & e) ^ (d & f) ^ (e & f));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += s_K [t] + data [t++] + (((g << 50) | (g >> 14)) ^ ((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41))) + ((g & h) ^ (~g & a));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: b += (((c << 36) | (c >> 28)) ^ ((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39))) + ((c & d) ^ (c & e) ^ (d & e));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += s_K [t] + data [t++] + (((f << 50) | (f >> 14)) ^ ((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41))) + ((f & g) ^ (~f & h));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: a += (((b << 36) | (b >> 28)) ^ ((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39))) + ((b & c) ^ (b & d) ^ (c & d));  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [2] += c;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [3] += d;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [4] += e;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [5] += f;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [6] += g;  
Magic Number,HashLib.Crypto,SHA512Base,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\HashLib\SHA512Base.cs,TransformBlock,The following statement contains a magic number: m_state [7] += h;  
Duplicate Code,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The method contains a code clone-set at the following line numbers (starting from the method definition): ((165' 187)' (202' 224))
Duplicate Code,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessModifyCommand,The method contains a code clone-set at the following line numbers (starting from the method definition): ((88' 117)' (163' 192))
Duplicate Code,VDS.RDF.Writing,HtmlSchemaWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\HtmlSchemaWriter.cs,GenerateOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((343' 362)' (436' 455))
Duplicate Code,VDS.RDF.Writing,RdfJsonWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\RdfJsonWriter.cs,GenerateOutput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((55' 74)' (79' 98))
Duplicate Code,VDS.RDF.Query.Describe,MinimalSpanningGraph,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Describe\MinimalSpanningGraph.cs,DescribeInternal,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 38)' (45' 75))
Duplicate Code,VDS.RDF.Query.Inference,SimpleN3RulesReasoner,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Inference\SimpleN3RulesReasoner.cs,TryCreateRule,The method contains a code clone-set at the following line numbers (starting from the method definition): ((13' 52)' (59' 98))
Duplicate Code,VDS.RDF.Update.Commands,ModifyCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ModifyCommand.cs,Evaluate,The method contains a code clone-set at the following line numbers (starting from the method definition): ((88' 117)' (164' 193))
Missing Default,VDS.RDF,BaseLiteralNode,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\LiteralNode.cs,ReadXml,The following switch statement is missing a default case: switch (reader.Name) {  case "lang":  	this._language = reader.Value;  	exit = true;  	break;  case "datatype":  	this._datatype = UriFactory.Create (reader.Value);  	exit = true;  	break;  }  
Missing Default,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Flush,The following switch statement is missing a default case: switch (action.GraphAction.Action) {  case GraphPersistenceActionType.Added:  	//No need to do anything in-memory as will be in the graph collection  	//Call SaveGraph() with an empty graph to create the relevant graph  	//If Triples were added these will be persisted separately with  	//TriplePersistenceActions  	Graph g = new Graph ();  	g.BaseUri = action.GraphAction.Graph.BaseUri;  	this._manager.SaveGraph (g);  	break;  case GraphPersistenceActionType.Deleted:  	//No need to do anything in-memory as won't be in the graph collection  	//If DeleteGraph() is supported call it to delete the relevant graph  	if (this._manager.DeleteSupported) {  		this._manager.DeleteGraph (action.GraphAction.Graph.BaseUri);  	}  	break;  }  
Missing Default,VDS.RDF,PersistentGraphCollection,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Core\PersistentTripleStore.cs,Discard,The following switch statement is missing a default case: switch (action.GraphAction.Action) {  case GraphPersistenceActionType.Added:  	//Need to remove from being in-memory  	this.Remove (action.GraphAction.Graph.BaseUri);  	break;  case GraphPersistenceActionType.Deleted:  	//Need to add back into memory  	this.Add (action.GraphAction.Graph' false);  	break;  }  
Missing Default,VDS.RDF.Configuration,StoreFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DataFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case TripleStore:  	store = new TripleStore ();  	break;  #if !SILVERLIGHT  case WebDemandTripleStore:  	store = new WebDemandTripleStore ();  	break;  #endif  case NativeTripleStore:  	throw new DotNetRdfConfigurationException ("The NativeTripleStore class is obsolete' please use a PersistentTripleStore instead which supercedes this class and provides more useful behaviour");  case PersistentTripleStore:  	subObj = ConfigurationLoader.GetConfigurationNode (g' objNode' propGenericManager);  	if (subObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' subObj);  	if (temp is IGenericIOManager) {  		store = new PersistentTripleStore ((IGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load a Persistent Triple Store identified by the Node '" + objNode.ToString () + "' as the value given the for dnr:genericManager property points to an Object which could not be loaded as an object which implements the IGenericIOManager interface");  	}  	break;  }  
Missing Default,VDS.RDF.Configuration,DatasetFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\DatasetFactory.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case InMemoryDataset:  	storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  	if (storeNode == null) {  		obj = new InMemoryDataset ();  	}  	else {  		Object temp = ConfigurationLoader.LoadObject (g' storeNode);  		if (temp is IInMemoryQueryableStore) {  			obj = new InMemoryDataset ((IInMemoryQueryableStore)temp);  			return true;  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Dataset identified by the Node '" + objNode.ToString () + "' since the Object pointed to by the dnr:usingStore property could not be loaded as an object which implements the IInMemoryQueryableStore interface");  		}  	}  	break;  case InMemoryQuadDataset:  	storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  	if (storeNode == null) {  		obj = new InMemoryQuadDataset ();  	}  	else {  		Object temp = ConfigurationLoader.LoadObject (g' storeNode);  		if (temp is IInMemoryQueryableStore) {  			obj = new InMemoryQuadDataset ((IInMemoryQueryableStore)temp);  			return true;  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Dataset identified by the Node '" + objNode.ToString () + "' since the Object pointed to by the dnr:usingStore property could not be loaded as an object which implements the IInMemoryQueryableStore interface");  		}  	}  	break;  }  
Missing Default,VDS.RDF.Configuration,SparqlEndpointFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\EndpointFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case Endpoint:  	String endpointUri = ConfigurationLoader.GetConfigurationValue (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpointUri));  	if (endpointUri == null)  		return false;  	//Get Default/Named Graphs if specified  	IEnumerable<String> defaultGraphs = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDefaultGraphUri))  	select n.ToString ();  	IEnumerable<String> namedGraphs = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyNamedGraphUri))  	select n.ToString ();  	endpoint = new SparqlRemoteEndpoint (UriFactory.Create (endpointUri)' defaultGraphs' namedGraphs);  	break;  #if !SILVERLIGHT  case FederatedEndpoint:  	IEnumerable<INode> endpoints = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint));  	foreach (INode e in endpoints) {  		Object temp = ConfigurationLoader.LoadObject (g' e);  		if (temp is SparqlRemoteEndpoint) {  			if (endpoint == null) {  				endpoint = new FederatedSparqlRemoteEndpoint ((SparqlRemoteEndpoint)temp);  			}  			else {  				((FederatedSparqlRemoteEndpoint)endpoint).AddEndpoint ((SparqlRemoteEndpoint)temp);  			}  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the SPARQL Endpoint identified by the Node '" + e.ToString () + "' as one of the values for the dnr:endpoint property points to an Object which cannot be loaded as an object which is a SparqlRemoteEndpoint");  		}  	}  	break;  #endif  }  
Missing Default,VDS.RDF.Configuration,PermissionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case Permission:  	String action = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAction));  	result = new Permission (action);  	break;  case PermissionSet:  	IEnumerable<String> actions = from n in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAction))  	where n.NodeType == NodeType.Literal  	select ((ILiteralNode)n).Value;  	result = new PermissionSet (actions);  	break;  }  
Missing Default,VDS.RDF.Configuration,UserGroupFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\PermissionFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case UserGroup:  	result = new UserGroup ();  	//Get the members of the Group  	IEnumerable<INode> members = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyMember));  	foreach (INode member in members) {  		String username' password;  		ConfigurationLoader.GetUsernameAndPassword (g' member' true' out username' out password);  		if (username != null && password != null) {  			result.AddUser (new NetworkCredential (username' password));  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the User identified by the Node '" + member.ToString () + "' as there does not appear to be a valid username and password specified for this User either via the dnr:user and dnr:password properties or via a dnr:credentials property");  		}  	}  	//Get the allow list for the Group  	IEnumerable<INode> allowed = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyAllow));  	foreach (INode allow in allowed) {  		Object temp = ConfigurationLoader.LoadObject (g' allow);  		if (temp is IPermission) {  			result.AddAllowedAction ((IPermission)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Permission identified by the Node '" + allow.ToString () + "' as the Object specified could not be loaded as an object which implements the IPermission interface");  		}  	}  	//Get the deny list for the Group  	IEnumerable<INode> denied = ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDeny));  	foreach (INode deny in denied) {  		Object temp = ConfigurationLoader.LoadObject (g' deny);  		if (temp is IPermission) {  			result.AddDeniedAction ((IPermission)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Permission identified by the Node '" + deny.ToString () + "' as the Object specified could not be loaded as an object which implements the IPermission interface");  		}  	}  	//Does the User Group require authentication?  	result.AllowGuests = !ConfigurationLoader.GetConfigurationBoolean (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyRequiresAuthentication)' true);  	//Is there a permission model specified?  	String mode = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyPermissionModel));  	if (mode != null) {  		#if SILVERLIGHT  		                        result.PermissionModel = (PermissionModel)Enum.Parse(typeof(PermissionModel)' mode' false); #else  		result.PermissionModel = (PermissionModel)Enum.Parse (typeof(PermissionModel)' mode);  		#endif  	}  	break;  }  
Missing Default,VDS.RDF.Configuration,QueryProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case LeviathanQueryProcessor:  	INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset));  	if (datasetObj != null) {  		temp = ConfigurationLoader.LoadObject (g' datasetObj);  		if (temp is ISparqlDataset) {  			processor = new LeviathanQueryProcessor ((ISparqlDataset)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface");  		}  	}  	else {  		//If no dnr:usingDataset try dnr:usingStore instead  		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  		if (storeObj == null)  			return false;  		temp = ConfigurationLoader.LoadObject (g' storeObj);  		if (temp is IInMemoryQueryableStore) {  			processor = new LeviathanQueryProcessor ((IInMemoryQueryableStore)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface");  		}  	}  	break;  case SimpleQueryProcessor:  	storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  	if (storeObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' storeObj);  	if (temp is INativelyQueryableStore) {  		processor = new SimpleQueryProcessor ((INativelyQueryableStore)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Simple Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the INativelyQueryableStore interface");  	}  	break;  case GenericQueryProcessor:  	INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager));  	if (managerObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' managerObj);  	if (temp is IQueryableGenericIOManager) {  		processor = new GenericQueryProcessor ((IQueryableGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Generic Query Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IQueryableGenericIOManager interface");  	}  	break;  #if !SILVERLIGHT  case RemoteQueryProcessor:  	INode endpointObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint));  	if (endpointObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' endpointObj);  	if (temp is SparqlRemoteEndpoint) {  		processor = new RemoteQueryProcessor ((SparqlRemoteEndpoint)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Remote Query Processor identified by the Node '" + objNode.ToSafeString () + "' as the value given for the dnr:endpoint property points to an Object that cannot be loaded as an object which is a SparqlRemoteEndpoint");  	}  	break;  case PelletQueryProcessor:  	String server = ConfigurationLoader.GetConfigurationValue (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyServer));  	if (server == null)  		return false;  	String kb = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyStore));  	if (kb == null)  		return false;  	processor = new PelletQueryProcessor (UriFactory.Create (server)' kb);  	break;  #endif  }  
Missing Default,VDS.RDF.Configuration,UpdateProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case LeviathanUpdateProcessor:  	INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset));  	if (datasetObj != null) {  		temp = ConfigurationLoader.LoadObject (g' datasetObj);  		if (temp is ISparqlDataset) {  			processor = new LeviathanUpdateProcessor ((ISparqlDataset)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface");  		}  	}  	else {  		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  		if (storeObj == null)  			return false;  		temp = ConfigurationLoader.LoadObject (g' storeObj);  		if (temp is IInMemoryQueryableStore) {  			processor = new LeviathanUpdateProcessor ((IInMemoryQueryableStore)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface");  		}  	}  	break;  case SimpleUpdateProcessor:  	storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  	if (storeObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' storeObj);  	if (temp is IUpdateableTripleStore) {  		processor = new SimpleUpdateProcessor ((IUpdateableTripleStore)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Simple Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IUpdateableTripleStore interface");  	}  	break;  case GenericUpdateProcessor:  	INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager));  	if (managerObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' managerObj);  	if (temp is IGenericIOManager) {  		processor = new GenericUpdateProcessor ((IGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Generic Update Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IGenericIOManager interface");  	}  	break;  }  
Missing Default,VDS.RDF.Configuration,ProtocolProcessorFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\ProcessorFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  case ProtocolToUpdateProcessor:  	INode qNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyQueryProcessor));  	INode uNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUpdateProcessor));  	if (qNode == null || uNode == null)  		return false;  	Object queryProc = ConfigurationLoader.LoadObject (g' qNode);  	Object updateProc = ConfigurationLoader.LoadObject (g' uNode);  	if (queryProc is ISparqlQueryProcessor) {  		if (updateProc is ISparqlUpdateProcessor) {  			processor = new ProtocolToUpdateProcessor ((ISparqlQueryProcessor)queryProc' (ISparqlUpdateProcessor)updateProc);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:updateProcessor property points to an Object that cannot be loaded as an object which implements the ISparqlUpdateProcessor interface");  		}  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:queryProcessor property points to an Object that cannot be loaded as an object which implements the ISparqlQueryProcessor interface");  	}  	break;  case LeviathanProtocolProcessor:  	INode datasetNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset));  	if (datasetNode != null) {  		temp = ConfigurationLoader.LoadObject (g' datasetNode);  		if (temp is ISparqlDataset) {  			processor = new LeviathanProtocolProcessor ((ISparqlDataset)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the Leviathan Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface");  		}  	}  	else {  		INode storeNode = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  		if (storeNode == null)  			return false;  		Object store = ConfigurationLoader.LoadObject (g' storeNode);  		if (store is IInMemoryQueryableStore) {  			processor = new LeviathanProtocolProcessor ((IInMemoryQueryableStore)store);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the SPARQL HTTP Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface");  		}  	}  	break;  #if !NO_WEB && !NO_ASP  case GenericProtocolProcessor:  	INode managerObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager));  	if (managerObj == null)  		return false;  	temp = ConfigurationLoader.LoadObject (g' managerObj);  	if (temp is IGenericIOManager) {  		processor = new GenericProtocolProcessor ((IGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Generic Protocol Processor identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object that cannot be loaded as an object which implements the IGenericIOManager interface");  	}  	break;  #endif  }  
Missing Default,VDS.RDF.Configuration,GenericManagerFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Configuration\StorageFactories.cs,TryLoadObject,The following switch statement is missing a default case: switch (targetType.FullName) {  #if !NO_SYNC_HTTP  case AllegroGraph:  	//Get the Server' Catalog and Store  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	String catalog = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyCatalog));  	store = ConfigurationLoader.GetConfigurationString (g' objNode' propStore);  	if (store == null)  		return false;  	//Get User Credentials  	ConfigurationLoader.GetUsernameAndPassword (g' objNode' true' out user' out pwd);  	if (user != null && pwd != null) {  		manager = new AllegroGraphConnector (server' catalog' store' user' pwd);  	}  	else {  		manager = new AllegroGraphConnector (server' catalog' store);  	}  	break;  #endif  case DatasetFile:  	//Get the Filename and whether the loading should be done asynchronously  	String file = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyFromFile));  	if (file == null)  		return false;  	file = ConfigurationLoader.ResolvePath (file);  	isAsync = ConfigurationLoader.GetConfigurationBoolean (g' objNode' propAsync' false);  	manager = new DatasetFileManager (file' isAsync);  	break;  #if !NO_SYNC_HTTP  case Dydra:  	//Get the Account Name and Store  	String account = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyCatalog));  	if (account == null)  		return false;  	store = ConfigurationLoader.GetConfigurationString (g' objNode' propStore);  	if (store == null)  		return false;  	//Get User Credentials  	ConfigurationLoader.GetUsernameAndPassword (g' objNode' true' out user' out pwd);  	if (user != null) {  		manager = new DydraConnector (account' store' user);  	}  	else {  		manager = new DydraConnector (account' store);  	}  	break;  case FourStore:  	//Get the Server and whether Updates are enabled  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	bool enableUpdates = ConfigurationLoader.GetConfigurationBoolean (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEnableUpdates)' true);  	manager = new FourStoreConnector (server' enableUpdates);  	break;  case Fuseki:  	//Get the Server URI  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	manager = new FusekiConnector (server);  	break;  #endif  case InMemory:  	//Get the Dataset/Store  	INode datasetObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingDataset));  	if (datasetObj != null) {  		temp = ConfigurationLoader.LoadObject (g' datasetObj);  		if (temp is ISparqlDataset) {  			manager = new InMemoryManager ((ISparqlDataset)temp);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Manager identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingDataset property points to an Object that cannot be loaded as an object which implements the ISparqlDataset interface");  		}  	}  	else {  		//If no dnr:usingDataset try dnr:usingStore instead  		storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUsingStore));  		if (storeObj != null) {  			temp = ConfigurationLoader.LoadObject (g' storeObj);  			if (temp is IInMemoryQueryableStore) {  				manager = new InMemoryManager ((IInMemoryQueryableStore)temp);  			}  			else {  				throw new DotNetRdfConfigurationException ("Unable to load the In-Memory Manager identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:usingStore property points to an Object that cannot be loaded as an object which implements the IInMemoryQueryableStore interface");  			}  		}  		else {  			//If no dnr:usingStore either then create a new empty store  			manager = new InMemoryManager ();  		}  	}  	break;  #if !NO_SYNC_HTTP  case Joseki:  	//Get the Query and Update URIs  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	String queryService = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyQueryPath));  	if (queryService == null)  		return false;  	String updateService = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyUpdatePath));  	if (updateService == null) {  		manager = new JosekiConnector (server' queryService);  	}  	else {  		manager = new JosekiConnector (server' queryService' updateService);  	}  	break;  #endif  case ReadOnly:  	//Get the actual Manager we are wrapping  	storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager));  	temp = ConfigurationLoader.LoadObject (g' storeObj);  	if (temp is IGenericIOManager) {  		manager = new ReadOnlyConnector ((IGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Read-Only Connector identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object which cannot be loaded as an object which implements the required IGenericIOManager interface");  	}  	break;  case ReadOnlyQueryable:  	//Get the actual Manager we are wrapping  	storeObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyGenericManager));  	temp = ConfigurationLoader.LoadObject (g' storeObj);  	if (temp is IQueryableGenericIOManager) {  		manager = new QueryableReadOnlyConnector ((IQueryableGenericIOManager)temp);  	}  	else {  		throw new DotNetRdfConfigurationException ("Unable to load the Queryable Read-Only Connector identified by the Node '" + objNode.ToString () + "' as the value given for the dnr:genericManager property points to an Object which cannot be loaded as an object which implements the required IQueryableGenericIOManager interface");  	}  	break;  #if !NO_SYNC_HTTP  case Sesame:  case SesameV5:  case SesameV6:  	//Get the Server and Store ID  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	store = ConfigurationLoader.GetConfigurationString (g' objNode' propStore);  	if (store == null)  		return false;  	ConfigurationLoader.GetUsernameAndPassword (g' objNode' true' out user' out pwd);  	if (user != null && pwd != null) {  		manager = (IGenericIOManager)Activator.CreateInstance (targetType' new Object[] {  			server'  			store'  			user'  			pwd  		});  	}  	else {  		manager = (IGenericIOManager)Activator.CreateInstance (targetType' new Object[] {  			server'  			store  		});  	}  	break;  case Sparql:  	//Get the Endpoint URI or the Endpoint  	server = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpointUri));  	//What's the load mode?  	String loadModeRaw = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyLoadMode));  	SparqlConnectorLoadMethod loadMode = SparqlConnectorLoadMethod.Construct;  	if (loadModeRaw != null) {  		try {  			#if SILVERLIGHT  			                            loadMode = (SparqlConnectorLoadMethod)Enum.Parse(typeof(SparqlConnectorLoadMethod)' loadModeRaw' false); #else  			loadMode = (SparqlConnectorLoadMethod)Enum.Parse (typeof(SparqlConnectorLoadMethod)' loadModeRaw);  			#endif  		}  		catch {  			throw new DotNetRdfConfigurationException ("Unable to load the SparqlConnector identified by the Node '" + objNode.ToString () + "' as the value given for the property dnr:loadMode is not valid");  		}  	}  	if (server == null) {  		INode endpointObj = ConfigurationLoader.GetConfigurationNode (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyEndpoint));  		if (endpointObj == null)  			return false;  		temp = ConfigurationLoader.LoadObject (g' endpointObj);  		if (temp is SparqlRemoteEndpoint) {  			manager = new SparqlConnector ((SparqlRemoteEndpoint)temp' loadMode);  		}  		else {  			throw new DotNetRdfConfigurationException ("Unable to load the SparqlConnector identified by the Node '" + objNode.ToString () + "' as the value given for the property dnr:endpoint points to an Object which cannot be loaded as an object which is of the type SparqlRemoteEndpoint");  		}  	}  	else {  		//Are there any Named/Default Graph URIs  		IEnumerable<Uri> defGraphs = from def in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyDefaultGraphUri))  		where def.NodeType == NodeType.Uri  		select ((IUriNode)def).Uri;  		IEnumerable<Uri> namedGraphs = from named in ConfigurationLoader.GetConfigurationData (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyNamedGraphUri))  		where named.NodeType == NodeType.Uri  		select ((IUriNode)named).Uri;  		if (defGraphs.Any () || namedGraphs.Any ()) {  			manager = new SparqlConnector (new SparqlRemoteEndpoint (UriFactory.Create (server)' defGraphs' namedGraphs)' loadMode);  		}  		else {  			manager = new SparqlConnector (UriFactory.Create (server)' loadMode);  		}  	}  	break;  case SparqlHttpProtocol:  	//Get the Service URI  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	manager = new SparqlHttpProtocolConnector (UriFactory.Create (server));  	break;  case Stardog:  	//Get the Server and Store  	server = ConfigurationLoader.GetConfigurationString (g' objNode' propServer);  	if (server == null)  		return false;  	store = ConfigurationLoader.GetConfigurationString (g' objNode' propStore);  	if (store == null)  		return false;  	//Get User Credentials  	ConfigurationLoader.GetUsernameAndPassword (g' objNode' true' out user' out pwd);  	//Get Reasoning Mode  	StardogReasoningMode reasoning = StardogReasoningMode.None;  	String mode = ConfigurationLoader.GetConfigurationString (g' objNode' ConfigurationLoader.CreateConfigurationNode (g' ConfigurationLoader.PropertyLoadMode));  	if (mode != null) {  		try {  			reasoning = (StardogReasoningMode)Enum.Parse (typeof(StardogReasoningMode)' mode);  		}  		catch {  			reasoning = StardogReasoningMode.None;  		}  	}  	if (user != null && pwd != null) {  		manager = new StardogConnector (server' store' reasoning' user' pwd);  	}  	else {  		manager = new StardogConnector (server' store' reasoning);  	}  	break;  case Talis:  	//Get the Store Name and User credentials  	store = ConfigurationLoader.GetConfigurationString (g' objNode' propStore);  	if (store == null)  		return false;  	ConfigurationLoader.GetUsernameAndPassword (g' objNode' true' out user' out pwd);  	if (user != null && pwd != null) {  		manager = new TalisPlatformConnector (store' user' pwd);  	}  	else {  		manager = new TalisPlatformConnector (store);  	}  	break;  #endif  }  
Missing Default,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,ParseInternal,The following switch statement is missing a default case: switch (context.Query.QueryType) {  case SparqlQueryType.Select:  case SparqlQueryType.SelectDistinct:  case SparqlQueryType.SelectReduced:  case SparqlQueryType.Describe:  	//Check Variable Usage  	List<String> projectedSoFar = new List<string> ();  	foreach (SparqlVariable var in context.Query.Variables) {  		if (!var.IsResultVariable)  			continue;  		if (projectedSoFar.Contains (var.Name) && (var.IsAggregate || var.IsProjection)) {  			throw new RdfParseException ("Cannot assign the results of an Aggregate/Project Expression to the variable " + var.ToString () + " as this Variable is already Projected to earlier in the SELECT");  		}  		if (var.IsProjection) {  			if (context.Query.GroupBy != null) {  				//if (!var.Projection.Variables.All(v => context.Query.GroupBy.ProjectableVariables.Contains(v) || projectedSoFar.Contains(v)))  				if (!this.IsProjectableExpression (context' var.Projection' projectedSoFar)) {  					throw new RdfParseException ("Your SELECT uses the Project Expression " + var.Projection.ToString () + " which uses one/more Variables which are either not projectable from the GROUP BY or not projected earlier in the SELECT.  All Variables used must be projectable from the GROUP BY' projected earlier in the SELECT or within an aggregate");  				}  			}  		}  		else if (var.IsAggregate) {  			if (context.Query.GroupBy != null) {  				//Q: Does ISparqlAggregate needs to expose a Variables property?  				//if (!var.Aggregate.Var  			}  		}  		else {  			if (context.Query.GroupBy != null) {  				//If there is a GROUP BY then the Variable must either be projectable from there  				if (!context.Query.GroupBy.ProjectableVariables.Contains (var.Name)) {  					throw new RdfParseException ("Your SELECT/DESCRIBE query tries to project the variable " + var.ToString () + " but this Variable is not Grouped By");  				}  			}  		}  		projectedSoFar.Add (var.Name);  	}  	break;  case SparqlQueryType.DescribeAll:  case SparqlQueryType.SelectAll:  case SparqlQueryType.SelectAllDistinct:  case SparqlQueryType.SelectAllReduced:  	//Check that a GROUP BY has not been used  	if (context.Query.GroupBy != null) {  		throw new RdfParseException ("SELECT/DESCRIBE * is not permitted when a GROUP BY is used");  	}  	break;  }  
Missing Default,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseQueryVerb,The following switch statement is missing a default case: switch (t.TokenType) {  case Token.ASK:  	if (context.SubQueryMode)  		throw ParserHelper.Error ("ASK is not supported in Sub-queries"' t);  	context.Query.QueryType = SparqlQueryType.Ask;  	break;  case Token.CONSTRUCT:  	if (context.SubQueryMode)  		throw ParserHelper.Error ("CONSTRUCT is not supported in Sub-queries"' t);  	context.Query.QueryType = SparqlQueryType.Construct;  	break;  case Token.DESCRIBE:  	if (context.SubQueryMode)  		throw ParserHelper.Error ("DESCRIBE is not supported in Sub-queries"' t);  	context.Query.QueryType = SparqlQueryType.Describe;  	break;  case Token.SELECT:  	context.Query.QueryType = SparqlQueryType.Select;  	break;  }  
Missing Default,VDS.RDF.Parsing,SparqlQueryParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\SparqlQueryParser.cs,TryParseSelectVariables,The following switch statement is missing a default case: switch (context.Query.QueryType) {  case SparqlQueryType.Select:  	context.Query.QueryType = SparqlQueryType.SelectAll;  	break;  case SparqlQueryType.SelectDistinct:  	context.Query.QueryType = SparqlQueryType.SelectAllDistinct;  	break;  case SparqlQueryType.SelectReduced:  	context.Query.QueryType = SparqlQueryType.SelectAllReduced;  	break;  }  
Missing Default,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,ProcessElement,The following switch statement is missing a default case: switch (attr.Name) {  case "xml:lang":  case "lang":  	//@lang and @xml:lang have the same affect  	if (!langChanged) {  		oldLang = lang;  		lang = attr.Value;  		langChanged = true;  	}  	break;  case "xml:base":  	//@xml:base may be permitted in some cases  	if (context.XmlBaseAllowed) {  		baseUri = Tools.ResolveUri (attr.Value' baseUri);  		if (!(baseUri.EndsWith ("/") || baseUri.EndsWith ("#")))  			baseUri += "#";  		oldBase = evalContext.BaseUri;  		baseChanged = true;  		evalContext.BaseUri = UriFactory.Create (baseUri);  	}  	break;  case "xmlns":  	//Can use @xmlns to override the default namespace  	uri = attr.Value;  	if (!(uri.EndsWith ("/") || uri.EndsWith ("#")))  		uri += "#";  	if (evalContext.NamespaceMap.HasNamespace (String.Empty)) {  		if (hiddenPrefixes == null)  			hiddenPrefixes = new Dictionary<string' Uri> ();  		hiddenPrefixes.Add (String.Empty' evalContext.NamespaceMap.GetNamespaceUri (String.Empty));  	}  	evalContext.NamespaceMap.AddNamespace (String.Empty' UriFactory.Create (uri));  	inScopePrefixes.Add (String.Empty);  	noDefaultNamespace = true;  	break;  case "prefix":  	//Can use @prefix to set multiple namespaces with one attribute  	if (context.Syntax == RdfASyntax.RDFa_1_0) {  		this.OnWarning ("Cannot use the @prefix attribute to define prefixes in RDFa 1.0");  	}  	else {  		this.ParsePrefixAttribute (context' evalContext' attr' baseUri' hiddenPrefixes' inScopePrefixes);  	}  	break;  case "rel":  	rel = true;  	break;  case "rev":  	rev = true;  	break;  case "about":  	about = true;  	break;  case "src":  	src = true;  	break;  case "href":  	href = true;  	break;  case "resource":  	resource = true;  	break;  case "typeof":  	type = true;  	break;  case "content":  	content = true;  	break;  case "datatype":  	datatype = true;  	break;  case "property":  	property = true;  	break;  case "profile":  	if (context.Syntax == RdfASyntax.RDFa_1_0) {  		this.OnWarning ("Cannot use the @profile attribute in RDFa 1.0");  	}  	else {  		if (this.ParseProfileAttribute (context' evalContext' attr)) {  			foreach (KeyValuePair<String' String> ns in evalContext.LocalVocabulary.Namespaces) {  				uri = Tools.ResolveUri (ns.Value' baseUri);  				if (!(uri.EndsWith ("/") || uri.EndsWith ("#")))  					uri += "#";  				if (evalContext.NamespaceMap.HasNamespace (ns.Key)) {  					if (hiddenPrefixes == null)  						hiddenPrefixes = new Dictionary<string' Uri> ();  					hiddenPrefixes.Add (ns.Key' evalContext.NamespaceMap.GetNamespaceUri (ns.Key));  				}  				evalContext.NamespaceMap.AddNamespace (ns.Key' UriFactory.Create (uri));  				inScopePrefixes.Add (ns.Key);  			}  		}  		else {  			this.OnWarning ("Unable to resolve a Profile document specified by the @profile attribute on the element <" + currElement.Name + "> - ignoring the DOM subtree of this element");  			return;  		}  	}  	break;  case "vocab":  	if (context.Syntax == RdfASyntax.RDFa_1_0) {  		this.OnWarning ("Cannot use the @vocab attribute in RDFa 1.0");  	}  	else {  		this.ParseVocabAttribute (context' evalContext' attr);  	}  	break;  }  
Missing Default,VDS.RDF.Parsing,RdfAParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\RdfAParser.cs,GrabText,The following switch statement is missing a default case: switch (n.NodeType) {  case HtmlNodeType.Document:  case HtmlNodeType.Element:  	foreach (HtmlNode child in n.ChildNodes) {  		this.GrabText (output' child);  	}  	break;  case HtmlNodeType.Text:  	output.Append (n.InnerText);  	break;  }  
Missing Default,VDS.RDF.Parsing,SparqlPathParser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\SparqlPathParser.cs,TryParsePathPrimary,The following switch statement is missing a default case: switch (next.TokenType) {  case Token.MULTIPLY:  case Token.PLUS:  case Token.QUESTION:  case Token.LEFTCURLYBRACKET:  	path = this.TryParsePathMod (context' tokens' path);  	break;  }  
Missing Default,VDS.RDF.Storage,StardogConnector,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Storage\StardogConnector.cs,ToString,The following switch statement is missing a default case: switch (this._reasoning) {  case StardogReasoningMode.QL:  	mode = " (OWL QL Reasoning)";  	break;  case StardogReasoningMode.EL:  	mode = " (OWL EL Reasoning)";  	break;  case StardogReasoningMode.RL:  	mode = " (OWL RL Reasoning)";  	break;  case StardogReasoningMode.DL:  	mode = " (OWL DL Reasoning)";  	break;  case StardogReasoningMode.RDFS:  	mode = " (RDFS Reasoning)";  	break;  }  
Missing Default,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessClearCommand,The following switch statement is missing a default case: switch (cmd.Mode) {  case ClearMode.Default:  case ClearMode.Graph:  	if (cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.HasDefaultGraph) == 0)  		throw new SparqlUpdateException ("Unable to clear the default graph as the underlying store does not support an explicit default graph");  	if (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.HasNamedGraphs) == 0)  		throw new SparqlUpdateException ("Unable to clear a named graph as the underlying store does not support named graphs");  	if ((cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) {  		//Can approximate by saving an empty Graph over the existing Graph  		g = new Graph ();  		g.BaseUri = cmd.TargetUri;  		this._manager.SaveGraph (g);  	}  	else if (this._manager.UpdateSupported && (this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) != 0) {  		//Can approximate by loading the Graph and then deleting all Triples from it  		g = new NonIndexedGraph ();  		this._manager.LoadGraph (g' cmd.TargetUri);  		this._manager.UpdateGraph (cmd.TargetUri' null' g.Triples);  	}  	else {  		throw new SparqlUpdateException ("Unable to evaluate a CLEAR command as the underlying store does not provide appropriate IO Behaviour to approximate this command");  	}  	break;  case ClearMode.Named:  case ClearMode.All:  	if ((this._manager.IOBehaviour & IOBehaviour.HasNamedGraphs) == 0)  		throw new SparqlUpdateException ("Unable to clear named graphs as the underlying store does not support named graphs");  	if (this._manager.ListGraphsSupported) {  		List<Uri> graphs = this._manager.ListGraphs ().ToList ();  		foreach (Uri u in graphs) {  			if ((u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) {  				//Can approximate by saving an empty Graph over the existing Graph  				g = new Graph ();  				g.BaseUri = u;  				this._manager.SaveGraph (g);  			}  			else if (this._manager.UpdateSupported && (this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) != 0) {  				//Can approximate by loading the Graph and then deleting all Triples from it  				g = new NonIndexedGraph ();  				this._manager.LoadGraph (g' u);  				this._manager.UpdateGraph (u' null' g.Triples);  			}  			else {  				throw new SparqlUpdateException ("Unable to evaluate a CLEAR command as the underlying store does not provide appropriate IO Behaviour to approximate this command");  			}  		}  	}  	else {  		throw new NotSupportedException ("The Generic Update processor does not support this form of the CLEAR command");  	}  	break;  }  
Missing Default,VDS.RDF.Update,GenericUpdateProcessor,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\GenericUpdateProcessor.cs,ProcessDropCommand,The following switch statement is missing a default case: switch (cmd.Mode) {  case ClearMode.Graph:  case ClearMode.Default:  	if (this._manager.DeleteSupported) {  		//If available use DeleteGraph()  		this._manager.DeleteGraph (cmd.TargetUri);  	}  	else if ((cmd.TargetUri == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (cmd.TargetUri != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) {  		//Can approximate by saving an empty Graph over the existing Graph  		g = new Graph ();  		g.BaseUri = cmd.TargetUri;  		this._manager.SaveGraph (g);  	}  	else if (this._manager.UpdateSupported && (this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) != 0) {  		//Can approximate by loading the Graph and then deleting all Triples from it  		g = new NonIndexedGraph ();  		this._manager.LoadGraph (g' cmd.TargetUri);  		this._manager.UpdateGraph (cmd.TargetUri' null' g.Triples);  	}  	else {  		throw new SparqlUpdateException ("Unable to evaluate a DROP command as the underlying store does not provide appropriate IO Behaviour to approximate this command");  	}  	break;  case ClearMode.All:  case ClearMode.Named:  	if (this._manager.ListGraphsSupported) {  		List<Uri> graphs = this._manager.ListGraphs ().ToList ();  		foreach (Uri u in graphs) {  			if (this._manager.DeleteSupported) {  				//If available use DeleteGraph()  				this._manager.DeleteGraph (u);  			}  			else if ((u == null && (this._manager.IOBehaviour & IOBehaviour.OverwriteDefault) != 0) || (u != null && (this._manager.IOBehaviour & IOBehaviour.OverwriteNamed) != 0)) {  				//Can approximate by saving an empty Graph over the existing Graph  				g = new Graph ();  				g.BaseUri = u;  				this._manager.SaveGraph (g);  			}  			else if (this._manager.UpdateSupported && (this._manager.IOBehaviour & IOBehaviour.CanUpdateDeleteTriples) != 0) {  				//Can approximate by loading the Graph and then deleting all Triples from it  				g = new NonIndexedGraph ();  				this._manager.LoadGraph (g' u);  				this._manager.UpdateGraph (u' null' g.Triples);  			}  			else {  				throw new SparqlUpdateException ("Unable to evaluate a DROP command as the underlying store does not provide appropriate IO Behaviour to approximate this command");  			}  		}  	}  	else {  		throw new NotSupportedException ("The Generic Update processor does not support this form of the DROP command");  	}  	break;  }  
Missing Default,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GeneratePredicateOutput,The following switch statement is missing a default case: switch (t.Predicate.NodeType) {  case NodeType.Blank:  	throw new RdfOutputException (WriterErrorMessages.BlankPredicatesUnserializable ("RDF/XML"));  case NodeType.GraphLiteral:  	throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  case NodeType.Literal:  	throw new RdfOutputException (WriterErrorMessages.LiteralPredicatesUnserializable ("RDF/XML"));  case NodeType.Variable:  	throw new RdfOutputException (WriterErrorMessages.VariableNodesUnserializable ("RDF/XML"));  }  
Missing Default,VDS.RDF.Writing,PrettyRdfXmlWriter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\PrettyRdfXmlWriter.cs,GenerateObjectOutput,The following switch statement is missing a default case: switch (t.Object.NodeType) {  case NodeType.Blank:  	if (context.Collections.ContainsKey (t.Object)) {  		//Blank Node has a collection associated with it  		this.GenerateCollectionOutput (context' t.Object);  	}  	else {  		//Isolated Blank Node so use nodeID  		context.Writer.WriteAttributeString ("rdf"' "nodeID"' NamespaceMapper.RDF' context.BlankNodeMapper.GetOutputID (((IBlankNode)t.Object).InternalID));  	}  	break;  case NodeType.GraphLiteral:  	throw new RdfOutputException (WriterErrorMessages.GraphLiteralsUnserializable ("RDF/XML"));  case NodeType.Literal:  	//Write as content of the current element  	ILiteralNode lit = (ILiteralNode)t.Object;  	if (lit.DataType != null) {  		if (lit.DataType.ToString ().Equals (RdfSpecsHelper.RdfXmlLiteral)) {  			//XML Literal  			context.Writer.WriteAttributeString ("rdf"' "parseType"' NamespaceMapper.RDF' "Literal");  			context.Writer.WriteRaw (lit.Value);  		}  		else {  			//Datatyped Literal  			context.Writer.WriteAttributeString ("rdf"' "datatype"' NamespaceMapper.RDF' Uri.EscapeUriString (lit.DataType.ToString ()));  			context.Writer.WriteString (lit.Value);  		}  	}  	else if (!lit.Language.Equals (String.Empty)) {  		//Language specified Literal  		context.Writer.WriteAttributeString ("xml"' "lang"' null' lit.Language);  		context.Writer.WriteString (lit.Value);  	}  	else {  		//Simple Literal  		context.Writer.WriteString (lit.Value);  	}  	break;  case NodeType.Uri:  	//Simple rdf:resource  	//TODO: Compress this into UriRef where possible  	context.Writer.WriteAttributeString ("rdf"' "resource"' NamespaceMapper.RDF' Uri.EscapeUriString (t.Object.ToString ()));  	break;  case NodeType.Variable:  	throw new RdfOutputException (WriterErrorMessages.VariableNodesUnserializable ("RDF/XML"));  }  
Missing Default,VDS.RDF.Parsing.Tokens,BaseTokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\BaseTokeniser.cs,HandleEscapes,The following switch statement is missing a default case: switch (next) {  case 't':  case 'n':  case 'r':  case 'u':  case 'U':  	this._output.Append ("\\");  	break;  }  
Missing Default,VDS.RDF.Parsing.Tokens,Notation3Tokeniser,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Parsing\Tokens\Notation3Tokeniser.cs,TryGetFormula,The following switch statement is missing a default case: switch (next) {  case '{':  	openBrackets++;  	break;  case '}':  	//openBrackets--;  	closeBrackets++;  	break;  case '\n':  case '\r':  	//Discard the White Space  	this.ConsumeNewLine (false);  	continue;  }  
Missing Default,VDS.RDF.Query.Datasets,BaseTransactionalQuadDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseQuadDataset.cs,Flush,The following switch statement is missing a default case: switch (action.Action) {  case GraphPersistenceActionType.Added:  	//If Graph was added ensure any changes were flushed  	action.Graph.Flush ();  	break;  case GraphPersistenceActionType.Deleted:  	//If Graph was deleted can discard any changes  	action.Graph.Discard ();  	break;  case GraphPersistenceActionType.Modified:  	//If Graph was modified ensure any changes were flushed  	action.Graph.Flush ();  	break;  }  
Missing Default,VDS.RDF.Query.Datasets,BaseTransactionalQuadDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseQuadDataset.cs,Discard,The following switch statement is missing a default case: switch (action.Action) {  case GraphPersistenceActionType.Added:  	//If a Graph was added we must now remove it  	if (this.HasGraphInternal (action.Graph.BaseUri)) {  		this.RemoveGraphInternal (action.Graph.BaseUri);  	}  	break;  case GraphPersistenceActionType.Deleted:  	//If a Graph was deleted we must now add it back again  	//Don't add the full Graph only an empty Graph with the given URI  	Graph g = new Graph ();  	g.BaseUri = action.Graph.BaseUri;  	this.AddGraphInternal (g);  	break;  case GraphPersistenceActionType.Modified:  	//If a Graph was modified we must discard the changes  	action.Graph.Discard ();  	break;  }  
Missing Default,VDS.RDF.Query.Datasets,BaseTransactionalDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseDataset.cs,Flush,The following switch statement is missing a default case: switch (action.Action) {  case GraphPersistenceActionType.Added:  	//If Graph was added ensure any changes were flushed  	action.Graph.Flush ();  	break;  case GraphPersistenceActionType.Deleted:  	//If Graph was deleted can discard any changes  	action.Graph.Discard ();  	break;  case GraphPersistenceActionType.Modified:  	//If Graph was modified ensure any changes were flushed  	action.Graph.Flush ();  	break;  }  
Missing Default,VDS.RDF.Query.Datasets,BaseTransactionalDataset,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Datasets\BaseDataset.cs,Discard,The following switch statement is missing a default case: switch (action.Action) {  case GraphPersistenceActionType.Added:  	//If a Graph was added we must now remove it  	if (this.HasGraphInternal (action.Graph.BaseUri)) {  		this.RemoveGraphInternal (action.Graph.BaseUri);  	}  	break;  case GraphPersistenceActionType.Deleted:  	//If a Graph was deleted we must now add it back again  	//Don't add the full Graph only an empty Graph with the given URI  	Graph g = new Graph ();  	g.BaseUri = action.Graph.BaseUri;  	this.AddGraphInternal (g);  	break;  case GraphPersistenceActionType.Modified:  	//If a Graph was modified we must discard the changes  	action.Graph.Discard ();  	break;  }  
Missing Default,VDS.RDF.Query.Expressions,ArqFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\ArqFunctionFactory.cs,TryCreateExpression,The following switch statement is missing a default case: switch (func) {  case ArqFunctionFactory.BNode:  	if (args.Count == 1) {  		arqFunc = new BNodeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ bnode() function");  	}  	break;  case ArqFunctionFactory.E:  	if (args.Count == 0) {  		arqFunc = new EFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ e() function");  	}  	break;  case ArqFunctionFactory.LocalName:  	if (args.Count == 1) {  		arqFunc = new LocalNameFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ localname() function");  	}  	break;  case ArqFunctionFactory.Max:  	if (args.Count == 2) {  		arqFunc = new MaxFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ max() function");  	}  	break;  case ArqFunctionFactory.Min:  	if (args.Count == 2) {  		arqFunc = new MinFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ min() function");  	}  	break;  case ArqFunctionFactory.Namespace:  	if (args.Count == 1) {  		arqFunc = new NamespaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ namespace() function");  	}  	break;  case ArqFunctionFactory.Now:  	if (args.Count == 0) {  		arqFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ now() function");  	}  	break;  case ArqFunctionFactory.Pi:  	if (args.Count == 0) {  		arqFunc = new PiFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ pi() function");  	}  	break;  case ArqFunctionFactory.Sha1Sum:  	if (args.Count == 1) {  		arqFunc = new Sha1Function (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ sha1sum() function");  	}  	break;  case ArqFunctionFactory.StrJoin:  	if (args.Count >= 2) {  		arqFunc = new StringJoinFunction (args.First ()' args.Skip (1));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ strjoing() function");  	}  	break;  case ArqFunctionFactory.Substr:  case ArqFunctionFactory.Substring:  	if (args.Count == 2) {  		arqFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		arqFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the ARQ " + func + "() function");  	}  	break;  }  
Missing Default,VDS.RDF.Query.Expressions,LeviathanFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\LeviathanFunctionFactory.cs,TryCreateExpression,The following switch statement is missing a default case: switch (func) {  case LeviathanFunctionFactory.All:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AllAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan all() aggregate");  	}  	break;  case LeviathanFunctionFactory.Any:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new AnyAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan any() aggregate");  	}  	break;  case LeviathanFunctionFactory.Cartesian:  	if (args.Count == 4) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]);  	}  	else if (args.Count == 6) {  		lvnFunc = new CartesianFunction (args [0]' args [1]' args [2]' args [3]' args [4]' args [5]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for Leviathan cartesian() function");  	}  	break;  case LeviathanFunctionFactory.Cube:  	if (args.Count == 1) {  		lvnFunc = new CubeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan cube() function");  	}  	break;  case LeviathanFunctionFactory.DegreesToRadians:  	if (args.Count == 1) {  		lvnFunc = new DegreesToRadiansFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan degrees-to-radians() function");  	}  	break;  case LeviathanFunctionFactory.E:  	if (args.Count == 1) {  		lvnFunc = new EFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan e() function");  	}  	break;  case LeviathanFunctionFactory.Factorial:  	if (args.Count == 1) {  		lvnFunc = new FactorialFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan factorial() function");  	}  	break;  case LeviathanFunctionFactory.Ln:  	if (args.Count == 1) {  		lvnFunc = new LeviathanNaturalLogFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ln() function");  	}  	break;  case LeviathanFunctionFactory.Log:  	if (args.Count == 1) {  		lvnFunc = new LogFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new LogFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan log() function");  	}  	break;  case LeviathanFunctionFactory.MD5Hash:  	if (args.Count == 1) {  		lvnFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan md5hash() function");  	}  	break;  case LeviathanFunctionFactory.Median:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new MedianAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan median() aggregate");  	}  	break;  case LeviathanFunctionFactory.Mode:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new ModeAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan mode() aggregate");  	}  	break;  case LeviathanFunctionFactory.None:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NoneAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan none() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMax:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMaxAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmax() aggregate");  	}  	break;  case LeviathanFunctionFactory.NumericMin:  	if (args.Count == 1) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.First ()));  	}  	else if (args.Count == 2 && args.First () is DistinctModifier) {  		lvnFunc = new AggregateTerm (new NumericMinAggregate (args.Last ()' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan nmin() aggregate");  	}  	break;  case LeviathanFunctionFactory.Power:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new PowerFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pow() function");  	}  	break;  case LeviathanFunctionFactory.Pythagoras:  	if (args.Count == 2) {  		lvnFunc = new PythagoreanDistanceFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan pythagoras() function");  	}  	break;  case LeviathanFunctionFactory.RadiansToDegrees:  	if (args.Count == 1) {  		lvnFunc = new RadiansToDegreesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan radians-to-degrees() function");  	}  	break;  case LeviathanFunctionFactory.Random:  	if (args.Count == 0) {  		lvnFunc = new RandomFunction ();  	}  	else if (args.Count == 1) {  		lvnFunc = new RandomFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RandomFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan rnd() function");  	}  	break;  case LeviathanFunctionFactory.Reciprocal:  	if (args.Count == 1) {  		lvnFunc = new ReciprocalFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan reciprocal() function");  	}  	break;  case LeviathanFunctionFactory.Root:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else if (args.Count == 2) {  		lvnFunc = new RootFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan root() function");  	}  	break;  case LeviathanFunctionFactory.Sha256Hash:  	if (args.Count == 1) {  		lvnFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sha256hash() function");  	}  	break;  case LeviathanFunctionFactory.Square:  	if (args.Count == 1) {  		lvnFunc = new SquareFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sq() function");  	}  	break;  case LeviathanFunctionFactory.SquareRoot:  	if (args.Count == 1) {  		lvnFunc = new SquareRootFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan sqrt() function");  	}  	break;  case LeviathanFunctionFactory.Ten:  	if (args.Count == 1) {  		lvnFunc = new TenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan ten() function");  	}  	break;  case LeviathanFunctionFactory.TrigCos:  case LeviathanFunctionFactory.TrigCosInv:  	if (args.Count == 1) {  		lvnFunc = new CosineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCosec:  case LeviathanFunctionFactory.TrigCosecInv:  	if (args.Count == 1) {  		lvnFunc = new CosecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCosecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigCotan:  case LeviathanFunctionFactory.TrigCotanInv:  	if (args.Count == 1) {  		lvnFunc = new CotangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigCotanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSec:  case LeviathanFunctionFactory.TrigSecInv:  	if (args.Count == 1) {  		lvnFunc = new SecantFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSecInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigSin:  case LeviathanFunctionFactory.TrigSinInv:  	if (args.Count == 1) {  		lvnFunc = new SineFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigSinInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  case LeviathanFunctionFactory.TrigTan:  case LeviathanFunctionFactory.TrigTanInv:  	if (args.Count == 1) {  		lvnFunc = new TangentFunction (args.First ()' func.Equals (LeviathanFunctionFactory.TrigTanInv));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the Leviathan " + func + "() function");  	}  	break;  }  
Missing Default,VDS.RDF.Query.Expressions,SparqlBuiltInFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\SparqlBuiltInFunctionFactory.cs,TryCreateExpression,The following switch statement is missing a default case: switch (func) {  case SparqlSpecsHelper.SparqlKeywordAbs:  	if (args.Count == 1) {  		sparqlFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordAvg:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new AverageAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordBound:  	if (args.Count == 1) {  		if (args [0] is VariableTerm) {  			sparqlFunc = new BoundFunction ((VariableTerm)args [0]);  		}  		else {  			throw new RdfParseException ("The SPARQL BOUND() function only operates over Variables");  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL BOUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCeil:  	if (args.Count == 1) {  		sparqlFunc = new CeilFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CEIL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCoalesce:  	if (args.Count >= 1) {  		sparqlFunc = new CoalesceFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL COALESCE() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordConcat:  	if (args.Count >= 1) {  		sparqlFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("The SPARQL CONCAT() function requires at least 1 argument");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordContains:  	if (args.Count == 2) {  		sparqlFunc = new ContainsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordCount:  	//Q: What will the URIs be for the special forms of COUNT?  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new CountAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL COUNT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDataType:  	if (args.Count == 1) {  		sparqlFunc = new DataTypeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DATATYPE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordDay:  	if (args.Count == 1) {  		sparqlFunc = new DayFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL DAY() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordEncodeForUri:  	if (args.Count == 1) {  		sparqlFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ENCODE_FOR_URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordFloor:  	if (args.Count == 1) {  		sparqlFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL FLOOR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordGroupConcat:  	if (args.Count == 1) {  		if (scalarArguments.ContainsKey (SparqlSpecsHelper.SparqlKeywordSeparator)) {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()' scalarArguments [SparqlSpecsHelper.SparqlKeywordSeparator]));  		}  		else {  			sparqlFunc = new AggregateTerm (new GroupConcatAggregate (args.First ()));  		}  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL GROUP_CONCAT() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordHours:  	if (args.Count == 1) {  		sparqlFunc = new HoursFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL HOURS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIf:  	if (args.Count == 3) {  		sparqlFunc = new IfElseFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IF() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL IRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsBlank:  	if (args.Count == 1) {  		sparqlFunc = new IsBlankFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISBLANK() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsIri:  	if (args.Count == 1) {  		sparqlFunc = new IsIriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISIRI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsLiteral:  	if (args.Count == 1) {  		sparqlFunc = new IsLiteralFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISLITERAL() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsNumeric:  	if (args.Count == 1) {  		sparqlFunc = new IsNumericFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISNUMERIC() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordIsUri:  	if (args.Count == 1) {  		sparqlFunc = new IsUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ISURI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLang:  	if (args.Count == 1) {  		sparqlFunc = new LangFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLangMatches:  	if (args.Count == 2) {  		sparqlFunc = new LangMatchesFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LANGMATCHES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordLCase:  	if (args.Count == 1) {  		sparqlFunc = new LCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL LCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMax:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MaxAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MAX() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMD5:  	if (args.Count == 1) {  		sparqlFunc = new MD5HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL CONTAINS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMin:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new MinAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MIN() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMinutes:  	if (args.Count == 1) {  		sparqlFunc = new MinutesFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MINUTES() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordMonth:  	if (args.Count == 1) {  		sparqlFunc = new MonthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL MONTH() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordNow:  	if (args.Count == 0) {  		sparqlFunc = new NowFunction ();  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ABS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRegex:  	if (args.Count == 2) {  		sparqlFunc = new RegexFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new RegexFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL REGEX() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordRound:  	if (args.Count == 1) {  		sparqlFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL ROUND() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSameTerm:  	if (args.Count == 2) {  		sparqlFunc = new SameTermFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SAMETERM() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSample:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SampleAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL AVG() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSeconds:  	if (args.Count == 1) {  		sparqlFunc = new SecondsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SECONDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha1:  	if (args.Count == 1) {  		sparqlFunc = new Sha1HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA1() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha256:  	if (args.Count == 1) {  		sparqlFunc = new Sha256HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA256() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha384:  	if (args.Count == 1) {  		sparqlFunc = new Sha384HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA384() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSha512:  	if (args.Count == 1) {  		sparqlFunc = new Sha512HashFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SHA512() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStr:  	if (args.Count == 1) {  		sparqlFunc = new StrFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrDt:  	if (args.Count == 2) {  		sparqlFunc = new StrDtFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRDT() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrEnds:  	if (args.Count == 2) {  		sparqlFunc = new StrEndsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRENDS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLang:  	if (args.Count == 2) {  		sparqlFunc = new StrLangFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRLANG() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrLen:  	if (args.Count == 1) {  		sparqlFunc = new StrLenFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRKEN() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordStrStarts:  	if (args.Count == 2) {  		sparqlFunc = new StrStartsFunction (args [0]' args [1]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL STRSTARTS() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSubStr:  	if (args.Count == 2) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]);  	}  	else if (args.Count == 3) {  		sparqlFunc = new SubStrFunction (args [0]' args [1]' args [2]);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUBSTR() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordSum:  	if (args.Count == 1) {  		sparqlFunc = new AggregateTerm (new SumAggregate (args.First ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL SUM() aggregate");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTimezone:  	if (args.Count == 1) {  		sparqlFunc = new TimezoneFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TIMEZONE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordTz:  	if (args.Count == 1) {  		sparqlFunc = new TZFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL TZ() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUCase:  	if (args.Count == 1) {  		sparqlFunc = new UCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL UCASE() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordUri:  	if (args.Count == 1) {  		sparqlFunc = new IriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL URI() function");  	}  	break;  case SparqlSpecsHelper.SparqlKeywordYear:  	if (args.Count == 1) {  		sparqlFunc = new YearFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the SPARQL YEAR() function");  	}  	break;  }  
Missing Default,VDS.RDF.Query.Expressions,XPathFunctionFactory,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\XPathFunctionFactory.cs,TryCreateExpression,The following switch statement is missing a default case: switch (func) {  case XPathFunctionFactory.Absolute:  	if (args.Count == 1) {  		xpathFunc = new AbsFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath abs() function");  	}  	break;  case XPathFunctionFactory.AdjustDateTimeToTimezone:  	throw new NotSupportedException ("XPath adjust-dateTime-to-timezone() function is not supported");  case XPathFunctionFactory.Boolean:  	if (args.Count == 1) {  		xpathFunc = new BooleanFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath boolean() function");  	}  	throw new NotSupportedException ("XPath boolean() function is not supported");  case XPathFunctionFactory.Ceiling:  	if (args.Count == 1) {  		xpathFunc = new CeilingFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ceiling() function");  	}  	break;  case XPathFunctionFactory.Compare:  	if (args.Count == 2) {  		xpathFunc = new CompareFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath compare() function");  	}  	break;  case XPathFunctionFactory.Concat:  	if (args.Count == 2) {  		xpathFunc = new ConcatFunction (args.First ()' args.Last ());  	}  	else if (args.Count > 2) {  		xpathFunc = new ConcatFunction (args);  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath concat() function");  	}  	break;  case XPathFunctionFactory.Contains:  	if (args.Count == 2) {  		xpathFunc = new ContainsFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath contains() function");  	}  	break;  case XPathFunctionFactory.DayFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new DayFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath day-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.EncodeForURI:  	if (args.Count == 1) {  		xpathFunc = new EncodeForUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath encode-for-uri() function");  	}  	break;  case XPathFunctionFactory.EndsWith:  	if (args.Count == 2) {  		xpathFunc = new EndsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath ends-with() function");  	}  	break;  #if !NO_WEB  case XPathFunctionFactory.EscapeHtmlURI:  	if (args.Count == 1) {  		xpathFunc = new EscapeHtmlUriFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath escape-html-uri() function");  	}  	break;  #endif  case XPathFunctionFactory.False:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' false));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath false() function");  	}  	break;  case XPathFunctionFactory.Floor:  	if (args.Count == 1) {  		xpathFunc = new FloorFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath floor() function");  	}  	break;  case XPathFunctionFactory.HoursFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new HoursFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath hours-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.LowerCase:  	if (args.Count == 1) {  		xpathFunc = new LowerCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath lower-case() function");  	}  	break;  case XPathFunctionFactory.Matches:  	if (args.Count == 2) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath matches() function");  	}  	break;  case XPathFunctionFactory.MinutesFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MinutesFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath minutes-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.MonthFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new MonthFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath month-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.NormalizeSpace:  	if (args.Count == 1) {  		xpathFunc = new NormalizeSpaceFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #if !NO_NORM  case XPathFunctionFactory.NormalizeUnicode:  	if (args.Count == 1) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new NormalizeUnicodeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath normalize-space() function");  	}  	break;  #endif  case XPathFunctionFactory.Not:  	if (args.Count == 1) {  		xpathFunc = new NotExpression (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath not() function");  	}  	break;  case XPathFunctionFactory.Replace:  	if (args.Count == 3) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args.Last ());  	}  	else if (args.Count == 4) {  		xpathFunc = new ReplaceFunction (args.First ()' args [1]' args [2]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath replace() function");  	}  	break;  case XPathFunctionFactory.Round:  	if (args.Count == 1) {  		xpathFunc = new RoundFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round() function");  	}  	break;  #if !SILVERLIGHT  case XPathFunctionFactory.RoundHalfToEven:  	if (args.Count == 1) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ());  	}  	else if (args.Count == 2) {  		xpathFunc = new RoundHalfToEvenFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath round-half-to-even() function");  	}  	break;  #endif  case XPathFunctionFactory.SecondsFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new SecondsFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath seconds-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.StartsWith:  	if (args.Count == 2) {  		xpathFunc = new StartsWithFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath starts-with() function");  	}  	break;  case XPathFunctionFactory.StringJoin:  	if (args.Count == 1) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()));  	}  	else if (args.Count == 2) {  		xpathFunc = new AggregateTerm (new StringJoinAggregate (args.First ()' args.Last ()));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-join() function");  	}  	break;  case XPathFunctionFactory.StringLength:  	if (args.Count == 1) {  		xpathFunc = new StringLengthFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath string-length() function");  	}  	break;  case XPathFunctionFactory.Substring:  	if (args.Count == 2) {  		xpathFunc = new SubstringFunction (args.First ()' args.Last ());  	}  	else if (args.Count == 3) {  		xpathFunc = new SubstringFunction (args.First ()' args [1]' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring() function");  	}  	break;  case XPathFunctionFactory.SubstringAfter:  	if (args.Count == 2) {  		xpathFunc = new SubstringAfterFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-after() function");  	}  	break;  case XPathFunctionFactory.SubstringBefore:  	if (args.Count == 2) {  		xpathFunc = new SubstringBeforeFunction (args.First ()' args.Last ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath substring-before() function");  	}  	break;  case XPathFunctionFactory.TimezoneFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new TimezoneFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath timezone-from-dateTime() function");  	}  	break;  case XPathFunctionFactory.Translate:  	throw new NotSupportedException ("XPath translate() function is not supported");  case XPathFunctionFactory.True:  	if (args.Count == 0) {  		xpathFunc = new ConstantTerm (new BooleanNode (null' true));  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath true() function");  	}  	break;  case XPathFunctionFactory.UpperCase:  	if (args.Count == 1) {  		xpathFunc = new UpperCaseFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath upper-case() function");  	}  	break;  case XPathFunctionFactory.YearFromDateTime:  	if (args.Count == 1) {  		xpathFunc = new YearFromDateTimeFunction (args.First ());  	}  	else {  		throw new RdfParseException ("Incorrect number of arguments for the XPath year-from-dateTime() function");  	}  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Leviathan,NumericMaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMaxAggregate.cs,Apply,The following switch statement is missing a default case: switch (numtype) {  case SparqlNumericType.Integer:  	lngmax = temp.AsInteger ();  	decmax = temp.AsDecimal ();  	fltmax = temp.AsFloat ();  	dblmax = temp.AsDouble ();  	break;  case SparqlNumericType.Decimal:  	decmax = temp.AsDecimal ();  	fltmax = temp.AsFloat ();  	dblmax = temp.AsDouble ();  	break;  case SparqlNumericType.Float:  	fltmax = temp.AsFloat ();  	dblmax = temp.AsDouble ();  	break;  case SparqlNumericType.Double:  	dblmax = temp.AsDouble ();  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Leviathan,NumericMaxAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMaxAggregate.cs,Apply,The following switch statement is missing a default case: switch (maxtype) {  case SparqlNumericType.Integer:  	lngval = temp.AsInteger ();  	if (lngval > lngmax) {  		lngmax = lngval;  		decmax = temp.AsDecimal ();  		fltmax = temp.AsFloat ();  		dblmax = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Decimal:  	decval = temp.AsDecimal ();  	if (decval > decmax) {  		decmax = decval;  		fltmax = temp.AsFloat ();  		dblmax = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Float:  	fltval = temp.AsFloat ();  	if (fltval > fltmax) {  		fltmax = fltval;  		dblmax = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Double:  	dblval = temp.AsDouble ();  	if (dblval > dblmax) {  		dblmax = dblval;  	}  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Leviathan,NumericMinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMinAggregate.cs,Apply,The following switch statement is missing a default case: switch (numtype) {  case SparqlNumericType.Integer:  	lngmin = temp.AsInteger ();  	decmin = temp.AsDecimal ();  	fltmin = temp.AsFloat ();  	dblmin = temp.AsDouble ();  	break;  case SparqlNumericType.Decimal:  	decmin = temp.AsDecimal ();  	fltmin = temp.AsFloat ();  	dblmin = temp.AsDouble ();  	break;  case SparqlNumericType.Float:  	fltmin = temp.AsFloat ();  	dblmin = temp.AsDouble ();  	break;  case SparqlNumericType.Double:  	dblmin = temp.AsDouble ();  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Leviathan,NumericMinAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Leviathan\NumericMinAggregate.cs,Apply,The following switch statement is missing a default case: switch (mintype) {  case SparqlNumericType.Integer:  	lngval = temp.AsInteger ();  	if (lngval < lngmin) {  		lngmin = lngval;  		decmin = temp.AsDecimal ();  		fltmin = temp.AsFloat ();  		dblmin = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Decimal:  	decval = temp.AsDecimal ();  	if (decval < decmin) {  		decmin = decval;  		fltmin = temp.AsFloat ();  		dblmin = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Float:  	fltval = temp.AsFloat ();  	if (fltval < fltmin) {  		fltmin = fltval;  		dblmin = temp.AsDouble ();  	}  	break;  case SparqlNumericType.Double:  	dblval = temp.AsDouble ();  	if (dblval < dblmin) {  		dblmin = dblval;  	}  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Sparql,AverageAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\AverageAggregate.cs,Apply,The following switch statement is missing a default case: switch (maxtype) {  case SparqlNumericType.Integer:  	//lngtotal += numExpr.IntegerValue(context' id);  	dectotal += temp.AsDecimal ();  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Decimal:  	dectotal += temp.AsDecimal ();  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Float:  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Double:  	dbltotal += temp.AsDouble ();  	break;  }  
Missing Default,VDS.RDF.Query.Aggregates.Sparql,SumAggregate,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Aggregates\Sparql\SumAggregate.cs,Apply,The following switch statement is missing a default case: switch (maxtype) {  case SparqlNumericType.Integer:  	lngtotal += temp.AsInteger ();  	dectotal += temp.AsDecimal ();  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Decimal:  	dectotal += temp.AsDecimal ();  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Float:  	flttotal += temp.AsFloat ();  	dbltotal += temp.AsDouble ();  	break;  case SparqlNumericType.Double:  	dbltotal += temp.AsDouble ();  	break;  }  
Missing Default,VDS.RDF.Query.Algebra,Select,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Algebra\Project.cs,Evaluate,The following switch statement is missing a default case: switch (context.Query.QueryType) {  case SparqlQueryType.DescribeAll:  case SparqlQueryType.SelectAll:  case SparqlQueryType.SelectAllDistinct:  case SparqlQueryType.SelectAllReduced:  	selectAll = true;  	break;  }  
Missing Default,VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric,RandomFunction,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Query\Expressions\Functions\Leviathan\Numeric\RandomFunction.cs,ToString,The following switch statement is missing a default case: switch (this._args) {  case 1:  	output.Append (this._rightExpr.ToString ());  	break;  case 2:  	output.Append (this._leftExpr.ToString ());  	output.Append (''');  	output.Append (this._rightExpr.ToString ());  	break;  }  
Missing Default,VDS.RDF.Update.Commands,ClearCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\ClearCommand.cs,Evaluate,The following switch statement is missing a default case: switch (this._mode) {  case ClearMode.Graph:  case ClearMode.Default:  	if (context.Data.HasGraph (this._graphUri)) {  		context.Data.GetModifiableGraph (this._graphUri).Clear ();  	}  	break;  case ClearMode.Named:  	foreach (Uri u in context.Data.GraphUris) {  		if (u != null) {  			context.Data.GetModifiableGraph (u).Clear ();  		}  	}  	break;  case ClearMode.All:  	foreach (Uri u in context.Data.GraphUris) {  		context.Data.GetModifiableGraph (u).Clear ();  	}  	break;  }  
Missing Default,VDS.RDF.Update.Commands,DropCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DropCommand.cs,Evaluate,The following switch statement is missing a default case: switch (this._mode) {  case ClearMode.Default:  case ClearMode.Graph:  	if (!context.Data.HasGraph (this._graphUri)) {  		if (!this._silent)  			throw new SparqlUpdateException ("Cannot remove a Named Graph with URI '" + this._graphUri.ToString () + "' since a Graph with this URI does not exist in the Store");  	}  	else {  		if (this._mode == ClearMode.Graph) {  			context.Data.RemoveGraph (this._graphUri);  		}  		else {  			//DROPing the DEFAULT graph only results in clearing it  			//This is because removing the default graph may cause errors in later commands/queries  			//which rely on it existing  			context.Data.GetModifiableGraph (this._graphUri).Clear ();  		}  	}  	break;  case ClearMode.Named:  	foreach (Uri u in context.Data.GraphUris.ToList ()) {  		if (u != null) {  			context.Data.RemoveGraph (u);  		}  	}  	break;  case ClearMode.All:  	foreach (Uri u in context.Data.GraphUris.ToList ()) {  		if (u != null) {  			context.Data.RemoveGraph (u);  		}  		else {  			//DROPing the DEFAULT graph only results in clearing it  			//This is because removing the default graph may cause errors in later commands/queries  			//which rely on it existing  			context.Data.GetModifiableGraph (u).Clear ();  		}  	}  	break;  }  
Missing Default,VDS.RDF.Update.Commands,DropCommand,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\Update\Commands\DropCommand.cs,ToString,The following switch statement is missing a default case: switch (this._mode) {  case ClearMode.All:  	output.Append ("ALL");  	break;  case ClearMode.Default:  	output.Append ("DEFAULT");  	break;  case ClearMode.Named:  	output.Append ("NAMED");  	break;  case ClearMode.Graph:  	output.Append ("GRAPH <");  	output.Append (this._graphUri.ToString ().Replace (">"' "\\>"));  	output.Append ('>');  	break;  }  
Missing Default,VDS.RDF.Web,NegotiateByFileExtension,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Web\NegotiateByFileExtension.cs,context_BeginRequest,The following switch statement is missing a default case: switch (ext) {  case ".aspx":  case ".asmx":  case ".ashx":  case ".axd":  	//The above file extensions are special to ASP.Net and so may not actually exist as files  	//so we need to ignore them for the purposes of negotiating by file extension  	return;  }  
Missing Default,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatDescribeVariablesList,The following switch statement is missing a default case: switch (t.TokenType) {  case Token.VARIABLE:  	output.Append (t.Value);  	onLine++;  	break;  case Token.URI:  	output.Append ('<');  	output.Append (this.FormatUri (t.Value));  	output.Append ('>');  	onLine += 3;  	break;  case Token.QNAME:  	//If the QName has the same Namespace URI in this Formatter as in the Query then format  	//as a QName otherwise expand to a full URI  	String prefix = t.Value.Substring (0' t.Value.IndexOf (':'));  	if (this._qnameMapper.HasNamespace (prefix) && q.NamespaceMap.GetNamespaceUri (prefix).ToString ().Equals (this._qnameMapper.GetNamespaceUri (prefix).ToString ())) {  		output.AppendLine (t.Value);  		onLine += 2;  	}  	else if (q.NamespaceMap.HasNamespace (prefix)) {  		output.Append ('<');  		output.Append (this.FormatUri (Tools.ResolveQName (t.Value' q.NamespaceMap' q.BaseUri)));  		output.Append ('>');  		onLine += 3;  	}  	else {  		throw new RdfOutputException ("Unable to Format the DESCRIBE variables list since one of the Variables is the QName '" + t.Value + "' which cannot be resolved using the Namespace Map of the Query");  	}  	break;  }  
Missing Default,VDS.RDF.Writing.Formatting,SparqlFormatter,C:\repos\jmahmud_RDFer\RDFerSolution\dotNetRdf\Writing\Formatting\SparqlFormatter.cs,FormatExpression,The following switch statement is missing a default case: switch (expr.Type) {  case SparqlExpressionType.Aggregate:  	if (expr is AggregateTerm) {  		AggregateTerm agg = (AggregateTerm)expr;  		output.Append (this.FormatAggregate (agg.Aggregate));  	}  	else {  		output.Append (expr.ToString ());  	}  	break;  case SparqlExpressionType.BinaryOperator:  	ISparqlExpression lhs = expr.Arguments.First ();  	ISparqlExpression rhs = expr.Arguments.Skip (1).First ();  	//Format the Expression wrapping the LHS and/or RHS in brackets if required  	//to ensure that ordering of operators is preserved  	if (lhs.Type == SparqlExpressionType.BinaryOperator) {  		output.Append ('(');  		output.Append (this.FormatExpression (lhs));  		output.Append (')');  	}  	else {  		output.Append (this.FormatExpression (lhs));  	}  	output.Append (' ');  	output.Append (expr.Functor);  	output.Append (' ');  	if (rhs.Type == SparqlExpressionType.BinaryOperator) {  		output.Append ('(');  		output.Append (this.FormatExpression (rhs));  		output.Append (')');  	}  	else {  		output.Append (this.FormatExpression (rhs));  	}  	break;  case SparqlExpressionType.Function:  	//Show either a Keyword/URI/QName as appropriate  	if (SparqlSpecsHelper.IsFunctionKeyword (expr.Functor)) {  		output.Append (expr.Functor);  	}  	else {  		String funcQname;  		if (this._qnameMapper.ReduceToQName (expr.Functor' out funcQname)) {  			output.Append (funcQname);  		}  		else {  			output.Append ('<');  			output.Append (this.FormatUri (expr.Functor));  			output.Append ('>');  		}  	}  	//Add Arguments list  	output.Append ('(');  	List<ISparqlExpression> args = expr.Arguments.ToList ();  	for (int i = 0; i < args.Count; i++) {  		output.Append (this.FormatExpression (args [i]));  		if (i < args.Count - 1) {  			output.Append ("' ");  		}  	}  	output.Append (')');  	break;  case SparqlExpressionType.GraphOperator:  	output.Append (expr.Functor);  	output.Append (' ');  	List<ISparqlExpression> gArgs = expr.Arguments.ToList ();  	if (gArgs.Count > 1)  		throw new RdfOutputException ("Error Formatting SPARQL Expression - Expressions of type GraphOperator are only allowed a single argument");  	for (int i = 0; i < gArgs.Count; i++) {  		output.Append (this.FormatExpression (gArgs [i]));  		if (i < gArgs.Count - 1) {  			output.Append ("' ");  		}  	}  	break;  case SparqlExpressionType.Primary:  	//If Node/Numeric Term then use Node Formatting otherwise use ToString() on the expression  	if (expr is ConstantTerm) {  		ConstantTerm nodeTerm = (ConstantTerm)expr;  		output.Append (this.Format (nodeTerm.Evaluate (null' 0)));  	}  	else if (expr is GraphPatternTerm) {  		GraphPatternTerm gp = (GraphPatternTerm)expr;  		output.Append (this.Format (gp.Pattern));  	}  	else {  		output.Append (expr.ToString ());  	}  	break;  case SparqlExpressionType.SetOperator:  	//Add First Argument and Set Operator  	output.Append (this.FormatExpression (expr.Arguments.First ()));  	output.Append (' ');  	output.Append (expr.Functor);  	//Add Set  	output.Append (" (");  	List<ISparqlExpression> set = expr.Arguments.Skip (1).ToList ();  	for (int i = 0; i < set.Count; i++) {  		output.Append (this.FormatExpression (set [i]));  		if (i < set.Count - 1) {  			output.Append ("' ");  		}  	}  	output.Append (')');  	break;  case SparqlExpressionType.UnaryOperator:  	//Just Functor then Expression  	output.Append (expr.Functor);  	output.Append (this.FormatExpression (expr.Arguments.First ()));  	break;  }  
