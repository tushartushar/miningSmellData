Implementation smell,Namespace,Class,File,Method,Description
Complex Method,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,Cyclomatic complexity of the method is 10
Long Parameter List,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,TheCompileMethod,The method has 7 parameters. Parameters: jitter' comp' info' flags' nativeEntry' nativeSizeOfCode' handled
Long Parameter List,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,TheCompileMethod,The method has 7 parameters. Parameters: jitter' comp' info' flags' nativeEntry' nativeSizeOfCode' handled
Long Statement,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,PrepareMethods,The length of the statement  "			foreach (var methodInfo in GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)) " is 140.
Long Statement,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The length of the statement  "				callMethodDelegate(*(IntPtr*)jitterVtbl' jitterInstance' ourCompMem' new IntPtr(&info)' 0' new IntPtr(0x12345678)' new IntPtr(0x3ABCDEF0)); " is 139.
Long Statement,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The length of the statement  "				byte* p = (byte*)baseAddr + (uint)section.VirtualAddress + ((section.VirtualSize + IntPtr.Size - 1) & ~(IntPtr.Size - 1)) - IntPtr.Size; " is 136.
Long Statement,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,PrepareMethods,The length of the statement  "			foreach (var methodInfo in GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)) " is 140.
Long Statement,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The length of the statement  "				callMethodDelegate(*(IntPtr*)jitterVtbl' jitterInstance' ourCompMem' new IntPtr(&info)' 0' new IntPtr(0x12345678)' new IntPtr(0x3ABCDEF0)); " is 139.
Long Statement,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The length of the statement  "				byte* p = (byte*)baseAddr + (uint)section.VirtualAddress + ((section.VirtualSize + IntPtr.Size - 1) & ~(IntPtr.Size - 1)) - IntPtr.Size; " is 136.
Empty Catch Block,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,PatchRT,The method has an empty catch block.
Empty Catch Block,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Empty Catch Block,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Empty Catch Block,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Empty Catch Block,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,PatchRT,The method has an empty catch block.
Empty Catch Block,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Empty Catch Block,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Empty Catch Block,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The method has an empty catch block.
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DynamicMethodsDecrypter,The following statement contains a magic number: if (UIntPtr.Size != 4)  				throw new ApplicationException("Only 32-bit dynamic methods decryption is supported");
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: p += 4;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: int numSections = *(ushort*)(p + 2);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: var textName = new byte[8] { (byte)'.'' (byte)'t'' (byte)'e'' (byte)'x'' (byte)'t'' 0' 0' 0 };
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: var name = new byte[8];
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: for (int i = 0; i < numSections; i++' pSection++) {  				Marshal.Copy(new IntPtr(pSection)' name' 0' name.Length);  				if (!CompareName(textName' name' name.Length))  					continue;    				uint size = pSection->VirtualSize;  				uint rva = pSection->VirtualAddress;  				int displ = -8;  				return new IntPtr((byte*)hDll + rva + size + displ);  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: int numPushedArgs = compileMethodIsThisCall ? 5 : 6;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: int numPushedArgs = compileMethodIsThisCall ? 5 : 6;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: if (!compileMethodIsThisCall)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));	// push dword ptr [esp+XXh]  			else  				code.WriteByte(0x51);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(numPushedArgs * 4));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < numPushedArgs; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(numPushedArgs * 4));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(numPushedArgs * 4));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(IntPtr.Size * 2));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(IntPtr.Size * 3));
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,TheCompileMethod,The following statement contains a magic number: if (ourCompMem != IntPtr.Zero && comp == ourCompMem) {  				// We're decrypting methods  				var info2 = (CORINFO_METHOD_INFO*)info;  				ctx.dm.code = new byte[info2->ILCodeSize];    				Marshal.Copy(info2->ILCode' ctx.dm.code' 0' ctx.dm.code.Length);  				ctx.dm.mhMaxStack = info2->maxStack;  				ctx.dm.mhCodeSize = info2->ILCodeSize;  				if ((ctx.dm.mhFlags & 8) != 0)  					ctx.dm.extraSections = ReadExtraSections((byte*)info2->ILCode + info2->ILCodeSize);    				UpdateFromMethodDefTableRow();    				handled = true;  				return 0;  			}  			else {  				// We're not decrypting methods    				var info2 = (CORINFO_METHOD_INFO*)info;  				if (info2->scope != moduleToDecryptScope ||  					decryptMethodsInfo.moduleCctorBytes == null ||  					moduleCctorCodeRva == 0) {  					handled = false;  					return 0;  				}    				uint codeRva = (uint)((byte*)info2->ILCode - (byte*)hInstModule);  				if (moduleCctorCodeRva == codeRva) {  					fixed (byte* newIlCodeBytes = &decryptMethodsInfo.moduleCctorBytes[0]) {  						WriteCompileMethod(origCompileMethod);  						info2->ILCode = new IntPtr(newIlCodeBytes);  						info2->ILCodeSize = (uint)decryptMethodsInfo.moduleCctorBytes.Length;  						handled = true;  						return callMethodDelegate(origCompileMethod' jitter' comp' info' flags' nativeEntry' nativeSizeOfCode);  					}  				}  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ReadExtraSections,The following statement contains a magic number: p = Align(p' 4);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdFlags = (ushort)Read(row' methodDefTable.Columns[2]);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdName = Read(row' methodDefTable.Columns[3]);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdSignature = Read(row' methodDefTable.Columns[4]);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdParamList = Read(row' methodDefTable.Columns[5]);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,Read,The following statement contains a magic number: switch (colInfo.Size) {  			case 1: return *(row + colInfo.Offset);  			case 2: return *(ushort*)(row + colInfo.Offset);  			case 4: return *(uint*)(row + colInfo.Offset);  			default: throw new ApplicationException(string.Format("Unknown size: {0}"' colInfo.Size));  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,Read,The following statement contains a magic number: switch (colInfo.Size) {  			case 1: return *(row + colInfo.Offset);  			case 2: return *(ushort*)(row + colInfo.Offset);  			case 4: return *(uint*)(row + colInfo.Offset);  			default: throw new ApplicationException(string.Format("Unknown size: {0}"' colInfo.Size));  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: const int numIndexes = 15;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[1] = new IntPtr(mem + 2);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[3] = new IntPtr(IntPtr.Size * 5);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[3] = new IntPtr(IntPtr.Size * 5);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[5] = new IntPtr(IntPtr.Size * 7);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[5] = new IntPtr(IntPtr.Size * 7);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[6] = new IntPtr(mem + 7);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[6] = new IntPtr(mem + 7);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[7] = returnNameOfMethodInfo.ptrInDll;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[8] = new IntPtr(mem);
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[13] = returnMethodTokenInfo.ptrInDll;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[14] = returnMethodTokenInfo.ptrInDll;
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetModuleHandle,The following statement contains a magic number: if (!GetModuleHandleEx(4' addr' out hModule))  				throw new ApplicationException("GetModuleHandleEx() failed");
Magic Number,de4dot.mdecrypt,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The following statement contains a magic number: int offset = Environment.Version.Major == 2 ? 0x10 : 0x28;
Magic Number,de4dot.mdecrypt,NativeCodeGenerator,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\NativeCodeGenerator.cs,FixOffsets,The following statement contains a magic number: foreach (var kv in offsetToBranchAddr) {  				memStream.Position = kv.Key;  				// kv.Value (func/label) = destAddr + kv.Key + 4 + displ  				var displ = (ulong)((byte*)kv.Value - (byte*)destAddr - kv.Key - 4);  				uint high = (uint)(displ >> 32);  				if (high != 0 && high != 0xFFFFFFFF)  					throw new ApplicationException("Invalid displ");  				writer.Write((uint)displ);  			}
Magic Number,de4dot.mdecrypt,NativeCodeGenerator,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\NativeCodeGenerator.cs,FixOffsets,The following statement contains a magic number: foreach (var kv in offsetToBranchAddr) {  				memStream.Position = kv.Key;  				// kv.Value (func/label) = destAddr + kv.Key + 4 + displ  				var displ = (ulong)((byte*)kv.Value - (byte*)destAddr - kv.Key - 4);  				uint high = (uint)(displ >> 32);  				if (high != 0 && high != 0xFFFFFFFF)  					throw new ApplicationException("Invalid displ");  				writer.Write((uint)displ);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DynamicMethodsDecrypter,The following statement contains a magic number: if (UIntPtr.Size != 4)  				throw new ApplicationException("Only 32-bit dynamic methods decryption is supported");
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeDNLibMethods,The following statement contains a magic number: if (moduleCctor == null)  				moduleCctorCodeRva = 0;  			else {  				byte* p = (byte*)hInstModule + (uint)moduleCctor.RVA;  				if ((*p & 3) == 2)  					moduleCctorCodeRva = (uint)moduleCctor.RVA + 1;  				else  					moduleCctorCodeRva = (uint)((uint)moduleCctor.RVA + (p[1] >> 4) * 4);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: p += 4;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: int numSections = *(ushort*)(p + 2);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: var textName = new byte[8] { (byte)'.'' (byte)'t'' (byte)'e'' (byte)'x'' (byte)'t'' 0' 0' 0 };
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: var name = new byte[8];
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetEndOfText,The following statement contains a magic number: for (int i = 0; i < numSections; i++' pSection++) {  				Marshal.Copy(new IntPtr(pSection)' name' 0' name.Length);  				if (!CompareName(textName' name' name.Length))  					continue;    				uint size = pSection->VirtualSize;  				uint rva = pSection->VirtualAddress;  				int displ = -8;  				return new IntPtr((byte*)hDll + rva + size + displ);  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: int numPushedArgs = compileMethodIsThisCall ? 5 : 6;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: int numPushedArgs = compileMethodIsThisCall ? 5 : 6;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: if (!compileMethodIsThisCall)  				WritePushDwordPtrEspDispl(code' (sbyte)(0xC + numPushedArgs * 4));	// push dword ptr [esp+XXh]  			else  				code.WriteByte(0x51);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(numPushedArgs * 4));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: for (int i = 0; i < numPushedArgs; i++)  				WritePushDwordPtrEspDispl(code' (sbyte)(numPushedArgs * 4));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(numPushedArgs * 4));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(IntPtr.Size * 2));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,CreateOurCode,The following statement contains a magic number: code.WriteBytes(0xC2' (ushort)(IntPtr.Size * 3));
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,TheCompileMethod,The following statement contains a magic number: if (ourCompMem != IntPtr.Zero && comp == ourCompMem) {  				// We're decrypting methods  				var info2 = (CORINFO_METHOD_INFO*)info;  				ctx.dm.code = new byte[info2->ILCodeSize];    				Marshal.Copy(info2->ILCode' ctx.dm.code' 0' ctx.dm.code.Length);  				ctx.dm.mhMaxStack = info2->maxStack;  				ctx.dm.mhCodeSize = info2->ILCodeSize;  				if ((ctx.dm.mhFlags & 8) != 0)  					ctx.dm.extraSections = ReadExtraSections((byte*)info2->ILCode + info2->ILCodeSize);    				UpdateFromMethodDefTableRow();    				handled = true;  				return 0;  			}  			else {  				// We're not decrypting methods    				var info2 = (CORINFO_METHOD_INFO*)info;  				if (info2->scope != moduleToDecryptScope ||  					decryptMethodsInfo.moduleCctorBytes == null ||  					moduleCctorCodeRva == 0) {  					handled = false;  					return 0;  				}    				uint codeRva = (uint)((byte*)info2->ILCode - (byte*)hInstModule);  				if (moduleCctorCodeRva == codeRva) {  					fixed (byte* newIlCodeBytes = &decryptMethodsInfo.moduleCctorBytes[0]) {  						WriteCompileMethod(origCompileMethod);  						info2->ILCode = new IntPtr(newIlCodeBytes);  						info2->ILCodeSize = (uint)decryptMethodsInfo.moduleCctorBytes.Length;  						handled = true;  						return callMethodDelegate(origCompileMethod' jitter' comp' info' flags' nativeEntry' nativeSizeOfCode);  					}  				}  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ReadExtraSections,The following statement contains a magic number: p = Align(p' 4);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,ParseSection,The following statement contains a magic number: do {  				p = Align(p' 4);    				flags = *p++;  				if ((flags & 1) == 0)  					throw new ApplicationException("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new ApplicationException("Invalid bits set");    				if ((flags & 0x40) != 0) {  					p--;  					int num = (int)(*(uint*)p >> 8) / 24;  					p += 4 + num * 24;  				}  				else {  					int num = *p++ / 12;  					p += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdFlags = (ushort)Read(row' methodDefTable.Columns[2]);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdName = Read(row' methodDefTable.Columns[3]);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdSignature = Read(row' methodDefTable.Columns[4]);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,UpdateFromMethodDefTableRow,The following statement contains a magic number: ctx.dm.mdParamList = Read(row' methodDefTable.Columns[5]);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,Read,The following statement contains a magic number: switch (colInfo.Size) {  			case 1: return *(row + colInfo.Offset);  			case 2: return *(ushort*)(row + colInfo.Offset);  			case 4: return *(uint*)(row + colInfo.Offset);  			default: throw new ApplicationException(string.Format("Unknown size: {0}"' colInfo.Size));  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,Read,The following statement contains a magic number: switch (colInfo.Size) {  			case 1: return *(row + colInfo.Offset);  			case 2: return *(ushort*)(row + colInfo.Offset);  			case 4: return *(uint*)(row + colInfo.Offset);  			default: throw new ApplicationException(string.Format("Unknown size: {0}"' colInfo.Size));  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,DecryptMethod,The following statement contains a magic number: if (mh == (byte*)hInstModule) {  				ctx.dm.mhMaxStack = 0;  				ctx.dm.mhCodeSize = 0;  				ctx.dm.mhFlags = 0;  				ctx.dm.mhLocalVarSigTok = 0;  				code = null;  			}  			else if ((*mh & 3) == 2) {  				uint headerSize = 1;  				ctx.dm.mhMaxStack = 8;  				ctx.dm.mhCodeSize = (uint)(*mh >> 2);  				ctx.dm.mhFlags = 2;  				ctx.dm.mhLocalVarSigTok = 0;  				code = mh + headerSize;  			}  			else {  				uint headerSize = (uint)((mh[1] >> 4) * 4);  				ctx.dm.mhMaxStack = *(ushort*)(mh + 2);  				ctx.dm.mhCodeSize = *(uint*)(mh + 4);  				ctx.dm.mhFlags = *(ushort*)mh;  				ctx.dm.mhLocalVarSigTok = *(uint*)(mh + 8);  				code = mh + headerSize;  			}
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: const int numIndexes = 15;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[1] = new IntPtr(mem + 2);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[3] = new IntPtr(IntPtr.Size * 5);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[3] = new IntPtr(IntPtr.Size * 5);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[5] = new IntPtr(IntPtr.Size * 7);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[5] = new IntPtr(IntPtr.Size * 7);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[6] = new IntPtr(mem + 7);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[6] = new IntPtr(mem + 7);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[7] = returnNameOfMethodInfo.ptrInDll;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[8] = new IntPtr(mem);
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[13] = returnMethodTokenInfo.ptrInDll;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,InitializeOurComp,The following statement contains a magic number: mem[14] = returnMethodTokenInfo.ptrInDll;
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,GetModuleHandle,The following statement contains a magic number: if (!GetModuleHandleEx(4' addr' out hModule))  				throw new ApplicationException("GetModuleHandleEx() failed");
Magic Number,System.Runtime.ExceptionServices,DynamicMethodsDecrypter,C:\repos\0xd4d_de4dot\de4dot.mdecrypt\DynamicMethodsDecrypter.cs,FindCMAddress,The following statement contains a magic number: int offset = Environment.Version.Major == 2 ? 0x10 : 0x28;
